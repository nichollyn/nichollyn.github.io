<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-center-radar.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://theinfinitegame.tech').hostname,
    root: '/',
    scheme: 'Muse',
    version: '7.6.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false,"b2t":true,"scrollpercent":true},
    copycode: {"enable":true,"show_result":true,"style":"flat"},
    back2top: {"enable":true,"sidebar":true,"scrollpercent":true},
    bookmark: {"enable":true,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Stay hungry, stay foolish.">
<meta property="og:type" content="website">
<meta property="og:title" content="The Infinite Game">
<meta property="og:url" content="https://theinfinitegame.tech/page/2/index.html">
<meta property="og:site_name" content="The Infinite Game">
<meta property="og:description" content="Stay hungry, stay foolish.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="猫克杯">
<meta property="article:tag" content="tech">
<meta property="article:tag" content=" life">
<meta property="article:tag" content=" philosophy">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://theinfinitegame.tech/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>The Infinite Game</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="The Infinite Game" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">The Infinite Game</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-top">

    <a href="/top/" rel="section"><i class="fa fa-fw fa-signal"></i>热门</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-commonweal">

    <a href="/404.html" rel="section"><i class="fa fa-fw fa-heartbeat"></i>公益 404</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/nichollyn" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://theinfinitegame.tech/development/note-ios-map-api/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="猫克杯">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Infinite Game">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/development/note-ios-map-api/" class="post-title-link" itemprop="url">iOS 笔记 | 地图 API</a>
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-26 13:22:08" itemprop="dateCreated datePublished" datetime="2020-02-26T13:22:08+08:00">2020-02-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/development/" itemprop="url" rel="index">
                    <span itemprop="name">development</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>778</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="CLLocationManager-CLLocationManagerDelegate"><a href="#CLLocationManager-CLLocationManagerDelegate" class="headerlink" title="CLLocationManager, CLLocationManagerDelegate"></a>CLLocationManager, CLLocationManagerDelegate</h1><p>监控目标区域，进入、离开，Beacon 相关</p>
<h2 id="MKMapView-MKCoordinateRegion-MKMapItem"><a href="#MKMapView-MKCoordinateRegion-MKMapItem" class="headerlink" title="MKMapView, MKCoordinateRegion, MKMapItem,"></a>MKMapView, MKCoordinateRegion, MKMapItem,</h2><ul>
<li>坐标 CLLocationCoordinate2D （CoreLocation）</li>
<li>MKMapItem</li>
<li>罗盘按钮 MKCompassButton</li>
</ul>
<ul>
<li>用 Array:compactMap 获取一个可选型集合到非可选型且不包含 nil 的映射集合。</li>
</ul>
<h2 id="KVO-Compliant-KVO-兼容"><a href="#KVO-Compliant-KVO-兼容" class="headerlink" title="KVO Compliant (KVO 兼容)"></a>KVO Compliant (KVO 兼容)</h2><p>KVO is key-value observing.</p>
<h2 id="MKLocalSearch-查找附近，MKLocalSearchCompleter"><a href="#MKLocalSearch-查找附近，MKLocalSearchCompleter" class="headerlink" title="MKLocalSearch 查找附近，MKLocalSearchCompleter"></a>MKLocalSearch 查找附近，MKLocalSearchCompleter</h2><h2 id="UISearchResultsUpdating"><a href="#UISearchResultsUpdating" class="headerlink" title="UISearchResultsUpdating"></a>UISearchResultsUpdating</h2><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateSearchResults (<span class="keyword">for</span> searchController: <span class="type">UISearchController</span>)</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://theinfinitegame.tech/development/note-watchos-minimum-viable-complication/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="猫克杯">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Infinite Game">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/development/note-watchos-minimum-viable-complication/" class="post-title-link" itemprop="url">watchOS 学习笔记 | 最小可行 Complication</a>
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-20 14:43:35" itemprop="dateCreated datePublished" datetime="2020-02-20T14:43:35+08:00">2020-02-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/development/" itemprop="url" rel="index">
                    <span itemprop="name">development</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>要做一个 watch app，逻辑上，你会先想到从主 UI 开始。毕竟，notfication 和 complication 是可选的。人们说到 app ，通常指的就是主 UI 。</p>
<p>但是，如果要做一个在表盘用于浏览空气质量指数的 watch app ，你会先想到 complication 。 watchOS 设计的三大准则之一是 <strong>glanceable</strong> ，意味着用户能在扫一眼手表，以尽快的方式看到想要的信息，理想的时间最多几秒钟。 complication 可以让看到这些信息，比从 app 启动栏访问主 UI 快得多。</p>
<p>不同于 iOS ，watchOS 的应用并不要求主 UI 一定得是最常用的使用方式 —— 如果用例使得通知和 complication 更合理的话。主 UI 可以充当用户想要查看更具体信息或者特定的动作时的 “回退” 方案。</p>
</blockquote>
<p>那么，为什么我们不跳过 view controller ，直接尝试构建一个 complication 呢？</p>
<p>以下是 Kuba 构建的一个简单的 MVP 版本的 watch app ，只有一个 complication (支持 1~2 种变体)。这个 app 没有 UI ，主试图只有一个黑盒子，一行 WKInterface* 对象相关的代码都没有。</p>
<p>这个没有 UI 的 watch app 的用途是获取空气质量的信息（PM10，PM2.5，$ NO_2 $ 等)，每个小时更新一次，但足够用了。</p>
<p><img src="/images/minimum-complication-watch-app.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>下面先了解一些基础知识。</p>
<hr>
<h1 id="Complication-时间线"><a href="#Complication-时间线" class="headerlink" title="Complication 时间线"></a>Complication 时间线</h1><p>管理 complications 的 API 单独从 WatchKit 分离出来，位于 ClockKit 中，以 <code>CLK</code> 前缀标识。</p>
<p>有一些 complication 在你抬腕时就是可见的。当手表的屏幕亮起，你希望立即看到渲染的 complication widget ，它显示的数据当下就必须是最新的 —— 用户很可能只看了它一秒钟不到，因此没有时间在这个时候启动网络请求。</p>
<p>Apple 也不可能采用 7 天 24 小时的方式让应用在后台运行扩展 —— 电池撑不住。</p>
<p>所以工作方式实际上是这样的：你的应用指定一个 <strong>complication data source</strong>  (<code>CLKComplicationDataSource</code>) ，然后每当它接收到新的数据时 (无论运行在前台或者后台)，它告诉 <strong>complication server</strong> (<code>CLKComplicationServer</code>) 通过数据源刷新数据。数据源返回一个 <strong>timeline</strong> 数据 (一个 <code>CLKComplicationTimelineEntry</code> 的对象) —— timeline 告诉 watchOS complication 在给定时间点到下一个时间点之前应该显示什么数字、文本、图标或者它们的组合。系统缓存这份数据。并且在正确的时间点自动更新显示的内容 —— 你的 app 只有在需要返回 timeline 时才会被唤起，但实际上也可以做到不需要唤起。你可以预先准备一整天的内容，只要你的数据足够提前。</p>
<p>下图是一个经典的天气 app 的例子，点标记 timeline 实体，上面的线显示每个实体被展示的时长。</p>
<p><img src="/images/timeline1.png" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>而这个是日历 app 的 complication ：</p>
<p><img src="/images/timeline2.png" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>取决于 app 类型，你需要的数据可能是未来的，过去的，两者都有，或者只需要当前状态。</p>
<p>在 Kuba 的案例中，他用的是过去的数据 —— 因为 PM10 这种数据不可能精确预测，它受到很多因素影响，某些是人为的 (比如烧煤取暖这类日常活动)</p>
<h1 id="Time-Travel"><a href="#Time-Travel" class="headerlink" title="Time Travel"></a>Time Travel</h1><p>Timeline 的设计还用到 watchOS 的另外一个特性，叫做 <strong>“Time Travel”</strong> ，它使得你可以在表盘上向前或者向后滚动时间，并更新 complication —— 这使得你可以看到诸如一场比赛中比分变化的过程，或者一只股票在一天中股价变化的过程。</p>
<p>watchOS 5 中这个特性被完全移除了，这意味着现在没办法看过去时间点的数据了。所以在实践中，实现处理过去数据这部分的 complication API 没有意义。</p>
<p>未来的数据仍然有价值 —— 虽然没有办法直接滚动操作了，但是 time travel 还可以工作，只不过是单方向固定节奏了。</p>
<p>有趣的是，这部分无用的 API 尚未被废弃，这意味着未来有回归的可能。</p>
<h1 id="Comlication-家族"><a href="#Comlication-家族" class="headerlink" title="Comlication 家族"></a>Comlication 家族</h1><p>在 watchOS 5 中你可以选择多达 26 种样式的表盘。不同的表盘可以适应不同数量和形状的 complications 。这些形状或者 complication 空间的变体被称为 <strong>complication famlilies</strong> ，目前有 10-11 种 families 可用：</p>
<ul>
<li>Modular Small, 用于所有的经典模块化表盘，也可用于 Siri 表盘的角落</li>
<li>Modular Large, 只能用在模块化表盘中间唯一的位置</li>
<li>Circular Small, 用于一些不同的表盘 (e.g. Activity)</li>
<li>Utilitarian Small (有 “flat” 变体) 和 Utilitarian Large, 用于占据表盘一半以上空间，展示一条水平的内容 (它有一个模式，容易跟 Circular Small 混淆)</li>
<li>Extra Large, 只用在 X-Large 表盘上</li>
<li>Graphic Corner, Graphic Circular, Graphic Bezel 和 Graphic Rectangular, 只用在 Apple Watch 4 系列的 Infograph 表盘</li>
</ul>
<p>你可以支持其中任意多你想要的家族子集，当然，理想情况下一个好的 app 是支持所有这些家族，因为不同的人偏好不同的表盘。</p>
<p>项目中为了让事情简单一些，我们只添加了对 Modular Small 和 Circular Small 的支持（覆盖了 11 中表盘，如果没算错的话）。</p>
<h1 id="内容模板"><a href="#内容模板" class="headerlink" title="内容模板"></a>内容模板</h1><p>由于资源的限制，你无法在 complication 空间随意绘制东西，你只能使用预定义的模板。模板限定了它们可以包含的内容类型和排布方式。你唯一的选择是选择一种模块，适配给定的空间，放入文本，图标或者值。</p>
<p>举个例子， Circular Small 家族有 6 种可用的模块：</p>
<p>.ringImage, 中间一个图标，然后一个围绕它的环，其他环的哪些部分被填充可以由你指定<br>.ringText, 中间是文本，然后一个围绕它的环 (实际中，文本通常是 1 到 3 位数字)<br>.simpleImage, 就是个简单的图标<br>.simpleText, 就是个标签<br>.stackImage, 上面一个小图标，下面是短的标签<br>.stackText, 两行短文本</p>
<p>大部分模块都只有极其有限的空间用于展示内容，有的时候你需要绞尽脑汁想如何利用给定的空间。如果实在想不出来，那么放弃对特定 complication 家族的支持也是可以的。</p>
<p>你的 app 会一些不同的状态 —— 例如，有或者没有数据，空或者非空数据列表，有或者没有进行中的活动等等。所以根据状态来选用不同的模块是可以的（比如，某些状态用数字，某些状态用图标）。每当你构建 timeline 时，你可以创建全新的模板对象并且用它们填充内容，所以只要你开心，甚至可以每次采用随机模板。</p>
<h1 id="文本和图像-providers"><a href="#文本和图像-providers" class="headerlink" title="文本和图像 providers"></a>文本和图像 providers</h1><p>为了渲染不同类型内容的灵活性， timeline 数据并非简单地以 <code>String</code> 或者 <code>UIImage</code> 对象的形式返回，而是借助某种可用的 <strong>provide</strong> 对象封装。这些 provider 使得你的内容可以更加动态，根据时间和上下文变化。</p>
<p>对于文本，最简单的选项是 <code>CLKSimpleTextProvider</code> ，你可以指定单一的字符串以及一个可选的简短版本，如果空间无法容纳完整字符串，则选取简短版本。</p>
<p>作为替代方案，有几种时间相关内容的 provider 可供选择：</p>
<ul>
<li><code>CLKDateTextProvider</code> 输出日期 (日 / 月)</li>
<li><code>CLKTimeTextProvider</code> 输出特定时间 (小时 / 分钟)</li>
<li><code>CLKTimeIntervalTextProvider</code> 输出时间范围 (from-to)</li>
<li><code>CLKRelativeDateTextProvider</code> 输出自某个时间开始或者到某个时间结束 (例如 “2 小时后”)</li>
</ul>
<p>上面最后一种会随着时间的流逝自动更新，你只需要配置一次目标时间戳，而不用每小时或者更频繁地手动更新，例如 “5 小时后”，“4 小时后” 等等。</p>
<p>对于图像，你通常用 <code>CLKImageProvider</code> 。它让你指定一个模板图像（被渲染为单色）和一个颜色。多少情况下，这个颜色会被忽略，因为大部分表盘都是以用户选定的单一颜色渲染所有的 complications 。有一个叫 <code>CLKFullColorImageProvider</code> 的模块可以以全彩的方式渲染图像，但只在新的 Infograph 表盘才用到。</p>
<p>模拟 Infograph 表盘上的 complications 还用到一些 <code>CLKGaugeProvider</code> —— 它们是用于配置新表盘角落里的彩色弧线。</p>
<hr>
<p>出发！</p>
<p>首先，创建工程，使用模板 “watchOS &gt; iOS App with WatchKit App” ，确保 “Include Complication” checkbox 勾选。</p>
<p>工程将包含 3 个 targets：</p>
<ul>
<li>SmogWatch, 它是 iOS app (这个案例里我们基本不碰这部分)</li>
<li>SmogWatch WatchKit App, UI 部分，只包含了 storyboard, (包括主 UI 和可能的 notification 场景) 以及 asset catalog 。</li>
<li>SmogWatch WatchKit Extension, 包含所有的 WatchKit 代码</li>
</ul>
<p>在导航栏中选择 “SmogWatch WatchKit App” 目标运行。</p>
<p><img src="/images/sim-new-app.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<h1 id="设计模板"><a href="#设计模板" class="headerlink" title="设计模板"></a>设计模板</h1><p>如上文所提，为了让事情更简单，我们只是实现 Modular Small 和 Circular Small complication 家族。不过默认情况下所有的 complication 家族都是启用的，所以你需要禁用掉其他的。</p>
<p>打开 “SmogWatch WatchKit Extension” target 的配置页，在 “General” tab 你会看见一个可以触发 complication 家族的列表：</p>
<p><img src="/images/enabled-complications.png" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>接下来，要确定每个 complication 家族要采用什么模板。在 <a href="https://developer.apple.com/documentation/clockkit" target="_blank" rel="noopener">CloudKit 文档</a> 中，找到 Modular Small 家族。在它的页面上，你会看到 7 种可用的模板类以及它们的效果截屏。</p>
<p>在我们的案例中，我们主要显示小数字，所以下面几种选项可能是合理的：</p>
<ul>
<li>显示数字，例如 “75” - 可读性没问题，但是第一眼看数字代表什么不明显</li>
<li>以一个圆来显示数字 - 弧应该怎么算，没有上限怎么办？</li>
<li>以上面是图标，下面是数字的方式显示</li>
<li>以两行文本显示</li>
</ul>
<p>最后，我选择了像下面这样的样式：</p>
<p><img src="/images/modular-small.png" width="10%" height="10%" style="margin: 10 auto;"></p>
<p>这个方案解决了展示 app 是什么的类型，同时也支持解释不同类型参数的问题，缺陷是使得字体更小了，尤其是 3 个数字的情况。尽管仍然可读，但是 Circular Small 版本肯定效果不好。因此，对于 Circular Small ，选项相似，也选择了两行文本的版本。</p>
<p><img src="/images/circular-small.png" width="7%" height="7%" style="margin: 10 auto;"></p>
<p>上面这个可读性差很多，但是 Circular Small 是非常通用的 complication 家族，因此基本上对所有使用者都是一个挑战。Apple 自己的 complications ，比如世界时钟，日出、日落，看起来也没有好多少。我们这里可以放弃 “PM” ，但这样一来又搞不清 app 是干什么用的，所以折中，把 “PM10” 缩短为 “PM” 。有可能上面用图标效果会更好，读者可以尝试一下。</p>
<hr>
<h1 id="实现-Complication-数据源"><a href="#实现-Complication-数据源" class="headerlink" title="实现 Complication 数据源"></a>实现 Complication 数据源</h1><p>现在，打开样板代码 <code>ComplicationController</code> 类，这里已经数据源协议所有要求的方法了，一些是空实现，但其中大多数我们并不需要。</p>
<p>注意，所有的方法都是通过一个 handler callback 返回数据的。这使得你可以通过某些异步的方式加载要求的数据 —— 理论上，你是可以按需在用到时再加载这些数据，但实际上我们绝不应该这么做。 </p>
<p>所有的方法都传入一个 CLKComplication 对象作为参数，它让你知道系统现在正为哪一种 complication 向你询问数据，这个对象只有一个字段叫 family ，这意味着在一个 Modular 表盘上，你无法区分同族的两个 complication 实例，但是不同族的可以。</p>
<p>因此，这个信息绝对是必须的 —— 不仅因为不同家族外观看起来不一样，也是为了让编译器匹配你返回的模板类型。</p>
<p><code>CLKComplicationDataSource</code> 协议里只有 <code>getSupportedTimeTravelDirections</code> 和 <code>getCurrentTimelineEntry</code> 两个方法是必须得实现的，但我们会先从一个可选的方法开始讲。</p>
<h1 id="样例模板"><a href="#样例模板" class="headerlink" title="样例模板"></a>样例模板</h1><p>我们要看的第一个方法是 <code>getLocalizableSampleTemplate</code> ，在文件的底部 —— 你有可能会需要在把 complication 添加到表盘之前先实现这个方法。</p>
<p>这个方法让你返回一个 complication 的 “样例” 外观，它是当用户在表盘配置视图中设置 complication 时用到的。这里应当展示一些随机数据，表现你的 complication 一般情况下的外观，就像你在应用的网站或者应用商店上放的截图那样的东西。</p>
<p>在这个方法中，我们需要返回一个 <code>CLKComplicationTemplate</code> 对象 —— 在实际的 timeline 中，我们也会返回一样的东西。不过这里不指定时间戳。对于两种 complication 家族，我们都用标准的 <code>CLKSimpleTextProvider</code> 来封装返回的文本。 在样例模板里，我们用 “50” 来代替真实值。</p>
<p>下面是代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLocalizableSampleTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTemplate?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"50"</span>)</span><br><span class="line">        handler (template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"50"</span>)</span><br><span class="line">        handler (template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>记得总是返回匹配给定 complication 家族的模板。不幸的是，好像没有可以在编译期检查这个过程的机制。</p>
<p>这里，我们为两种家族都选用了 “stack text” 模板，因此都有 <code>line1TextProvider</code> 和 <code>line2TextProvider</code> 属性。如果你选择另外的配置的话，可能的属性有 <code>imageProvider</code> ， <code>headerTextProvider</code> ， <code>ringStyle</code> 等等。</p>
<p>如果系统向我们请求其他我们不支持的 complication 类别的话，我们在默认 case 抛出断言 —— 但这不应该发生，因为我们已经禁用所有其他类型的 complication 。用 <code>preconditionFailure</code> 触发崩溃是为了确保自己不忘掉一些东西，最终版本其实应该返回 nil 更安全。</p>
<p>之所以先说这部分，是因为无论你在这个模板返回了什么，它都会被系统缓存。如果你改变了代码再次运行，你不会看到任何效果 —— 你需要从模拟器中删除 app ，重新安装以便更新版本。</p>
<p>现在，当你运行 app ，你可以编辑表盘（通过用力按压 MacBook 的 touchpad ，或者在菜单 Hardware &gt; Touch Pressure），选择一个 complication 空间，并且选择你的 complication ：</p>
<p><img src="/images/watch-face-editing-1.png" width="25%" height="25%" style="margin: 10 auto;"></p>
<p>注意，默认你的 app 名是 app target 的完整名，这会有点长。为了把它改成更可读的，打开 WatchKit app target 的 <code>Info.plist</code> (注意，是 app 而不是 extension 的) 然后把 “Bundle display name” 改成 “SmogWatch” 。</p>
<p>当你退出编辑模式并返回表盘，你会看到你放置 complication 的地方有一个空白的空间 —— 别急，我们接下来就着手处理这块。</p>
<h1 id="getSupportedTimeTravelDirections"><a href="#getSupportedTimeTravelDirections" class="headerlink" title="getSupportedTimeTravelDirections"></a>getSupportedTimeTravelDirections</h1><p>这个方法告知系统你的 app 在过去、未来、两个方向或者只有当前时刻拥有数据。因为之前提到过去的数据已经不再使用了，所以只有返回 <code>.forward</code> 或者空列表是有意义的。由于我们并不需要预测未来的空气质量，所以我们只需要返回一个空的列表：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSupportedTimeTravelDirections</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimeTravelDirections)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    handler ([])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里返回的东西决定了系统是否会调用 <code>getTimelineStartDate</code> ， <code>getTimelineEndDate</code> ， <code>getTimelineEntries (for:before:limit:withHandler:)</code> 和 <code>getTimelineEntries (for:after:limit:withHandler:)</code> 这些方法，以询问你 timeline 在两个方向上延展的长度，时点。如果我们返回 <code>[]</code> ，那么系统只会询问当前时点。</p>
<p>不过这些方法都是可选的，所以如果你都不实现它们， watchOS 会假定当前时点没有什么有趣的东西。</p>
<h1 id="getCurrentTimelineEntry"><a href="#getCurrentTimelineEntry" class="headerlink" title="getCurrentTimelineEntry"></a>getCurrentTimelineEntry</h1><p>这是整个协议核心的代码，它是我们返回最新数据点的地方。</p>
<p>timeline 数据是以一个或者多个 <code>CLKComplicationTimelineEntry</code> 对象返回的。一个 timeline 实体其实就是一个时间戳加上一个或者多个指派的数据 provider ，里面填充着你需要的数据。实体借由时间戳验证。</p>
<p>目前我们还没有实际拥有数据，不过别担心 —— 我们可以先返回一个静态数值，比如 75 ，就像样例模板中的做法一样。我们使用当前时间作为时间戳，因为根据前面方法返回的设定，我们不会被询问任何在当前时点之前的时段数据。</p>
<p>下面是 <code>getCurrentTimelineEntry</code> 的初始版本:</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentTimelineEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimelineEntry?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> entry: <span class="type">CLKComplicationTimelineEntry</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"75"</span>)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: <span class="type">Date</span>(), complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"75"</span>)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: <span class="type">Date</span>(), complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    handler (entry)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当你添加了以上两个方法，编译运行你的 app 到模拟器。你应该会在 complication 里看到我们配置的模板和数值：</p>
<p><img src="/images/watch-complication-75.png" width="25%" height="25%" style="margin: 10 auto;"></p>
<p>如果你还是没有看到效果，那可能是因为系统缓存了之前编译版本的状态。为了强制加载 complication ，你可以进入编辑模式，切到不同的 complication ，退出编辑模式。 然后再进入编辑模式，切回你的 complication 。</p>
<h1 id="可选的方法"><a href="#可选的方法" class="headerlink" title="可选的方法"></a>可选的方法</h1><p>在数据源协议中还有一些其他的协议，但针对我们的用途，我们只需要用到 <code>getTimelineEntries (for:after:limit:withHandler:)</code> 。这个方法询问我们早前传入的 timeline 时点之后的时点。当我们写的 app 需要提前了解某个时点时，会用到这个方法。例如，天气预报，日历事件，todo list 上预定的任务等。不过，大部分 app 只需要显示当前实体就够了。</p>
<p>我们在这个 app 中使用这个 API 的作用是，我们很可能需要在时点过去之后将未来版本的数据标记为过时。如果你查看的是 6 个小时前的空气质量，它很可能是没什么价值的，因为当前的空气很有可能已经发生显著的变化。在 Krakow ，这种变化可能发生在 2 个小时内。例如，起风或者风停了。所以，我们可能在几小时后自动隐藏掉当前数值，借助添加一个几小时后的 “重置” 数据来实现。如果我们成功地在每个小时更新了数据，那么备选的第二个时点的数据永远不会被展示，但是如果有些东西出错了，那么当时间变化足够长，会在时点到来时借助这个 API 来更新数据。</p>
<p>我认为 watchOS 之前应该也是这么干的，至少在 Time Travel 功能里是这么做的 —— 文档里也提到了。不过这本该是 <code>getTimelineStartDate</code> 和 <code>getTimelineEndDate</code> 方法存在的意义 —— 但是由于这两个 API 不起作用 (Time Travel)，所以实现它们也没意义。 </p>
<hr>
<h1 id="从网络上获取真实数据"><a href="#从网络上获取真实数据" class="headerlink" title="从网络上获取真实数据"></a>从网络上获取真实数据</h1><p>对于第一个版本，我们用使用 Małopolska 地区空气监控系统的公共数据 (仅限波兰) 。</p>
<p>前端通过一个挺复杂的 POST 请求，发送到 URL <a href="http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz" target="_blank" rel="noopener">http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz</a> ，然后解析返回的 Json 数据。</p>
<p>这个主题并不是跟 watchOS 特定相关，它是特定于 web API —— 所以这里不详细描述，下面是拉取和解析数据的完整代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">DataURL</span> = <span class="string">"http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KrakowPiosDataLoader</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> d = <span class="type">DateFormatter</span>()</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 不确定下面是否必须，安全起见 </span></span><br><span class="line">        <span class="comment">//see https://developer.apple.com/library/archive/qa/qa1480/</span></span><br><span class="line">        d.locale = <span class="type">Locale</span>(identifier: <span class="string">"en_US_POSIX"</span>)</span><br><span class="line"> </span><br><span class="line">        d.dateFormat = <span class="string">"dd.MM.yyyy"</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 确保我们用的是 CET 时区 —— 比如说你是在莫斯科 </span></span><br><span class="line">        <span class="comment">// 你在 2 月 19 号午夜之后请求 19.02.2019 （这时候在波兰还是 2 月 18 号）</span></span><br><span class="line">        <span class="comment">// 你将拿不到数据 </span></span><br><span class="line">        d.timeZone = <span class="type">TimeZone</span>(identifier: <span class="string">"Europe/Warsaw"</span>)!</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    }()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> dataStore = <span class="type">DataStore</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> session: <span class="type">URLSession</span> = {</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.ephemeral</span><br><span class="line">        config.timeoutIntervalForResource = <span class="number">10.0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: config)</span><br><span class="line">    }()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">queryString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> query: [<span class="type">String</span>: <span class="type">Any</span>] = [</span><br><span class="line">            <span class="string">"measType"</span>: <span class="string">"Auto"</span>,</span><br><span class="line">            <span class="string">"viewType"</span>: <span class="string">"Parameter"</span>,</span><br><span class="line">            <span class="string">"dateRange"</span>: <span class="string">"Day"</span>,</span><br><span class="line">            <span class="string">"date"</span>: dateFormatter.string (from: <span class="type">Date</span>()),</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//hardcoded ID for PM10 on a specific station</span></span><br><span class="line">            <span class="comment">//we'll make it configurable later</span></span><br><span class="line">            <span class="string">"viewTypeEntityId"</span>: <span class="string">"pm10"</span>,</span><br><span class="line">            <span class="string">"channels"</span>: [<span class="number">148</span>]</span><br><span class="line">        ]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> jsonData = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.data (withJSONObject: query, options: [])</span><br><span class="line">        <span class="keyword">let</span> json = <span class="type">String</span>(data: jsonData, encoding: .utf8)!</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//don't ask me, that's what the API expects</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"query=\(json)"</span></span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(<span class="number">_</span> completion: @escaping <span class="params">(Bool)</span></span></span> -&gt; ()) {</span><br><span class="line">        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="type">DataURL</span>)!)</span><br><span class="line">        request.httpBody = queryString ().data (using: .utf8)!</span><br><span class="line">        request.httpMethod = <span class="string">"POST"</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: sending request to %@ with %@ ..."</span>,</span><br><span class="line">            <span class="type">DataURL</span>, queryString ())</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> task = session.dataTask (with: request) { (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = error {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: received error: %@"</span>, <span class="string">"\(error)"</span>)</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: received response: %@"</span>,</span><br><span class="line">                    data != <span class="literal">nil</span> ? <span class="string">"\(data!.count) bytes"</span> : <span class="string">"(nil)"</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data = data {</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> obj = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject (with: data, options: []) {</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> json = obj <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] {</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> data = json [<span class="string">"data"</span>] <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] {</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> series = data [<span class="string">"series"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]] {</span><br><span class="line"> </span><br><span class="line">                                <span class="comment">//there would be more than one data series if we passed</span></span><br><span class="line">                                <span class="comment">//multiple "channel IDs" (e.g. for more than 1 station)</span></span><br><span class="line">                                <span class="keyword">if</span> <span class="keyword">let</span> first = series.first {</span><br><span class="line">                                    <span class="keyword">if</span> <span class="keyword">let</span> points = first [<span class="string">"data"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>]] {</span><br><span class="line"> </span><br><span class="line">                                        <span class="comment">//the data series is an array of up to 26 hourly</span></span><br><span class="line">                                        <span class="comment">//measurements; we only take the last one for now</span></span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> point = points.last {</span><br><span class="line">                                            <span class="keyword">let</span> date = <span class="type">Date</span>(</span><br><span class="line">                                                timeIntervalSince1970: <span class="type">Double</span>(point [<span class="number">0</span>])!</span><br><span class="line">                                            )</span><br><span class="line">                                            <span class="keyword">let</span> value = <span class="type">Double</span>(point [<span class="number">1</span>])!</span><br><span class="line"> </span><br><span class="line">                                            <span class="keyword">self</span>.dataStore.currentLevel = value</span><br><span class="line">                                            <span class="keyword">self</span>.dataStore.lastMeasurementDate = date</span><br><span class="line"> </span><br><span class="line">                                            <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: saving data:"</span> +</span><br><span class="line">                                                <span class="string">"%.0f at %@"</span>, value, <span class="string">"\(date)"</span>)</span><br><span class="line"> </span><br><span class="line">                                            success = <span class="literal">true</span></span><br><span class="line">                                        }</span><br><span class="line">                                    }</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> !success {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: no data found"</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            completion (success)</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        task.resume ()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不要忘记在最后用 <code>resume ()</code> 启动任务。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>我们向 API 请求 PM10 的数据，硬编码请求当天和特点地点。</li>
<li>我们只取最后的测量结果 (多数情况下是最近一两个小时的数据)</li>
<li>如果我们拿到数据，存储一个数字，表示 PM10 的浓度，以及测量的时间点</li>
<li>通知调用方我们拿到或者没有拿到数据</li>
</ul>
<p>上面的代码用了老式的 Json 解析方法，因为我认为这样比较容易理解。</p>
<p>我用老式的 <code>NSLog</code> 而不是 Swift 的 <code>print ()</code> ，是因为后者只会显示在 Xcode 的控制台，并不会记录到系统日志，所以在控制台 app 的诊断日志里看到，在某些情况下你需要在 app 没有连接 mac 时跟踪它的行为。</p>
<p>还有，注意我们是在前台请求数据，用最基本的 URL session 。这不是通常我们最理想的应用方案 —— 理想的，所有的请求都应该是在后台 URL sessions 中完成，不过这里只是一个最小可用原型，先保持这样吧。</p>
<p>不过我们通过把超时时间设置为每次请求不超过 10 秒钟来限制了 URL session。 这里 <code>timeoutIntervalForResource</code> 的用法，而不是 <code>timeoutIntervalForRequest</code> 或者 <code>timeoutInterval</code> 很重要，因为自上一次接收到数据包后，后面两个只会在空闲时间工作，而我们希望控制总的请求时间。之所以要控制总时间，是因为看起来这里边有一个针对后台任务的硬性限制，并且没有在文档中提到：如果一个 app 超出了 15 秒的后台运行时间，它会被立即杀死，崩溃报告如下：</p>
<blockquote>
<p>Termination Reason: CAROUSEL, Background App Refresh watchdog transgression. Exhausted wall time allowance of 15.00 seconds. Termination Description: SPRINGBOARD, CSLHandleBackgroundRefreshAction watchdog transgression: eu.mackuba.SmogWatch.watchkitapp.watchkitextension exhausted real (wall clock) time allowance of 15.00 seconds (…)</p>
</blockquote>
<p>为了便于你了解最后一次检测的时间点，我们把 <code>lastMeasurementDate</code> 时间戳存进了 <code>DataStore</code> ，这是一个我们可以用来实现之前提到的 “过时数据 特性的潜在结构。</p>
<p>那么这个 <code>DataStore</code> 究竟是什么？其实只是 <code>UserDefaults</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">CurrentLevelKey</span> = <span class="string">"CurrentLevel"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">LastMeasurementDate</span> = <span class="string">"LastMeasurementDate"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataStore</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> defaults = <span class="type">UserDefaults</span>.standard</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Double?</span> {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> defaults.object (forKey: <span class="type">CurrentLevelKey</span>) <span class="keyword">as</span>? <span class="type">Double</span> }</span><br><span class="line">        <span class="keyword">set</span> { defaults.<span class="keyword">set</span>(newValue, forKey: <span class="type">CurrentLevelKey</span>) }</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> lastMeasurementDate: <span class="type">Date?</span> {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> defaults.object (forKey: <span class="type">LastMeasurementDate</span>) <span class="keyword">as</span>? <span class="type">Date</span> }</span><br><span class="line">        <span class="keyword">set</span> { defaults.<span class="keyword">set</span>(newValue, forKey: <span class="type">LastMeasurementDate</span>)}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后，我们需要添加一个例外域名到 WatchKit Extension target 的 App Transport Security 设置中，因为这个域名不支持 Https 。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionDomains<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>monitoring.krakow.pios.gov.pl<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionAllowsInsecureHTTPLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="显示真实数据"><a href="#显示真实数据" class="headerlink" title="显示真实数据"></a>显示真实数据</h1><p>为了实际加载数据，我们需要在某个地方调用这个类的方法。我们来看一看 <code>ExtensionDelegate</code> 这个类，它实现了 <code>WKExtensionDelegate</code> —— 基本上就是一个 WatchKit 版本的 <code>UIApplicationDelegate</code> 。就像所有的 app 代理， <code>WKExtensionDelegate</code> 有许多生命周期方法，这些方法会被系统在各种时刻调用： <code>applicationWillEnterForeground</code> ， <code>applicationDidBecomeActive</code> ， <code>applicationWillResignActive</code> 和 <code>applicationDidEnterBackground</code> 等等。</p>
<p>这里头我们目前唯一会用到的是 <code>applicationDidFinishLaunching</code> 。这个方法会在 app 进程启动时被调用 —— 无论是通过 app launcher 或者通过 Xcode ，又或者从后台启动。只要是 app 需要被唤起，并且之前已经被系统清理掉的时候，这个周期都会运行 (通常在晚上，被系统杀死的情况经常发生) 。</p>
<p>无论何时， app 启动或者在后台重启，我们都希望借助这个机会立即拉取最新的数据，如果我们得到响应，重新加载所有活动的 complication （活动的 complication 指那些在当前选择的表盘上显示的 complication）。</p>
<p>所以我们将这样做：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: applicationDidFinishLaunching ()"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> success {</span><br><span class="line">            <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了拉取数据，我们调用了 KrakowPiosDataLoader 类，然后在有任何新数据的情况下重载加载 complications ，否则的话就不必了。在 watchOS 上，不要浪费时间做无用功，这是一条通用的准则。</p>
<p>为了重新加载 complications ，我们得拿到活动 complication 的列表，这是借由全局共享的  <code>CLKComplicationServer</code> 实例来获得的，并且也通过它的 <code>reloadTimeline (for:)</code> 方法来重新加载那些活动的 complication 。如果打算在已经存在的 timeline 实体后追加新的 timeline 实体，我们也可以用另一个相似方法  <code>extendTimeline (for:)</code> ，两者的区别是前者我们希望立刻用新数据替换掉之前的数据。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadActiveComplications</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">let</span> server = <span class="type">CLKComplicationServer</span>.sharedInstance ()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> complication <span class="keyword">in</span> server.activeComplications ?? [] {</span><br><span class="line">        server.reloadTimeline (<span class="keyword">for</span>: complication)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码会触发一轮对你的 <code>CLKComplicationDataSource</code> 的调用 —— 有的时候是一会之后，不过通常几乎都是立刻发生。现在我们有了真实数据，我们可以回到之前写的 <code>getCurrentTimelineEntry</code> 方法，然后把占位的代码替换成实际的逻辑：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentTimelineEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimelineEntry?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> store = <span class="type">DataStore</span>()</span><br><span class="line">    <span class="keyword">let</span> entry: <span class="type">CLKComplicationTimelineEntry</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> valueLabel: <span class="type">String</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> lastMeasurement = store.lastMeasurementDate, <span class="keyword">let</span> level = store.currentLevel {</span><br><span class="line">        valueLabel = <span class="type">String</span>(<span class="type">Int</span>(level.rounded ()))</span><br><span class="line">        date = lastMeasurement</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        valueLabel = <span class="string">"--"</span></span><br><span class="line">        date = <span class="type">Date</span>()</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: valueLabel)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: date, complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: valueLabel)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: date, complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    handler (entry)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在，当我们运行 app 时，点击 home 按钮返回表盘时，我们会看到一个刚刚借助 API 加载的真实数据：</p>
<figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExtensionDelegate: applicationDidFinishLaunching ()</span><br><span class="line">KrakowPiosDataLoader: sending request to http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz with</span><br><span class="line">query={"viewTypeEntityId": "pm10", "measType": "Auto", "viewType": "Parameter", "dateRange": "Day",</span><br><span class="line">"date": "24.02.2019", "channels": [148]} ...</span><br><span class="line">KrakowPiosDataLoader: received response: 1553 bytes</span><br><span class="line">KrakowPiosDataLoader: saving data: 46.4462 at 2019-02-24 10:00:00 +0000</span><br></pre></td></tr></tbody></table></figure>
<p><img src="/images/watch-complication-46.png" width="34%" height="34%" style="margin: 10 auto;"></p>
<hr>
<h1 id="安排更新"><a href="#安排更新" class="headerlink" title="安排更新"></a>安排更新</h1><p>最后的拼图是确保我们可以按照有规律的间隔加载新的数据并重新加载 complication 。有一些场景你可以更新 complications ：</p>
<ul>
<li>当你的 app 处于前台时，你总是可以做这件事 —— 但你无法依赖它定期发生。</li>
<li>当你接受到一些静默的推送通知时，尤其是专门为这种用途设计的 (借助 PushKit framework ，采用  PKPushTypeComplication 类型) —— 当你的数据以不规则间隔更新时，这种机制会有用 —— 当外部发生一些事件时。</li>
<li>当 iPhone app 以某种方式接收到新的数据并把它传输给 watch 时</li>
<li>通过计划定期的后台刷新 —— 当你希望拉取数据而不是被动等推送时，这种方式更好。</li>
</ul>
<p>注意，不管你采用哪种策略，对于我们刷新数据的频率以及完成刷新的用时，有许多限制。 (比如，每天不超过 50 个推送通知) —— 如果你用尽了所有的时间或者每天可用的推送数量，你将无法再在后台运行，有可能要等到第二天。对于这点约束，看起来没有什么特别好的方案可以绕过，你也不应该尝试去寻找这类方案。</p>
<p>既然我们知道城市监测站每小时发送一次新的测量数据，我们会使用计划好的后台刷新来更新我们的 complication ，并且会在 <code>ExtensionDelegate</code> 中完成。</p>
<p>为了确保我们的 app ，我们需要实现一样我称为 “后台刷新循环” 的东西：当 app 启动或者重启时，我们安排一次后台刷新，然后当 app 被这个后台刷新唤起时，我们做的第一件事就是安排下一次后台刷新，以确保若干时间后总有新的刷新被计划。</p>
<p>我们会在所有其他事情之前开始做刷新计划，因为我们无法知道在我们的 app 被挂起或者杀死之前还有多少可用的时间。否则，如果在我们设置下一次刷新之前 app 就被挂起，那么 app 就相当于没设闹钟就睡过去了，那么它将会睡过头。 😉</p>
<p>现在，让我们再看一下 <code>applicationDidFinishLaunching</code> 方法，我们需要在 web 请求发送之前增加一个新的方法调用 <code>scheduleNextReload ()</code> :</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: applicationDidFinishLaunching ()"</span>)</span><br><span class="line"> </span><br><span class="line">    scheduleNextReload ()</span><br><span class="line"> </span><br><span class="line">    <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> success {</span><br><span class="line">            <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="计算下一次刷新时间"><a href="#计算下一次刷新时间" class="headerlink" title="计算下一次刷新时间"></a>计算下一次刷新时间</h1><p>在计划下一次刷新前，我们首先需要定出下一次刷新的时机。</p>
<p>为了优化后台刷新的耗时，尽可能利用好珍贵的后台时间，思考清楚我们的数据究竟需要在何时和以何种频率改变。一个很好的例子是 —— 证券交易只发生在工作时间，不在工作时间内，股票价格不会变化，所以在夜间重载不会改变的数据是没有意义的。</p>
<p>我对获取数据的 API 做了一些测试，新的数据几乎总是 1 个整小时的 0 到 10 分钟内添加。所以我决定每小时请求一次刷新，总是在每小时的 15 分做这件事 (10:15 ， 然后 11:15， 然后 12:15 ，以此类推)。为了实现这种方式，我们需要一个辅助方法来让我们基于当前时间找到最接近 xx:15 的时间 —— 幸运的是，利用 NSCalendar API 很容易做到：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextReloadTime</span><span class="params">(after date: Date)</span></span> -&gt; <span class="type">Date</span> {</span><br><span class="line">    <span class="keyword">let</span> calendar = <span class="type">Calendar</span>(identifier: .gregorian)</span><br><span class="line">    <span class="keyword">let</span> targetMinutes = <span class="type">DateComponents</span>(minute: <span class="number">15</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> nextReloadTime = calendar.nextDate (</span><br><span class="line">        after: date,</span><br><span class="line">        matching: targetMinutes,</span><br><span class="line">        matchingPolicy: .nextTime</span><br><span class="line">    )!</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果和当前时间间隔小于 5 分钟，那么跳过，尝试下一个小时 </span></span><br><span class="line">    <span class="keyword">if</span> nextReloadTime.timeIntervalSince (date) &lt; <span class="number">5</span> * <span class="number">60</span> {</span><br><span class="line">        nextReloadTime.addTimeInterval (<span class="number">3600</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> nextReloadTime</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="计划后台刷新"><a href="#计划后台刷新" class="headerlink" title="计划后台刷新"></a>计划后台刷新</h1><p>最后，为了在计算好的未来时点请求更新，我们需要在 <code>WKExtension</code> (等价于 <code>UIApplication</code>) 上调用  <code>scheduleBackgroundRefresh</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleNextReload</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">let</span> targetDate = nextReloadTime (after: <span class="type">Date</span>())</span><br><span class="line"> </span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: scheduling next update at %@"</span>, <span class="string">"\(targetDate)"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="type">WKExtension</span>.shared ().scheduleBackgroundRefresh (</span><br><span class="line">        withPreferredDate: targetDate,</span><br><span class="line">        userInfo: <span class="literal">nil</span>,</span><br><span class="line">        scheduledCompletion: { <span class="number">_</span> <span class="keyword">in</span> }</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你传入的日期是你希望你的 app 被唤起的时间。当然，系统会把它看做一种提示 —— 你的 app 实际被唤起的时间还可能取决于各种因素（我猜测这其中包含电量，充电状态，网络访问，你请求刷新的频率，你每次刷新的耗时，等等）。所以，不要假定你的 app 总是能在固定的间隔运行。</p>
<p>不过，基于我的测试，在实践中一个拥有一个活动 complication ，每隔一个小时更新的 app ，通常在 10 秒以后的请求时间，在白天的表现比在夜间充电的表现要好很多，或者 app 运行频繁，或者 app 处于 dock 但是没有 complication 时，后台任务被调用的机会更少。不在 dock 也不没有 complication 的 app ，几乎不被调用。</p>
<p><code>scheduledCompletion</code> 块在文档中被描述为 “A block that is called by the system after the background app refresh task has completed” ，但是实际上它是在下一个刷新任务计划完成时就被立即执行。不过由于它是一个可选的参数，你可以提供一个空的块。至于 <code>userInfo</code> ，它可以传递一些元数据给后台任务的 handler ，但这里我们用不上。</p>
<h1 id="处理后台任务"><a href="#处理后台任务" class="headerlink" title="处理后台任务"></a>处理后台任务</h1><p>watchOS 上的后台刷新是通过在各种时刻从后台唤起你的 app ，然后调用代理方法 <code>handle (_ backgroundTasks:)</code> ，传给它一个或者多个取决于上下文的 “后台任务”。这个方法对于你的 app 后台事务至关重要，不管你构建的 app 是什么类型，几乎一定要在这里做些事情。</p>
<p>任务的类型有不少，但你应当做跟当时接收到的任务相关的工作。比如有的任务是处理 URLSession 返回的数据，有的任务是处理 iPhone 返回的数据，有的任务是处理 Siri 快捷方式，但是这里我们要处理的是一种通过之前的 <code>scheduleBackgroundRefresh</code> 发起的任务 —— 这是一种最普通的 <code>WKApplicationRefreshBackgroundTask</code> 。这种任务意味着你的 app 是由于你自己的请求而被唤起的，以便你可以运行一些后台的 URL 请求，更新你的 complication 等等。</p>
<p>当 app 在后台被唤起时，在 <code>handle (_ backgroundTasks:)</code> 方法中，我们做的事情跟启动时的差不多 —— 我们计划下一次刷新，并尝试更新数据。注意，我们只用了 <code>WKApplicationRefreshBackgroundTask</code> ，忽略其他的任务类型。不过，在完成任务后，记得总是调用 <code>setTaskCompletedWithSnapshot ()</code> 方法，这很关键，即便对于那些被你忽略掉并且不处理的任务。不过，调用这个方法表明我们的事干完了，在这之后我们的 app 可能会被挂起。</p>
<figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(<span class="number">_</span> backgroundTasks: Set&lt;WKRefreshBackgroundTask&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> backgroundTasks {</span><br><span class="line">        <span class="keyword">switch</span> task {</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> backgroundTask <span class="keyword">as</span> <span class="type">WKApplicationRefreshBackgroundTask</span>:</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: handling WKApplicationRefreshBackgroundTask"</span>)</span><br><span class="line"> </span><br><span class="line">            scheduleNextReload ()</span><br><span class="line"> </span><br><span class="line">            <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> success {</span><br><span class="line">                    <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">                }</span><br><span class="line"> </span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: completed WKApplicationRefreshBackgroundTask"</span>)</span><br><span class="line">                backgroundTask.setTaskCompletedWithSnapshot (<span class="literal">false</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            task.setTaskCompletedWithSnapshot (<span class="literal">false</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>让 watchOS 模拟器运行 app 后台刷新任务需要一些技巧，即使你已经安排它们在一会之后运行。如果你测试时发现不工作，可以尝试随机切换 app ，主屏和表盘，直到后台刷新任务可以工作。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就这些，我们完成了！🎉 我们得到一个每小时运行的 app ，从 web API 加载新数据，显示到你选择的表盘上，你只要抬腕就能看到它。</p>
<p>依我看来，为了构建一个带 complication 的最小可行的 watch app ，你需要做这些事：</p>
<ol>
<li>确定你的 app 想要在 complication 上展示的最重要的东西。</li>
<li>确定你的 complication 内容什么时候改变，你的 timeline 存放什么以及存在哪里。</li>
<li>浏览 complication 家族以及对应可用的模板，确定哪些最适合你</li>
<li>实现从 web 或者系统 API 加载数据的代码</li>
<li>实现 complication 数据源要求的方法，以构建 <code>CLKComplicationTimelineEntry</code> 和 <code>CLKComplicationTemplate</code> 对象，以合适的方式展示你的内容。</li>
<li>确保你的 app 定期更新，用计划的后台刷新或者借助推送通知 (分析你的数据变化的模式，以便优化后台时间)</li>
<li>测试，测试，再测试，用任何你能想到的场景和组合 🙂</li>
</ol>
<p>如果你只是构建一个静态的 complication ，永远不更新，就像 Apple 的 “launcher” 型的 complications ， 比如 Breathe ， Maps ， Reminders 等等。那么，你只需要做这些事：</p>
<ol>
<li>为所有支持的 complications 挑选一个图标。</li>
<li>实现数据源方法，用 “single icon” 模板返回单一实体的 timeline 。</li>
</ol>
<p>这种情况下你不需要计划后台刷新以更新 complication ，因为它永远不变。不过，由于 complication 需要链接到真实 app 时，也有大量工作需要做。 😉</p>
<p>工程中的代码可以从这个仓库找到: <a href="https://github.com/mackuba/SmogWatch" target="_blank" rel="noopener">https://github.com/mackuba/SmogWatch</a> (master 分支最新代码，或者对应这篇文档的 post2 分支的版本)。 它是 WTFPL-licensed ，所以尽管拿去用，你可以分享给我你都做出什么好玩的东西！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://theinfinitegame.tech/development/note-watchos-big-picture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="猫克杯">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Infinite Game">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/development/note-watchos-big-picture/" class="post-title-link" itemprop="url">watchOS 学习笔记 | Big Picture</a>
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-20 11:42:05" itemprop="dateCreated datePublished" datetime="2020-02-20T11:42:05+08:00">2020-02-20</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/development/" itemprop="url" rel="index">
                    <span itemprop="name">development</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>3.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="watchOS-应用"><a href="#watchOS-应用" class="headerlink" title="watchOS 应用"></a>watchOS 应用</h1><p>相比 macOS，iOS 和 tvOS ，watchOS (目前为止) 并非是完全独立的平台，一定程度上依赖配对的 iPhone 。</p>
<blockquote>
<p>watchOS 6.0 之后，watch app 可以独立发布和安装，也就说，应用生态上可以独立了。但是，某些功能要想发挥最大的效用，还要借助 iPhone 设备的计算能力。毕竟，后者目前还是要强大很多。可以这么理解，当需要用到 watch 本身不具备的硬件能力时，如视频拍摄，你仍可以把 watch 视为控制器。这个跟人们看待早期智能手表的视角一致。</p>
</blockquote>
<h1 id="Watch-app-和扩展"><a href="#Watch-app-和扩展" class="headerlink" title="Watch app 和扩展"></a>Watch app 和扩展</h1><p>watchOS app 跟 iOS app 最显著的差异是前者被严格的分成了两部分。第一部分称为 Watch app —— 有点混淆对吧？正常理解，两部分加起来才是一个完整的 app 。但字面上，这个主要由 UI 构成的部分就叫 Watch app ，所以我们干脆以 UI 来代表，第二个部分是 WatchKit 扩展。两部分有各自独立的数据容器，如果需要共享容器中的文件，需要用到 <strong>App Groups</strong> 。</p>
<p>watch OS 6 引入 SwiftUI 后，情况变得有些复杂。因为 SwiftUI 中，UI 即代码。原来的 watch app 部分只有一个 hosting view 。</p>
<h1 id="这些年-watchOS-的变化"><a href="#这些年-watchOS-的变化" class="headerlink" title="这些年 watchOS 的变化"></a>这些年 watchOS 的变化</h1><p>watchOS 1 中，app UI 运行在 watch 上，但扩展运行在 iPhone 上。扩展可以很容易地与设备上的其他 iOS app 通信，但扩展和 watch UI 之间的通信是设备间的，因此整个 app 运行很慢。</p>
<p>watchOS 2 中，扩展被移到了 watch 上。watch app 和 iOS app 通信需要借助 <strong>WatchConnectivty framework</strong> 。因为扩展处于 watch 上，所以能用到 SDK 自然变少了。当然，后来各种缺失的 SDK 也被陆续添加到 watchOS 中。</p>
<p>watchOS 4 中，扩展和 UI 被合为一个进程运行。当然，这一点对开发者来说相对无感，唯一的效果是 app 运行的更快了。</p>
<p>watch OS 5 以前，WatchKit app 需要依赖 iPhone 的连接来完成大部分通信。它只能连接 iPhone 连接过的 “已知 Wi-Fi 网络” 。watch OS 5 引入了连接全新 WiFi 网络的能力。</p>
<p>在 watch OS 5 及之前的版本，watch app 总是要求有一个伴生的 iOS app 。watch app 是内置在 iOS app bundle 中，它的安装也是通过先安装 iOS app ，再间接下载到 watch 上来完成的。最近的 watch OS 6 ，watch app 真正意义上宣布独立。你既可以采用之前的 iOS app + watch app 的方式， 也可以只开发独立的 watch app 。watch app 不再是内置在 iOS app 中，两者被分隔在各自平台的 App Store 发布。因此，对于因特网的连接方式，最新的建议是 借助 <strong>URLSession</strong> ，<strong>CloudKit</strong> 等直接下载数据到 watch ，只有在真的需要跟 iPhone 交换数据时才用到 <strong>WatchConnectivity</strong> 。</p>
<hr>
<h1 id="多于一个用户接口"><a href="#多于一个用户接口" class="headerlink" title="多于一个用户接口"></a>多于一个用户接口</h1><p>iOS app 通常有一个主要的用户入口。人们想到 iOS app 的时候，通常想到的是主界面上的图标。当然，也有各种扩展可以访问 app 的不同部分，但是通常被认为是主 app 的附属。你使用 app 的主要姿势是打开主 app 。</p>
<p>来到 watchOS ，情况大不相同。主 UI ，根据你的用例，很有可能不是最常被使用的部分。其主要原因在于 iPhone 和 Apple Watch 完全不同的交互模式。你不可能像在 iPhone 上那样在 watch 的屏幕上花很长的时间浏览内容吧？很显然，那很不舒服。</p>
<p>对于 watchOS ，Apple 一直重复的关键词是 <strong>glances</strong> 或者说 <strong>glanceable</strong> 。期望的 app 交互方式是：抬起手腕，看表，做一两个点击（或者甚至都不点击），或者转一下数字表冠，然后放下手腕，回到现实。这一系列动作的平均时间是以秒计的。实际上，建议是在 2 秒内让用户找到目标信息 (glanceable) 或者执行动作 (actionable) 。</p>
<p>如果你用过 watchOS app ，你应该知道通过主 app 找到目标信息需要一点技巧。首先，你要在主屏上那一堆六边形网格中找到 app ，然后点击，等待加载，然后在 app 的不同屏之间寻找你要的东西。基于此，也取决于你的 app 类型，极有可能你的主 UI 只会偶尔被用到。 WatchKit app 实际上提供了一些其他的入口来交互，它们可能更重要。</p>
<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>通知实际上是 watch 的一个绝佳的应用场景。花不到一秒的时间看一眼手表，比从口袋里掏出手机来省事不少吧？许多人会告诉你，他们戴 watch 的主要用途就是看通知。</p>
<p>但是，通知用的好不好，对不对，主要还是取决于你的 app 类型，通知的目的。比如，你的目的是不定期的通知用户某些事情发生了，通知可以是你的 app 很重要的一部分。典型的，提醒事项 app 。</p>
<p>watchOS 上通知的 UI 有三种变体：</p>
<ul>
<li>只有预制的静态信息</li>
<li>非交互式的动态信息</li>
<li>可交互的动态信息，watchOS 5 引入 </li>
</ul>
<p>watch OS 6 允许推送绕过 iPhone ，只到达 Apple Watch 的远程通知。</p>
<h3 id="Glances-Dock"><a href="#Glances-Dock" class="headerlink" title="Glances / Dock"></a>Glances / Dock</h3><p>watchOS 1 开始，引入了一种被叫做 <strong>glance</strong> 的界面，卡片式，可点击，水平滚动。借助 storyboard 上单独的场景构建。</p>
<p>watchOS 3 开始，<strong>glance</strong> 被废弃，由 <strong>dock</strong> 取代，后者是通过按压表侧的长按钮访问。它的工作方式和 glance 相似，但是卡片的外观是基于主 app 的实际 UI (类似 iOS 上的体验)，通过系统对 app 生命周期某些节点的快照来实现。当你完成滚动，选择了某个 app 后，系统会唤醒这个 app ，不久之后这个 app 实际的 live 视图会更新 dock 的静态图片。</p>
<p>watch OS 4 之后，dock 变成竖向滚动，跟 iOS 的体验更相似。</p>
<h3 id="Complications"><a href="#Complications" class="headerlink" title="Complications"></a>Complications</h3><p>“<strong>Complications</strong>“ 是 Apple 给表盘上的各种 widget 取的一个比较有逼格的名字。</p>
<img src="/images/watch-complications.png" width="68%" height="68%" style="margin: 10 auto;">

<p>Complications 有很多不同的家族，为不同的表盘设计 —— 圆形的，矩形的，小的，大的。这些 complictions 的共同点是展示信息的空间极其有限，一直可见（激活状态），因此需要保持最新状态。</p>
<p>你可以想象，complication 的特点是不可能通过让 app 持续运行在后台，并且完全访问表盘的方式来实现的。因为这样做电池撑不住。</p>
<p>Apple 的解决方案是你需要周期性的提前提供一个包含给定时间范围的 <strong>timeline</strong> 数据给 complication 用于显示。系统存储这份数据，到时间点了自动切换到正确的状态。你不能在 complication 里随意显示内容 —— 你只能从给定的 complication 家族中选择预先定义好的模板，然后填充一些精心准备的，允许系统在必要时简化以便适配可用空间的数据。</p>
<p>这里面的一个挑战是：如何找出有用的东西，填充到这么小的空间里 —— 同时这也是一个能简化工作的约束，因为你只有有限的选项。</p>
<p>Apple 一开始就说了，complications 只对部分 app 有意义 —— 因而并非每个 app 都有一些关键信息，可以展示为一个数字或者一行文本。不过，从 watchOS 3 开始，官方建议所有的 app 都实现一个 complication ，即便这个 complication 只是一个静态的启动器。（个人认为这个要求对用户的意义在于，用户可以在表盘上添加特定 app 的 complication ，仅仅作为启动器也是有价值的）。技术层面，系统可以针对当前表格的启动器，做一些优化，以便 app 启动更快。</p>
<h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><p>最后一个入口就是 Siri 了， watchOS 5 以后，Siri 可以用于更多的用例，例如发消息，todo list 等等。</p>
<hr>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://mackuba.eu/2018/12/18/watchkit-adventure-1-the-big-picture/" target="_blank" rel="noopener">MacKuba 关于 WatchKit 的文章 1</a></p>
<p><a href="https://mackuba.eu/2019/03/06/watchkit-adventure-2-mvc/" target="_blank" rel="noopener">MacKuba 关于 WatchKit 的文章 2</a></p>
<p><a href="https://github.com/mackuba/SmogWatch" target="_blank" rel="noopener">MacKuba 的一个 apple watch 项目</a></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://theinfinitegame.tech/computer-tech/ar-arkit-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="猫克杯">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Infinite Game">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/computer-tech/ar-arkit-overview/" class="post-title-link" itemprop="url">AR | ARKit 概览</a>
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-17 16:44:13" itemprop="dateCreated datePublished" datetime="2020-02-17T16:44:13+08:00">2020-02-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/computer-tech/" itemprop="url" rel="index">
                    <span itemprop="name">computer-tech</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>2.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><ul>
<li><strong>运动跟踪 (motion tracking)</strong> 使得手机理解和追踪它相对于世界的位置。</li>
<li><strong>环境理解 (environmental understanding)</strong> 使得手机可以侦测各种表面的尺寸和位置：水平的，竖直的，成一定角度的，比如地面，咖啡桌或者墙面。</li>
<li><strong>光线评估 (light estimation)</strong> 使得手机可以估计环境当前的光照条件。</li>
</ul>
<hr>
<h1 id="ARKit"><a href="#ARKit" class="headerlink" title="ARKit"></a>ARKit</h1><h2 id="ARKit-3"><a href="#ARKit-3" class="headerlink" title="ARKit 3"></a>ARKit 3</h2><p>ARKit 3 带给人们不可思议的体验。通过 People Occlusion，ARKit 3 知道人们和 AR 对象在哪里，并适当地遮挡 scene。ARKit 3 使用 Motion Capture 跟踪人们的运动，将其输入到 AR scene 中。它还可以同时跟踪最多三张人脸，支持 collaborative sessions 等等。</p>
<h4 id="People-Occlusion"><a href="#People-Occlusion" class="headerlink" title="People Occlusion"></a>People Occlusion</h4><p>现在 AR 内容能呈现在人们的身后和前面，使 AR 体验更加沉浸化。同时，在大多数环境能实现绿幕风格的效果。</p>
<h4 id="Motion-Capture"><a href="#Motion-Capture" class="headerlink" title="Motion Capture"></a>Motion Capture</h4><p>用一台相机实时捕捉人们的运动。通过将人们身体的位置和运动，理解为一系列关节和骨骼，您可以使用运动和姿势作为 AR 体验的输入 —— 将人们放置在 AR 的中心。</p>
<h4 id="Simultaneous-Front-and-Back-Camera"><a href="#Simultaneous-Front-and-Back-Camera" class="headerlink" title="Simultaneous Front and Back Camera"></a>Simultaneous Front and Back Camera</h4><p>现在，你可以在前置和后置摄像头上同时使用人脸和世界跟踪。例如，用户可以只使用他们的脸部，与后置摄像头的 AR 内容交互。</p>
<h4 id="Multiple-Face-Tracking"><a href="#Multiple-Face-Tracking" class="headerlink" title="Multiple Face Tracking"></a>Multiple Face Tracking</h4><p>现在 ARKit 人脸跟踪可以一次跟踪最多三张人脸，使用 iPhone X, iPhone XS, iPhone XS Max, iPhone XR 和 iPad Pro 的 TrueDepth 摄像头。该摄像头为 Memoji 和 Snapchat 等前置摄像头的体验提供能力。</p>
<h4 id="Collaborative-Sessions"><a href="#Collaborative-Sessions" class="headerlink" title="Collaborative Sessions"></a>Collaborative Sessions</h4><p>通过多人之间的实时协作会话，您可以构建一个协作的 world map，让您更快地开发 AR 体验，让用户像进入多人游戏一样，更快地进入共享的 AR 体验。</p>
<h4 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h4><p>一次检测多达 100 幅图像，并自动地估计图像的物理大小。3D 对象检测更加稳定，因为对象在复杂环境中可以更好地被识别。现在，机器学习被用来更快地检测环境中的平面。</p>
<h2 id="Reality-Composer"><a href="#Reality-Composer" class="headerlink" title="Reality Composer"></a>Reality Composer</h2><p>Reality Composer 是一款针对 iOS 和 Mac 的功能强大的新应用，可以轻松创建交互式 AR 体验，而无需 3D 经验。可以使用 live linking ，在您的 Mac、iPhone 和 iPad 之间无缝地移动。 RealityKit 是一个全新的高级框架，包含 photo-realistic 渲染、相机特效、动画、物理等功能，专为 AR 而构建。</p>
<p>现在，任何人都可以快速地原型化和制作 AR 体验的内容，这些内容可以使用 Xcode 集成到应用程序中或者导出到 AR Quick Look 。Reality Composer 让您在 iOS 和 Mac 上构建动画和交互，以丰富您的 3D 内容。</p>
<h4 id="Built-in-AR-Library"><a href="#Built-in-AR-Library" class="headerlink" title="Built-in AR Library"></a>Built-in AR Library</h4><p>导入您自己的 USDZ 文件，或者利用内置 AR 库中数百个现成的虚拟对象。该库为各种 assets 利用 procedural content generation ，您可以自定义虚拟对象的大小、样式等。</p>
<h4 id="Animations-and-Audio"><a href="#Animations-and-Audio" class="headerlink" title="Animations and Audio"></a>Animations and Audio</h4><p>增加移动、缩放等动画，比如虚拟对象的 “摆动” 或 “旋转”。当用户点击对象、靠近对象或触发其他触发器，您可以选择要进行的操作。您还可以利用 spatial audio 为您的 AR 场景添加真实感。</p>
<h4 id="Seamless-Tools"><a href="#Seamless-Tools" class="headerlink" title="Seamless Tools"></a>Seamless Tools</h4><p>Reality Composer 被包含在 Xcode ，也是一款 iOS APP 。因此您可以在 iPhone 或 iPad 上 build 、 test 、 tune 和模拟 AR 体验。利用 live linking ，您可以在 Mac 和 iOS 之间快速切换，创建吸引人的复杂的 AR 体验。</p>
<h4 id="Record-and-Play"><a href="#Record-and-Play" class="headerlink" title="Record and Play"></a>Record and Play</h4><p>有了 iOS 版的 Reality Composer，您可以记录 AR 体验运行位置的传感器和摄像机数据，然后在构建 APP 时在 iOS 上播放这些数据。</p>
<h2 id="RealityKit"><a href="#RealityKit" class="headerlink" title="RealityKit"></a>RealityKit</h2><p>这个全新的高级框架是从头开始创建的，专门用于 AR ，包括 photo-realistic 渲染、相机特效、动画、物理等等。它还有一个 Swift API 。使用集成的 ARKit 、基于物理的渲染、变换和骨骼动画、 spatial audio 和刚体物理， RealityKit 使 AR 开发比以往任何时候都更快、更容易。</p>
<h4 id="World-class-Rendering-RealityKit"><a href="#World-class-Rendering-RealityKit" class="headerlink" title="World-class Rendering RealityKit"></a>World-class Rendering RealityKit</h4><p>使用基于物理的真实材质、环境反射、 grounding shadows 、 camera noise 、 motion blur 等，将虚拟内容与现实世界无缝融合，使虚拟内容与现实世界几乎无法区分。</p>
<h4 id="Scalable-Performance"><a href="#Scalable-Performance" class="headerlink" title="Scalable Performance"></a>Scalable Performance</h4><p>RealityKit 利用最新的 Metal 特性充分利用 GPU ，充分利用 CPU 缓存和多核，提供难以置信的流畅的视觉效果和物理模拟。因为它自动地伸展每个 iOS 设备的 AR 体验的性能，所以您只需要创建一个 AR 体验。</p>
<h4 id="Swift-API"><a href="#Swift-API" class="headerlink" title="Swift API"></a>Swift API</h4><p>容易使用但功能强大的 RealityKit 使用 Swift 丰富的语言特性并提供完整的功能。因此您可以更快地构建增强现实体验，而无需抄模板代码。</p>
<h4 id="Shared-AR-Experiences"><a href="#Shared-AR-Experiences" class="headerlink" title="Shared AR Experiences"></a>Shared AR Experiences</h4><p>RealityKit 使网络开发工作变得简单，例如保持一致的状态、优化网络流量、处理数据包丢失或 performing ownership transfers 。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://theinfinitegame.tech/social-science/quantitative-method-origin/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="猫克杯">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="The Infinite Game">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/social-science/quantitative-method-origin/" class="post-title-link" itemprop="url">计算方法 02 | 科学的起源</a>
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-08 14:15:52" itemprop="dateCreated datePublished" datetime="2020-02-08T14:15:52+08:00">2020-02-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/social-science/" itemprop="url" rel="index">
                    <span itemprop="name">social-science</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>6.2k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>6 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="古典时期-Classical-Period"><a href="#古典时期-Classical-Period" class="headerlink" title="古典时期 (Classical Period)"></a>古典时期 (Classical Period)</h1><p>最早寻求事物的自然或俗世解释而非神的解释的思想家，是古希腊学者泰勒斯 (Thales)、毕达哥拉斯 (Pythagoras) 和德谟克利特 (Democritus) 等人。但最先思考如何获得知识的 是两千三百多年前的柏拉图 (Plato) 和亚里士多德 (Aristotle) 。</p>
<p>对柏拉图来说，外部世界及其中的事物，只是它们理想形式的不完美投射或影子。这些理想形式往往被描绘成在墙上投下影子。</p>
<p><img src="/images/sci-ori_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>柏拉图是一个 <strong>哲学实在论者 (philosophical realist)</strong> 。他认为 <strong>现实 (reality)</strong> 即理想世界，是独立于人的思想之外存在的。对他来说，这些理想并非只是我们心中的抽象概念，它们真实存在，但独立于物质世界之外。</p>
<p>他认为既然我们看到的物质世界是真实的 <em>不完美投射 (imperfect reflection)</em> ，我们就不能从感官经历中认识到 <strong>现实的本质 (the true nature of reality)</strong> 。他坚信理想形式的知识只能通过推理论证获得。所以柏拉图被称为 <strong>理性主义者 (rationalist)</strong> 。</p>
<p>他的学生亚里士多德也是个实在论者。他认为现实独立存在于人类的思想之外。但对亚里士多德来说，现实就是物质世界，没有单独的抽象形象存在。在如何了解事物本质上，他也与柏拉图意见相左。亚里士多德是 <strong>经验主义者 (empiricist)</strong> 。他认为感官经验准确地代表了现实。所以我们可以用感官去理解现实。他认为，归根结底知识来源于观察。但这并不意味着他仅对观察感兴趣，他依然将推理论证视作了解和解释自然的最佳方式。事实上，他建立了 <strong>形式逻辑 (formal logic)</strong> ，更确切地说是 <strong>三段论 (syllogism)</strong> 。</p>
<p><img src="/images/sci-ori_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>这有一个三段论的例子。</p>
<blockquote>
<p>“所有人都会死去，而所有希腊人都是人类，因此所有希腊人都会死。”</p>
</blockquote>
<p>如果两个前提为真，那么结论必然为真。把此结论当作新三段论的前提，我们就能积累知识。但这只在前提确实为真的情况下成立。看看这个：</p>
<blockquote>
<p>“所有哺乳动物都长毛，而猫都是哺乳动物，所以猫全都长毛。”</p>
</blockquote>
<p>第一个前提是错的，这就意味着结论不一定对，不是积累知识的好基础。</p>
<p>那么如何确保前提是正确的呢？你可以用另一个三段论来证明它。但当然你需要不停地证明这些前提，有一套你认为毫无争议的初始前提。亚里士多德认为，这些 <strong>基础前提 (fundamental premises)</strong> ，可以通过观察世界的基本形式或规律来决定。不巧他并未意识到他的某些观察选择性太强，导致一些基础前提在我们现在看来错得彻彻底底。比如，以他的观察为依据，昆虫有四条腿，男人比女人的牙齿多。</p>
<p>亚里士多德可能看到蜉蝣用四条腿走路得出了这个结论，但实际上蜉蝣与其他昆虫一样都有六条腿。也有可能他检查了自己和那些男性朋友的牙齿，但只查看了女佣的牙齿，她们更有可能因为营养不良而牙齿变少。他并没有意识到这点，他的观察是不准确的。即便如此，他和柏拉图的观念仍在近两千年内占据了主流。直到 16 世纪末期，人们才意识到他们的观点是有缺陷的。</p>
<p><img src="/images/sci-ori_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>他们时代之后的科学方法是如何发展的呢？古希腊人有很多科技进步。比如，托勒密 (Ptolemy) 将行星运动描述为：地球位于宇宙的中心，静止不动；其他行星，包括太阳都沿着各自的小轨道绕地球运动。必须要加上这些大环套小环，才能解释行星有时逆行的奇怪现象。</p>
<p>托勒密的模型能进行准确的预测，但人们并不认为它描述了真实的行星运动，它只能解释现象。</p>
<p><img src="/images/sci-ori_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>希腊城邦消亡后，在罗马帝国的兴衰更替间，以及中世纪的最初几百年，几乎没有任何科学进展。柏拉图和之后亚里士多德的哲学观点一直是主流，直到 16 世纪末新的科学革命拉开了启蒙时代的序幕。</p>
<p>让我们来看看哪些进步最终引导了革命。</p>
<p>首先，阿拉伯和波斯学者比如伊本・哈桑 (Ibn al-Hasan) ，比鲁尼 (Al Biruni) 和伊本西纳 (Ibn Sina) 开始使用系统观察和实验。强调无偏见的观察，而不只是逻辑推理。之后，在前人的基础上，英国的格罗斯泰斯特 (Grosseteste) 和罗杰・培根 (Roger Bacon) 提倡使用归纳 (induction) 与演绎 (deduction) 。</p>
<p><strong>归纳 (Induction)</strong> ，即通过特定观察得到一般解释。 <strong>演绎 (Deduction)</strong> ，即用一般解释预测特定结果。</p>
<p>第三个重大发展是印刷机的发明，这为科学革命创造了极好的条件。更多学者的成果得到了广泛的传播，其中就包括哥白尼 (Copernicus) 的《天体运行论》(De Revolutionibus Orbium Coelestium) ，这是引领科学革命的第四个重大发展。在哥白尼的新行星运动模型中，行星包括地球都围绕太阳运动。这与当时的宗教教义不符，教会接受亚里士多德和托勒密的模型，即地球位于宇宙中心。很多历史学家认为，哥白尼不敢发表他的成果，因为他害怕教会会因为违背教义惩罚他。但他最终还是发表了他的新模型，但加上了给教皇的特别献词，声称如果托勒密能炮制一个轨道怪异且只能解释现象的模型，那么他也应该享有同等的自由。他暗示他的模型仅仅是个实用的模型，而不是确切的表述。</p>
<p>他是否真心相信这一点也不得而知，不久他就与世长辞了。在这之后 60 年都没有引发骚动。很多人认为，科学革命和启蒙时代由哥白尼而始，但其他人认为荣誉应该归于第一个拒绝向天主教低头，坚持认为日心说模型才是现实的真实描述的人。</p>
<p>这个人就是伽利略・伽利雷 (Galileo Galilei) 。</p>
<hr>
<h1 id="启发-Enlightenment"><a href="#启发-Enlightenment" class="headerlink" title="启发 (Enlightenment)"></a>启发 (Enlightenment)</h1><p>伽利略 (Galileo) 被认为是现代科学之父，因为他开始将科学从哲学、伦理学和神学中分离，这些原来都在天主教的严格管控之下。</p>
<p>有人已经默默拥护基于 <strong>观察和实验 (observation and experimentation)</strong> 的科学方法，而不是使用 <strong>神学推理 (theological reasoning)</strong>，但伽利略是第一个这样光明正大做的人<br>。他也反对亚里士多德的几个理论，这些理论被天主教视为教义。</p>
<p>例如，他驳斥了亚里士多德说重物落地比轻物更快的观点。伽利略用了思想实验来证明这个观点，表明除了观察，他也重视 <strong>逻辑推理 (logical reasoning)</strong> 。当然，他最出名的是质疑亚里士多德和托勒密有关地球是宇宙中心的观点。他支持哥白尼的日心，即太阳是宇宙中心。伽利略对金星进行了系统的观察，发现行星只有绕太阳转而不是绕地球转才说得通。</p>
<p>哥白尼认为，日心说模型恰恰解释了这个现象，说明该模型准确预测了我们对行星的观察，但他却说这模型并非反映物理现实。相反，伽利略却毫无顾忌地声称地球就是绕着太阳转的。</p>
<p>天主教不喜欢伽利略离经叛道的想法。他们对伽利略进行宗教审判，把他软禁起来直到去世。</p>
<p><img src="/images/sci-ori_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>发明笛卡尔坐标系的 勒内・笛卡尔 (René Descartes) 和伽利略是同一时代的。虽然笛卡尔也反对亚里士多德许多的观点，但他同意知识应当基于 <strong>第一原理 (First principle)</strong> 。因为他认为我们的感官和思想很容易被欺骗，他决定放弃所有哪怕只有一点点疑问的想法。一旦移除了所有的怀疑，就只剩下一点可以确定 —— 即他在思考，那么他一定存在。我思故我在。</p>
<p><img src="/images/sci-ori_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>他最终得出结论：我们只能用 <strong>推理 (reasoning)</strong> 来了解世界本质。</p>
<p>弗朗西斯・培根 (René Descartes) 和笛卡尔一样，认为科学知识应当基于第一原理。但和笛卡尔相反，培根坚持认为这只能通过 <strong>归纳法 (inductive methods)</strong> 。归纳法就是把对特定实例的观察，用于总结普遍规律或解释。假设我每次碰到的天鹅都是白色的，我就能归纳出普遍规律：所有天鹅都是白色的。培根相信，不仅仅是第一原理，所有的知识都只能用归纳法获取，也就是这种基于感官经验总结出解释的方法。这就是为什么他被视作 <strong>经验主义 (empiricism)</strong> 之父。经验主义就是关于经验或观察。</p>
<p>大卫・休谟 (René Descartes) 把经验主义发挥到了极致 —— 只接受感官数据为知识来源，且摈弃与直接观察结果不符的理论概念。他认为现实的本质只由物体的特征组成，而不是物体本身。经验主义的极端形式叫做 <strong>怀疑主义  (skepticism)</strong> 。我来给你举个例子，比如有个实物 —— 一只猫。什么使得这只猫能成为猫 是它的各种属性 它的尾巴、胡须、颜色、皮毛、体型。如果把组成猫的属性都移走，那剩下的是啥都没了，猫的本质埋藏在其特征中。</p>
<p>休谟也指出了归纳法的问题：即使持续反复观察一个现象，但也没法保证下一次观察到的和前一次相同。</p>
<p>至少在欧洲人的长期观念中，所有的天鹅目击记录都证明天鹅是白色的。直到在澳州发现黑天鹅后，才知道原来还有黑的。换句话说，即使再多的验证观察，也不能确实证明关于世界的科学命题是真的。所以如果你要求所有的知识都只能基于观察，那么你永远不能确定你知道些什么。</p>
<p>19 世纪初，部分是针对休谟的怀疑主义， <strong>德国唯心主义 (German Idealism)</strong> 的哲学运动流行起来。唯心主义者相信我们的精神构筑了现实，我们对世界的体验是精神的重构，因此科学探索应当专注于通过自身推理能获得什么。唯心主义者主要关注的问题是非物质的东西，像自我、上帝、本质、存在和因果，他们也因使用模糊和过度复杂的语言而受到强烈批评。</p>
<p>在十九世纪第二次工业革命前夕，科学家开始对唯心主义者的形而上学失去耐心。在科学、医药和技术飞速发展的时代，他们对存在本质的思考变得越来越没用。在 20 世纪初，一种新的科学哲学登上舞台，提议彻底返回经验主义，这项运动叫做 <strong>逻辑实证主义 (logical positivism)</strong> 。</p>
<hr>
<h1 id="现代科学-Modern-Science"><a href="#现代科学-Modern-Science" class="headerlink" title="现代科学 (Modern Science)"></a>现代科学 (Modern Science)</h1><p>第一次世界大战过后，由于不满于德国那群专注于知识的第一原理和世界的本质的唯心主义者的 <strong>形而上学 (metaphysics)</strong> ，一群数学家、科学家和哲学家组成了维也纳学派 (Vienna Circle)。</p>
<p>维也纳学派的成员，摩里茲・石里克 (Moritz Schlick)、奥托・诺伊拉特 (Otto Neurath) 和鲁道夫・卡纳普 (Rudolf Carnap) 认为唯心主义者关于自我存在的问题毫无意义，因为这些问题无法回答。他们提出了新的科学哲学思想 ——  <strong>逻辑实证主义 (Logical Positivism)</strong> 。它重新将科学定义成是研究对世界有意义的命题。那么，要使一个命题有意义，它必须可验证，也就是有验证标准。这意味着要能确定命题的真实性。</p>
<p>有意义的命题有两种： <strong>分析命题 (analytic statements)</strong> 和 <strong>综合命题 (synthetic statements)</strong> 。</p>
<p>分析命题会 <strong>同义反复 (tautological)</strong> ，一定是真的。比如说，单身汉未婚，所有正方形都有四条边。这些是 <strong>先验命题 (priori statements)</strong> ，如定义和纯逻辑命题。它们不取决于世界的状态，因此也不需要通过观察来验证。它们可以被运用在数学和逻辑中，分析命题的新组合可以用形式逻辑验证。</p>
<p>综合命题依存于世界的状态。比如说，所有单身汉都快乐和所有猫天生都有尾巴。这些命题是 <strong>后验的 (posteriori)</strong> —— 它们只能通过观察验证。逻辑实证主义者认为，这些命题应始终可公开研究。同时，命题不许提及无法观察的实体，如电子或重力，因为它们无法被直接观察到。如果命题提及了无法观察的实体 或不是同义反复的，或不合逻辑的，或经验上不可验证的，那么它就是无意义的。这样一来，形而上学、神学和伦理学之类的主题，就完美地从科学中被剔除了。</p>
<p>当然，源自观察的标准和验证无法处理归纳法问题。明确证明或验证一个命题的确切证据永远都不够。总有可能在未来发现矛盾的地方。所以就把验证标准的强度弱化了，只要求确认而不是验证就可以了。</p>
<p>另一个非常严格的规则也必须改变了 —— 不许提及无法观察的实体造成了大麻烦：像电子、重力和抑郁这种无法被直接观察，但它们在科学解释中是不可或缺的。</p>
<p>这些以及归纳法问题，使逻辑实证主义出现了一个更温和版本 —— <strong>逻辑经验主义 (logical empiricism)</strong> 。</p>
<p>卡尔・波普尔 (Karl Popper) 也被戏称为维也纳学派的官方反对者，是他们的主要批判者之一。他认为要区分命题是否有意义，应建立在 <strong>可证伪性 (falsification)</strong> 的标准上，而不是能否 <strong>证实 (verification)</strong> 。</p>
<p>他认为，我们永远不能用观察来确切验证或证明一个命题，但我们可以用与之矛盾的证据有力驳斥。他认为一个命题必须有可证伪性才有意义。他提出科学家应该积极进行冒险的实验，它们能把找到与假说矛盾的证据的可能性最大化。如果我们找到了这样的反面证据，就能从中找到改进假说的线索。 <strong>只有反面证据缺失时 该假说才能暂时成立。</strong></p>
<p>现在，威拉德・冯・奥曼・奎因 (Willard Van Orman Quine) 证明，这个标准也有问题。在杜恒 - 奎因论题 (Duhem-Quine thesis) 中，他认为没有假说能够被单独验证，总有 <strong>背景假设 (background assumptions)</strong> 和 <strong>辅助假设 (supporting hypotheses)</strong> 来支持。如果找到了反面证据，根据波普尔的理论，我们的科学解释是错的，应该被驳回。但根据奎因的理论，我们总可以驳回某个背景假设或辅助假说，而不是科学解释本身。这样就挽救了原始假说。</p>
<p>托马斯・库恩 (Thomas Kuhn) 指出，科学并非脱胎于验证或证伪原则的严格应用。如果数据与假设不符，假设不会被立刻驳回或修改，科学是在一定的框架或 <strong>范式 (paradigm)</strong> 内进行。建立的假说要适用这个范式，意外结果使假说需要修正。但只要其适合范式即可。但当越来也多的反面证据累积起来，危机就出现了 这就导致了 <strong>范式转换 (paradigm shift)</strong> 。新的范式被采用，然后循而往复。</p>
<p><img src="/images/sci-ori_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>即使变成较弱形式的逻辑经验主义，逻辑实证主义也不能从波普尔、奎因等人的批判中幸存。所以，我们发展出一种更实用的科学哲学。如今的科学家采用 <strong>假说 - 演绎法 (hypothetico-deductive method)</strong>，其结合了归纳和演绎的方法；要求可证伪性；仅在假说有临时支持时接受重复确认。</p>
<p><img src="/images/sci-ori_8.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>哲学层面上，很多科学家可能会喜欢巴斯・范・弗拉森的 <strong>建构经验主义 (constructive empiricism)</strong> ，其主张科学是为了产生基于大量经验的理论。知识需要观察，但不可观察的实体也是允许的。接受一个科学理论并不意味永远认同 —— 这是对世界的真实表述。建构经验主义者认为，只要在观察范围内，即可接受科学主张为真实。该命题是否真实代表了不可观察的实体，我们无需判断，这只是目前对观察结果的最佳解释，仅此而已。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="猫克杯"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">猫克杯</p>
  <div class="site-description" itemprop="description">Stay hungry, stay foolish.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/nichollyn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;nichollyn" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/atom.xml" title="RSS → &#x2F;atom.xml"><i class="fa fa-fw fa-rss"></i>RSS</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.zhihu.com/people/kai-wen-mao-66" title="知乎 → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;kai-wen-mao-66" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i>知乎</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">闽ICP备 - 20000913 </a>
      <img src="/images/gongan.png" style="display: inline-block;"><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=35021302000298" rel="noopener" target="_blank">闽公网安备35021302000298号 </a>
  </div>

<div class="copyright">
  
  &copy; 2019 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">猫克杯</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">223k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:23</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  



  <script>
  if (CONFIG.page.isPost) {
    wpac_init = window.wpac_init || [];
    wpac_init.push({
      widget: 'Rating',
      id: ,
      el: 'wpac-rating',
      color: 'f79533'
    });
    (function() {
      if ('WIDGETPACK_LOADED' in window) return;
      WIDGETPACK_LOADED = true;
      var mc = document.createElement('script');
      mc.type = 'text/javascript';
      mc.async = true;
      mc.src = '//embed.widgetpack.com/widget.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(mc, s.nextSibling);
    })();
  }
  </script>

  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
