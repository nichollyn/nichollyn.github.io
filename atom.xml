<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Infinite Game</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://theinfinitegame.tech/"/>
  <updated>2020-03-17T09:35:03.273Z</updated>
  <id>https://theinfinitegame.tech/</id>
  
  <author>
    <name>猫克杯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用 “流水线” 设计拆解复杂处理流程</title>
    <link href="https://theinfinitegame.tech/development/programming-use-pipeline-to-tackle-complexity/"/>
    <id>https://theinfinitegame.tech/development/programming-use-pipeline-to-tackle-complexity/</id>
    <published>2020-03-17T03:32:12.000Z</published>
    <updated>2020-03-17T09:35:03.273Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文的主要价值：提供一种抽象复杂逻辑，达成功能复用的思路</li><li>关键词：语义提炼、动态具名</li><li>本文约 4000 字，建议阅读时间 12 分钟。</li></ul><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在软件开发中，我们常常会遇到一种场景：随着产品功能的扩展，出现了多个具备高度相似性的功能单元。作为功能单元，它们可能有着相似的交互逻辑，提供同类的输入数据和输出数据。并且，对于用户来说，它们都在处理同一个的东西。</p><p>举个例子，比如一款修图 app ，它包含了一组编辑功能，每个功能都作用于一张图片，处理之后的图片，还可以作为其他功能的输入。作为编辑工具，在每个功能内部，可能还需要支持撤销和重做这样的用户操作。我们容易想到的是，这些功能间存在着许多可以进行复用设计的代码。</p><p>本文基于一次回顾发起，出于记录和分享的目的：一次代码重构，一款之前我参与开发的图像处理应用。</p><hr><h1 id="重构的具体背景"><a href="#重构的具体背景" class="headerlink" title="重构的具体背景"></a>重构的具体背景</h1><p>请看下面这幅图：</p><p><img src="/images/black_box.png" alt="某个图像功能模块的结构图"></p><p>元素不多，让我解释一下。图中的 “<strong>内存图像管理 + 效果处理</strong>” 是一个 “<strong>黑盒子</strong>”。“逻辑黑盒” 有的时候是好事，有的时候是坏事。那这里的黑盒子算好事还是坏事呢？ 既然对这种设计做了重构，多半是有痛点了。这里，我们重点探讨一下它的负面效应。 </p><p>在具体业务场景下，这个黑盒子有两个问题：</p><ul><li>图像处理接口粒度太大，难以复用代码；</li><li>图像 <strong>管理</strong> 和图像 <strong>效果处理</strong> 被绑定在一起。使得外部难以灵活的接触和使用图像。强调一下，管理和效果处理是两件事。前者是站在用户的角度，后者是站在服务提供者的角度。更高层应用逻辑的开发者，对于更底层支撑 API 的开发者来说，也是用户。</li></ul><h1 id="“管道”-概念的提炼"><a href="#“管道”-概念的提炼" class="headerlink" title="“管道” 概念的提炼"></a>“管道” 概念的提炼</h1><p>黑盒子的两个问题在重构时都得到了解决，但第一个问题与本文要分享的设计思想关联不大，不做展开。</p><p>为了说明我们是如何解决第二个问题的，这里先引入两个概念：“<strong>流水线</strong>” 和 “<strong>例程</strong>”。相信对于从事编程类工作的读者来说，这两个词不会陌生。</p><blockquote><p><strong>流水线</strong>  pipeline，[计] 又称管道，管线。<br><strong>例程</strong>  routine，[计] 程序；日常工作；例行公事</p></blockquote><p>在我们的案例中，<code>Pipeline</code> 相当于内存中的图像状态机，提供了基本的图像管理功能，例如加入图像，删除图像，复制图像，移动图像，等等。<code>Routine</code> 相当于各个图像功能单元中的通用事务，比如说，对于每个图像功能单元，都需要在其开始运作时从某处获得一份初始的图像，并在其结束运作时输出一份 <strong><em>最终的</em></strong> 图像到另一处。我们还约定，<code>Routine</code> 中的事务会基于 <code>Pipeline</code> 来完成。可以具体解释成这样：每个 <code>Routine</code> 都会包含一组典型的图像处理动作，这些处理动作借助一个或者多个 <code>Pipeline</code> 的通用操作，以及每个 <code>Pipeline</code> 的差异化操作来完成（后面会具体说明这个 <strong><em>差异化的图像处理步骤</em></strong>）。</p><p>从这里开始，我们不妨把 “<strong>流水线</strong>” 的叫法直接替换成 “<strong>管道</strong>”，因为后面会用到一些比喻性的描述，我个人它们觉得基于 “管道” 一词衍生出来，会比用 “流水线” 来得更自然。接下来，我们对 “管道” 这个意象再做进一步的挖掘，可以设计出下面这些对应关系（表格中左侧的概念只是一种比喻，读者可自行体会，这里不会详细解读）</p><table><thead><tr><th>比喻</th><th>原对象</th></tr></thead><tbody><tr><td>“管道”</td><td>图像状态机</td></tr><tr><td>“流体”</td><td>图像</td></tr><tr><td>“节点”</td><td>图像状态</td></tr><tr><td>“流动”</td><td>图像状态流转</td></tr><tr><td>“锋面”(流体的最前端)</td><td>当前正在处理的图像状态</td></tr><tr><td>“连通性”</td><td>状态机内的图像以及图像状态机之间都是可串联的</td></tr></tbody></table><p>“流体” 是一个名词，它对应的是图像，涉及到存储模型。根据 “流体” 的特性，我们可以想象，或者说推断，管道里的图像存储模型应该会被设计为平行结构。</p><p>请读者联想一个类比， &lt;<strong>化妆 / 整容  VS  软件上美化照片上的人脸</strong>&gt; ，再思考一下，两者在存储模型和工序这两个方面有什么异同？ </p><p>回到正题，我配了五幅图来描述管道在具体实现中的五个特性：</p><ol><li>“流体” 由一系列 “节点” 组成。“节点”，即图像的状态，它的含义构成了我们对某一个图像的本征性认知。通俗地讲，图像状态能够帮助我们在特定的场景下把不同的图像区分开来。举个例子，有协同开发的两位程序员，对于 “美颜” 和 “滤镜” 这两个步骤的认知达成了共识。于是，我们就可以建立两个节点：“美颜”、“滤镜”，然后在开发过程中使用这两个节点来 <em>协作</em> 。注意，图像状态不是图像本身。对于图像状态的代码实现，我们可以使用一个极轻量的数据结构 —— 字符串。它体现的是 <strong>占位符思想</strong>，而我想要强调占位符的三个重要好处：它们是 <strong>可预见的</strong>（基于认知共识）、<strong>可预置的</strong>（很轻量）、<strong>可固化的</strong>（可复用代码的一个内在要求）。</li></ol><p><img src="/images/nodes.png" alt="节点及同位节点"></p><ol start="2"><li>“管道” 通过衔接 “节点” 构成 “连通”。在 “节点” 中，有必要特别介绍的是 “同位节点”。它指的是：几个步骤在 <strong>同一个图像</strong> 上先后发生。在时间上有先后，但在空间上始终操作同一份存储。我后面会再用到这个描述。</li></ol><p><img src="/images/connectivity.png" alt="连通性"></p><ol start="3"><li><p>“流动” 的 “流体” 会有一个 <strong>最前部</strong> ，就好像水流的最前端，又称为 “锋面” (Waterfront)，对应着这样一个事实：“管道” 中所有的图像，在同一时间里，只会有 <strong>唯一的</strong> 图像处于 <strong>可操作</strong> 的状态，这个状态代表着 <strong>图像的变化趋势</strong> 。具体到代码实现，可能会是一组带有 * 同步关键字 * 的方法，加上一个唯一的指向当前状态的指针。我们通过 <strong>引导</strong> 和 <strong>操刀</strong> 这个趋势，把图像 “引向” 最终要呈现出来的样子。在图示中，我有意使用了绿色代表原始的、最初的，使用红色代表成熟的、完全体的。<code>Pipeline</code> 专注于做一件事：把图像从一种状态转化为另外一种状态。这期间，可能要经历多个 “节点”，而 “锋面” 的意义就在于，它保证了一件事。那就是 <code>Pipeline</code> 的操刀者可以确信，这一刻只有他自己在引导图像的 “流向”，没有人会干扰到他。</p><p><img src="/images/waterfront.png" alt="锋面"></p></li><li><p>“流动” 可以是双向的（相比生产车间的 “流水线”，“管道” 之所以更贴切，在于后者可以实现双向的流动，对应到图像，相当于实现反向编辑，或者说撤销到一个处理步骤之前的状态）</p></li><li><p>“流体” 如果 “分流”，则可以出现多个 “锋面”，对应着图像的 <strong>并行处理</strong> 。</p><p><img src="/images/shunt.png" alt="分流"></p></li></ol><h1 id="“管道”-的具体实现"><a href="#“管道”-的具体实现" class="headerlink" title="“管道” 的具体实现"></a>“管道” 的具体实现</h1><p>如前所述，“流体” 其实就是图像，简单封装即可。我们主要实现的是 “<strong>节点</strong>”、“<strong>锋面</strong>”、 “<strong>流动</strong>” 和 “<strong>连通</strong>”。</p><h2 id="节点的实现方案和意义"><a href="#节点的实现方案和意义" class="headerlink" title="节点的实现方案和意义"></a>节点的实现方案和意义</h2><p>我们先来看一种典型的图像处理过程中可能会采用的写法，代码为 swift 实现：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图像 xyz</span></span><br><span class="line"><span class="keyword">var</span> xyz: <span class="type">MyImage</span></span><br><span class="line"><span class="comment">// 图像 ijk</span></span><br><span class="line"><span class="keyword">var</span> ijk: <span class="type">MyImage</span></span><br><span class="line"><span class="comment">// 图像 abc </span></span><br><span class="line"><span class="keyword">var</span> abc: <span class="type">MyImage</span></span><br></pre></td></tr></tbody></table></figure><p>当然，现代编程语言的语法特性，可以让你省去写各种 getter/setter 的样板代码，从而节省代码量。但这不是重点，重点在于 —— 上述这种代码无法复用。因为每一个图像的引用都被赋予了 <strong>具体</strong> 的含义：同样的写法不太可能完全地适用于另外一个图像处理场景。比如说，另外那个图像处理场景很可能不会用到描述为 ijk 的图像，可能会用到描述是 uvw 的图像。因此，采取这种写法会遇到的一个典型问题是：每新增一个图像处理场景，我们都需要新增若干个特定描述的图像声明。在编码层面，这无疑是一项繁冗的工作。</p><p>上面说的图像引用，其实正是我们的图像 “管道” 里的某个 “节点”。思考一个问题，如果要对 “节点” 实现代码复用，你会怎么做？稍微提示一下，关键在于 “<strong>具体</strong>” 这两个字。</p><p>是的，如果我们能想到，上面的写法中代码之所以不能复用，根源在于图像引用的用途已经被 <strong>具体定义</strong>（同时也是被具体 <strong>约束</strong>），那么我们就更有可能往这样一个方向思考问题的解决方案：能不能把图像引用 “去具体化” ，让它的含义在具体场景到来时才被赋予呢？</p><p>讲到这一层，有些读者可能已经想到一种数据结构 —— 字典。是的，没有什么奇淫巧技，只用字典，就能实现 “去具体化”，解决这个代码复用问题中的最大障碍 —— 既然无法预知我们可能需要处理什么样的图像，可能需要处理多少份图像，并且这些未知数总是易变的，那为什么不让具体场景的使用者来 <strong>动态添加</strong> 这些图像引用，并且为它们具名呢？图像部分被复用的代码，这里只声明了一样东西，就是从图像状态表述到图像引用的映射表。它提供了一个之前的写法不具备的特点，而这个特点是达成复用的必要前提：图像存取的方式是 <strong>统一的</strong>，<strong>有限的</strong>，从而是 <strong>可固化的</strong>。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stateTagToImageMap = [<span class="type">String</span>:<span class="type">MyImage</span>]()</span><br></pre></td></tr></tbody></table></figure><p>我们用一个 <strong>字符串标签</strong> 来表示图像的状态。对于图像 “管道” 的使用者来说，他只需要理解每个标签的含义，通过标签来存取图像并进行处理。在这些标签中，我们再提炼出几个具有通用含义的代表性标签：比如，<code>original</code> 代表 “<strong>最初的</strong>”，<code>processed</code> 代表 “<strong>加工完成的</strong>”，这正是前文提到的 <strong>占位符</strong> 。容易理解，在一份可复用的代码库中，你可以声明并且预置许多 <strong>占位符</strong> 。但你不会在这个代码库里声明同样数量的图像引用 —— 这样很奇怪对吧？哪怕从程序实现的角度来说，没有分配实际空间的引用并不一定会占据更多的内存。在后面列举的代码范例中，我们将会经常地用到 <code>original</code> 和 <code>processed</code> 这样的标签。</p><p>不妨阅读下面这段代码，这就是一种使用标签来操作对应图像的写法。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示两个处理步骤之后的图像 </span></span><br><span class="line">pipeline.from (.original) <span class="comment">// 从原始的图像开始 </span></span><br><span class="line">        .copyTo (.processed) <span class="comment">// 拷贝出一份图像用于处理，对应标签 processed</span></span><br><span class="line">        .doProcess (tag: .processed, specificProcess1)  <span class="comment">// 在 processed 上执行处理 1</span></span><br><span class="line">        .doProcess (tag: .processed, specificProcess2) <span class="comment">// 在 processed 上执行处理 2</span></span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed)) <span class="comment">// 取得 processed 标签代表的图像并且展示 </span></span><br></pre></td></tr></tbody></table></figure><h2 id="锋面的实现方案和意义"><a href="#锋面的实现方案和意义" class="headerlink" title="锋面的实现方案和意义"></a>锋面的实现方案和意义</h2><p>解决了 “节点” 的设计，我们再来看基于 “节点” 提炼出来的 “锋面” 要怎么设计。容易理解，“<strong>锋面</strong>” 是最前面的那个 “节点” ，具有 <strong>唯一性</strong>，对应具体的图像处理代码中就是 “当前正在被处理的那个图像”。在设计图像管道对外提供的处理 API 时，我们约定处理动作一定只能发生在这个 “<strong>当前的</strong>” 图像上，这样就能够保证我们的 “图像流” 总是按照我们想要的方向流动，并且在这个过程中，“图像流” 是不会被篡改的。这也是我们的图像编辑功能要实现撤销和重做功能的基本前提。</p><p>还是上面那段代码，现在可以去掉实际处理步骤的标签参数。因为我们约束了处理只能发生在 <strong>唯一的</strong>、<strong>当前的</strong> 图像上。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示一个处理步骤之后的图像 </span></span><br><span class="line">pipeline.from (.original) <span class="comment">// 从原始的图像开始 </span></span><br><span class="line">        .copyTo (.processed) <span class="comment">// 拷贝出一份图像用于处理，对应标签 processed</span></span><br><span class="line">        .doProcess (specificProcess1) <span class="comment">// 隐含了在 processed 上执行处理 1</span></span><br><span class="line">        .doProcess (specificProcess2) <span class="comment">// 隐含了在 processed 上执行处理 2</span></span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed)) <span class="comment">// 取得 processed 标签代表的图像并且展示 </span></span><br></pre></td></tr></tbody></table></figure><p>如果要求能够回撤到第一个处理步骤之后的状态，再做第二个处理步骤，并且第二个处理步骤的参数是可以改变的。可以这么做：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示一个处理步骤之后的图像，但我们在过程中保留了第一个步骤的状态 </span></span><br><span class="line">pipeline.from (.original)</span><br><span class="line">        .copyTo (<span class="string">"specificProcess1"</span>) <span class="comment">// 相比一步到位，这里多存储了第一个步骤的状态 </span></span><br><span class="line">        .doProcess (specificProcess1)</span><br><span class="line">        .copyTo (.processed)</span><br><span class="line">        .doProcess (specificProcess2.setParams (params1))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整第二个步骤的某些参数，重新显示图像 </span></span><br><span class="line">pipeline.from (<span class="string">"specificProcess1"</span>) <span class="comment">// 之前存储了第一个步骤的状态，直接从这个步骤开始 </span></span><br><span class="line">        .copyTo (.processed)</span><br><span class="line">        .doProcess (specificProcess2.setParams (params2))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed))</span><br></pre></td></tr></tbody></table></figure><h2 id="流动和连通性的实现方案"><a href="#流动和连通性的实现方案" class="headerlink" title="流动和连通性的实现方案"></a>流动和连通性的实现方案</h2><p>有了 “节点” 和 “锋面”，“流动” 和 “连通” 就有了作用的主体。对应到图像编辑功能，“<strong>流动</strong>” 其实就是图像从一个状态变成另外一个状态的过程。“<strong>连通</strong>” 则更好理解，一个管道出来的图像可以被另外一个管道接纳，由此构成管道之间的连接。连接在一起的每一节 “<strong>小管道</strong>” 各司其职，灵活组合，再构成更长跨度的 “<strong>大管道</strong>” 或者 “<strong>管道网络</strong>”，从而协同完成复杂的业务流程。</p><p>回归到代码，我们来看一组步骤稍多的图片处理工序，看它是如何体现出管道的 “流动性” 和 “连通性”。刨去内部的实现细节，整合或者忽略一些与管道设计思想关联不大的逻辑，以下代码在流程上算是比较接近实际生产环境了。虽然采用的是伪代码，相信读者可以看懂。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 主功能区，不妨将它的例程称为 Main</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 可以从这里进入各子功能处理图片再回到这里展示新的图片 </span></span><br><span class="line"><span class="comment"> * 3. 撤销到经过某个步骤处理之前的图像或者重做出之前做过但是被撤销掉的某个步骤的图像   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineMain</span>.startFrom (imageFile) {</span><br><span class="line">    <span class="type">RoutineMain</span>.pipeline.loadFrom (imageFile, .original) <span class="comment">// 从图片中加载初始的图像 </span></span><br><span class="line">}</span><br><span class="line"><span class="type">RoutineMain</span>.showCurrent () {</span><br><span class="line">    showImage (<span class="type">RoutineMain</span>.pipeline.front () <span class="comment">// 显示 “锋面”</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美型” 的功能区，对应的例程称为 FaceLift</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸轮廓，五官进行形状调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineFaceLift</span>.startFrom (<span class="type">RoutineMain</span>.pipeline.front ().copy ())</span><br><span class="line"><span class="type">RoutineFaceLift</span>.process () {</span><br><span class="line">    <span class="type">RoutineFaceLift</span>.pipeline</span><br><span class="line">         <span class="comment">// 这个过程用户无法干预，不会有 “重做”，因此我们可以直接在原稿上操作 </span></span><br><span class="line">        .from (.original)</span><br><span class="line">        .doProcess (faceLift_step_1_process)</span><br><span class="line">        .doProcess (faceLift_step_2_process)</span><br><span class="line">        .doProcess (faceLift_step_3_process)</span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美型” 处理好的图像提交给主功能 </span></span><br><span class="line"><span class="type">RoutineMain</span>.accept (<span class="type">RoutineFaceLift</span>.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “滤镜” 的功能区，对应的例程称为 Filter</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 滤镜化处理图像 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineFilter</span>.startFrom (<span class="type">RoutineMain</span>.pipeline.front ().copy ());</span><br><span class="line"><span class="type">RoutineFilter</span>.process () {</span><br><span class="line">    <span class="type">RoutineFilter</span>.pipeline</span><br><span class="line">        <span class="comment">// 这个过程中用户决定要选用哪个具体的滤镜，因此每次都需要基于原稿复制一份再滤镜化 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"awful"</span>)))</span><br><span class="line">        ... <span class="comment">// 皱眉，这个不好，换一个！</span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"notbad"</span>)))</span><br><span class="line">        ... <span class="comment">// 托腮，这个还行，再换个试试～</span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"perfect"</span>)))</span><br><span class="line">        ... <span class="comment">// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “滤镜” 处理好的图像提交给主功能 </span></span><br><span class="line"><span class="type">RoutineMain</span>.accept (<span class="type">RoutineFilter</span>.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美颜 ” 的功能区，对应的例程称为 SkinBeauty</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸皮肤进行色相调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像给 Main 功能 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineSkinBeauty</span>.startFrom (<span class="type">RoutineMain</span>.pipeline.front ().copy ());</span><br><span class="line"><span class="type">RoutineSkinBeauty</span>.process () {</span><br><span class="line">    <span class="type">RoutineSkinBeauty</span>.pipeline</span><br><span class="line">        <span class="comment">// 这个过程用户可以调节一个滑竿来控制色相参数，每次都基于原稿复制一份再调色相 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_weak))</span><br><span class="line">        ... <span class="comment">// 托腮，效果好像不明显，加强一点 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_much)))</span><br><span class="line">        ... <span class="comment">// 皱眉，好像有点过头了，往回调一点 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_just_right)</span><br><span class="line">        ... <span class="comment">// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美颜” 处理好的图像提交给主功能 </span></span><br><span class="line"><span class="type">RoutineMain</span>.accept (<span class="type">RoutineSkinBeauty</span>.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纠结一下。。</span></span><br><span class="line"><span class="comment">// 犹豫，要不还是不美颜了吧？</span></span><br><span class="line"><span class="type">RoutineMain</span>.undo ();</span><br><span class="line"><span class="comment">// 迟疑，滤镜也不要了？</span></span><br><span class="line"><span class="type">RoutineMain</span>.undo ();</span><br><span class="line"><span class="comment">// 思考中。。。</span></span><br><span class="line"><span class="comment">//... 不行，还是都加回来吧 </span></span><br><span class="line"><span class="type">RoutineMain</span>.redo ().redo ();</span><br><span class="line"><span class="comment">// 端详 5 分钟。。。完美～</span></span><br><span class="line">save (); <span class="comment">// 收工，准备发朋友圈 </span></span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于 “管道” 的设计思路和实现方案介绍到此。我们可以回顾一下，本文开始所提到 “黑盒子” 设计的第二个问题：“图像 <strong><em>管理</em></strong>  和图像 <strong><em>效果处理</em></strong>  被绑定在一起。”，在管道方案中是不是已经解决了呢？</p><blockquote><p>“管道” 设计的基石是 <strong>无差别地管理图像</strong> ，被管理的每一个图像，由最初将其投入管道的创建者为其定义标签。最初的创建者和后来的协同者，只需要对这个标签的含义达成 <strong>共识</strong> 便可以进行协作。“管道” 的思想是模拟 “<strong>流体</strong>” 的运行方式来实现图像处理过程，通过 “<strong>节点</strong>” 的设定来 <strong>分解</strong> 处理步骤，通过 “<strong>锋面</strong>” 的操控来 <strong>聚焦</strong> 每个单步的操作，通过 <strong>连通性</strong> 来将 <strong>分治</strong> 的逻辑重新 <strong>串联</strong> 起来完成复杂的功能。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;本文的主要价值：提供一种抽象复杂逻辑，达成功能复用的思路&lt;/li&gt;
&lt;li&gt;关键词：语义提炼、动态具名&lt;/li&gt;
&lt;li&gt;本文约 4000 字，建议阅读时间 12 分钟。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
      <category term="programming" scheme="https://theinfinitegame.tech/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>计算方法 06 | 相关变量的类型</title>
    <link href="https://theinfinitegame.tech/social-science/quantitative-methods-relevant-types-of-variables/"/>
    <id>https://theinfinitegame.tech/social-science/quantitative-methods-relevant-types-of-variables/</id>
    <published>2020-03-03T11:19:01.000Z</published>
    <updated>2020-03-03T11:29:13.684Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Variables-of-Interest"><a href="#Variables-of-Interest" class="headerlink" title="Variables of Interest"></a>Variables of Interest</h1><p>I want to go in to research designs and give you a more concrete idea how a research design can minimize threats to internal validity. But before I can do that, you have to become familiar with the terms, construct, variable, constant, and independent and dependent variable.<br>在 23 秒处开始记录 0:23<br>A hypothesis describes or explains a relationship between constructs. The term construct is used to indicate that we’re talking about a property in general, abstract terms. For example, I can hypothesis that loneliness and depression are associated. The terms loneliness and depression are the constructs here.<br>在 44 秒处开始记录 0:44<br>Of course, loneliness and depression can be expressed in many different ways. The term, variable, refers to an operationalized version of a construct. A variable is a specific, concrete expression of the construct, and is measurable or manipulable.<br>在 1 分 1 秒处开始记录 1:01<br>For example, I could operationalize loneliness in a group of elderly people in a nursing home, for example, by using a self-report questionnaire. I could administer the UCLA loneliness scale.<br>在 1 分 12 秒处开始记录 1:12<br>This scale is a 20-item questionnaire consisting of items like, I have nobody to talk to.<br>在 1 分 18 秒处开始记录 1:18<br>The variable loneliness now refers to loneliness as expressed through scores on the UCLA scale.<br>在 1 分 25 秒处开始记录 1:25<br>If I hypothesize that loneliness causes depression, I would be better off manipulating instead of measuring loneliness. I could give one group of elderly people a cat to take care of, comparing them with the control group without a cat.</p><p>I’ve now operationalized loneliness by creating two levels of loneliness. The variable loneliness now refers to high or low loneliness expressed through the presence or absence of a feline companion.<br>在 1 分 55 秒处开始记录 1:55<br>Finally, I could operationalize depression by using the geriatric depression scale, the GDS, consisting of 15 questions such as, do you feel happy most of the time?<br>在 2 分 5 秒处开始记录 2:05<br>The variable depression, now refers to depression, as expressed through the scores on the GDS.<br>在 2 分 12 秒处开始记录 2:12<br>Okay, so variables are measured or manipulated properties that take on different values. This last bit is important. A variable’s values need to vary. Otherwise, the property isn’t very interesting. It’s a constant.<br>在 2 分 26 秒处开始记录 2:26<br>Suppose the nursing home is so horrible that all residents get the maximum depression score. Well, then we cannot show a relation between loneliness and depression, at least not in this group of subjects. Both lonely and less lonely people will be equally depressed.<br>在 2 分 43 秒处开始记录 2:43<br>Depression is a constant.<br>在 2 分 46 秒处开始记录 2:46<br>So the variable central to our hypothesis should be variable. It should show variation. Of course, it is a good idea to keep other extraneous variables constant, so that they cannot provide alternative explanations. But we’ll get to that in another video.<br>在 3 分 1 秒处开始记录 3:01<br>Okay. Now that I’ve defined what a variable is, let’s look at different types of variables, according to the role they play in describing or explaining a phenomenon.<br>在 3 分 11 秒处开始记录 3:11<br>I’ll refer to the variables that are central to our hypothesis as variables of interest.<br>在 3 分 17 秒处开始记录 3:17<br>When a cause and effect can’t be identified or when a causal direction isn’t obvious or even of interest, our variables are on equal footing. And then we just refer to them as variables. But when our hypothesis is causal, we can identify a cause and an effect. And we then refer to the cause variable as the independent variable and to the effect variable as the dependent variable.<br>在 3 分 40 秒处开始记录 3:40<br>The independent variable is also referred to as cause variable, explanatory variable, input variable, or predictor. It refers to a variable that is hypothesized to cause or predicts another variable.<br>在 3 分 53 秒处开始记录 3:53<br>In our example, loneliness was hypothesized to cause depression.<br>在 3 分 58 秒处开始记录 3:58<br>The independent variable here, of course, is loneliness.<br>在 4 分 2 秒处开始记录 4:02<br>And its operationalized through the presence or the absence of a cat.<br>在 4 分 7 秒处开始记录 4:07<br>Now the dependent variable is hypothesized to be influenced by the cause variable or to be the result of another variable. It’s values depend on another variable.<br>在 4 分 18 秒处开始记录 4:18<br>In our example, the dependent variable was depression as measured through scores on the GDS questionnaire. The dependent variable is also referred to as effect variable, response variable, outcome or output variable.<br>在 4 分 33 秒处开始记录 4:33<br>Now, if you’re having trouble telling the terms independent and dependent apart, try to remember that the independent variable is what the researcher would like to be in control of.<br>在 4 分 43 秒处开始记录 4:43<br>It’s the cause that comes first.</p><p>这节课的主题是研究设计 我想具体讲下研究设计如何减少影响内部效度的因素 不过在这之前 我们先要学习几个术语 它们分别是 概念 变量 常数 自变量和因变量<br>在 23 秒处开始记录 0:23<br>假设就是描述或解释概念间的关系 提到概念这个术语 即意味着我们谈及的是一种笼统抽象的属性 比方说 我可以假设孤独和抑郁相关 “孤独” 和 “抑郁” 在这里就是两个概念<br>在 44 秒处开始记录 0:44<br>当然 孤独与抑郁有多种不同的表达方式 变量这个术语是指概念的可操作版本 变量是概念具体明确的表现 变量是可测量、可改变的<br>在 1 分 1 秒处开始记录 1:01<br>比如我可以用自陈量表 来量化养老院中一群老人的孤独感 我可以使用 UCLA 孤独感量表<br>在 1 分 12 秒处开始记录 1:12<br>该量表由 20 个问题组成 比如” 没人可以陪我说话 “这类问题<br>在 1 分 18 秒处开始记录 1:18<br>孤独感变量以 UCLA 量表分数的形式表现了” 孤独 “这个概念 孤独感变量以 UCLA 量表分数的形式表现了” 孤独 “这个概念<br>在 1 分 25 秒处开始记录 1:25<br>如果我假设孤独导致了抑郁 那么最好是改变孤独感 而非测量孤独感 我可以让一组老年人照顾一只猫 然后和没有猫的对照组比较<br>在 1 分 40 秒处开始记录 1:40<br>通过建立两种孤独水平 就使孤独感可操作化 通过有无猫陪伴 孤独变量就表现出了高低 通过有无猫陪伴 孤独变量就表现出了高低<br>在 1 分 55 秒处开始记录 1:55<br>最后我可以通过老年抑郁量表 (GDS) 使抑郁可操作化 该量表有 15 个问题 如” 你大多数时间都快乐吗？“<br>在 2 分 5 秒处开始记录 2:05<br>现在代表抑郁的变量 可以通过 GDS 得分的形式表现出来了<br>在 2 分 12 秒处开始记录 2:12<br>所以变量有可测量或改变的属性 它们可以有不同的值 最后这一点很重要 变量值必须能改变 不然这个属性就没什么意思了 它就是个常数了<br>在 2 分 26 秒处开始记录 2:26<br>假设这个养老院太糟糕了 以至于所有人的抑郁指数都是满分 那至少在这个研究群体里 我们不能体现孤独和抑郁间的关系 孤独和没那么孤独的人都一样意志消沉<br>在 2 分 43 秒处开始记录 2:43<br>抑郁就成了个常数<br>在 2 分 46 秒处开始记录 2:46<br>所以与我们的假设息息相关的变量应该可变 它应表现出一定的变化 当然 最好保持其他额外变量不变 以避免出现替代解释 我们之后专门有一节课讲这个问题<br>在 3 分 1 秒处开始记录 3:01<br>好 说完变量的定义 现在我们再讲下变量的不同类型 因其在描述或解释一个现象中所扮演的角色而异<br>在 3 分 11 秒处开始记录 3:11<br>我将假设中关键的变量称为目标变量 我将假设中关键的变量称为目标变量<br>在 3 分 17 秒处开始记录 3:17<br>当因果关系不确定 不明显甚至没意义时 所有的变量都是平等的 我们只称之为变量 当在假设中存在因果关系 因和果都能确定 那么原因变量就称为自变量 结果变量称为因变量<br>在 3 分 40 秒处开始记录 3:40<br>自变量也称为原因变量 解释变量 输入变量或预测变量 自变量也称为原因变量 解释变量 输入变量或预测变量 意思是根据假设 这个变量会引起另一个变量的变化 或能预测另一个变量的变化<br>在 3 分 53 秒处开始记录 3:53<br>在我们的例子中 假设孤独会引发抑郁<br>在 3 分 58 秒处开始记录 3:58<br>这里的自变量就是孤独<br>在 4 分 2 秒处开始记录 4:02<br>通过有没有猫来操作该变量<br>在 4 分 7 秒处开始记录 4:07<br>因变量就是假设会受到原因变量影响的变量 也就是另一个变量的结果 它的值取决于其他变量<br>在 4 分 18 秒处开始记录 4:18<br>在我们的例子中 因变量就是抑郁 通过 GDS 量表得分评估 因变量也叫做影响变量 反应变量 结果或输出变量 因变量也叫做影响变量 反应变量 结果或输出变量<br>在 4 分 33 秒处开始记录 4:33<br>如果你无法区分自变量和因变量 那就试着记住 自变量是研究者需要控制的部分<br>在 4 分 43 秒处开始记录 4:43<br>自变量是原因 先于结果发生</p><h1 id="Variables-of-Disinterest"><a href="#Variables-of-Disinterest" class="headerlink" title="Variables of Disinterest"></a>Variables of Disinterest</h1><p>I’ve discussed variables that are the focus of our hypothesis, the variables of interest. Of course in any study there will be other extraneous properties associated with the participants and the research setting that vary between participants.<br>在 20 秒处开始记录 0:20<br>These properties are not the main focus of our study. But they might be associated with our variables of interest, providing possible alternative explanations.<br>在 30 秒处开始记录 0:30<br>Such variables of disinterest come in three flavors. Confounders, control variables, and background variables.<br>在 39 秒处开始记录 0:39<br>A confounder, or lurking variable, is a variable that is related to both the independent and dependent variable, and partially, or even entirely, accounts for the relationship between these two.<br>在 53 秒处开始记录 0:53<br>Suppose I investigate the effect of reducing loneliness on depression in a group of elderly people. I lower loneliness by providing a cat to the elderly in an experimental group.<br>在 1 分 3 秒处开始记录 1:03<br>An elderly in a control group receive a stuffed toy.<br>在 1 分 8 秒处开始记录 1:08<br>Now besides loneliness, the two groups might also differ in terms of the physical exercise they get, their age, or their susceptibility to depression, which are all variables of disinterest. Take physical exercise. The experimental group will likely be more physically active, because they have to feed and clean up after the cat. So physical exercise is related to loneliness. The cat group, the less lonely group, is more active than the control group.<br>在 1 分 39 秒处开始记录 1:39<br>Suppose physical activity is also causally related to depression. Being more active lowers depression. Well, then physical activity and not loneliness may account for a lower depression score in the experimental cat group.<br>在 1 分 52 秒处开始记录 1:52<br>The relation between loneliness and depression is said to be spurious. The relation can be explained by the confounding variable, physical activity.<br>在 2 分 3 秒处开始记录 2:03<br>An important thing to note about confounders, is that they are not included in the hypothesis and they are generally not measured. This makes it impossible to determine what the actual effect of a confounder was. The only thing to do is to repeat the study, and control the confounder by making sure it takes on the same value for all participants. For example, if all elderly people in both groups are required to be equally active, then physical activity cannot explain differences in depression.<br>在 2 分 36 秒处开始记录 2:36<br>Another possibility is to turn a confounder into a control variable. A control variable is a property that is likely to be related to the independent and dependent variable, just like a confounder. But unlike a confounder a control variable is measured. It’s effects can therefore be assessed and controlled for.<br>在 2 分 55 秒处开始记录 2:55<br>For example, we could see if physical activity provides an alternative explanation by measuring it and taking it into account. Suppose we could distinguish inactive and active people. In the cat therapy, there are more active people, but some are inactive. In the control condition, most people are inactive, but some are active.<br>在 3 分 16 秒处开始记录 3:16<br>We now consider the difference in depression between the cat therapy and control group, first for the active people, and then for the inactive people. We control for activity, in fact holding it constant, by considering each activity level separately.<br>在 3 分 32 秒处开始记录 3:32<br>If the relationship between loneliness and depression disappears when we look at each activity level separately, then activity explains a way this spurious relation between loneliness and depression. But if the relationship still shows and at each activity level, then we’ve eliminated physical activity as an alternative explanation for the drop in depression.<br>在 3 分 54 秒处开始记录 3:54<br>The last type of variable of disinterest is a background variable. This type of variable is not immediately relevant to the relation between the variables of interest, but it is relevant to determine how representative the participants in our study are for a larger group, maybe all elderly people everywhere. Even all people of any age.<br>在 4 分 16 秒处开始记录 4:16<br>For this reason, it’s interesting to know how many men and women participated, what their mean age was, their ethnic or cultural background, social economic status, education level, whatever else is relevant to the study at hand.<br>在 4 分 32 秒处开始记录 4:32<br>So to summarize, a confounder is a variable that partially or entirely explains an effect on the dependent variable instead of, or additional to, the independent variable.<br>在 4 分 44 秒处开始记录 4:44<br>A confounder is not accounted for in the hypothesis, and is not measured or controlled for in the study.<br>在 4 分 49 秒处开始记录 4:49<br>A possible confounder can be controlled for by keeping the property constant or by turning it into a control variable. A control variable accounts for a possible confounder, by measuring the relevant property and checking the relationship between the variables of interest at each value or level of the control variable.<br>在 5 分 10 秒处开始记录 5:10<br>Background variables, finally, are measured, not because of possible effect on the variables of interest, it is expected. But because the background properties are useful to assess the generalizability of the study, based on the sample characteristics.<br>I’ve discussed variables</p><p>前一节课我们讲了假设中的关键变量 即目标变量 当然 任何研究中都有其他额外的属性 与参与者和研究设置有关 且因人而异<br>在 20 秒处开始记录 0:20<br>它们不是我们的研究重点 但可能与目标变量存在联系 可能会导致出现替代解释<br>在 30 秒处开始记录 0:30<br>这样的次要变量有三种类型 混杂变量、控制变量及背景变量<br>在 39 秒处开始记录 0:39<br>混杂变量 也称作潜在变量 与自变量、因变量均相关 且在二者的关系中占部分 甚至全部比重<br>在 53 秒处开始记录 0:53<br>假设我要调查一群老年人 减少孤独感对抑郁有何影响 通过给实验组老人猫咪来降低孤独感<br>在 1 分 3 秒处开始记录 1:03<br>对照组老人则给个毛绒玩具<br>在 1 分 8 秒处开始记录 1:08<br>现在除了孤独感 两组的运动量、年纪、抑郁易感性都不尽相同 而这些都是次要变量 比如运动 实验组的老人可能运动要多一些 因为他们要给猫喂食铲屎 而运动是与孤独感相关的 猫咪组不那么孤独 他们比对照组运动量更多<br>在 1 分 39 秒处开始记录 1:39<br>假设运动与抑郁也有因果关系 多运动可以减少抑郁 那么运动及不孤独都可能造成实验组抑郁分值较低 那么运动及不孤独都可能造成实验组抑郁分值较低<br>在 1 分 52 秒处开始记录 1:52<br>孤独和抑郁间的关系则会被认为是假相关 因为混杂变量 “运动” 也能解释这个关系<br>在 2 分 3 秒处开始记录 2:03<br>对于混杂变量 需要强调的是 假说中不包含它们 一般也不会被测量 所以也不可能测量混杂变量的实际影响 我们唯一能做的就是重复这个研究 控制混杂变量 使其对所有参与者影响一致 比方说 如果让两组老人的运动量相等 那么运动就不能解释抑郁程度的差异了<br>在 2 分 36 秒处开始记录 2:36<br>另一种方法是把混杂变量转换成控制变量 控制变量就像混杂变量 是可能和自变量与因变量都有关的属性 但与混杂变量不同的是 控制变量可测量 因此其影响能被评估和控制<br>在 2 分 55 秒处开始记录 2:55<br>比如通过测量运动量 将其包括在研究之中 来看运动是否会提供一个替代解释 假设我们可以分出活跃和不活跃的人群 猫咪疗法中 有的人相对活跃 有的人则略为安静 对照组中 大多数人是安静的 但还有一些较为活跃<br>在 3 分 16 秒处开始记录 3:16<br>在观察猫咪治疗组和对照组抑郁程度差别时 先看活跃人群 再看非活跃人群 通过将参与者根据运动水平分组 我们控制运动量 在每组内将其作为常数<br>在 3 分 32 秒处开始记录 3:32<br>当我们分别观察每个运动水平时 如果孤独和抑郁间的相关性不复存在 那么运动就能解释孤独和抑郁间的假相关性 但如果在各个运动水平 仍然表现出相关性 那我们就能排除运动是减少抑郁的替代解释<br>在 3 分 54 秒处开始记录 3:54<br>最后一种次要变量叫做背景变量 这类变量与目标变量没有直接联系 这类变量与目标变量没有直接联系 但它说明了参与者是否可以代表一个更大的群体 甚至是否可以代表世界各地的老年人群体 甚至各个年龄段群体<br>在 4 分 16 秒处开始记录 4:16<br>出于这种原因 要了解参与者的性别 平均年龄、宗教或文化背景、社会经济状况 教育程度等任何和研究相关的背景<br>在 4 分 32 秒处开始记录 4:32<br>总结一下 混杂变量是能替代或附加于自变量 对因变量造成部分或全部影响的变量 对因变量造成部分或全部影响的变量<br>在 4 分 44 秒处开始记录 4:44<br>研究中 假设并不会提及混杂变量 也不能测量或控制<br>在 4 分 49 秒处开始记录 4:49<br>控制混杂变量可以有两种方式 将这一属性变为常数或将其变为控制变量 控制变量来自可能的混杂变量 通过测量相关属性 核查控制变量每个水平上目标变量间的关系<br>在 5 分 10 秒处开始记录 5:10<br>最后讲到了测量背景变量 不仅因为其对目标变量可能有潜在影响 还因为基于样本特征 背景属性对评估研究普遍性有用 还因为基于样本特征 背景属性对评估研究普遍性有用</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Variables-of-Interest&quot;&gt;&lt;a href=&quot;#Variables-of-Interest&quot; class=&quot;headerlink&quot; title=&quot;Variables of Interest&quot;&gt;&lt;/a&gt;Variables of Interest&lt;/
      
    
    </summary>
    
    
      <category term="social-science" scheme="https://theinfinitegame.tech/categories/social-science/"/>
    
    
      <category term="计量方法" scheme="https://theinfinitegame.tech/tags/%E8%AE%A1%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    
      <category term="社会科学" scheme="https://theinfinitegame.tech/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计算方法 05 | 对内部效度的影响</title>
    <link href="https://theinfinitegame.tech/social-science/quantitative-method-threats-to-internal-validity/"/>
    <id>https://theinfinitegame.tech/social-science/quantitative-method-threats-to-internal-validity/</id>
    <published>2020-03-02T08:19:43.000Z</published>
    <updated>2020-03-03T11:30:51.084Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内部效度的影响：参与者-（Internal-Validity-Threats-Participants）"><a href="#内部效度的影响：参与者-（Internal-Validity-Threats-Participants）" class="headerlink" title="内部效度的影响：参与者 （Internal Validity Threats: Participants）"></a>内部效度的影响：参与者 （Internal Validity Threats: Participants）</h1><p>Internal validity is threatened if there is a plausible alternative explanation for a study’s results. In order to judge the internal validity of a particular study, you have to be familiar with the type of threats that can occur.</p><p>当研究结果存在似乎可信的替代解释时，研究的内部效度就受到影响。为了评价一项特定研究的内部效度，你们必须熟悉可能出现的几种影响因素。</p><p>I’ll start with three types of threats that are in some way associated with the participants or the subjects used in the study.</p><p>我先从三类影响因素讲起，它们都在某种程度上与研究的参与者或说被试者相关。</p><p>These threats are called maturation, selection, and selection by maturation. Let’s start with maturation. Maturation refers to an alternative explanation formed by natural change.</p><p>这些影响因素被称为成熟、选择以及选择 - 成熟协同作用。让我们从成熟开始讲。成熟是指可以用自然变化作为一种替代解释。</p><p>Suppose I hypothesize that loneliness causes depression.</p><p>譬如我假设孤独导致抑郁。</p><p>I decrease loneliness in elderly people who are prone to depression by giving them a cat to take care of. I expect their depression to go down, because they are now less lonely. I find a retirement home willing to participate, and I measure depression in a group of residents who seem unhappy. I give them a cat to take care of for four months, and then I measure depression again.</p><p>我通过让易于产生抑郁的老人养猫来减轻他们的孤独。我预测他们的抑郁程度会下降，因为他们现在不那么孤独了。我找到一家愿意合作的养老院，测量一组不太开心的老人的抑郁度。我并让他们养猫四个月，然后再次测量他们的抑郁度。</p><p>Let’s assume depression is lowered after taking care of the cat. Does this mean that the cat’s companionship caused the decrease in depression? Well, not necessarily. The decrease in depression could have occurred naturally. People develop, they change. Many physical and mental problems simply disappear after a while. Even if we don’t receive treatment, depressions often go away by themselves.</p><p>我们假定养猫之后他们的抑郁度下降了。这是否意味着猫的陪伴导致了抑郁程度的下降呢？并不一定，抑郁度的下降可能是自然发生的。人是发展的，是会变化的。很多生理和心理问题过段时间就会消失，即使不接受治疗，抑郁常常不治自愈。</p><p>Fortunately, there’s a way to eliminate this alternative explanation of natural change that we refer to as maturation. </p><p>幸运的是，有种方法可以消除自然变化这一替代解释，即我们所说的成熟。</p><p>We can introduce a control group that is measured at the same time, but is not exposed to the hypothesized cause. Both groups should mature or change to the same degree.</p><p>我们可以引入一个对照组与实验组同时测量，但不让其接触我们的假设原因。两组都应有成熟现象，或变化至同一水平。</p><p>Any difference between the groups can now be attributed to the hypothesized cause and not natural change.</p><p>现在两组间的任何不同都可归因于假设的原因，而非自然变化。</p><p>The threat of maturation is eliminated. But, unfortunately, a study that includes control group is still vulnerable to other threats to internal validity. This brings us to the threat of selection.</p><p>成熟的影响就被消除了。但不幸的是，包含对照组的研究的内部效度，仍易受其它因素的影响。这就要说到选择的影响。</p><p>Selection refers to any systematic difference in subject characteristics between groups, other than the manipulated cause.</p><p>选择是指除可控因素外，存在于组间受试者特征中的任何系统性差异。</p><p>Suppose in my study, I included a control group that didn’t take care of a cat.</p><p>假定在我的研究中，我引入一组不养猫的对照组。</p><p>What if assignment of elderly participants to the groups was based on mobility? Suppose people who weren’t able to bend over and clean the litter box were put in the control group.</p><p>如果我对老年参与者的分组是基于行动力的话会怎样呢？假定对照组的老人不能弯腰、不能清理猫砂盆。</p><p>Now suppose the experimental group was, in fact, less depressed than in the control group, this might be caused not by the company of the cat but because the people in the experimental group were just more physically fit.</p><p>现在假定实验组确实比对照组抑郁程度低，但这可能不是由猫的陪伴所导致的，而仅仅因为实验组的人在生理上更健康。</p><p>A solution to this threat is to use a method of assignment to groups that ensures that a systematic difference on, on subject characteristics is highly unlikely. This method is called randomization. I’ll discuss it in much more detail when we cover research designs.</p><p>对这一影响因素的解决办法是：采用一种能够基本避免受试者特征的系统性差异的分组方法。这一方法称为随机化，我会在讲到研究设计时再详述。</p><p>The last threat to internal validity related to participants is the combined threat of maturation and selection. We call this a selection by maturation threat. This happens when groups systematically differ in their rate of maturation.</p><p>最后一个和参与者相关的内部效度影响因素是成熟与选择的相互作用。我们称之为选择 - 成熟协同作用。它发生于组间成熟速率存在系统性差异的情况下。</p><p>For example, suppose the effectiveness of the cat treatment was examined in an experimental group consisting of volunteers who are open to new things. In contrast, the control group consisted of more conservative people who don’t like change. Participants were selected so that both groups had a similar level of depression at the start of the study. But what if we find that the experimental group shows lower depression?</p><p>比方说，假定在两组间考察养猫疗法的有效性。实验组的志愿者对新事物持开放态度；相反，对照组由更加保守、不喜欢变化的人组成。参与者被选入两组中，使两组在研究之初抑郁度相似。但如果我们发现实验组表现出较低的抑郁程度呢？</p><p>Well, perhaps the lower rate of depression in the experimental cat therapy group is simply due to the fact that open-minded people tend to naturally get over their depressive feelings more quickly than conservative people do.</p><p>或许这种差异，仅仅是由思想开放的人较保守的人更易克服抑郁情绪这一事实所致。</p><p>Just like selection on its own, the threat of selection by maturation can be eliminated by randomized assignment to groups.</p><p>正如单纯的选择型影响因素，选择 - 成熟协同作用的影响也可被随机分组所消除。</p><p>So you see that the research design we choose, for example, adding a control group, and the methods we use, for example, random assignment, can help to minimize threats to internal validity.</p><p>因此如你所见，我们选择的研究设计，比如增加对照组，以及我们所使用的研究方法，比如随机分组，都可帮助我们将内部效度的影响因素最小化。</p><hr><h1 id="内部效度的影响：仪器-（Internal-Validity-Threats-Instruments）"><a href="#内部效度的影响：仪器-（Internal-Validity-Threats-Instruments）" class="headerlink" title="内部效度的影响：仪器 （Internal Validity Threats: Instruments）"></a>内部效度的影响：仪器 （Internal Validity Threats: Instruments）</h1><p>Another category of threats to internal validity is associated with the instruments that are used to measure and manipulate the constructs in our hypothesis. The threats of low construct validity, instrumentation, and testing fall into this category. I’ll start with low construct validity. Construct validity is low if our instruments contain a systematic bias or measure another construct or property entirely. In this case, there’s not much point in further considering the internal validity of a study. As I discussed in an earlier video, construct validity is a prerequisite for internal validity. If our measurement instruments or manipulation methods are of poor quality, then we can’t infer anything about the relation between the hypothesized constructs. Suppose I hypothesized that loneliness causes depression. I attempt to lower loneliness of elderly people in a retirement home by giving them a cat to take care of, expecting their depression to go down. Suppose that taking care of the cat didn’t affect loneliness at all, but instead gave residents a higher social status. They’re special because they’re allowed to have a cat. The manipulation aimed at lowering loneliness, in fact, changed a different property, social status. Now consider my measurement of depression. What if the questionnaire that I used actually measured feeling socially accepted instead of feeling depressed? If we accidentally manipulated social status or measured feeling accepted, then we cannot conclude anything about the relation between loneliness and depression. The second threat that relates to measurement methods is instrumentation. The threat of instrumentation occurs when an instrument is changed during the course of the study. Suppose I use a self-report questionnaire to measure depression at the start of the study, but I switch to a different questionnaire, or maybe to an open interview at the end of the study. Well then, any difference in depression scores might be explained by the use of different instruments. For example, the scores on the post test at the end of the study could be lower because the new instrument measures slightly different aspects of depression, for example. Of course, it seems rather stupid to change your methods or instruments half way, but sometimes a researcher has to depend on others for data. For example, when using tests that are constructed by national testing agencies or polling agencies. A good example is the use of the standardized diagnostic tool called the DSM. This Diagnostic and Statistical Manual is used to classify things like mental illness, depression, autism. And it’s updated every 10 to 15 years. Now you can imagine the problems this can cause, for example, for a researcher who is doing a long-term study on schizophrenia. In the recently updated DSM, several subtypes of schizophrenia are no longer recognized. Now if we see a decline in schizophrenia in the coming years, is this a real effect or is it due to the change in measurement system? The last threat I want to discuss here is testing, also referred to as sensitization. Administering a test or measurement procedure can affect people’s behavior. A testing threat occurs if this sensitizing effect of measuring provides an alternative explanation for our results. For example, taking the depression pre-test at the start of the study might alert people to their feelings of depression. This might cause them to be more proactive about improving their emotional state, for example, by being more social. Of course this threat can be eliminated by introducing a control group. Both groups will be similarly affected by the testing effect. Their depression scores will both go down, but hopefully more so in the cat companionship group. Adding a control group is not always enough, though. In some cases, there’s a risk that the pre-test sensitizes people in the control group differently than people in the experimental group. For example, in our cat study, the pre-test in combination with getting a cat could alert people in the experimental cat group to the purpose of the study. They might report lowered depression on the post-test, not because they’re less depressed, but to ensure the study seemed successful so they can keep the cat. Suppose people in the control group don’t figure out the purpose of the study, because they don’t get a cat. They’re not sensitized and not motivated to change their scores on the post-test. This difference in sensitization provides an alternative explanation. One solution is to add an experimental and control group that weren’t given a pre-test. I’ll discuss this solution in more detail when we consider different experimental designs. Okay. So to summarize. Internal validity can be threatened by low construct validity, instrumentation and testing. Low construct validity and instrumentation can be eliminated by using valid instruments, and valid manipulation methods. And of course by using them consistently. Testing can be eliminated by using a special design that includes groups that are exposed to a pretest, and groups that aren’t.</p><p>另一类对内部效度的影响因素 与我们测量和操作假说内建构的测量工具有关 与我们测量和操作假说内建构的测量工具有关 造成低建构效度的影响因素中 仪器使用 (instrumentation) 和测验 (testing) 属于这一类 我从低建构效度开始讲 如果我们的测量工具包含有系统性偏误 或测量的是完全不同的建构或属性 建构效度就低 这种情况下 进一步考虑研究的内部效度意义不大 这种情况下 进一步考虑研究的内部效度意义不大 正如我在之前视频里讲过的 此法特别适用 如果我们的测量仪器或操作方法质量较差 如果我们的测量仪器或操作方法的质量较差 我们就不能推论出任何有关假设建构之间关系的结论 比如我假设孤独会引起抑郁 我试图通过让养老院中老人去养猫来降低他们的孤独感 并预测他们的抑郁会减轻 假设养猫完全不会影响孤独感 而是给老人更高的社会地位 他们因为可以养猫而变得特殊 这一操作本是用来降低孤独感的 实际上却改变了另一个属性 社会地位 再看看我测量抑郁程度的方法 如果我用的调查问卷 实际上测量的是社会接受感而不是抑郁感呢 如果我们无意间改变的是社会地位 或碰巧测量的是感觉被接受的程度 那么我们就不能得出任何关于孤独和抑郁相关性的结论 第二个与测量方法有关的影响因素是仪器使用 如果测量工具在研究过程中发生了改变 仪器使用的这个影响因素就随之出现了 假设我在研究之初用自陈量表来测量抑郁程度 但是在研究后期 我换了一种问卷形式 或换成了开放式访问 那么抑郁感评分的任何不同 都可能是因为使用了不同的测量工具造成的 比如 在研究结束的后期测验中得到的分数更低 可能是因为新工具测量的是抑郁的另一个略微不同的方面 可能是因为新工具测量的是抑郁的另一个略微不同的方面 当然 半路换方法或测量工具会显得很蠢 但有时研究者必须依靠别的方法或工具来获得数据 比如说 在使用由国家测试机构或投票机构构建的测试时 一个范例就是被称为 DSM 的标准化诊断工具的使用 一个范例就是被称为 DSM 的标准化诊断工具的使用 DSM 是《精神疾病诊断与统计手册 (The Diagnostic and Statistical Manual)》 用于对精神疾病、抑郁症、自闭症等疾病进行分类 并且每 10 到 15 年更新一次 你可以想象这会引起的问题 比如某研究者正在进行一项关于精神分裂症的长期研究 在最近更新的 DSM 中 一些精神分裂症的亚型不再被承认 如果我们看到了未来几年精神分裂症人数减少的趋势 这是实际效果还是因为测量系统的改变 这里我想讨论的最后一个影响因素是测验 也被称为敏感效应 (sensitization) 执行一项测验或测量程序可能会影响人的行为 如果测量产生的敏感效应为结果提供了一个替代解释 测验这个影响因素就表现出来了 比如在研究开始时进行的抑郁程度的前期测验 有可能使人们对自己的抑郁感变得警觉 这可能会使他们更积极地改进自己的情绪状态 比如通过变得更合群的方式 当然这一影响因素能通过引入一个对照组来消除 两组都十分相似地受到测试效应的影响 他们的抑郁感评分都会下降 但可预测在有猫陪伴的组下降幅度会更大 但引入对照组并不总是足够的 某些情况下 有可能对照组和实验组对前期测验的敏感化程度不同 比如这项有猫的研究中 前期测验加上要养猫 可能让有猫的实验组的人们对研究目的变得警觉 他们可能在后期测验时报告更低的抑郁感 不是因为事实如此 而是为了使研究看上去成功 以便能继续养猫 假设对照组的人们想不出研究目的 因为他们没有猫 他们没有被敏感化也没有动机去改变后期测验的评分 敏感效应的不同为实验提供了一个替代解释 一个解决办法是 增加一对没有进行前期测验的实验组和对照组 我会在讲到不同的实验设计时 详细讨论这一解决方法 来总结一下 内部效度会被低建构效度、仪器使用和测验影响 内部效度会被低建构效度、仪器使用和测验影响 低建构效度和仪器使用带来的影响因素可以通过 采用有效的测量工具和合理的操作方法来消除 当然还需要在使用中前后一致 测验的影响因素可以通过采用一种特殊设计来消除 这种特殊设计包括一对分别做过和没做过前期测验的组别</p><h1 id="内部效度的影响：人造因素-Artificiality"><a href="#内部效度的影响：人造因素-Artificiality" class="headerlink" title="内部效度的影响：人造因素 (Artificiality)"></a>内部效度的影响：人造因素 (Artificiality)</h1><p>Another category of threats to internal validity is associated with the artificial or unnatural reaction caused by participating in a research study.<br>在 15 秒处开始记录 0:15<br>This can be a reaction from the participant, but also from the researcher.<br>在 20 秒处开始记录 0:20<br>In any scientific study the researcher has to observe the behavior of individuals or groups. And in most cases the people under observation are aware of being observed.<br>在 32 秒处开始记录 0:32<br>Both researcher and participants have expectations about the goal of the study and about the desired behavior.<br>在 39 秒处开始记录 0:39<br>These expectations can lead to a change in behavior. That can provide an alternative explanation. I’ll discuss two of these threats to internal validity right here. Experimenter expectancy and demand characteristics.<br>在 53 秒处开始记录 0:53<br>If a researchers expectation have a biasing effect we call this threat to internal validity an experimenter expectancy effect. Experimenter expectancy refers to an unconscious change in a researchers behavior caused by expectations about the outcome that influences a participants responses.<br>在 1 分 12 秒处开始记录 1:12<br>Of course, this becomes an even bigger problem if a researcher unconsciously treats people in the control group differently from people in the experimental group.<br>在 1 分 22 秒处开始记录 1:22<br>One of the most subtle and shocking demonstrations of an experimenter expectancy effect was undoubtably provided by Rosenthal in the 1960s.<br>在 1 分 32 秒处开始记录 1:32<br>Psychology students were lead to believe they were taking a course on practical research skill in handling animals and duplicating experimental results.<br>在 1 分 44 秒处开始记录 1:44<br>Students handled one of two batches of rats that were compared on their performance in navigating a maze. The first batch of rats, students were told, was bred for their excellent spatial ability. The other batch was bred for the exact opposite purpose. Low and behold, there was a difference in performance. The maze bright rats out performed the maze dull rats.<br>在 2 分 9 秒处开始记录 2:09<br>Of course, in reality there was no difference in maze brightness in the two groups of rats. They were both from the same breeding line, and they were randomly assigned to be bright or dull.<br>在 2 分 21 秒处开始记录 2:21<br>Apparently just knowing what was expected of their batch of rats led students to treat them differently resulting in an actual difference in performance of the rats.<br>在 2 分 32 秒处开始记录 2:32<br>Imagine what the effect can be when a researcher interacts with human participants.<br>在 2 分 38 秒处开始记录 2:38<br>Fortunately, there is a solution. If the experimenter who interacts with the participants doesn’t know what behavior is expected of the, the experimenter will not be able to unconsciously influence participants. We call this an Experimenter Blind Design.<br>在 2 分 55 秒处开始记录 2:55<br>Of course the participant can also have expectations about the purpose of the study. Participants who are aware that they’re subjects in a study, will look for queues to figure out what the study is about.<br>在 3 分 9 秒处开始记录 3:09<br>Demand characteristics refers to a change in participant behavior due to their expectations about the study.<br>在 3 分 16 秒处开始记录 3:16<br>Demand characteristics are especially problematic if people respond to cues differently in the control, than in the experimental group.<br>在 3 分 26 秒处开始记录 3:26<br>A well known form of demand characteristics occurs when people are aware that they’re in an experimental group and are undergoing a treatment, especially if the treatment aims to help them.<br>在 3 分 39 秒处开始记录 3:39<br>Participants might be grateful to be in this group or hopeful that the treatment will be effective. And this might lead them to be more positive about the treatment, than had they been unaware of it. But the cues don’t even have to be accurately interpreted by the participants.<br>在 3 分 57 秒处开始记录 3:57<br>As long as participants in the same group interpret the queues in the same manner and change their behavior in the same way, demand characteristics form a real problem.<br>在 4 分 9 秒处开始记录 4:09<br>This is why it’s always a good idea to leave participants unaware of the actual purpose of the study or at least leave them unaware of which group they’re in, the experimental or the control group.<br>在 4 分 21 秒处开始记录 4:21<br>If both the subject and the experimenter are unaware, we call this a Double Blind Research Design. Now because any cue can lead to a bias in behavior, researchers usually come up with a cover story. A cover story is a plausible explanation of the purpose of the study. It should provide participants with cues that are unlikely to bias their behavior. Of course, this temporary deception needs to be necessary. The risk of bias, due to demand characteristics, needs to be real. And of course, you need to debrief participants afterwards and inform them about the real purpose of the study.</p><p>另一类影响内部效度的因素 与人们由于参与研究而导致的有意或无意的不自然反应有关<br>在 15 秒处开始记录 0:15<br>这可能是参与者的反应 也可能来自研究者<br>在 20 秒处开始记录 0:20<br>在任何科学研究中 研究者必须观察个体或群体的行为 在大多数情况下 被观察的对象知道自己被观察<br>在 32 秒处开始记录 0:32<br>研究者和参与者对于研究目标 和期望行为都有预期<br>在 39 秒处开始记录 0:39<br>这些预期会导致行为上的变化 这种变化将提供另一种解释 下面我们将讨论两种影响内部效度的因素 实验者预期 (experimenter expectancy) 和需求特征 (demand characteristics)<br>在 53 秒处开始记录 0:53<br>如果研究者的预期与结果有偏差 我们将这种对内部效度的影响称为实验者预期效果 实验者的预期是指 源于对结果的预期 研究人员无意识下改变行为 该变化而影响参与者的回应<br>在 1 分 12 秒处开始记录 1:12<br>当然 如果研究人员下意识地 对控制组的参与者和实验组的参与者 区别对待 会带来更大的问题<br>在 1 分 22 秒处开始记录 1:22<br>最能展现实验者预期效应是多么微妙与惊人的实验之一 是上世纪 60 年代由罗森塔尔所做的实验<br>在 1 分 32 秒处开始记录 1:32<br>心理学专业的学生被引导 相信他们参加了一门课程 即处理动物的实际研究技能 与复制实验结果<br>在 1 分 44 秒处开始记录 1:44<br>学生们处理了两批老鼠中的一组 比较它们在迷宫中认路的表现<br>在 1 分 51 秒处开始记录 1:51<br>学生们被告知 第一组大鼠被特殊培育 拥有出众的空间感 而另一组的培育目的截然相反 果不其然 两组大鼠的表现有差别 善于走迷宫的那组大鼠表现得比空间感迟钝的那组好 然而在现实中 两组老鼠在迷宫认路能力上并无差异 它们来自用同样的大鼠品系 并且被随机分为两批<br>在 2 分 21 秒处开始记录 2:21<br>显然 仅仅让学生知道 处理的老鼠群组的预期实验结果 导致学生对它们区别对待 从而导致老鼠之间的实际表现差异<br>在 2 分 32 秒处开始记录 2:32<br>想想看 如果被试对象是人 研究员会对他们产生多大的影响<br>在 2 分 38 秒处开始记录 2:38<br>幸运的是 有一个解决办法 如果与参与者互动的实验者 不知道他们会有什么预期 那么他们也就不会在无意中影响被试对象了 我们称其为研究者单盲实验<br>在 2 分 55 秒处开始记录 2:55<br>当然 被试对象也会对实验目标有所预期 因为受试者在了解研究目的后 可能会对实验有不同反应 意识到自己是研究对象的参与者 会去寻找提示 来找出研究的目的<br>在 3 分 9 秒处开始记录 3:09<br>需求特征是指被试对象由于对实验的预期的猜测 而改变自己行为的现象<br>在 3 分 16 秒处开始记录 3:16<br>当对照组与实验组中的人对线索反应不同时 需求特征造成的问题尤为严重<br>在 3 分 26 秒处开始记录 3:26<br>一种常见的需求特征 会在人们意识到 他们被分配到实验组中时出现 尤其在治疗是以帮助他们为目标的时候<br>在 3 分 39 秒处开始记录 3:39<br>被试对象也许会因被分配到实验组而十分感激 或是对治疗效果抱有期待 这可能导致他们比没有意识到自己在哪一组中时 更积极地面对治疗 但是 被试对象并不需要 准确地解读线索 只要隶属同一组的参与者 以同样的方式解读暗示 并以同样的方式改变他们的行为 需求特征就将造成问题<br>在 4 分 9 秒处开始记录 4:09<br>这就是为什么最好不要让被试意识到实验的真实目的 一种是编造与真实实验目的大相径庭的研究介绍 或者至少让他们不知道他们隶属哪个组 实验组或是对照组<br>在 4 分 21 秒处开始记录 4:21<br>我们把这种被试与 实验者均不知情的情况 称为双盲研究设计<br>在 4 分 28 秒处开始记录 4:28<br>因为任何提示都可能导致行为偏差 研究员们常常会编造一个故事作为幌子 这个幌子是一个对于实验目的合理的解释 它给被试对象的线索不太可能造成他们的行为偏差<br>在 4 分 43 秒处开始记录 4:43<br>当然 只有必要时 才会进行暂时欺骗 只有当确实存在需求特征引起偏差这一风险时 才能使用该方法 你还要在实验结束后 向他们做汇报 并告知他们实验的真正目的<br>另一类影响内部</p><h1 id="内部效度的影响：研究设计-Research-Setup"><a href="#内部效度的影响：研究设计-Research-Setup" class="headerlink" title="内部效度的影响：研究设计 (Research Setup)"></a>内部效度的影响：研究设计 (Research Setup)</h1><p>The last category of threats to internal validity, is a bit of a remainder category. Very generally, the three types of threats in this category are related to the research procedure or setup.<br>在 17 秒处开始记录 0:17<br>The threats are ambiguous temporal precedence, history and mortality.<br>在 23 秒处开始记录 0:23<br>An ambiguous temporal precedence and the hypothesized causal relation, is just a fancy way of saying that it’s unclear if the hypothesized cause actually precedes the observed effect.<br>在 35 秒处开始记录 0:35<br>Suppose I’m interested in the relationship between playing violent video games, and aggressive behavior.<br>在 42 秒处开始记录 0:42<br>I ask high school students how many hours a week they play violent games. And I ask their teacher to rate their aggressiveness in class.<br>在 52 秒处开始记录 0:52<br>What if I find a strong relation. Children who play violent games for many hours a week, also show more aggressive behavior.<br>在 1 分 1 秒处开始记录 1:01<br>Well this doesn’t mean violent game play causes aggressive behavior. Maybe children who play more violent games, were more aggressive to begin with. And are more likely to seek out violent stimuli.<br>在 1 分 14 秒处开始记录 1:14<br>The threat of ambiguous temporal precedence can be eliminated by manipulating, or introducing the hypothesised cause.<br>在 1 分 22 秒处开始记录 1:22<br>Of course, not all constructs can be manipulated, but if i can manipulate the cause, I can make sure it happens before the effect.<br>在 1 分 31 秒处开始记录 1:31<br>For example, I can make all children play violent games. If children that were not aggressive to begin with, also become more aggressive after playing the violent game, then my causal inference is much stronger.<br>在 1 分 45 秒处开始记录 1:45<br>Lets move on to a threat referred to as history.<br>在 1 分 49 秒处开始记录 1:49<br>A history effect is an unforeseen event that happens during the study that provides an alternative explanation.<br>在 1 分 56 秒处开始记录 1:56<br>Now, this could be a large-scale event or something small that goes wrong during data collection.<br>在 2 分 3 秒处开始记录 2:03<br>Consider a study on mitigating negative stereotypes about a minority group.<br>在 2 分 8 秒处开始记录 2:08<br>The manipulation consists of a group discussion led by an experimenter. The experimenter focuses on the point of view of the minority group, asking participants to put themselves in their shoes.<br>在 2 分 20 秒处开始记录 2:20<br>In the control condition the experimenter focuses on differences between the majority and minority, and stresses the point of view of the majority.<br>在 2 分 29 秒处开始记录 2:29<br>In both groups, there are three weekly group discussions. Okay. To give an example of a history effect on a small scale, imagine that during the last session in the control group, the experimenter faints.<br>在 2 分 42 秒处开始记录 2:42<br>Of course, participants are shaken and upset about this. And this might translate into a more general negative attitude in the control group. Which also makes the control group’s attitude towards the minority group more negative.<br>在 2 分 55 秒处开始记录 2:55<br>The treatment might look effective, because the experimental group is more positive, but the difference is due not to the discussion technique, but due to the fainting incident. Let’s consider the history effect on a larger scale. Suppose that during the study, a horrific murder is committed. Allegedly by a member of the minority. The crime gets an enormous amount of media attention, reinforcing the negative stereotype about the minority group.<br>在 3 分 22 秒处开始记录 3:22<br>Any positive effect of the intervention could be undone by this event.<br>在 3 分 28 秒处开始记录 3:28<br>The threat of history is hard to eliminate. Large scale events, well they can’t be avoided. Small scale events that happen during the study can be avoided at least to some extent by testing subjects separately, if this is possible. This way, if something goes wrong, the results of only one or maybe a few subjects will have to be discarded.<br>在 3 分 49 秒处开始记录 3:49<br>The final threat to discuss is mortality. Mortality refers to participant dropout from the study. If groups are compared and drop out is different in these groups, then this could provide an alternative explanation.<br>在 4 分 2 秒处开始记录 4:02<br>For example, suppose we’re investigating the effectiveness of a drug for depression. Suppose the drug is actually not very effective, and has a very strong side effect. It causes extreme flatulents. Of course this can be so uncomfortable and embarrassing that it wouldn’t be strange for people to drop out of the study because of the side effect.<br>在 4 分 24 秒处开始记录 4:24<br>Suppose 80% of the people in the experimental group dropped out. In the control group, participants are administered a placebo, with no active ingredient. So also, no side effects. Dropout in this group is only 10%. It’s obvious that the groups are no longer comparable. Suppose that for the remaining 20% of participants in the experimental group, the drug is effective enough to outweigh the negative side effect.<br>在 4 分 51 秒处开始记录 4:51<br>This wasn’t the case for the 80% who dropped out.<br>在 4 分 56 秒处开始记录 4:56<br>Based on the remaining subjects, we might conclude that the drug is very effective.<br>在 5 分 1 秒处开始记录 5:01<br>But if all subjects had reamined in the study, the conclusion would have been very different.<br>在 5 分 8 秒处开始记录 5:08<br>The threat of mortality is very hard to eliminate. In most cases, the best a researcher can do is document the reasons for dropout, so that these reasons can be investigated, and possibly mitigated in further studies.</p><p>最后我们将剩下的那些内部效度影响因素归结为一类 最后我们将剩下的那些内部效度影响因素归结为一类 这三个影响因素都和研究程序或设计相关 这三个影响因素都和研究程序或设计相关<br>在 17 秒处开始记录 0:17<br>它们是 模糊的先后顺序、历史、亡失<br>在 23 秒处开始记录 0:23<br>模糊的先后次序和假定的因果关系是指 模糊的先后次序和假定的因果关系是指 并不清楚假定的原因是否真的在观察结果之前<br>在 35 秒处开始记录 0:35<br>假设我关注玩暴力游戏和攻击行为之间的关系 假设我关注玩暴力游戏和攻击行为之间的关系<br>在 42 秒处开始记录 0:42<br>我问高中生一周玩多少小时的暴力游戏 我让老师评估他们在班中出现的攻击行为<br>在 52 秒处开始记录 0:52<br>假设我发现两者有强相关性 长时间玩暴力游戏的孩子更多出现攻击行为 长时间玩暴力游戏的孩子更多出现攻击行为<br>在 1 分 1 秒处开始记录 1:01<br>这并不能得出暴力游戏导致了攻击行为 可能是本身攻击性强一些的孩子才更喜欢玩暴力游戏 也会更多寻求暴力刺激<br>在 1 分 14 秒处开始记录 1:14<br>模糊的先后次序带来的影响 能通过控制或引入假设的原因来消除<br>在 1 分 22 秒处开始记录 1:22<br>当然 不是所有的因素都能被控制 但如果我控制了原因 那我就能肯定它在结果之前<br>在 1 分 31 秒处开始记录 1:31<br>比如 我让所有的孩子都玩暴力游戏 如果玩游戏后 起先没攻击性的孩子也变得有攻击性 那么我的因果推论就更有说服力<br>在 1 分 45 秒处开始记录 1:45<br>接下来要讲的是历史这个影响因素<br>在 1 分 49 秒处开始记录 1:49<br>历史影响是指研究中发生的意外事件 它们会产生替代解释<br>在 1 分 56 秒处开始记录 1:56<br>这可以是大规模事件 或者是数据收集期间的小错误<br>在 2 分 3 秒处开始记录 2:03<br>比如一个研究想要消除人们对少数群体的负面成见<br>在 2 分 8 秒处开始记录 2:08<br>操作方法是由实验者主持一个小组讨论 实验者的重心是少数群体的观点 要求参与者设身处地考虑问题<br>在 2 分 20 秒处开始记录 2:20<br>在对照组 实验者重心是多数群体和少数群体间的差异 并强调多数人的观点<br>在 2 分 29 秒处开始记录 2:29<br>两组都会有三次周会 先举个小规模的历史型影响 假设在对照组最后一次讨论会上 实验者昏倒了<br>在 2 分 42 秒处开始记录 2:42<br>当然 参与者对此感到震惊、不安 这可能会让对照组普遍陷入负面情绪状态 假设我发现 玩了暴力游戏的孩子比对照组更具攻击性 这使对照组对少数群体的态度更加负面 这使对照组对少数群体的态度更加负面<br>在 2 分 55 秒处开始记录 2:55<br>实验处理似乎起作用了 因为实验组更正面 但差异并非来自讨论的设计 而是因为昏倒事件 来看看大规模历史影响的例子 假设研究期间 出现了一件可怕的罪行 嫌疑人是一个少数群体的人 该罪行受到大量媒体的关注 加强了对少数群体的负面成见<br>在 3 分 22 秒处开始记录 3:22<br>任何干预的正面效果都会被这个事件抹去<br>在 3 分 28 秒处开始记录 3:28<br>历史这种影响因素很难消除 大规模事件难以避免 研究期间发生的小规模事件 如果可能 至少能通过将受试者分组测试来避免 这样 如果出错了 只有一个或可能几个受试者必须要被舍弃<br>在 3 分 49 秒处开始记录 3:49<br>最后一个影响因素就是亡失 亡失意味着参与者退出了 如果组间比较时 它们的退出率不一样 那么就会出现替代解释<br>在 4 分 2 秒处开始记录 4:02<br>比如 假设调查治疗抑郁症药物的效果 比如 假设调查治疗抑郁症药物的效果 假设药物其实不是很有效 但副作用很大 它会导致不停地放屁 当然 这会很不舒服而且尴尬 人们因为这个副作用而退出也没有什么奇怪的<br>在 4 分 24 秒处开始记录 4:24<br>假设实验组 80% 的人退出了 在对照组 参与者服用的是没有药效的安慰剂 当然也没副作用 对照组的退出率只有 10% 很明显这两组没有可比性了 假设在实验组剩余 20% 的参与者中 药效带来的好处要胜过副作用<br>在 4 分 51 秒处开始记录 4:51<br>但退出的 80% 就不是这样了<br>在 4 分 56 秒处开始记录 4:56<br>仅基于剩下的 20% 参与者的结果 我们可能认为药物非常有效<br>在 5 分 1 秒处开始记录 5:01<br>但如果实验组所有的对象都在的话 结论可能会大不一样<br>在 5 分 8 秒处开始记录 5:08<br>亡失这个影响因素很难消除 大多数情况下 研究者所能做的就是记录退出原因 以便调查 并在下次研究中避免这些原因</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内部效度的影响：参与者-（Internal-Validity-Threats-Participants）&quot;&gt;&lt;a href=&quot;#内部效度的影响：参与者-（Internal-Validity-Threats-Participants）&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="social-science" scheme="https://theinfinitegame.tech/categories/social-science/"/>
    
    
      <category term="计量方法" scheme="https://theinfinitegame.tech/tags/%E8%AE%A1%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    
      <category term="社会科学" scheme="https://theinfinitegame.tech/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 笔记 | MVVM In SwiftUI</title>
    <link href="https://theinfinitegame.tech/development/note-swiftui-mvvm/"/>
    <id>https://theinfinitegame.tech/development/note-swiftui-mvvm/</id>
    <published>2020-03-02T02:51:18.000Z</published>
    <updated>2020-03-02T06:40:55.145Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>译自 <a href="https://augmentedcode.io/2020/01/05/mvvm-in-swiftui/" target="_blank" rel="noopener">MVVM in SwiftUI</a></p></blockquote><p>让我们用 MVVM (model-view-view model) 来构建一个应用，其中的每个 SwiftUI 视图都有自己的 model 。这会是一个拥有两个视图的 app : 一个电影列表以及一个用于添加电影的表单。新增的电影存在在 <code>MovieStore</code> ，它由两个 view models 共享。我们将通过 environment 来共享 MovieStore ，也就说，当我们需要时，会从 environment 中读取。</p><h2 id="用-Movie-和-MovieStore-来表示数据"><a href="#用-Movie-和-MovieStore-来表示数据" class="headerlink" title="用 Movie 和 MovieStore 来表示数据"></a>用 Movie 和 MovieStore 来表示数据</h2><p>Movie 是一个很小的结构体，只存储了标题和评分。标题和评分都是可变的，因为我们需要在 AddMovieView 里更新它们。这个结构体也遵循 <code>Identifiable</code> 协议，因为我们将用 List 视图来展示所有的电影。List 需要能够标识内容中的每一项，而遵循这个协议是最简单的方式。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Movie</span>: <span class="title">Equatable</span>, <span class="title">Identifiable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id = <span class="type">UUID</span>()</span><br><span class="line">    <span class="keyword">var</span> fullTitle: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> givenRating: <span class="type">Rating</span> = .notSeen</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Movie</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Rating</span>: <span class="title">Int</span>, <span class="title">CaseIterable</span> </span>{</span><br><span class="line">        <span class="keyword">case</span> notSeen, terrible, poor, decent, good, excellent</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>MovieStore 也很简单，不过实际的 app 会包含更多的逻辑：持久化，删除等等。我们用 <code>Published</code> 属性包装器来为订阅者自动提供发布。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieStore</span> </span>{</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> allMovies = [<span class="type">Movie</span>]()</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> movie: Movie)</span></span> {</span><br><span class="line">        allMovies.append (movie)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了将共享的 <code>MovieStore</code> 插入环境，我们需要使用自定义的 EnvironmentKey 。自定义 key 仅仅只是一个遵循  <code>EnvironmentKey</code> 协议的自定义 key 。我们需要提供类型和默认值。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MovieStoreKey</span>: <span class="title">EnvironmentKey</span> </span>{</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Value</span> = <span class="type">MovieStore</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue = <span class="type">MovieStore</span>()</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EnvironmentValues</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> movieStore: <span class="type">MovieStore</span> {</span><br><span class="line">        <span class="keyword">get</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>[<span class="type">MovieStoreKey</span>]</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">set</span> {</span><br><span class="line">            <span class="keyword">self</span>[<span class="type">MovieStoreKey</span>] = newValue</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们不插入自己的 <code>MovieStore</code> 实例到 environment ，那就会使用 defaultValue 默认值。典型情况下，我们会在视图体系之外初始化这个特定实例。</p><h2 id="SceneDelegate-和-MovieScene-呈现"><a href="#SceneDelegate-和-MovieScene-呈现" class="headerlink" title="SceneDelegate 和 MovieScene 呈现"></a>SceneDelegate 和 MovieScene 呈现</h2><p>MovieStore 作为依赖项，在构造函数被传给 view model 。我们将使用存储在 SceneDelegate 的实例。再次申明，在实际的 app 中，这种依赖项很可能是处于一个独立的容器或者别的类似的东西。 MovieListView 是我们要呈现的第一个视图，因此我们会初始化 view model ， view ，并且插入 MovieStore 实例到 environment ，以便后续使用。 (movieStore keypath 是通过 EnvironmentValues 的 extension 来定义的)。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SceneDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIWindowSceneDelegate</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> movieStore = <span class="type">MovieStore</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scene</span><span class="params">(<span class="number">_</span> scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</span></span> {</span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">MovieListView</span>.<span class="type">ViewModel</span>(movieStore: movieStore)</span><br><span class="line">        <span class="keyword">let</span> contentView = <span class="type">MovieListView</span>(viewModel: viewModel).environment (\.movieStore, movieStore)</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> windowScene = scene <span class="keyword">as</span>? <span class="type">UIWindowScene</span> <span class="keyword">else</span> { <span class="keyword">return</span> }</span><br><span class="line">        <span class="keyword">let</span> window = <span class="type">UIWindow</span>(windowScene: windowScene)</span><br><span class="line">        window.rootViewController = <span class="type">UIHostingController</span>(rootView: contentView)</span><br><span class="line">        <span class="keyword">self</span>.window = window</span><br><span class="line">        window.makeKeyAndVisible ()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="MovieListView-和对应的-ViewModel"><a href="#MovieListView-和对应的-ViewModel" class="headerlink" title="MovieListView 和对应的 ViewModel"></a>MovieListView 和对应的 ViewModel</h2><p>在 SwiftUI 中，view model 遵循 <code>ObservableObject</code> 协议，使用 @Published 属性包装器。 ObservableObject 的默认实现提供了 <code>objectWillChange</code> publisher 。 @Published 属性包装器能在属性将要改变时自动发射这个 publisher 。在 MovieListView 中，我们用 @ObservedObject 属性包装器声明 view model 属性。这会使得该视图订阅 objectWillChange publisher ，并且在 objectWillChange 发动时自动刷新视图。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MovieListView</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">let</span> movieStore: <span class="type">MovieStore</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cancellables = [<span class="type">AnyCancellable</span>]()</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">init</span>(movieStore: <span class="type">MovieStore</span>) {</span><br><span class="line">            <span class="keyword">self</span>.movieStore = movieStore</span><br><span class="line">            cancellables.append (movieStore.$allMovies.assign (to: \.movies, on: <span class="keyword">self</span>))</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> movies = [<span class="type">Movie</span>]()</span><br><span class="line">        @<span class="type">Published</span> <span class="keyword">var</span> isPresentingAddMovie = <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MovieListView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">Environment</span>(\.<span class="keyword">self</span>) <span class="keyword">var</span> environment</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">ViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">NavigationView</span> {</span><br><span class="line">            <span class="type">List</span>(<span class="keyword">self</span>.viewModel.movies) { movie <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(movie.fullTitle)</span><br><span class="line">            }.navigationBarTitle (<span class="string">"Movies"</span>)</span><br><span class="line">                .navigationBarItems (trailing: navigationBarTrailingItem)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> navigationBarTrailingItem: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: {</span><br><span class="line">            <span class="keyword">self</span>.viewModel.isPresentingAddMovie = <span class="literal">true</span></span><br><span class="line">        }, label: {</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"plus"</span>).frame (minWidth: <span class="number">32</span>, minHeight: <span class="number">32</span>)</span><br><span class="line">        }).sheet (isPresented: <span class="keyword">self</span>.$viewModel.isPresentingAddMovie) {</span><br><span class="line">            <span class="keyword">self</span>.makeAddMovieView ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAddMovieView</span><span class="params">()</span></span> -&gt; <span class="type">AddMovieView</span> {</span><br><span class="line">        <span class="keyword">let</span> movieStore = environment [<span class="type">MovieStoreKey</span>]</span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">AddMovieView</span>.<span class="type">ViewModel</span>(movieStore: movieStore)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AddMovieView</span>(viewModel: viewModel)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你会注意到，MovieStore 时用了两份，一份在 view model 中，一份放在环境中。</p><p><code>AddMovieView</code> 和它的 view model 是在用户点击导航栏上的加号按钮时被创建的。环境属性包装器可以被用于获取整个环境或者借助特定键获取某个值。在这个案例中我们访问了整个环境对象，然后在需要的时候借助 MovieStoreKey 访问 MovieStore 。或者你也可以使用 @Environment (.movieStore) var movieStore 来代替。</p><h2 id="AddMovieView-和对应的-ViewModel"><a href="#AddMovieView-和对应的-ViewModel" class="headerlink" title="AddMovieView 和对应的 ViewModel"></a>AddMovieView 和对应的 ViewModel</h2><p><code>AddMovieView</code> 的 view model 是随着 MovieStore 一同被初始化的，它内部呈现了一个 Movie 实例。 Published 属性包装器和 MovieListView 的 view model 里的用法相似。 内部的 movie 对象是一个私有的属性， TextField 和 Picker 都采用双向 Binding 。 Binding 是一种 view 和 model 间的双向连接方式。另外，还有一个 <code>canSave</code> 属性，它是用来控制导航栏上的保存按钮是否启用。保持按钮只有在标题有填充的时才启用。</p><p>简单复习一下视图更新的流程：TextField 或者 Picker 会利用 Binding 来更新私有属性 <code>newMovie</code> 。 因为 newMovie 属性使用了 @Published 属性包装器，它会发射 ObservableObject 的 objectWillChange publisher 。 SwiftUI 自动订阅 objectWillChange ，因为 view model 的属性用了 @ObservedObject 。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AddMovieView</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">let</span> movieStore: <span class="type">MovieStore</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">init</span>(movieStore: <span class="type">MovieStore</span>) {</span><br><span class="line">            <span class="keyword">self</span>.movieStore = movieStore</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        @<span class="type">Published</span> <span class="keyword">private</span> <span class="keyword">var</span> newMovie = <span class="type">Movie</span>(fullTitle: <span class="string">""</span>)</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">lazy</span> <span class="keyword">var</span> title = <span class="type">Binding</span>&lt;<span class="type">String</span>&gt;(<span class="keyword">get</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.fullTitle</span><br><span class="line">        }, <span class="keyword">set</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.fullTitle = $<span class="number">0</span></span><br><span class="line">        })</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">lazy</span> <span class="keyword">var</span> rating = <span class="type">Binding</span>&lt;<span class="type">Movie</span>.<span class="type">Rating</span>&gt;(<span class="keyword">get</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.givenRating</span><br><span class="line">        }, <span class="keyword">set</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.givenRating = $<span class="number">0</span></span><br><span class="line">        })</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">var</span> canSave: <span class="type">Bool</span> {</span><br><span class="line">            <span class="keyword">return</span> !newMovie.fullTitle.isEmpty</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">()</span></span> {</span><br><span class="line">            movieStore.add (newMovie)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddMovieView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">Environment</span>(\.presentationMode) <span class="keyword">private</span> <span class="keyword">var</span> presentationMode</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">ViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">NavigationView</span> {</span><br><span class="line">            <span class="type">Form</span> {</span><br><span class="line">                titleSection</span><br><span class="line">                ratingSection</span><br><span class="line">            }.navigationBarTitle (<span class="string">"Add Movie"</span>, displayMode: .inline)</span><br><span class="line">                .navigationBarItems (leading: leadingBarItem, trailing: trailingBarItem)</span><br><span class="line">                .navigationViewStyle (<span class="type">StackNavigationViewStyle</span>())</span><br><span class="line">             </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> titleSection: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Section</span>() {</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">"Title"</span>, text: viewModel.title)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ratingSection: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Section</span>() {</span><br><span class="line">            <span class="type">Picker</span>(<span class="type">LocalizedStringKey</span>(<span class="string">"Rating"</span>), selection: viewModel.rating) {</span><br><span class="line">                <span class="type">ForEach</span>(<span class="type">Movie</span>.<span class="type">Rating</span>.allCases, id: \.rawValue) {</span><br><span class="line">                    <span class="type">Text</span>($<span class="number">0</span>.localizedName).tag ($<span class="number">0</span>)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> leadingBarItem: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: { <span class="keyword">self</span>.presentationMode.wrappedValue.dismiss () }, label: {</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Cancel"</span>)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> trailingBarItem: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: {</span><br><span class="line">            <span class="keyword">self</span>.viewModel.save ()</span><br><span class="line">            <span class="keyword">self</span>.presentationMode.wrappedValue.dismiss ()</span><br><span class="line">        }, label: {</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Save"</span>).disabled (!<span class="keyword">self</span>.viewModel.canSave)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们创建了一个只有两个视图的简单 app 。两个视图都有各自的 view model ，并且都依赖 MovieStore 。一个 view model 中触发了 MovieStore 的改变，这些改变会被另一个 view model 观察到。另外，我们还了解了 SwiftUI 的 environment 以及如何从 view model 中触发 view 更新。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;译自 &lt;a href=&quot;https://augmentedcode.io/2020/01/05/mvvm-in-swiftui/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MVVM in SwiftUI&lt;/a&gt;&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
      <category term="swiftui" scheme="https://theinfinitegame.tech/tags/swiftui/"/>
    
  </entry>
  
  <entry>
    <title>note-swiftui-dynamic-user-notification-on-apple-watch</title>
    <link href="https://theinfinitegame.tech/uncategorized/note-swiftui-dynamic-user-notification-on-apple-watch/"/>
    <id>https://theinfinitegame.tech/uncategorized/note-swiftui-dynamic-user-notification-on-apple-watch/</id>
    <published>2020-03-01T09:08:42.112Z</published>
    <updated>2020-03-02T02:52:09.193Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: SwiftUI 应用 | 浇水提醒 app<br>top: false<br>date: 2020-03-01 17:08:42<br>tags:</p><ul><li>watchOS</li><li>development</li><li>swiftui<br>categories: development<br>description:</li></ul><hr><h1 id="用-SwiftUI-在-Apple-Watch-上构建动态通知"><a href="#用-SwiftUI-在-Apple-Watch-上构建动态通知" class="headerlink" title="用 SwiftUI 在 Apple Watch 上构建动态通知"></a>用 SwiftUI 在 Apple Watch 上构建动态通知</h1><blockquote><p>译自 <a href="https://augmentedcode.io/2020/02/02/dynamic-user-notification-on-apple-watch-with-swiftui/" target="_blank" rel="noopener">Dynamic user notification on Apple Watch with SwiftUI</a><br>源码地址：<a href="https://github.com/laevandus/WaterMyPlants" target="_blank" rel="noopener">WaterMyPlants</a></p></blockquote><p>集成了推送或者本地通知的 app 可以定制 apple watch 上的通知。本文是关于如何在 apple watch 上实现动态通知的笔记。样例工程实现一个提醒给植物浇水的功能。我们会聚焦在添加通知视图，省略从 iOS app 发送通知的步骤。</p><h2 id="为-Apple-Watch-添加富文本通知添加构建目标"><a href="#为-Apple-Watch-添加富文本通知添加构建目标" class="headerlink" title="为 Apple Watch 添加富文本通知添加构建目标"></a>为 Apple Watch 添加富文本通知添加构建目标</h2><p>如果工程里没有 App Watch app ，你需要添加它。在 Xcode 中，我们新增一个构建目标，并配置成包含通知场景。打开 New -&gt; Target:</p><p><img src="/images/watch_app_target.png" width="80%" height="80%" style="margin: 10 auto;"></p><p>确保 User Interface 选择，并且 “Include Notification Scene” 选中。我们将会把它嵌入当前的 iOS app ，所以 “Embed in Companion App” 要选择当前 app 。值得一提的是，从 iOS 13 和 WatchOS 6 开始，Apple Watch app 已经可以独立存在了。</p><p><img src="/images/watch_app_target_2.png" width="80%" height="80%" style="margin: 10 auto;"></p><p>点击完成，Xcode 会询问激活新的 scheme ，点击激活，它会自动选择新建的目标，所以我们可以直接开始写代码了。先检查工程，会发现 Xcode 加了两个目标：watch app 和 extension。App 包含了 storyboard ，而 extension 包含了所有的代码。 storyboard 是提供基于 <code>WKHostingController</code> 的子类的 HostingController 演示用的场景。这个类负责承载你的 Apple Watch app 的 SwiftUI 视图。另外，还有两个场景，分别是静态和动态通知。我们对动态通知感兴趣，在 storyboard 里可以看见动态视图是由 <code>NotificationController</code> 提供的，它是 <code>WKUserNotificationHostingController</code> 的子类，承载通知的 SwiftUI 视图。这里就是我们给通知提供自定义界面的地方。如果通知的分类和 storyboard 里预先定义的匹配，就会选择动态通知视图。</p><h2 id="解析通知的-payload-并设置动态通知视图"><a href="#解析通知的-payload-并设置动态通知视图" class="headerlink" title="解析通知的 payload 并设置动态通知视图"></a>解析通知的 payload 并设置动态通知视图</h2><p>NotificationController 的职责是消费用户通知的 payload ，并生成 SwiftUI 视图来展示它们。用户通知是从 <code>didReceive</code> 函数接收的，我们需要释放信息，用于视图。在本地测试的时候，我们可以把测试数据写在 <code>PushNotificationPayload.apns</code> 文件里。因为我们要展示的是关于植物的信息，所有我们添加一个植物对象到文件中。同时，我们还需要把通知分类修改成某个有含义的字符串。确保你设置新的分类时正确更新 storyboard 。</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"aps"</span>: {</span><br><span class="line">        <span class="attr">"alert"</span>: {</span><br><span class="line">            <span class="attr">"body"</span>: <span class="string">"Test message"</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Optional title"</span>,</span><br><span class="line">            <span class="attr">"subtitle"</span>: <span class="string">"Optional subtitle"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="attr">"category"</span>: <span class="string">"WATERING_REMINDER"</span>,</span><br><span class="line">        <span class="attr">"thread-id"</span>: <span class="string">"plantid123"</span></span><br><span class="line">    },</span><br><span class="line">     </span><br><span class="line">    <span class="attr">"plant"</span>: {</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"plantid123"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Aloe"</span>,</span><br><span class="line">        <span class="attr">"lastDate"</span>: <span class="number">1579937802</span>,</span><br><span class="line">        <span class="attr">"nextDate"</span>: <span class="number">1580515200</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/watch_app_target_3.png" width="50%" height="50%" style="margin: 10 auto;"></p><p>当我们访问 <code>UNNotification.request.content.userInfo</code> 拿到植物的信息时，我们可以用 <code>Decodable</code> 和 <code>JSONDecoder</code> 将代表植物的字典转换成值类型。 <code>JSONDecoder</code> 接收 <code>JSON</code> 数据，所以我们先用 <code>JSONSerialization</code> 包装数据，然后把包装的结果传给 <code>JSONDecoder</code> 。 或者我们也可以手动从 <code>userInfo</code> 字典里读取所有的值，然后创建出植物类型。留意，我们需要用 view model 来提供数据给 SwiftUI ，而不是直接使用 <code>Plant</code> 类型。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span>: <span class="title">Decodable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastDate: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> nextDate: <span class="type">Date</span></span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">let</span> plantInfo = notification.request.content.userInfo [<span class="string">"plant"</span>] <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">Any</span>]</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.data (withJSONObject: plantInfo, options: [])</span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        decoder.dateDecodingStrategy = .secondsSince1970</span><br><span class="line">        <span class="keyword">let</span> plant = <span class="keyword">try</span> decoder.decode (<span class="type">Plant</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">        viewModel = <span class="type">NotificationViewModel</span>(plant: plant)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> <span class="keyword">let</span> nsError <span class="keyword">as</span> <span class="type">NSError</span> {</span><br><span class="line">        <span class="built_in">print</span>(nsError.localizedDescription)</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>另外，我们想要添加三个用户可以执行的动作：标记植物已经浇水，推后提醒，或者安排明天再提醒。这些动作是用 <code>UNNotificationAction</code> 实例表示。当用户点击任意其中一个时，<code>UNUserNotificationCenter</code> 的委托方法会被调用，并且带有该动作的 <code>identifier</code> 。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doneTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Done"</span>, comment: <span class="string">"Done button title in notification."</span>)</span><br><span class="line"><span class="keyword">let</span> laterTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Later"</span>, comment: <span class="string">"Later button title in notification."</span>)</span><br><span class="line"><span class="keyword">let</span> tomorrowTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Tomorrow"</span>, comment: <span class="string">"Tomorrow button title in notification."</span>)</span><br><span class="line">notificationActions = [</span><br><span class="line">    <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_done"</span>, title: doneTitle, options: []),</span><br><span class="line">    <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_later"</span>, title: laterTitle, options: []),</span><br><span class="line">    <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_tomorrow"</span>, title: tomorrowTitle, options: [])</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><code>NotificationController</code> 的完整实现如下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationController</span>: <span class="title">WKUserNotificationHostingController</span>&lt;<span class="title">NotificationView</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> viewModel: <span class="type">NotificationViewModel?</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> body: <span class="type">NotificationView</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NotificationView</span>(viewModel: viewModel!)</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> notification: UNNotification)</span></span> {</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="keyword">let</span> plantInfo = notification.request.content.userInfo [<span class="string">"plant"</span>] <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">Any</span>]</span><br><span class="line">            <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.data (withJSONObject: plantInfo, options: [])</span><br><span class="line">            <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">            decoder.dateDecodingStrategy = .secondsSince1970</span><br><span class="line">            <span class="keyword">let</span> plant = <span class="keyword">try</span> decoder.decode (<span class="type">Plant</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">            viewModel = <span class="type">NotificationViewModel</span>(plant: plant)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> <span class="keyword">let</span> nsError <span class="keyword">as</span> <span class="type">NSError</span> {</span><br><span class="line">            <span class="built_in">print</span>(nsError.localizedDescription)</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">let</span> doneTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Done"</span>, comment: <span class="string">"Done button title in notification."</span>)</span><br><span class="line">        <span class="keyword">let</span> laterTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Later"</span>, comment: <span class="string">"Later button title in notification."</span>)</span><br><span class="line">        <span class="keyword">let</span> tomorrowTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Tomorrow"</span>, comment: <span class="string">"Tomorrow button title in notification."</span>)</span><br><span class="line">        notificationActions = [</span><br><span class="line">            <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_done"</span>, title: doneTitle, options: []),</span><br><span class="line">            <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_later"</span>, title: laterTitle, options: []),</span><br><span class="line">            <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_tomorrow"</span>, title: tomorrowTitle, options: [])</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="呈现通知的-NotificationView"><a href="#呈现通知的-NotificationView" class="headerlink" title="呈现通知的 NotificationView"></a>呈现通知的 NotificationView</h2><p>上面提到 view model <code>NotificationViewModel</code> 为 NotificationView 提供文本，它主要处理日期的格式化字符。 </p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotificationViewModel</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> plant: <span class="type">Plant</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(plant: <span class="type">Plant</span>) {</span><br><span class="line">        <span class="keyword">self</span>.plant = plant</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> plant.name</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> subtitle: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSLocalizedString</span>(<span class="string">"NotificationView_Subtitle"</span>, comment: <span class="string">"Notification suggestion text"</span>)</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        formatter.dateFormat = <span class="type">DateFormatter</span>.dateFormat (fromTemplate: <span class="string">"dMMMM"</span>, options: <span class="number">0</span>, locale: .current)</span><br><span class="line">        <span class="keyword">return</span> formatter</span><br><span class="line">    }()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> lastWatering: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> format = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationView_LastWatering"</span>, comment: <span class="string">"Last watering date."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: format, dateFormatter.string (from: plant.lastDate))</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> nextWatering: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> format = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationView_NextWatering"</span>, comment: <span class="string">"Next watering date."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: format, dateFormatter.string (from: plant.nextDate))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>SwiftUI 视图很简单，4 个文本。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotificationView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> viewModel: <span class="type">NotificationViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">Text</span>(viewModel.title).font (.title)</span><br><span class="line">            <span class="type">Text</span>(viewModel.subtitle).font (.subheadline)</span><br><span class="line">            <span class="type">Divider</span>()</span><br><span class="line">            <span class="type">Text</span>(viewModel.lastWatering).font (.body).multilineTextAlignment (.center)</span><br><span class="line">            <span class="type">Text</span>(viewModel.nextWatering).font (.body).multilineTextAlignment (.center)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/watch_notification_1.png" width="30%" height="30%" style="margin: 10 auto;"></p><p><img src="/images/watch_notification_2.png" width="30%" height="30%" style="margin: 10 auto;"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们往一个 iOS app 中添加了 watch app ，实现一个通知分类的动态通知视图。我们学习了如何解析通知数据，添加动作按钮。下一步是在 companion iOS app 里基于按钮的 identifier 处理对应通知动作。</p><hr><h1 id="拉取和显示数据"><a href="#拉取和显示数据" class="headerlink" title="拉取和显示数据"></a>拉取和显示数据</h1><p> 这一节的主题是从 compasion iOS app 的 CoreData 存储中获取数据，需要借助 WatchConnectivity framework 。</p><h2 id="iOS-和-WatchOS-app-之间的-session"><a href="#iOS-和-WatchOS-app-之间的-session" class="headerlink" title="iOS 和 WatchOS app 之间的 session"></a>iOS 和 WatchOS app 之间的 session</h2><p> iOS app 用 CoreData 来存储植物列表，记录了每株植物上一次和下一次浇水的日期。在这里，没有 web 服务，所有的东西都存在设备上。那么如何把持久化存储中的数据拿给 WatchOS app 使用呢？</p><p>我们会用到 WatchConnectivity framework 来做 iOS 和 WatchOS app 之间的交互。连接是在 iOS 和 WatchOS app 上都激活 <code>WCSession</code> 来实现的。因此，第一步是添加一个管理 <code>WCSession</code> 的类到 iOS 工程，我们不妨称它为 WatchConnectivityProvider (稍后也会添加一个相似的类到 WatchOS app)。它的主要职能是建立 <code>WCSession</code> ，处理 <code>WCSessionDelegate</code> ，其中包含从 CoreData 存储拉取数据。因此，有一个叫 <code>NSPersistentContainer</code> 的参数会提供对 <code>CoreData</code> 栈的访问 (借由访问 performBackgroundTask 函数)。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchConnectivityProvider</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> persistentContainer: <span class="type">NSPersistentContainer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">WCSession</span> = .<span class="keyword">default</span>, persistentContainer: <span class="type">NSPersistentContainer</span>) {</span><br><span class="line">        <span class="keyword">self</span>.persistentContainer = persistentContainer</span><br><span class="line">        <span class="keyword">self</span>.session = session</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><code>WCSession</code> 是通过调用 activate () 来激活，激活过程是异步的。激活的响应通过 <code>session (_:activationDidCompleteWith:error:)</code> 委托访问返回。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">guard</span> <span class="type">WCSession</span>.isSupported () <span class="keyword">else</span> {</span><br><span class="line">        os_log (.debug, log: .watch, <span class="string">"watch session is not supported"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"activating watch session"</span>)</span><br><span class="line">    session.activate ()</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, </span></span></span><br><span class="line"><span class="function"><span class="params">             activationDidCompleteWith activationState: WCSessionActivationState, </span></span></span><br><span class="line"><span class="function"><span class="params">             error: Error?)</span></span> {</span><br><span class="line">    os_log (.debug, </span><br><span class="line">               log: .watch, </span><br><span class="line">               <span class="string">"did finish activating session % lu (error: % s)"</span>, </span><br><span class="line">               activationState == .activated, </span><br><span class="line">               error?.localizedDescription ?? <span class="string">"none"</span>) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 watchOS extension target 那边，我们会添加相似的代码，不过名字不一样，叫 “PhoneConnectivityProvider” 。当两个类都创建完成后，我们需要初始化并调用 connect ，分别在 <code>SceneDelegate</code> (iOS) 和 <code>ExtensionDelegate</code> (watchOS) 中完成。注意，在 iOS app 这边，我们需要实现两个委托方面，不过目前我们简单打印就可以了。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sessionDidBecomeInactive</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> {</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"session became inactive"</span>)</span><br><span class="line">}</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sessionDidDeactivate</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> {</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"session deactivated"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了测试 session ，我们需要先编译并运行，然后在编译运行 watchOS app 。如果一切工作正常， Xcode 调试窗口会打印出消息： “did finish activating session 1 (error: none)”. 这表明 session 已经建立并且正在运行，我们可以两个 app 间发送消息了。</p><h2 id="Fetching-plants-from-iOS-app"><a href="#Fetching-plants-from-iOS-app" class="headerlink" title="Fetching plants from iOS app"></a>Fetching plants from iOS app</h2><p>因为 iOS 和 watchOS app 之间的通信依赖字典，所以第一步是定义一组两个 app 共享使用的 key 。这样可以减少误拼写的风险，所以我们可以添加新文件，并且同时包含到 iOS app target 和 watchOS extension target 中去。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WatchCommunication</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> requestKey = <span class="string">"request"</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> responseKey = <span class="string">"response"</span></span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Content</span>: <span class="title">String</span> </span>{</span><br><span class="line">        <span class="keyword">case</span> allPlants</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二步是在 <code>PhoneConnectivityProvider</code> (watchOS app extension target) 中实现一个 <code>refreshAllPlants (completionHandler)</code> 函数，用来发送消息给 iOS app ，并且等待植物数据的数组返回。 <code>WCSession</code> 有一个叫  <code>sendMessage (_:replyHandler:errorHandler:)</code> 的函数，我们可以用它来发送一个字典给 iOS app ，然后等待 reply handler 。我们会用 WatchCommunication.requestKey 和 WatchCommunication.Content.allPlants 枚举的 rawValue 来构建消息。这种模式便于后续扩展，你只要添加更到 case 到枚举就可以了。在 reply handler 中，我们期望得到一个字典的数组，描述所有的植物。让我们先看一眼完整的实现，然后再讨论字典是如何被转换成 <code>Plant</code> 值类型的。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refreshAllPlants</span><span class="params">(withCompletionHandler completionHandler: @escaping <span class="params">([Plant]?)</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">    <span class="keyword">guard</span> session.activationState == .activated <span class="keyword">else</span> {</span><br><span class="line">        os_log (.debug, log: .phone, <span class="string">"session is not active"</span>)</span><br><span class="line">        completionHandler (<span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">let</span> message = [<span class="type">WatchCommunication</span>.requestKey: <span class="type">WatchCommunication</span>.<span class="type">Content</span>.allPlants.rawValue]</span><br><span class="line">    session.sendMessage (message, replyHandler: { (payload) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> plantDictionaries = payload [<span class="type">WatchCommunication</span>.requestKey] <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]]</span><br><span class="line">        os_log (.debug, log: .phone, <span class="string">"received % lu plants"</span>, plantDictionaries?.<span class="built_in">count</span> ?? <span class="number">0</span>)</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        decoder.dateDecodingStrategy = .secondsSince1970</span><br><span class="line">        <span class="keyword">let</span> plants = plantDictionaries?.compactMap ({ <span class="type">Plant</span>(dictionary: $<span class="number">0</span>, decoder: decoder) })</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async {</span><br><span class="line">            completionHandler (plants)</span><br><span class="line">        }</span><br><span class="line">    }, errorHandler: { error <span class="keyword">in</span></span><br><span class="line">        os_log (.debug, log: .phone, <span class="string">"sending message failed: % s"</span>, error.localizedDescription)</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>iOS app 上处理 CoreData 和 Plant 类型的是一个 NSManagedObject 子类的对象。watchOS app extension 定义了它自己的 <code>Plant</code> 值类型，因为它并没有 CoreData 栈。为了将字典转换成值类型，我们可以使用 “Storing struct in UserDefault” 中描述的方法，只需要额外配置 <code>JSONDecoder</code> 使用的 <code>dateDecodingStrategy</code>  为 <code>secondsSince1970</code> 。理由是我们希望以自 1970 年之后的秒数来存储日期。转换字典到值类型的过程用到了 <code>JSONSerialization</code> ，它只支持 <code>NSString</code> ， <code>NSNumber</code> ， <code>NSArray</code> ， <code>NSDictionary</code> ， 或者 <code>NSNull</code> 。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Plant value type in WatchOS app extension</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span>: <span class="title">Identifiable</span>, <span class="title">Decodable</span>, <span class="title">DictionaryDecodable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastWateringDate: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> nextWateringDate: <span class="type">Date</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// Plant class in iOS app</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Plant</span>: <span class="title">NSManagedObject</span>, <span class="title">Identifiable</span> </span>{</span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> lastWateringDate: <span class="type">Date</span></span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> nextWateringDate: <span class="type">Date</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第三步是在 iOS app 端处理消息，并且提供数据给 watchOS app 。我们需要做的是实现 session 的委托，从 CoreData 栈中获取字典数据。 先看下完整实现，然后逐一拆解。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, didReceiveMessage message: [String: <span class="keyword">Any</span>], replyHandler: @escaping <span class="params">([String: <span class="keyword">Any</span>])</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"did receive message: % s"</span>, message [<span class="type">WatchCommunication</span>.requestKey] <span class="keyword">as</span>? <span class="type">String</span> ?? <span class="string">"unknown"</span>)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> contentString = message [<span class="type">WatchCommunication</span>.requestKey] <span class="keyword">as</span>? <span class="type">String</span> , <span class="keyword">let</span> content = <span class="type">WatchCommunication</span>.<span class="type">Content</span>(rawValue: contentString) <span class="keyword">else</span> {</span><br><span class="line">        replyHandler ([:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">switch</span> content {</span><br><span class="line">    <span class="keyword">case</span> .allPlants:</span><br><span class="line">        persistentContainer.performBackgroundTask { (managedObjectContext) <span class="keyword">in</span>            </span><br><span class="line">            <span class="keyword">let</span> all = <span class="type">Plant</span>.allPlantsDictionaryRepresentation () <span class="keyword">as</span>! [[<span class="type">String</span>: <span class="type">Any</span>]]</span><br><span class="line">            <span class="comment">// Replace Date with Double</span></span><br><span class="line">            <span class="keyword">let</span> converted = all.<span class="built_in">map</span> { (plantDictionary) -&gt; [<span class="type">String</span>: <span class="type">Any</span>] <span class="keyword">in</span></span><br><span class="line">                plantDictionary.mapValues { (value) -&gt; <span class="type">Any</span> <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> date = value <span class="keyword">as</span>? <span class="type">Date</span> {</span><br><span class="line">                        <span class="keyword">return</span> date.timeIntervalSince1970</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">return</span> value</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }                </span><br><span class="line">            <span class="keyword">let</span> response = [<span class="type">WatchCommunication</span>.responseKey: converted]</span><br><span class="line">            replyHandler (response)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第一步是查看接收到的字典，看看 watchOS app 请求的是哪些内容。然后我们访问持久化存储，获取表示 Plant 的字典，把其他的日期转换成 1970 年后秒数的形式 (以便 watchOS app 能够在字典上使用 <code>JSONSerialization</code>)，然后把数据发送回 watchOS app 。注意，从 CoreData 中获取字典形式的 Plant 很容易：我们首先是请求 <code>NSDictionary</code> 类型的数据，并且将结果类型属性设置为 <code>.dictionaryResultType</code> 。对于各庞大的模型，我们可能还会用到属性集合 (propertiesToFetch) 。不过目前，所有的属性都被添加到字典中了。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Plant</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> entityName = <span class="string">"Plant"</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">makeDictionaryRequest</span><span class="params">()</span></span> -&gt; <span class="type">NSFetchRequest</span>&lt;<span class="type">NSDictionary</span>&gt; {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSFetchRequest</span>&lt;<span class="type">NSDictionary</span>&gt;(entityName: entityName)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">allPlantsDictionaryRepresentation</span><span class="params">()</span></span> -&gt; [<span class="type">NSDictionary</span>] {</span><br><span class="line">        <span class="keyword">let</span> request = makeDictionaryRequest ()</span><br><span class="line">        request.resultType = .dictionaryResultType</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> request.execute ()</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> <span class="keyword">let</span> nsError <span class="keyword">as</span> <span class="type">NSError</span> {</span><br><span class="line">            os_log (.debug, log: .plants, <span class="string">"failed fetching all plants with error % s % s"</span>, nsError, nsError.userInfo)</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="用-SwiftUI-在-watchOS-app-中构建-UI"><a href="#用-SwiftUI-在-watchOS-app-中构建-UI" class="headerlink" title="用 SwiftUI 在 watchOS app 中构建 UI"></a>用 SwiftUI 在 watchOS app 中构建 UI</h2><p>Xcode 中 watchOS app 的模板是借助 storyboard 初始化 <code>HostingController</code>， 这个控制器负责提供初始的 SwiftUI 视图。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostingController</span>: <span class="title">WKHostingController</span>&lt;<span class="title">PlantListView</span>&gt; </span>{</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> connectivityProvider: <span class="type">PhoneConnectivityProvider</span> = {</span><br><span class="line">        <span class="keyword">let</span> provider = <span class="type">PhoneConnectivityProvider</span>()</span><br><span class="line">        provider.connect ()</span><br><span class="line">        <span class="keyword">return</span> provider</span><br><span class="line">    }()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> listViewModel = <span class="type">PlantListViewModel</span>(connectivityProvider: connectivityProvider)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> body: <span class="type">PlantListView</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">PlantListView</span>(viewModel: listViewModel)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>PlantListView</code> 是一个显示植物列表的简单视图，它用 <code>PhoneConnectivityProvider</code> 的 <code>refreshAllPlants (withCompletionHandler:)</code> 来处理刷新植物的逻辑。 SwiftUI 视图会在 view model 改变时自动更新。这是因为 view model 的 <code>plants</code> 属性使用了 <code>@Published</code> 属性包装器，而 view model 本身是 <code>ObservableObject</code> ，这是 SwiftUI 视图中为 view model 采用的属性包装器 (更多信息可以阅读 refreshing SwiftUI view in MVVM in SwiftUI) 。注意，这里的 view model 是 SwiftUI 视图显现时刷新内容的。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PlantListViewModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> connectivityProvider: <span class="type">PhoneConnectivityProvider</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(plants: [<span class="type">Plant</span>] = [], connectivityProvider: <span class="type">PhoneConnectivityProvider</span>) {</span><br><span class="line">        <span class="keyword">self</span>.plants = plants</span><br><span class="line">        <span class="keyword">self</span>.connectivityProvider = connectivityProvider</span><br><span class="line">        refresh ()</span><br><span class="line">    }</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> plants: [<span class="type">Plant</span>]</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">refresh</span><span class="params">()</span></span> {</span><br><span class="line">        connectivityProvider.refreshAllPlants { [<span class="keyword">weak</span> <span class="keyword">self</span>] (plants) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> plants = plants <span class="keyword">else</span> { <span class="keyword">return</span> }</span><br><span class="line">            <span class="keyword">self</span>?.plants = plants</span><br><span class="line">        }</span><br><span class="line">    }    </span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlantListView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">PlantListViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">List</span>(<span class="keyword">self</span>.viewModel.plants) { plant <span class="keyword">in</span></span><br><span class="line">                <span class="type">PlantCell</span>(viewModel: <span class="type">PlantCellViewModel</span>(plant: plant))</span><br><span class="line">            }</span><br><span class="line">        }.onAppear {</span><br><span class="line">            <span class="keyword">self</span>.viewModel.refresh ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>PlantListView</code> 用 <code>PlantCell</code> 来显示独立的视图。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlantCell</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> viewModel: <span class="type">PlantCellViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">4</span>) {</span><br><span class="line">            <span class="type">Text</span>(viewModel.title).font (.headline).multilineTextAlignment (.center)</span><br><span class="line">            <span class="type">Text</span>(viewModel.subtitle).font (.footnote).multilineTextAlignment (.center)</span><br><span class="line">        }.padding (<span class="number">8</span>)</span><br><span class="line">            .frame (minWidth: <span class="number">0</span>, maxWidth: .greatestFiniteMagnitude)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlantCellViewModel</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> plant: <span class="type">Plant</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> plant.name</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        formatter.dateFormat = <span class="type">DateFormatter</span>.dateFormat (fromTemplate: <span class="string">"dMMMM"</span>, options: <span class="number">0</span>, locale: .current)</span><br><span class="line">        <span class="keyword">return</span> formatter</span><br><span class="line">    }()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> subtitle: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> format = <span class="type">NSLocalizedString</span>(<span class="string">"PlantCellView_NextWatering"</span>, comment: <span class="string">"Next watering date."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: format, <span class="type">Self</span>.dateFormatter.string (from: plant.nextWateringDate))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>我们在 iOS 和 watchOS app 上都添加 <code>WCSessions</code> ，实现相关的委托方法以处理 session 和接收到的消息。然后，我们定义一个简单的通信模式，并在 watchOS app 端实现刷新植物的方法，在 iOS 端实现 CoreData 集成。当数据访问创建完成后，我们在 watchOS app 上用 SwiftUI 视图显示植物的列表。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: SwiftUI 应用 | 浇水提醒 app&lt;br&gt;top: false&lt;br&gt;date: 2020-03-01 17:08:42&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;watchOS&lt;/li&gt;
&lt;li&gt;development&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算方法 04 | 科学方法</title>
    <link href="https://theinfinitegame.tech/social-science/quantitative-methods-scientific-method/"/>
    <id>https://theinfinitegame.tech/social-science/quantitative-methods-scientific-method/</id>
    <published>2020-02-27T09:39:54.000Z</published>
    <updated>2020-03-02T07:29:29.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实证周期-Empirical-Cycle"><a href="#实证周期-Empirical-Cycle" class="headerlink" title="实证周期 (Empirical Cycle)"></a>实证周期 (Empirical Cycle)</h1><p>The empirical cycle captures the process of coming up with hypotheses about how stuff works and testing these hypotheses against empirical data in a systematic and rigorous way.</p><p>实证周期是指提出事物运作原理的假说，并使用经验数据来系统地、严格地检验这些假说的过程。</p><p>It characterizes the hypothetical deductive approach to science.</p><p>它描述了科学研究中的假说演绎法。</p><p>Being familiar with the five different phases of the cycle, will really help you keep the big picture in mind, especially when we get into specifics of things like experimental design and sampling。</p><p>熟悉这个过程中的五个阶段，可以很好地帮助你抓住重点，尤其是当我们涉及到具体的细节，比如实验设计和采样的时候。</p><p><img src="/images/sci-methods_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>So we’ll start with the observation phase, obviously. This is where the magic happens. It’s where an observation, again, obviously, sparks the idea for a new research hypothesis. We might observe an intriguing pattern, an unexpected event. Anything that we find interesting and that we want to explain.</p><p>让我们从观察阶段讲起，这个阶段很神奇。在这一步中，观察激发了灵感，并由此提出一项新的研究假说。我们可能观察到了有趣的规律，一个令人感到意外的事件，或者是任何一件我们感兴趣并试图解释的事情。</p><p>How we make the observation really doesn’t matter. It can be a personal observation, an experience that somebody else shares with us. Even an imaginary observation that takes place entirely in your head.</p><p>至于我们是如何进行观察的则不重要。它可以是个人的观察，或者是其他人和我们分享的他们的经历，甚至可以是完全发生在你脑袋里的想象。</p><p>Of course, observations generally come from previous research findings, which are systematically obtained. But in principle, anything goes. Okay, so, let’s take as an example a personal observation of mine.</p><p>当然，这些观察通常来自之前的研究发现，这些发现是系统地获得的。但是理论上来讲，万物皆可。让我们来举个例子，这个例子是我的个人观察。</p><p>I have a horrible mother-in-law. I’ve talked to some friends and they also complain about their mother-in-law. So this looks like an interesting pattern to me. A pattern between type of person and likability.</p><p>我有个糟糕的婆婆。我和我的朋友们聊了聊，他们也对另一半的妈妈也颇有微词。我认为这是一个有趣的规律，这是一个关于某类人是否讨人喜欢的规律。</p><p>Okay, so the observation phase is about observing a relation in one or more specific instances. In the induction phase this relation, observed in specific instances, is turned into a general rule. That’s what induction means, taking a statement that’s true in specific cases, and inferring that the statement is true in all cases, always. For example, from the observation that my friends and I have horrible mothers-in-law, I can induce the general rule that all mothers-in-law are horrible. Of course, this rule or hypothesis is not necessarily true. It could be wrong. That’s what the rest of the cycle is about, testing our hypothesis.</p><p>那么，观察阶段我们要做的就是观测一个或者多个例子中的一组关系。在归纳阶段，我们把在具体事例中观察到的这种关系，归纳为一条通用法则。通过一个在特例中成立的命题，推测此命题在所有情况下都成立，这就是归纳的含义。例如，通过观察得知我和朋友们都觉得我们另一半的妈妈很糟糕，我归纳得出 “所有的婆婆或岳母都令人讨厌” 这条通用法则。当然，这条法则，或者说假说，并不一定是成立的，它可能是错误的。这就是周期中其他那些阶段的目的，就是检验我们的假说。</p><p>In the induction phase, inductive reasoning is used to transform specific observations into a general rule or hypothesis. In the deduction phase, we deduce that the relations specified in the general rule should also hold in new, specific instances. From our hypothesis, we deduce an explicit expectation or prediction about new observations. For example, if all mothers-in-law are indeed horrible, then if I asked ten of my colleagues to rate their mother-in-law as either likeable, neutral or horrible, then they should all choose the category horrible.</p><p>在归纳阶段中，具体的观测被归纳推理，转换为一条通用法则或假说。在演绎阶段中我们推导出在新的具体个例中，这条通用法则也应该成立。通过我们的假说，我们推导出一个明确的预测，也就是关于新观测的预测。比如，如果所有人的婆婆或岳母都确实很讨厌，那我让十个同事按喜欢、一般、讨厌给婆婆 / 岳母分类，他们所有人应该都会选择讨厌这一栏。</p><p>Now in order to make such a prediction we need to determine the research setup. We need to decide on a definition of the relevant concepts, measurement instruments, procedures, the sample that we’ll collect new data from，et cetera.</p><p>为了能够做出这样的预测，我们需要确定研究的设定，我们需要确定相关概念的定义、测量仪器、步骤以及我们用来采集新数据的样本，等等。</p><p>So, in the deduction phase, the hypothesis is transformed by deductive reasoning. And specification of the research setup into a prediction about new empirical observations.</p><p>所以，在演绎阶段中，假说被演绎推理转变，并将研究具体化，设定出一个对新实证观察的预测。</p><p>In the testing phase, the hypothesis is actually tested, by collecting new data, and comparing them to the prediction.</p><p>在测试阶段，我们通过收集新的数据，并将它们与预测相对比，来实际检测假说。</p><p>Now this almost always requires statistical processing, using descriptive statistics to summarize the observations for us, and inferential statistics to help us decide if the prediction was correct.</p><p>现在，这通常需要用描述性统计学的统计手段，来为我们归纳观察结果，并用推论性统计学来帮助我们判断预测是否准确。</p><p>In our simple example we don’t need statistics. Let’s say that eight out of ten colleagues rate their mother-in-law as horrible. But, two rate her as neutral. Now we can see right away, our prediction didn’t come true, it was refuted. All ten mothers-in-law should have been rated as horrible. So in the testing phase new empirical data is collected, and with the aid of statistics, the prediction is confirmed or disconfirmed. In the evaluation phase we interpret the results in terms of our hypothesis. If a prediction was confirmed, this only provides provisional support for a hypothesis. It doesn’t mean that we’ve definitively proven the hypothesis, because it’s always possible that in the future, we will find somebody who just loves their mother-in-law. In our example, the prediction was actually refuted.</p><p>我们那个简单的例子里不需要用到统计学。假设十个同事中有八个人认为他们的婆婆 / 岳母很讨厌。但是，另外两个勾选了 “一般”，因此结果立竿见影 —— 我们的假设并不成立，它被驳倒了。按照我们的假设，十个人都应认为婆婆 / 岳母很讨厌。因此，在测试阶段，我们会收集新的实证数据，并通过统计学的帮助来确认我们的预测是否成立。在评估阶段，我们用假说来解释实验结果。如果与预测一致，那么它就暂时为假说提供了支持。这并不意味着我们已经最终证实假说了，因为总有可能在将来，会有人说他们就是很爱自己的婆婆 / 岳母。在我们的例子中，预测实际上被驳倒了。</p><p>This doesn’t mean we should reject our hypothesis outright. In many cases there are plausible explanations for our failure to confirm. If these explanations have to do with a research setup, the hypothesis is preserved and investigated again. But, with a better research design. In other cases, the hypothesis is adjusted based on the results. The hypothesis is rejected and discarded only in very rare cases. In the evaluation phase, the results are interpreted in terms of the hypothesis, which is provisionally supported, adjusted, or rejected.</p><p>这并不意味着我们要将我们的假说全部否认。在很多情况下，我们能够为没能成功证实预测找到可信的解释。如果这个解释与实验设定相关，那么这个假说就能保留下来重新论证，但是需要一个更好的实验设计。在其他情况下，人们会基于结果调整假说。只有在一些很罕见的情况下，假说才会被推翻并放弃。在评估阶段，我们会用假说来解释实验结果，假说会被暂时支持、调整或者推翻。</p><p>The observations collected in the testing phase can serve as new specific observations in the observation phase. This is why the process is described as a cycle. New empirical data obtained in the testing phase give rise to new insights that lead to a new run through. And that’s what empirical science comes down to. We try to hone in on the best hypotheses and build our understanding of the world as we go through the cycle, again and again.</p><p>在测试阶段收集到的观测数据，会被当作下一轮观测阶段的新具体观测数据。这就是为什么这个过程被称为周期。测试阶段中，新的实证数据给人们以新的灵感，启发他们进行新一轮的研究，这就是实证科学的本质所在。我们试图打造出最好的假说，并在周期循环往复中建立起我们对这个世界的认识。</p><p><img src="/images/sci-methods_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><hr><h1 id="确认-否认-Confirm-Disconfirm"><a href="#确认-否认-Confirm-Disconfirm" class="headerlink" title="确认 / 否认 (Confirm/Disconfirm)"></a>确认 / 否认 (Confirm/Disconfirm)</h1><p>We’re going to take a look at how we should interpret results that confirm or disconfirm our predictions, and whether we should confirm or reject our hypothesis accordingly.</p><p>我们将学习应当如何解释确认或否认了预测的研究结果，以及是否应当相应地确认或驳回我们的假说。</p><p>Let’s consider the hypothesis that all mothers-in-law are horrible. I formulated this hypothesis based on personal observations.</p><p>让我们假设所有婆婆 / 岳母都是令人厌恶的，我基于个人观察建立了这一假说。</p><p>To test the hypothesis, I came up with a research setup. I selected to measure horribleness using a rating scale with the options likeable, neutral and horrible. I also decided to collect data from ten colleagues in my department.</p><p>为了检验这一假说，我构思了一套研究方案。我选择一组等级选项来测量讨厌程度，包括喜欢、中立和讨厌，同时我决定在系里的十位同事中收集数据。</p><p>With research set up in place, I formulated the following prediction. If the hypothesis all mothers-in-law are horrible is true, then all ten colleagues should choose the category horrible to describe their mother in law.</p><p>建立好研究方案后，我设定了以下预测：如果所有婆婆 / 岳母都是令人厌恶的假说是正确的，那么十位同事都应选择讨厌这一项去形容他们对婆婆 / 岳母的感受。</p><p><img src="/images/sci-confirm_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>Okay, let’s look at confirmation first. Suppose all ten colleagues rated their mother-in-law as horrible, the prediction is confirmed, but this doesn’t mean the hypothesis’ been proven. It’s easily conceivable that we will be proven wrong in the future. If we were to repeat the study, we might find a person that simply adores their mother-in-law.</p><p>让我们先来看确认。假定十位同事都将他们的婆婆 / 岳母评为讨厌，那么预测就被确认了。但这并不意味着假说被证实了。很容易想象，如果我们重复这一研究，我们可能发现有人喜爱他们的婆婆 / 岳母，我们的假说会被证明是错误的。</p><p>The point is that confirmation is never conclusive. The only thing we can say is that our hypothesis is provisionally supported. The more support from different studies, the more credence we afford a hypothesis. But we can never prove it.</p><p>关键要点是确认永远不是决定性的。我们唯一能说的是我们的假说暂时被支持了，有越多不同的研究支持假说，这一假说就越可信，但我们永远不能证实它。</p><p>Let me repeat that. No scientific empirical statement can ever be proven once and for all. The best we can do is produce overwhelming support for a hypothesis. Okay, now let’s turn to disconfirmation. Suppose only eight out of ten colleagues rate their mother-in-law as horrible, and two actually rate her as neutral.</p><p>我再次强调， <strong>没有任何科学实证命题能够被一劳永逸地证实</strong> ，我们能做到的最大程度是为假说提供压倒性的支持。那么现在我们来看否认。假定十位同事中只有八位将他们的婆婆 / 岳母评为讨厌，两位选择了一般。</p><p>Obviously, in this case our prediction turned out to be false. Logically speaking, empirical findings that contradict the hypothesis should lead to its rejection. If our hypothesis states that all swans are white, and we then find black swans in Australia, we can very conclusively reject out hypothesis.</p><p>显然，这时我们的预测就是错误的。从逻辑上说，实证发现若与假说相悖，则应驳回假说。如果我们的假说是所有天鹅都是白的，随后在澳大利亚发现了黑天鹅，我们就可以确凿地驳回这一假说。</p><p><img src="/images/sci-confirm_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>And practice, however, especially in the social sciences, there are often plausible alternative explanations for our failure to confirm. These are in fact so easy to find, that we rarely reject the hypothesis outright. In many cases, these explanations have to do with methodological issues. The research design or the measurement instrument wasn’t appropriate. Maybe relevant background variables weren’t controlled for. Et cetera, et cetera.</p><p>然而在实践中，尤其在社会科学领域，关于我们未能对假说进行确认这一点，总有似乎可信的替代解释。事实上我们很容易发现，我们很少能完全驳回某一假说。多数情况下，这些解释与方法论的问题有关，研究设计或是测量工具不合适 又或是没有为相关背景变量设置对照，等等。</p><p>Coming back to our mother-in-law example, I could have made a procedural error while collecting responses from the two colleagues who rated their mother-in-law as neutral. Maybe I forgot to tell them that their responses were confidential, making them uncomfortable to choose the most negative category.</p><p>回到婆婆 / 岳母的例子，我可能在收集那两位选择一般的同事的回答时，犯了程序上的错误。或许我忘记告诉他们这些回答是保密的，从而使得他们不能自在地选择最消极的选项。</p><p>Is there a plausible methodological explanation for the failure to confirm? We preserve the hypothesis and instead choose to reject the auxiliary, implicit assumptions concerning the research design and the measurement.</p><p>对于假说的失验，是否有方法学上的替代解释呢？我们没有抛弃、而是保留了假说，却抛弃了那些关于研究方案设计和计量方法的辅助、隐含的假设。</p><p>We investigated the original hypothesis again, only with a better research setup.</p><p>我们再次研究原始假说，但用一套更好的研究方案。</p><p>Sometimes result do give rise to a modification of the hypothesis. Suppose that the eight colleagues who did have horrible mothers-in-law were all women, and the other two were men. Perhaps all mothers-in-law are indeed horrible but only to their daughters in law.</p><p>有时研究结果确实会导致对假说的修改。假定确实有令人厌恶的婆婆的八位同事都是女性，而另外两位是男性。或许只有对媳妇来说，婆婆才都是真正令人厌恶的。</p><p>If we alter the hypothesis slightly by adding additional clauses, it only applies to daughters-in-law. And strictly speaking, we’re rejecting the original hypothesis, sort of.</p><p>如果我们对假说稍作修改，增加只适用于媳妇这一条件。严格来说，我们从某种程度上驳回了原始假说。</p><p>Of course the new hypothesis is essentially the same as the original one, just not as general and therefore not as strong. An outright rejection, or radical adjustment of a hypothesis is actually very rare in social sciences. Progress is made in very small increments, not giant leaps.</p><p>当然，新的假说在本质上与原始假说是相同的，只是不那么笼统，故而也不那么强硬。对假说完全的驳回或根本上的调整，在社会科学领域其实是很少见的。进步并非一蹴而就，而是积跬步，成千里。</p><hr><h1 id="标准-Criteria"><a href="#标准-Criteria" class="headerlink" title="标准 (Criteria)"></a>标准 (Criteria)</h1><p>We follow the empirical cycle to come up with hypothesis and to test and evaluate them against observations. But once the results are in, a confirmation doesn’t mean hypothesis was been proven and a disconfirmation doesn’t automatically mean we reject it.</p><p>我们根据实证周期做出假说，并通过观察来检验和评估它。但即便观察结果符合假说，也并非确证其为真；同理，如果观察结果与假说不符，也不代表我们就要驳回它。</p><p>So how do we decide whether we find the study convincing?</p><p>我们应该如何判断该研究是否可信呢？</p><p>Well there are two main criteria for evaluation: reliability and validity. Reliability is very closely related to replicability. A study is replicable if independent researchers are in principle able to repeat it. A research finding is reliable if we actually repeat the study and then find consistent results.</p><p>有两个主要标准：可靠性 (reliability) 和效度 (validity) 。可靠性与可重复性紧密相联，如果独立研究员大体上可以重复该研究，那么它就是可重复的。当研究可重复，且得到的结果也一致的时候，我们就认为它是可信的。</p><p>Validity is more complicated. A study is valid if the conclusion about the hypothesized relation between properties accurately reflects reality. In short, a study is valid if the conclusion based on the results, is true.</p><p>效度则更为复杂，如果关于特性间假设关系的结论能准确反映现实，这个研究就是有效的。简而言之，如果根据结果得出的结论是真实的，那么这个研究就是有效的。</p><p>Suppose I hypothesize that loneliness causes feelings of depression. I deduce that if I decrease loneliness in elderly people, by giving them a cat to take care of. Their feelings of depression should also decrease. Now suppose I perform this study in a retirement home and find that depression actually decreases after residents take care of a cat.</p><p>比如，我假定孤独会导致抑郁感，我推论出如果我能够通过让老人养猫来减轻他们的孤独感，那么他们的抑郁感也应该随之下降。现在，假设我在养老院进行这项研究，并且发现这里老人的抑郁感确实在养猫之后减轻了。</p><p>Is this study valid? Do the results support the conclusion that loneliness causes depression?</p><p>那么，这一研究是否有效呢？通过这一研究结果，是否支持 “孤独感造成抑郁” 这个结论呢？</p><p>Well, because this is still a pretty general questions, we’ll consider three more specific types of validity. Construct, internal and external validity.</p><p>当然，这个例子也比较宽泛。下面我们要具体讲三种效度，它们就是建构效度、内部效度和外部效度。</p><p>Construct validity is an important prerequisite for internal and external validity. A study has high construct validity if the properties or constructs that appear in the hypothesis are measured and manipulated. Accurately, in other words our methods have high construct validity if they actually measure and manipulate the properties that we intended them to.</p><p>建构效度是内部和外部效度的重要先决条件。如果假说中的特性和建构被准确地测量和控制，我们就说这项研究具有较高的建构效度。换言之，如果它能实际测量和操控我们想要研究的特性，我们的研究方法就具有较高的建构效度。</p><p>Suppose I accidentally measured an entirely different construct with for example my depression questionnaire. What if it measures feelings of social exclusion instead of depression?</p><p>假设我不小心测量了完全不同的建构，比如我关于抑郁的问卷，实际上测量的却是社会排斥感又会怎么样呢？</p><p>Or suppose that taking care of the cat didn’t affect loneliness at all, but instead increased feelings of responsibility and self worth.</p><p>或者，假如照顾猫实际上并不影响孤独感，但能增强责任感和自我价值感。</p><p>What if loneliness remained the same?</p><p>如果孤独感并没有改变会怎样呢？</p><p>Will then the results only seem to support the hypothesis that loneliness caused depression. When in reality, we’ve manipulated a different cause and measured a different effect.</p><p>实验结果只是看上去支持孤独感造成抑郁这一假说，实际上我们操控的是另外的成因，并测量了一种不同的影响。</p><p>Developing accurate measurement and manipulation methods is one of the biggest challenges in the social and behavioral sciences.</p><p>找到准确的测量和控制方法，是进行社会和行为学研究的最大挑战之一。</p><p>I’ll discuss this in more detail when we look at operationalization.</p><p>我们在操作主义一章中将详细探讨这一问题。</p><p>But for now, I’ll move on to internal validity. Internal validity is relevant when our hypothesis describes a causal relationship.</p><p>但接下来我要讲内部效度。当我们的假说描述因果关系的时候，内部效度尤为重要。</p><p>A study is internally valid if the observed effect, is actually due to the hypothesized cause.</p><p>如果观测到的结果确实是由假设中的原因引起的，那么这项研究是内部有效的。</p><p>Let’s assume our measurement and manipulation methods are valid for a second. Can we conclude depression went down, because the elderly felt less lonely. Well, maybe something else caused the decrease in depression. For example, if the study started in the winter and ended din the spring, then maybe the change in season lowered depression.</p><p>请先暂且认为，我们的测量和控制方法都是有效的。我们能得出 “老人孤独感减轻因此抑郁感下降” 这一结论吗？其他因素也可能会导致抑郁感下降。比如，如果这项研究是在冬天进行，春天结束的。那么，季节的变化也可能会导致抑郁感的下降。</p><p>Or maybe it wasn’t the cat’s company, but the increased physical exercise from cleaning the litter box and feeding bowl.</p><p>或者，也许并不是因为猫的陪伴，而是因为换猫砂和清洁猫食盆，让他们做了更多的运动。</p><p>Alternative explanations like these threaten internal validity. If there’s a plausible alternative explanation internal validity is low.</p><p>类似的替代解释影响着内部效度。若有似乎合理的替代解释，那么实验的内部效度就很低。</p><p>Now there are many different threats to internal validity that I will discuss in much more detail in later videos.</p><p>还有很多其他因素影响着内部效度，我们在后面的课程中会进行更具体的讲解。</p><p>Okay, let’s look at external validity. A study is externally valid if the hypothesized relationship supported by our findings also holds in other settings and other groups, in other words, if the results generalize to different people, groups, environments and times.</p><p>好的，现在我们来谈谈外部效度。如果我们研究证实的关系也能被应用于其他情景。换句话说，如果该结果可以适用于不同个人、群体、环境和时间，那么我们就说此研究外部有效。</p><p>Let’s return to our example. Will taking care of a cat decrease depression in teenagers and middle-aged people, too? Will the effect be the same for men and women? What about people from different cultures? Will a dog be as effective as a cat?</p><p>让我们回到上一个例子。养猫是否也能帮助青少年和中年人减轻抑郁？它对男性和女性的影响是否相同？对不同文化背景的人是否会有不同影响？养狗和养猫是否有一样的效果？</p><p>Of course this is all hard to say based on the results of only elderly people and cats. If we’d included younger people from different cultural background and used other animals we might have been more confident of the studies external validity.</p><p>当然，仅仅基于对老人和猫这组样本的研究，我们很难回答上述问题。如果这个研究并不局限于老年人，且包括不同文化背景，也涵盖其他动物，那我们就能对这个实验的外部效度更有信心。</p><p>I’ll come back to external validity and how it can be threatened when we come to the subject of sampling.</p><p>我们讲到抽样的时候，会再次提及外部效度，以及它会受到哪些因素影响。</p><p>So to summarize, construct validity relates to whether our methods actually reflect the properties we intended to manipulate and measure. Internal validity relates to whether our hypothesized cause is the actual cause for the observed effect.</p><p>小结，建构效度与我们的实验方法是否真实反映了我们想要控制和测量的性质有关，内部效度是关于我们假设的原因是否真的可以得出观察现象这个结果。</p><p>Internal validity is threatened by alternative explanations.</p><p>内部效度受替代解释的影响。</p><p>External validity, or generalizability, relates to whether the hypothesized relation holds in other settings.</p><p>外部效度或普适性，则是关于假设的关系是否在其他情景下适用。</p><hr><h1 id="因果关系-Causality"><a href="#因果关系-Causality" class="headerlink" title="因果关系 (Causality)"></a>因果关系 (Causality)</h1><p>The most interesting hypotheses are the ones that describe a causal relationship. If we know what causes an effect, we can predict it, influence it, better understand it. So, how do we identify a causal relationship? Well, it was David Hume. With a little help from John Stuart MIll, who first listed the criteria that we still use today. These are the four essential criteria. Number one, the cause and effect are connected. The first criterion means there has to be a way to trace the effect back to the cause. If a patient was not exposed to a virus, then we can’t argue that the virus caused the patient’s death.</p><p>最有趣一类的假说是描述因果关系的。如果我们知道产生结果的原因，我们就可以预知它、影响它、更好地理解它。我们该如何确定因果关系呢？大卫・休谟在约翰・斯图尔特・穆勒的帮助下，首次列出了判断准则。我们至今仍在使用。一共有四条基本准则。</p><p><img src="/images/sci-method-causality_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>第一条，原因和结果是相联系的。第一条准则意味着必须可以由果溯因。如果病人没有接触过某种病毒，我们就不能认为是这种病毒导致了病人的死亡。</p><p>Number two, the cause precedes the effect, I hope this is obvious. Number three, the cause and effect occur together consistently. This means cause and effect should go together, or covary.</p><p>第二条，因先行于果。我想这是显而易见的。第三条，因果总是如影随形。这意味着因和果会一起改变，或称为共变。</p><p>When the cause is present, we should see the effect, and if the cause is not present, then the effect should be absent. If the cause influences the effect to a certain degree, then we should see a consistently stronger or weaker effect, accordingly.</p><p>当原因存在时我们应该能得到结果，当原因不存在时结果也应该不存在。如果原因对结果的影响程度较强或较弱，那相应的，得到的结果也应该较强或较弱。</p><p>Criteria number four, alternative explanations can be ruled out.</p><p>第四条准则，替代解释可被排除。</p><p>Okay, so let me illustrate these criteria with an example. Suppose I hypothesize that loneliness causes feelings of depression. I give some lonely depressed people a cat to take care of. Now, they’re no longer lonely. If my hypothesis is correct, then we would expect this to lower their depression. The cause and effect, loneliness and depression, are in close proximity. They happen in the same persons, and fairly close together in time. So we can show they are connected. </p><p>让我来举例说明这些准则。假设孤独会导致抑郁，我让孤独抑郁的人去养只猫。现在他们不再孤独。如果我的假说是对的，就可以预测这将缓解他们的抑郁。因和果，即孤独和抑郁彼此紧密连接。他们发生在同一个人身上，又几乎同时发生，我们可以证明它们是有联系的。</p><p>The cause, a decrease in loneliness, needs to happen before the effect, a decrease in depression. We can show this because we can control the presence of the cause, loneliness. </p><p>因先行于果，所以孤独感的降低应发生在抑郁症缓解之前。我们能这么说是因为我们可以控制因，即孤独的存在。</p><p>The cause and effect should occur together consistently. This means that less loneliness should go together with lower depression. I could find a comparison group of lonely, depressed people that do not get a cat. Since the cause is absent, their loneliness doesn’t change. There should be no effect. </p><p>因和果应总是伴随出现。这意味着更少的孤独感应该伴随出现更轻的抑郁症。我可以找不养猫的孤独抑郁人群作对照组。由于因不存在了，即他们的孤独感没有变化，也就不应该存在结果。</p><p>Now, this is all easy. The real difficulty lies in the last criterion. Excluding any alternative explanations. Other possible causes. Let’s look for an alternative explanation in our example. Maybe the increased physical activity required to take care of a cat, actually caused lower depression, instead of the reduction in loneliness.</p><p>这些还算简单。真正难的是最后一条准则。排除替代解释：即其他可能的因。我们来在这个例子中找一个替代解释。也许其实是养猫所需的体力活动的增加，引起了抑郁症的减轻，而不是因为孤独感的降低。</p><p>Alternative explanations form threats to the internal validity of a research study. An important part of methodology is developing and choosing research designs that minimize these threats.</p><p>替代解释会影响一项研究的内部效度。方法论的一个重要部分就是：不断改善并选择可以最少化这些影响因素的研究设计。</p><p><img src="/images/sci-method-causality_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>Okay there’s one more point I want to make about causation. Causation requires correlation. The cause and effect have to occur consistently. But correlation doesn’t imply causation. I’ll give you an example. If we consistently observe aggressive behavior after children play a violent video game. This doesn’t mean the game caused the aggressive behavior. It could be that aggressive children seek out more aggressive stimuli. Reversing the causal direction.</p><p>关于因果关系还有一点我想补充。因果关系需要相关性。因和果必须一致地出现，但是相关性并不意味着因果性。我来给你举个例子。如果我们总是观察到孩子在玩包含暴力的电子游戏后表现出攻击性行为，这并不意味着游戏诱发了攻击性行为。这可能是攻击性强的孩子在寻找更多的攻击性刺激，这就颠倒了原因和结果。</p><p>Or, maybe children whose parents allow them to play violent games aren’t supervised as closely. Maybe they’re just as aggressive as other children. They just feel less inhibited to show this aggressive behavior. So remember, correlation does not imply causation.</p><p>或许那些家长允许玩暴力游戏的孩子，并没有受到严格的家庭教育。或许他们和别的孩子一样好斗，他们只是在表现出攻击性行为时很少意识到这是被禁止的。所以记住，相关性并不意味着因果性。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实证周期-Empirical-Cycle&quot;&gt;&lt;a href=&quot;#实证周期-Empirical-Cycle&quot; class=&quot;headerlink&quot; title=&quot;实证周期 (Empirical Cycle)&quot;&gt;&lt;/a&gt;实证周期 (Empirical Cycle)&lt;/
      
    
    </summary>
    
    
      <category term="social-science" scheme="https://theinfinitegame.tech/categories/social-science/"/>
    
    
      <category term="计量方法" scheme="https://theinfinitegame.tech/tags/%E8%AE%A1%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    
      <category term="社会科学" scheme="https://theinfinitegame.tech/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>大纲 | SwiftUI 教程</title>
    <link href="https://theinfinitegame.tech/uncategorized/outline-swiftui-tutorials/"/>
    <id>https://theinfinitegame.tech/uncategorized/outline-swiftui-tutorials/</id>
    <published>2020-02-27T02:25:01.000Z</published>
    <updated>2020-03-01T08:01:41.893Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views" target="_blank" rel="noopener">源</a></p><h1 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章 基础"></a>第一章 基础</h1><h2 id="创建和绑定视图"><a href="#创建和绑定视图" class="headerlink" title="创建和绑定视图"></a>创建和绑定视图</h2><h3 id="1-创建项目和探索-Canvas"><a href="#1-创建项目和探索-Canvas" class="headerlink" title="1 创建项目和探索 Canvas"></a>1 <strong>创建项目和探索 Canvas</strong></h3><p>要点：</p><ol><li>创建项目时 User Interface 选择 “SwiftUI”</li><li>基础扩展：演示 Xcode 界面布局，菜单</li><li>SwiftUI 文件的两部分：描述视图内容和布局的主结构体，预览</li><li>显示隐藏 Canvas 面板快捷键</li><li>演示实时预览 （改变 body 里的代码） SwiftUI 开发体验的核心卖点之一<br>进阶资源：声明式 UI 、Flutter 和 SwiftUI 的比较，拖尾闭包语法</li></ol><h3 id="2-自定义文本视图"><a href="#2-自定义文本视图" class="headerlink" title="2 自定义文本视图"></a>2 自定义文本视图</h3><p>要点：</p><ol><li>演示从预览中的检视 UI 元素，顺便提一下 modifier ，演示 Font modifier</li><li>代码和视图的关系：source of truth (真理之源)</li><li>演示预览、检视器和代码的自动同步</li></ol><h3 id="3-通过堆叠组合视图"><a href="#3-通过堆叠组合视图" class="headerlink" title="3 通过堆叠组合视图"></a>3 通过堆叠组合视图</h3><p>要点</p><ol><li>body 属性只返回一个视图<br>进阶资源：关于 body 属性的文章</li><li>介绍三类 stacks ，HStack, VStack，ZStack</li><li>介绍 Xcode 的结构化编辑：嵌套、检视、提取等。通用的 ” 右键菜单 “ ，SwiftUI 专有的 Cmd + 点击<br>进阶资源：Flutter</li><li>演示 embed in vstack</li><li>演示添加控件： + 按钮，快捷键</li><li>演示两层 Stack 嵌套，演示 Spacer 的使用。<br>进阶资源：Spacer 的特性</li><li>演示 padding<br>进阶资源：padding 的各种版本</li></ol><h3 id="4-创建自定义图像视图"><a href="#4-创建自定义图像视图" class="headerlink" title="4 创建自定义图像视图"></a>4 创建自定义图像视图</h3><p>要点</p><ol><li>简介 image view ，常见图片相关概念：mask，边缘 (border)，投影 (drop shadow)</li><li>基础扩展： 添加资源到 asset catalog</li><li>演示创建新的 SwiftUI 文件，CircleImage</li><li>演示 Image () 构造器，演示 clipShaper modifier, Circle mask<br>进阶：mask 遮蔽</li><li>演示 overlay， shadow</li></ol><h3 id="5-让-UIKit-和-SwiftUI-一起工作"><a href="#5-让-UIKit-和-SwiftUI-一起工作" class="headerlink" title="5 让 UIKit 和 SwiftUI 一起工作"></a>5 让 UIKit 和 SwiftUI 一起工作</h3><ol><li>如何在 SwiftUI 中使用 UIKit 里的视图？关键词：wrap, UIViewRepresentable 协议<br>进阶资源：wrap，协议</li><li>[学习曲线] 跳过，后续再来说明。<br>MapKit 相关知识点</li></ol><h3 id="6-构成视图-Compose-Views-——-需要练习"><a href="#6-构成视图-Compose-Views-——-需要练习" class="headerlink" title="6 构成视图 (Compose Views) —— (需要练习)"></a>6 构成视图 (Compose Views) —— (需要练习)</h3><p>要点：</p><ol><li>选择容器 —— stacks，文字、图像、Spacer、自定义视图</li><li>调整视图 —— modifier，属性</li><li>打开源链接，演示样例 app 界面变化过程。</li></ol><p>检查理解的测验。</p><hr><h2 id="构建-List-和导航"><a href="#构建-List-和导航" class="headerlink" title="构建 List 和导航"></a>构建 List 和导航</h2><h3 id="1-了解样本数据"><a href="#1-了解样本数据" class="headerlink" title="1 了解样本数据"></a>1 了解样本数据</h3><p>要点：</p><ol><li>理解 Model ，粗浅理解为数据，相对于视图<br>进阶资源：MVC 设计模式，结构体和类的区别，数据格式，json</li><li>带一些新的关键字，协议</li><li>进阶扩展：为什么要用扩展 Landmark 的 image 属性</li><li>json 数据格式</li></ol><h3 id="2-创建-“行”-视图"><a href="#2-创建-“行”-视图" class="headerlink" title="2 创建 “行” 视图"></a>2 创建 “行” 视图</h3><p>要点</p><ol><li>创建新 SwiftUI 文件，起名 LandmarkRow.swift</li><li>进阶扩展：存储属性和计算属性</li><li>介绍 Image resizable modifier</li></ol><h3 id="3-自定义预览"><a href="#3-自定义预览" class="headerlink" title="3 自定义预览"></a>3 自定义预览</h3><p>要点</p><ol><li>previewLayout<br>进阶资源：previewDevice</li></ol><h3 id="4-创建列表"><a href="#4-创建列表" class="headerlink" title="4 创建列表"></a>4 创建列表</h3><p>要点</p><ol><li>List 的元素可以是动态的、静态的或者混合的<br>进阶资源：SwiftUI 的 List</li><li>使用 List<br>进阶资源：</li></ol><h3 id="5-创建动态列表"><a href="#5-创建动态列表" class="headerlink" title="5 创建动态列表"></a>5 创建动态列表</h3><p>要点</p><ol><li>List 接收 <code>identifiable</code> 的数据<br>进阶资源：Swift keypath 语法，SwiftUI 的 List、ForEach<br>进阶资源：闭包、拖尾闭包语法</li><li>Identifiable 协议：id 属性的约定</li></ol><h3 id="6-在-List-之间建立导航"><a href="#6-在-List-之间建立导航" class="headerlink" title="6 在 List 之间建立导航"></a>6 在 List 之间建立导航</h3><p>要点</p><ol><li>NavigationView<br>进阶资源：SwiftUI 给视图 “赋能” 的方式</li><li>标题、导航按钮<br>进阶资源：标准化 UI</li><li>NavigationLink</li></ol><h3 id="7-数据传递"><a href="#7-数据传递" class="headerlink" title="7 数据传递"></a>7 <strong>数据传递</strong></h3><p>要点</p><ol><li>演示改动</li></ol><h3 id="8-生成动态预览"><a href="#8-生成动态预览" class="headerlink" title="8 生成动态预览"></a>8 生成动态预览</h3><p>要点</p><ol><li>演示实现方式<br>进阶：对移动开发的意义</li></ol><hr><h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h2><h3 id="1-标记最爱的地标"><a href="#1-标记最爱的地标" class="headerlink" title="1. 标记最爱的地标"></a>1. 标记最爱的地标</h3><p>要点</p><ol><li>添加一个图标：系统图标、缩放、着色<br>进阶：SF Symbols，着色</li></ol><h3 id="2-过滤列表视图"><a href="#2-过滤列表视图" class="headerlink" title="2 过滤列表视图"></a>2 过滤列表视图</h3><p>要点</p><ol><li>@State 属性</li></ol><h3 id="3-添加控件以触发-State"><a href="#3-添加控件以触发-State" class="headerlink" title="3 添加控件以触发 State"></a>3 添加控件以触发 State</h3><p>要点</p><ol><li>绑定：$ 语法</li></ol><h3 id="4-用-Observable-Object-存储"><a href="#4-用-Observable-Object-存储" class="headerlink" title="4 用 Observable Object 存储"></a>4 用 Observable Object 存储</h3><p>要点</p><ol><li>ObservableObject 协议</li><li>@Published 属性</li></ol><h3 id="5-在视图中接收模型对象"><a href="#5-在视图中接收模型对象" class="headerlink" title="5 在视图中接收模型对象"></a>5 在视图中接收模型对象</h3><p>要点：</p><ol><li>环境变量: EnvironmentOjbect 属性声明，environmentObject 传入</li><li>where 语句</li></ol><h3 id="6-为每个地标创建按钮"><a href="#6-为每个地标创建按钮" class="headerlink" title="6 为每个地标创建按钮"></a>6 为每个地标创建按钮</h3><p>要点：演示</p><hr><h1 id="第二章-绘制和动画"><a href="#第二章-绘制和动画" class="headerlink" title="第二章 绘制和动画"></a>第二章 绘制和动画</h1><hr><h1 id="第三章-App-设计和布局"><a href="#第三章-App-设计和布局" class="headerlink" title="第三章 App 设计和布局"></a>第三章 App 设计和布局</h1><h1 id="构成复杂界面"><a href="#构成复杂界面" class="headerlink" title="构成复杂界面"></a>构成复杂界面</h1><h2 id="1-Home-视图"><a href="#1-Home-视图" class="headerlink" title="1 Home 视图"></a>1 Home 视图</h2><p>要点</p><p>Home 界面<br>   进阶：心智模式：干扰和专注，简单和复杂 （通知）</p><h2 id="2-分类列表"><a href="#2-分类列表" class="headerlink" title="2 分类列表"></a>2 分类列表</h2><p>要点</p><ol><li>分类 =&gt; 建立层级 （“抽屉”、容器）=&gt; 寻找</li><li>用字典将地标分组</li><li>重温 List、ForEach、keypath 的用法</li></ol><h2 id="3-增加地标分类的内容"><a href="#3-增加地标分类的内容" class="headerlink" title="3 增加地标分类的内容"></a>3 增加地标分类的内容</h2><p>要点</p><ol><li>重温 Stack</li><li>ScrollView (.horizontal), ForEach</li></ol><h2 id="4-构成-Home-视图"><a href="#4-构成-Home-视图" class="headerlink" title="4 构成 Home 视图"></a>4 构成 Home 视图</h2><p>要点</p><ol><li>改造 CategoryRow</li><li>listRowInsets、EdgeInsets</li></ol><h2 id="5-添加导航"><a href="#5-添加导航" class="headerlink" title="5 添加导航"></a>5 添加导航</h2><p>要点</p><ol><li>重温 NavigationLink</li><li>Image .renderingMode , Text .foregroundColor</li><li>重温 @State， 重点: sheet<br>进阶：alert, 内建的环境变量 .presentationMode</li><li>导航栏按钮 navigationBarItems</li></ol><hr><h2 id="和-UI-控件合作"><a href="#和-UI-控件合作" class="headerlink" title="和 UI 控件合作"></a>和 UI 控件合作</h2><h3 id="1-显示用户资料"><a href="#1-显示用户资料" class="headerlink" title="1 显示用户资料"></a>1 显示用户资料</h3><h3 id="2-编辑模式"><a href="#2-编辑模式" class="headerlink" title="2 编辑模式"></a>2 编辑模式</h3><p>要点</p><ol><li>editMode</li><li>条件视图，wrappedValue</li></ol><h3 id="3-定义资料编辑器"><a href="#3-定义资料编辑器" class="headerlink" title="3 定义资料编辑器"></a>3 定义资料编辑器</h3><p>要点</p><ol><li>Divider</li><li>Toggle</li><li>Picker</li><li>DatePicker</li></ol><h3 id="4-延后编辑的生效"><a href="#4-延后编辑的生效" class="headerlink" title="4 延后编辑的生效"></a>4 延后编辑的生效</h3><p>要点</p><ol><li>编辑草稿</li><li>可取消的编辑</li><li>onAppear, onDisappear</li></ol><hr><h1 id="第四章-Framework-集成"><a href="#第四章-Framework-集成" class="headerlink" title="第四章 Framework 集成"></a>第四章 Framework 集成</h1><h2 id="与-UIKit-对接"><a href="#与-UIKit-对接" class="headerlink" title="与 UIKit 对接"></a>与 UIKit 对接</h2><h3 id="1-创建视图来表示-UIPageViewController"><a href="#1-创建视图来表示-UIPageViewController" class="headerlink" title="1 创建视图来表示 UIPageViewController"></a>1 创建视图来表示 UIPageViewController</h3><p>要点</p><ol><li>UIViewControllerRepresentable, #makeUIViewController, #updateUIViewController<br>进阶资源：回调</li><li>用 SwiftUI 的 view 来构建 UIPageViewController 中的 controller</li><li>map</li></ol><h3 id="2-创建-ViewController-的数据源"><a href="#2-创建-ViewController-的数据源" class="headerlink" title="2 创建 ViewController 的数据源"></a>2 创建 ViewController 的数据源</h3><p>要点</p><ol><li>使用 Coordinator, UIPageViewControllerDataSource</li></ol><h3 id="3-用-SwiftUI-中的视图状态跟踪-Page"><a href="#3-用-SwiftUI-中的视图状态跟踪-Page" class="headerlink" title="3 用 SwiftUI 中的视图状态跟踪 Page"></a>3 用 SwiftUI 中的视图状态跟踪 Page</h3><p>要点</p><ol><li>@State, @Binding 的传递</li><li>UIPageViewControllerDelegate</li></ol><h3 id="4-添加一个自定义页面控制"><a href="#4-添加一个自定义页面控制" class="headerlink" title="4 添加一个自定义页面控制"></a>4 添加一个自定义页面控制</h3><p>要点</p><ol><li>UIViewRepresentable</li><li>UIPageControl, UIControl<br>进阶资源：“控件”</li><li><strong>target-action pattern</strong> , <strong>*delegate</strong>， <strong>#selector</strong></li><li><strong>@objc 关键字 </strong></li><li>可选进阶：起名字，一个名字在多个层次中使用<br>PageControl, UIPageControl</li><li>可选进阶：PageViewController 和 PageControl 之间如何联动</li></ol><hr><h2 id="创建-watchOS-App"><a href="#创建-watchOS-App" class="headerlink" title="创建 watchOS App"></a>创建 watchOS App</h2><h3 id="1-添加-watchOS-目标"><a href="#1-添加-watchOS-目标" class="headerlink" title="1 添加 watchOS 目标"></a>1 添加 watchOS 目标</h3><p>要点</p><ol><li>激活 watch app 的 scheme</li><li>Supports Running Without iOS App Installation<br>进阶内容：watchOS 6.0, watch app 和 iOS app 的关系</li></ol><h3 id="2-在目标间共享文件"><a href="#2-在目标间共享文件" class="headerlink" title="2 在目标间共享文件"></a>2 在目标间共享文件</h3><p>要点</p><ol><li>文件 inspector, Target membership 段</li><li>watchkit app 和 watchkit extension 的区别<br>进阶内容：watch app 的结构</li></ol><h3 id="3-创建细节视图"><a href="#3-创建细节视图" class="headerlink" title="3 创建细节视图"></a>3 创建细节视图</h3><p>要点</p><ol><li>适配不同尺寸的屏幕</li><li><strong>where 语句 </strong></li><li>scaleToFill, scaleToFit</li></ol><h3 id="4-添加-watchOS-的地图视图"><a href="#4-添加-watchOS-的地图视图" class="headerlink" title="4 添加 watchOS 的地图视图"></a>4 添加 watchOS 的地图视图</h3><p>要点</p><ol><li>WKInterfaceObjectRepresentable<br>进阶：为什么不能像复用 CircleImage 那样直接复用 iOS 里写好的地图视图？SwiftUI 的定位（learn once, apply everywhere）</li><li>添加到 detail 界面</li></ol><h3 id="5-创建跨平台的列表视图"><a href="#5-创建跨平台的列表视图" class="headerlink" title="5 创建跨平台的列表视图"></a>5 创建跨平台的列表视图</h3><p>要点</p><ol><li><strong> 泛型 </strong>，<strong> 类型推断 </strong></li><li>对应修改 iOS scheme 的 Home 视图，LandmarkList 的初始化，重温拖尾闭包。</li><li>LandmarkList 预览怎么解决？ #if, #else, #endif, typealias</li></ol><h3 id="6-在-watch-app-中）添加-Landmarks-List"><a href="#6-在-watch-app-中）添加-Landmarks-List" class="headerlink" title="6 (在 watch app 中）添加 Landmarks List"></a>6 (在 watch app 中）添加 Landmarks List</h3><p>要点</p><ol><li>切换 scheme</li><li>思考题：watch app 为什么没有 Home ?</li></ol><h3 id="7-创建自定义的通知接口"><a href="#7-创建自定义的通知接口" class="headerlink" title="7 创建自定义的通知接口"></a>7 创建自定义的通知接口</h3><p>要点</p><ol><li><strong> 如何正确地使用通知？</strong></li><li>构建通知视图：swift 的 init 模式</li><li>通知控制：WKUserNotificationHostingController, #didReceive, </li><li>UNNotification</li><li>通知配置：Notification Category, apns 文件模拟远程通知</li><li>切换到 Notification scheme</li></ol><hr><h2 id="创建-macOS-app"><a href="#创建-macOS-app" class="headerlink" title="创建 macOS app"></a>创建 macOS app</h2><h3 id="1-创建-macOS-目标"><a href="#1-创建-macOS-目标" class="headerlink" title="1 创建 macOS 目标"></a>1 创建 macOS 目标</h3><p>要点</p><ol><li>Deployment Target<br>进阶资源：<strong> 软件兼容（向前兼容）</strong>，<strong> 版本号 </strong></li></ol><h3 id="2-共享数据和-Assets"><a href="#2-共享数据和-Assets" class="headerlink" title="2 共享数据和 Assets"></a>2 共享数据和 Assets</h3><p>要点</p><ol><li>Membership</li></ol><h3 id="3-Row-视图"><a href="#3-Row-视图" class="headerlink" title="3 Row 视图"></a>3 Row 视图</h3><h3 id="4-组装视图"><a href="#4-组装视图" class="headerlink" title="4 组装视图"></a>4 组装视图</h3><p>要点</p><ol><li>List (selection: Binding<set<selectionvalue>)</set<selectionvalue></li></ol><h3 id="5-过滤器视图"><a href="#5-过滤器视图" class="headerlink" title="5 过滤器视图"></a>5 过滤器视图</h3><p>要点</p><ol><li>相同控件在不同平台上的外观</li><li>preview 中样例的 .constant 用法</li><li>数组相加</li><li>通用规范：复杂条件，注意使用括号</li></ol><h3 id="6-组合列表和过滤器视图"><a href="#6-组合列表和过滤器视图" class="headerlink" title="6 组合列表和过滤器视图"></a>6 组合列表和过滤器视图</h3><h3 id="7-复用-CircleImage"><a href="#7-复用-CircleImage" class="headerlink" title="7 复用 CircleImage"></a>7 复用 CircleImage</h3><p>要点</p><ol><li>属性默认值</li></ol><h3 id="8-macOS-上的地图视图"><a href="#8-macOS-上的地图视图" class="headerlink" title="8 macOS 上的地图视图"></a>8 macOS 上的地图视图</h3><p>要点</p><ol><li>善用 extension 分治代码</li></ol><h3 id="9-构建细节视图"><a href="#9-构建细节视图" class="headerlink" title="9 构建细节视图"></a>9 构建细节视图</h3><h3 id="10-Master-Detail-视图"><a href="#10-Master-Detail-视图" class="headerlink" title="10 Master Detail 视图"></a>10 Master Detail 视图</h3><p>要点</p><ol><li>mac (iPad) 上的应用布局，NavigationView</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/tutorials/swiftui/creating-and-combining-views&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一章
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算方法 03 | 科学哲学</title>
    <link href="https://theinfinitegame.tech/social-science/quantitative-method-philosophy-of-science/"/>
    <id>https://theinfinitegame.tech/social-science/quantitative-method-philosophy-of-science/</id>
    <published>2020-02-26T10:13:30.000Z</published>
    <updated>2020-02-26T12:42:35.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识论-Epistemology"><a href="#认识论-Epistemology" class="headerlink" title="认识论 (Epistemology)"></a>认识论 (Epistemology)</h1><p>在把假说 - 演绎法作为获取世界知识的最佳途径之前。第一个问题是：现实的本性？什么是现实？什么存在？因此，我们首先要问，获得的知识到底是关于什么的知识。解决这类问题的哲学领域叫做 <strong>本体论 (ontology)</strong> —— 对存在的研究。第二个问题涉及获取知识的方法。假设的确有一个现实：原则上是可知的，那么我们能获取哪些现实的知识？怎么获取？哲学领域中考虑这类问题的叫 <strong>认识论 (epistemology)</strong> —— 认识的研究或理论。</p><p>我们从后一个问题开始讲。假设有一个可知的现实，我们如何来获取知识。有很多不同的认识论观点，我们这里讨论两个最重要的观点。</p><p>第一个是 <strong>理性主义 (rationalism)</strong> 。理性主义者认为知识通过理性获得，用我们大脑的逻辑和理性思维能力，可以推断世界的真理，而无需借助经验。</p><p>哲学家柏拉图和笛卡尔结合了理性主义和其他观点，认为至少某些自然结构的抽象概念是天生的，是我们与生俱来的。就是说，我们的大脑能轻易理解这些概念，因为我们已经知道了，只要用推理回忆或辨识即可。</p><p><strong>经验主义 (Empiricism)</strong> 反对这一观点，经验主义者认为感官经验才是最主要方式。一些绝对经验主义者甚至认为，这是获取世界知识的唯一方式。</p><p>亚里士多德被认为是第一个经验主义者，他认为关于自然的基本真理来自感官经验。我们可以通过演绎推理获取更多知识，但观察是所有知识的基础。亚里士多德不相信天赋观念 (innate ideas) 。其实，他创造了 “白板” 这个词，指出每个人生下来就是一块白板。我们的知识并不是预先确定的，大脑可以接受任何概念。</p><p>当然，亚里士多德不是激进的经验主义者。他不反对理性思维加入进来，他也不反对用一些抽象的、不能直接观察的概念。</p><p>我觉得伽利略算是温和的经验主义者。他很注重观察法和实验法，但他也极度依赖逻辑推理。伽利略有句名言 “自然之书以数学语言写就”。他完全不排斥运用思想实验，也在他的假说中引入不可观测的性质。</p><img src="/images/sci-phil_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>后来的经验主义者如培根，尤其是休谟和逻辑实证主义者，都是绝对经验主义者，坚信只有感官经验才能获得世界的真知。他们认为建立在无法被直接观测的共相上的论断没有意义。</p><p>现代的经验主义就是范弗拉森的建构经验主义。它强调感官经验在归纳法和演绎法中都有作用，但它也允许理论术语存在，对应不能直接观测的实体。建构经验主义的目标是提出实证上恰当的解释，只要它表述的世界与观测到的一致，即可被接受。建构经验主义者会说因为存在不可观测的性质，真假无法判断。这承认了知识是暂时的，因为未来总存在发现新的反例的可能。</p><hr><h1 id="本体论-Ontology"><a href="#本体论-Ontology" class="headerlink" title="本体论 (Ontology)"></a>本体论 (Ontology)</h1><p>我们来说说本体论 (ontology) 即现实的本质是什么。</p><p>有很多对立的观点。在深入各种哲学观点之前，我先来解释这些观点里两个主要区别。第一点，现实是否独立存在于人类思想之外。当我们感知世间万物，它们真的脱离我们而真实存在吗？或者只是我们思想构建的心理表征，只能说存在于我们的思想。第二点是关于本体状态的殊相 (particular) 和共相 (universal)。殊相是指具体实例或能观察到属性的事件；共相或者说不可观察的性质，就是指那些无法直接观察到的普遍性质。</p><p>我们来举个例子，爱是我们无法直接观察到的普遍性质，但能通过行为表达或具现。因此当我家猫爬上我的膝盖打个小盹，这就是爱这个共相的具体实例。重力是另一个不可观察的共相，重力可用具体实例来表现。例如，当我打翻猫食盆，它就会掉在地上。</p><p>我们来看一下不同的本体论观点，看看他们对殊相和共相问题，以及对现实是外部存在还是仅存于思想内的看法。</p><p>唯心主义 (Idealism) 哲学观认为我们感知的现实完全存在于脑内。在我们精神世界感知到之前，外部物质世界的存在与我们无关。现实其实是精神世界的映射，重力和爱是存在的，但仅在我们的思想里，与之相关的具体实例也是如此。唯心主义者会说：猫睡在我膝上，以及碗掉在地上，这都是你想出来的。</p><p>对唯心主义而言，共相或不可观察的性质，它们是否真的在外部独立存在无关紧要。因为他们认为殊相和共相都是存在的，但都是精神世界的映射。</p><p>和唯心主义相对的是唯物主义 (Materialism) 。唯物主义认为思想世界外有独立存在的世界，唯物主义还认为一切由独立的物质世界构成。这就是说一切都是实物相互作用的结果，包括我们的意识、情绪和思想，这些是我们大脑和物质世界相互作用的副产品。</p><p>和唯心主义刚好相反，这是物质对精神。唯物主义只关注世界的物质组成，和唯心主义类似，它并不关心如何区分殊相和共相。</p><p>现实主义 (Realism) 又有所不同，就像唯物主义者，现实主义者坚持外部现实世界独立于人类思想存在，但现实主义者还坚持，像爱和重力这种共相是真实的，其存在形式取决于现实主义的类型。柏拉图式的现实主义认为像重力、爱这种共相，真的存在但我们观察不到，其位于一个独立的抽象位面。科学现实主义则更温和，它认为把共相用于现象观察能得到坚实可靠的主张。</p><p>在科学现实主义中，像爱和重力这种共相，和可观察的殊相位于同样的本体状态。之所以能假设不可测性的存在，是因为其对构造成功的科学主张有用且经常很必需。</p><p>最后是唯名论 (名义主义，Nominalism) 。这个观点在共相方面与现实主义完全对立，它承认现实独立于人类思想存在，但否认共相的存在。唯名论认为没有重力或爱这回事儿，只有掉落的物品以及经常在你膝盖打呼噜的猫。根据唯名论，我们用重力和爱这些术语，只因为能帮助理解世界，但共相不是真实存在的。</p><hr><h1 id="方法-Approaches"><a href="#方法-Approaches" class="headerlink" title="方法 (Approaches)"></a>方法 (Approaches)</h1><p>至今为止我讲到的科学方法的发展，主要在自然科学领域。物理学 physics、天文学 astronomy、生物学 biology，但在 19 世纪下半叶， <strong>社会科学 (social sciences)</strong> 开始登上历史舞台。</p><p>这段时期，人们又重拾了现实主义的本体论观点，即假设物质世界是真实的，我们感知的是外部世界，是独立于我们思想存在的。</p><p>认识论的观点越来越实证主义 (positivistic) ，这意味着科学家认为我们可以通过观察和实验来获取有关世界本质的知识。这种现实实证观点大多应用于自然现象方面，但随着社会科学发展并成为独特的科学领域，问题来了：现实主义观点是否适用于社会学和心理学现象呢？</p><p>根据 <strong>客观主义 (objectivism)</strong> 的观点，现实主义本体论立场确实适用于心理学和社会学现象，比如智力和社会凝聚力是外部的、独立的性质，是独立于我们的心理表征的。</p><p>客观主义可以建构主义 (constructivism) 做对比。</p><img src="/images/sci-phil_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>根据建构主义，社会现象的本质取决于所涉及的社会角色。这意味着现实不是独立和外在的，而被认为是基于观察者和情境的心理建构。比如，快乐或女性气质这些属性不是外在的，不是永恒的，也不能被客观定义。要如何看待这些属性以及它们的意义，取决于观察者的文化背景、社会族群及特定的历史时期。那么，如果心理现实和社会现实是建构的、主观的、难以捉摸的，我们如何了解它呢？怎样的认识论立场适合建构主义的本体论立场？</p><p>事实上，有一组互相联系的观念，统称为 <strong>解释主义 (interpretivism)</strong> 。解释主义的观点都假设研究者关于社会现象的经历或观察，可能与这些社会现象亲历者的经历大相径庭。所以重点应该放在参与者的角度来解读现象。</p><p>我想讲的三个解释主义观点是 <strong>解释学 (hermeneutics)</strong> 、 <strong>现象学 (phenomenology)</strong> 和 <strong>诠释社会学 (verstehen)</strong> ，它们在如何获得心理学和社会现实的理解上有些微差别。</p><p>先来看看解释学。这个术语来自神学，是关于解读经文。解释学旨在通过解读人们在社会情境下的行为 来解释社会现象。研究者需要将情境纳入考量，并试着理解人们如何看待这世界，以此来理解他们的行为。</p><p>现象学与解释学密切相关。它的首要前提是人不是无生命的对象，他们会思考和感知周遭的世界，而这会影响他们的行为。为了理解他们的行为，就需要调查他们给自己所经历的现象赋予的意义。这意味着调查人们如何从自身的角度探究世界。要切身了解他人对自己经历的理解，研究者需要尽可能地消除自己先入为主的观念。</p><p>诠释社会学是第三种解释主义观点，它与解释学和现象学有紧密联系。诠释社会学主要与社会学家马克斯・韦伯 (Max Weber) 相关。诠释社会学是指对社会现象的移情理解。研究者需要站在研究对象的立场，来解读他们如何看待世界，只有这样研究者才能解释他们的行为。比如，如果欧洲研究者想在一个与世隔绝的亚马逊部落中探究快乐。他们需要站在部落的角度，考虑到部落的社会情境。对部落来说，或许集体比个人更重要，这可能意味着快乐被认为是一种集体属性，甚至根本不适用于个人。现在，为了理解这种完全不同的世界观，研究者需要将自己沉浸在他们研究的人或族群的文化中。</p><p>当然，建构解释主义的观点存在一些问题。首先，有分层解读的问题 —— 研究者的解读；研究对象的解读；而将发现放进一个框架或关联一个理论时，又进行了解读。每多一层解读，就增大了误解的机会。第二个更严重的问题是结果缺乏可比性。在我们的例子中，快乐是主观的，在不同的文化中意义不同。我们不能就这么进行比较。这意味着我们永远无法提出普适解释或理论，而仅仅适用于特定人群或特定时段。第三个问题是参考系的不同。如果参考系与研究者相去甚远，研究者就很难站在研究对象的立场上，从而甚至难以发现社会情境中的相关方面。</p><p>建构 - 解释主义的观点常与科学的定性方法有关。换言之，观察是通过非结构化访谈或参与性观察进行的，而研究者是他们中的一份子。数据来源于一个或少数几个研究对象，通过解读文本或录制的素材对数据进行定性分析。反之，客观 - 实证观点于定量研究方法相关。得到的观察结果可以被计数或测量，所以多个研究对象的数据可以整合在一起，选取的研究对象代表更大的人群，或许可以支持一个普适解释。而且数据用量化统计手段来分析。</p><p>尽管定性方法通常与建构主义的科学观点相关，而定量方法与客观主义观点相关，这并不是限制我们仅使用定性或定量方法的理由。两种方法都各有优劣。对有些研究问题来说，定性方法更好；其他情况下 定量方法可能更合适。事实上，将两种方法互补结合在一起的方法，越来越受到欢迎。</p><hr><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>当然最后，科学的总体目标是获得知识，但可以分为更多具体的目标，区分目标的方式有获取知识的类型以及获取知识的目的。</p><p><strong>普遍性研究 (universalistic research)</strong> 试图提供能广泛使用的解释。</p><p>例如，假设玩暴力电脑游戏会导致攻击行为。这与具体游戏或特定玩家没有关系，因为我们假定的是玩暴力游戏和攻击性间的相关性，这适用于任何暴力游戏，如 GTA 、使命召唤等等；我们还假设相关性适用于男性和女性，任何年龄、任何文化背景的人。</p><p>普遍性研究致力描述或解释的现象，能用于所有人、所有群体或社会。</p><p>科学方法也能用于特殊性研究。特殊性研究致力描述或解释发生在特定环境下的现象，或者涉及特定群体。</p><p>例如，在荷兰将法定饮酒年龄从 16 岁升至 18 岁后，我们能调查荷兰青年酒精中毒住院人数的变化。关键是在特定的时间、地点、群体内调查影响的大小。不要指望在不同国家或十年里再次改变饮酒年龄会有同样结果。所以研究目的既可以是普遍性的，也可以是特殊性的。说得简短些就是：可获得普遍性或特定的知识。</p><p><strong>基础研究 (fundamental research)</strong> 和 <strong>应用研究 (applied research)</strong> 间关系很近，重叠度很高。</p><p>应用研究为了直接解决问题，其开发和应用知识是为了提高人类福祉。假设我们想帮助抑郁人群，我们认为抑郁是孤独造成的。我们就可以建立一个项目，目的是减少孤独感以降低抑郁程度。我们让孤独抑郁的人去养只猫，来观察是否真的由于不再孤独降低了抑郁程度。</p><p>基础研究相较于应用研究旨在获取知识，就是为了增进了解。基础研究的唯一目的是加深了解身边的世界，不需要能立即应用和接解决问题。例如，调查孤独和抑郁间的相关性，用大规模调查来看是否越感觉孤独的人越抑郁，反之亦然。这里是为了揭示孤独和抑郁间的相关性。也许我们想看看是否男性女性都有这种相关性，不同文化和年龄也有这种相关性。但注意，我们不关心如何治疗抑郁，这里的目的更多的是了解相关性，不是帮助抑郁人群。</p><p>大多数基础研究是普遍性研究，但有时候基础研究也会是特殊性研究。例如，在非常特定的情形下的研究。好比我们调查玩暴力游戏和攻击行为的相关性，就在阿姆斯特丹特定的初犯少年犯群体中，他们都来自权贵阶级。在玩暴力游戏和攻击行为相关性方面，这个非常特定的问题群体能提供有趣的新见解。注意，我们不观察该群体如何改造或不再犯罪。</p><p>应用研究常是特殊性研究，旨在特定环境、特定群体中解决问题，但它也可以是普遍性的研究。以养猫来减少抑郁的研究为例，我们可以扩展这项应用研究，比较照顾友善易交流的猫和拒绝接触的猫的人群。这会更有针对性地帮助找到何种治疗有效，但这也加入了普遍性元素，我们还可以调查它对孤独的意义。仅仅有个活物存在就够了吗？还是需要有互动？很多时候，应用研究的结果会产生新的见解，这些见解会和介入或治疗相关，但它们也会提供基础的知识。</p><p>因此，两种研究类型会互相增强。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识论-Epistemology&quot;&gt;&lt;a href=&quot;#认识论-Epistemology&quot; class=&quot;headerlink&quot; title=&quot;认识论 (Epistemology)&quot;&gt;&lt;/a&gt;认识论 (Epistemology)&lt;/h1&gt;&lt;p&gt;在把假说 - 演绎法
      
    
    </summary>
    
    
      <category term="social-science" scheme="https://theinfinitegame.tech/categories/social-science/"/>
    
    
      <category term="计量方法" scheme="https://theinfinitegame.tech/tags/%E8%AE%A1%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    
      <category term="社会科学" scheme="https://theinfinitegame.tech/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>iOS 笔记 | 地图 API</title>
    <link href="https://theinfinitegame.tech/development/note-ios-map-api/"/>
    <id>https://theinfinitegame.tech/development/note-ios-map-api/</id>
    <published>2020-02-26T05:22:08.000Z</published>
    <updated>2020-02-26T12:27:09.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CLLocationManager-CLLocationManagerDelegate"><a href="#CLLocationManager-CLLocationManagerDelegate" class="headerlink" title="CLLocationManager, CLLocationManagerDelegate"></a>CLLocationManager, CLLocationManagerDelegate</h1><p>监控目标区域，进入、离开，Beacon 相关</p><h2 id="MKMapView-MKCoordinateRegion-MKMapItem"><a href="#MKMapView-MKCoordinateRegion-MKMapItem" class="headerlink" title="MKMapView, MKCoordinateRegion, MKMapItem,"></a>MKMapView, MKCoordinateRegion, MKMapItem,</h2><ul><li>坐标 CLLocationCoordinate2D （CoreLocation）</li><li>MKMapItem</li><li>罗盘按钮 MKCompassButton</li></ul><ul><li>用 Array:compactMap 获取一个可选型集合到非可选型且不包含 nil 的映射集合。</li></ul><h2 id="KVO-Compliant-KVO-兼容"><a href="#KVO-Compliant-KVO-兼容" class="headerlink" title="KVO Compliant (KVO 兼容)"></a>KVO Compliant (KVO 兼容)</h2><p>KVO is key-value observing.</p><h2 id="MKLocalSearch-查找附近，MKLocalSearchCompleter"><a href="#MKLocalSearch-查找附近，MKLocalSearchCompleter" class="headerlink" title="MKLocalSearch 查找附近，MKLocalSearchCompleter"></a>MKLocalSearch 查找附近，MKLocalSearchCompleter</h2><h2 id="UISearchResultsUpdating"><a href="#UISearchResultsUpdating" class="headerlink" title="UISearchResultsUpdating"></a>UISearchResultsUpdating</h2><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateSearchResults (<span class="keyword">for</span> searchController: <span class="type">UISearchController</span>)</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CLLocationManager-CLLocationManagerDelegate&quot;&gt;&lt;a href=&quot;#CLLocationManager-CLLocationManagerDelegate&quot; class=&quot;headerlink&quot; title=&quot;CLLoca
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
      <category term="iOS" scheme="https://theinfinitegame.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>watchOS 学习笔记 | 最小可行 Complication</title>
    <link href="https://theinfinitegame.tech/development/note-watchos-minimum-viable-complication/"/>
    <id>https://theinfinitegame.tech/development/note-watchos-minimum-viable-complication/</id>
    <published>2020-02-20T06:43:35.000Z</published>
    <updated>2020-02-22T05:30:26.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>要做一个 watch app，逻辑上，你会先想到从主 UI 开始。毕竟，notfication 和 complication 是可选的。人们说到 app ，通常指的就是主 UI 。</p><p>但是，如果要做一个在表盘用于浏览空气质量指数的 watch app ，你会先想到 complication 。 watchOS 设计的三大准则之一是 <strong>glanceable</strong> ，意味着用户能在扫一眼手表，以尽快的方式看到想要的信息，理想的时间最多几秒钟。 complication 可以让看到这些信息，比从 app 启动栏访问主 UI 快得多。</p><p>不同于 iOS ，watchOS 的应用并不要求主 UI 一定得是最常用的使用方式 —— 如果用例使得通知和 complication 更合理的话。主 UI 可以充当用户想要查看更具体信息或者特定的动作时的 “回退” 方案。</p></blockquote><p>那么，为什么我们不跳过 view controller ，直接尝试构建一个 complication 呢？</p><p>以下是 Kuba 构建的一个简单的 MVP 版本的 watch app ，只有一个 complication (支持 1~2 种变体)。这个 app 没有 UI ，主试图只有一个黑盒子，一行 WKInterface* 对象相关的代码都没有。</p><p>这个没有 UI 的 watch app 的用途是获取空气质量的信息（PM10，PM2.5，$ NO_2 $ 等)，每个小时更新一次，但足够用了。</p><p><img src="/images/minimum-complication-watch-app.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>下面先了解一些基础知识。</p><hr><h1 id="Complication-时间线"><a href="#Complication-时间线" class="headerlink" title="Complication 时间线"></a>Complication 时间线</h1><p>管理 complications 的 API 单独从 WatchKit 分离出来，位于 ClockKit 中，以 <code>CLK</code> 前缀标识。</p><p>有一些 complication 在你抬腕时就是可见的。当手表的屏幕亮起，你希望立即看到渲染的 complication widget ，它显示的数据当下就必须是最新的 —— 用户很可能只看了它一秒钟不到，因此没有时间在这个时候启动网络请求。</p><p>Apple 也不可能采用 7 天 24 小时的方式让应用在后台运行扩展 —— 电池撑不住。</p><p>所以工作方式实际上是这样的：你的应用指定一个 <strong>complication data source</strong>  (<code>CLKComplicationDataSource</code>) ，然后每当它接收到新的数据时 (无论运行在前台或者后台)，它告诉 <strong>complication server</strong> (<code>CLKComplicationServer</code>) 通过数据源刷新数据。数据源返回一个 <strong>timeline</strong> 数据 (一个 <code>CLKComplicationTimelineEntry</code> 的对象) —— timeline 告诉 watchOS complication 在给定时间点到下一个时间点之前应该显示什么数字、文本、图标或者它们的组合。系统缓存这份数据。并且在正确的时间点自动更新显示的内容 —— 你的 app 只有在需要返回 timeline 时才会被唤起，但实际上也可以做到不需要唤起。你可以预先准备一整天的内容，只要你的数据足够提前。</p><p>下图是一个经典的天气 app 的例子，点标记 timeline 实体，上面的线显示每个实体被展示的时长。</p><p><img src="/images/timeline1.png" width="68%" height="68%" style="margin: 10 auto;"></p><p>而这个是日历 app 的 complication ：</p><p><img src="/images/timeline2.png" width="68%" height="68%" style="margin: 10 auto;"></p><p>取决于 app 类型，你需要的数据可能是未来的，过去的，两者都有，或者只需要当前状态。</p><p>在 Kuba 的案例中，他用的是过去的数据 —— 因为 PM10 这种数据不可能精确预测，它受到很多因素影响，某些是人为的 (比如烧煤取暖这类日常活动)</p><h1 id="Time-Travel"><a href="#Time-Travel" class="headerlink" title="Time Travel"></a>Time Travel</h1><p>Timeline 的设计还用到 watchOS 的另外一个特性，叫做 <strong>“Time Travel”</strong> ，它使得你可以在表盘上向前或者向后滚动时间，并更新 complication —— 这使得你可以看到诸如一场比赛中比分变化的过程，或者一只股票在一天中股价变化的过程。</p><p>watchOS 5 中这个特性被完全移除了，这意味着现在没办法看过去时间点的数据了。所以在实践中，实现处理过去数据这部分的 complication API 没有意义。</p><p>未来的数据仍然有价值 —— 虽然没有办法直接滚动操作了，但是 time travel 还可以工作，只不过是单方向固定节奏了。</p><p>有趣的是，这部分无用的 API 尚未被废弃，这意味着未来有回归的可能。</p><h1 id="Comlication-家族"><a href="#Comlication-家族" class="headerlink" title="Comlication 家族"></a>Comlication 家族</h1><p>在 watchOS 5 中你可以选择多达 26 种样式的表盘。不同的表盘可以适应不同数量和形状的 complications 。这些形状或者 complication 空间的变体被称为 <strong>complication famlilies</strong> ，目前有 10-11 种 families 可用：</p><ul><li>Modular Small, 用于所有的经典模块化表盘，也可用于 Siri 表盘的角落</li><li>Modular Large, 只能用在模块化表盘中间唯一的位置</li><li>Circular Small, 用于一些不同的表盘 (e.g. Activity)</li><li>Utilitarian Small (有 “flat” 变体) 和 Utilitarian Large, 用于占据表盘一半以上空间，展示一条水平的内容 (它有一个模式，容易跟 Circular Small 混淆)</li><li>Extra Large, 只用在 X-Large 表盘上</li><li>Graphic Corner, Graphic Circular, Graphic Bezel 和 Graphic Rectangular, 只用在 Apple Watch 4 系列的 Infograph 表盘</li></ul><p>你可以支持其中任意多你想要的家族子集，当然，理想情况下一个好的 app 是支持所有这些家族，因为不同的人偏好不同的表盘。</p><p>项目中为了让事情简单一些，我们只添加了对 Modular Small 和 Circular Small 的支持（覆盖了 11 中表盘，如果没算错的话）。</p><h1 id="内容模板"><a href="#内容模板" class="headerlink" title="内容模板"></a>内容模板</h1><p>由于资源的限制，你无法在 complication 空间随意绘制东西，你只能使用预定义的模板。模板限定了它们可以包含的内容类型和排布方式。你唯一的选择是选择一种模块，适配给定的空间，放入文本，图标或者值。</p><p>举个例子， Circular Small 家族有 6 种可用的模块：</p><p>.ringImage, 中间一个图标，然后一个围绕它的环，其他环的哪些部分被填充可以由你指定<br>.ringText, 中间是文本，然后一个围绕它的环 (实际中，文本通常是 1 到 3 位数字)<br>.simpleImage, 就是个简单的图标<br>.simpleText, 就是个标签<br>.stackImage, 上面一个小图标，下面是短的标签<br>.stackText, 两行短文本</p><p>大部分模块都只有极其有限的空间用于展示内容，有的时候你需要绞尽脑汁想如何利用给定的空间。如果实在想不出来，那么放弃对特定 complication 家族的支持也是可以的。</p><p>你的 app 会一些不同的状态 —— 例如，有或者没有数据，空或者非空数据列表，有或者没有进行中的活动等等。所以根据状态来选用不同的模块是可以的（比如，某些状态用数字，某些状态用图标）。每当你构建 timeline 时，你可以创建全新的模板对象并且用它们填充内容，所以只要你开心，甚至可以每次采用随机模板。</p><h1 id="文本和图像-providers"><a href="#文本和图像-providers" class="headerlink" title="文本和图像 providers"></a>文本和图像 providers</h1><p>为了渲染不同类型内容的灵活性， timeline 数据并非简单地以 <code>String</code> 或者 <code>UIImage</code> 对象的形式返回，而是借助某种可用的 <strong>provide</strong> 对象封装。这些 provider 使得你的内容可以更加动态，根据时间和上下文变化。</p><p>对于文本，最简单的选项是 <code>CLKSimpleTextProvider</code> ，你可以指定单一的字符串以及一个可选的简短版本，如果空间无法容纳完整字符串，则选取简短版本。</p><p>作为替代方案，有几种时间相关内容的 provider 可供选择：</p><ul><li><code>CLKDateTextProvider</code> 输出日期 (日 / 月)</li><li><code>CLKTimeTextProvider</code> 输出特定时间 (小时 / 分钟)</li><li><code>CLKTimeIntervalTextProvider</code> 输出时间范围 (from-to)</li><li><code>CLKRelativeDateTextProvider</code> 输出自某个时间开始或者到某个时间结束 (例如 “2 小时后”)</li></ul><p>上面最后一种会随着时间的流逝自动更新，你只需要配置一次目标时间戳，而不用每小时或者更频繁地手动更新，例如 “5 小时后”，“4 小时后” 等等。</p><p>对于图像，你通常用 <code>CLKImageProvider</code> 。它让你指定一个模板图像（被渲染为单色）和一个颜色。多少情况下，这个颜色会被忽略，因为大部分表盘都是以用户选定的单一颜色渲染所有的 complications 。有一个叫 <code>CLKFullColorImageProvider</code> 的模块可以以全彩的方式渲染图像，但只在新的 Infograph 表盘才用到。</p><p>模拟 Infograph 表盘上的 complications 还用到一些 <code>CLKGaugeProvider</code> —— 它们是用于配置新表盘角落里的彩色弧线。</p><hr><p>出发！</p><p>首先，创建工程，使用模板 “watchOS &gt; iOS App with WatchKit App” ，确保 “Include Complication” checkbox 勾选。</p><p>工程将包含 3 个 targets：</p><ul><li>SmogWatch, 它是 iOS app (这个案例里我们基本不碰这部分)</li><li>SmogWatch WatchKit App, UI 部分，只包含了 storyboard, (包括主 UI 和可能的 notification 场景) 以及 asset catalog 。</li><li>SmogWatch WatchKit Extension, 包含所有的 WatchKit 代码</li></ul><p>在导航栏中选择 “SmogWatch WatchKit App” 目标运行。</p><p><img src="/images/sim-new-app.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><h1 id="设计模板"><a href="#设计模板" class="headerlink" title="设计模板"></a>设计模板</h1><p>如上文所提，为了让事情更简单，我们只是实现 Modular Small 和 Circular Small complication 家族。不过默认情况下所有的 complication 家族都是启用的，所以你需要禁用掉其他的。</p><p>打开 “SmogWatch WatchKit Extension” target 的配置页，在 “General” tab 你会看见一个可以触发 complication 家族的列表：</p><p><img src="/images/enabled-complications.png" width="68%" height="68%" style="margin: 10 auto;"></p><p>接下来，要确定每个 complication 家族要采用什么模板。在 <a href="https://developer.apple.com/documentation/clockkit" target="_blank" rel="noopener">CloudKit 文档</a> 中，找到 Modular Small 家族。在它的页面上，你会看到 7 种可用的模板类以及它们的效果截屏。</p><p>在我们的案例中，我们主要显示小数字，所以下面几种选项可能是合理的：</p><ul><li>显示数字，例如 “75” - 可读性没问题，但是第一眼看数字代表什么不明显</li><li>以一个圆来显示数字 - 弧应该怎么算，没有上限怎么办？</li><li>以上面是图标，下面是数字的方式显示</li><li>以两行文本显示</li></ul><p>最后，我选择了像下面这样的样式：</p><p><img src="/images/modular-small.png" width="10%" height="10%" style="margin: 10 auto;"></p><p>这个方案解决了展示 app 是什么的类型，同时也支持解释不同类型参数的问题，缺陷是使得字体更小了，尤其是 3 个数字的情况。尽管仍然可读，但是 Circular Small 版本肯定效果不好。因此，对于 Circular Small ，选项相似，也选择了两行文本的版本。</p><p><img src="/images/circular-small.png" width="7%" height="7%" style="margin: 10 auto;"></p><p>上面这个可读性差很多，但是 Circular Small 是非常通用的 complication 家族，因此基本上对所有使用者都是一个挑战。Apple 自己的 complications ，比如世界时钟，日出、日落，看起来也没有好多少。我们这里可以放弃 “PM” ，但这样一来又搞不清 app 是干什么用的，所以折中，把 “PM10” 缩短为 “PM” 。有可能上面用图标效果会更好，读者可以尝试一下。</p><hr><h1 id="实现-Complication-数据源"><a href="#实现-Complication-数据源" class="headerlink" title="实现 Complication 数据源"></a>实现 Complication 数据源</h1><p>现在，打开样板代码 <code>ComplicationController</code> 类，这里已经数据源协议所有要求的方法了，一些是空实现，但其中大多数我们并不需要。</p><p>注意，所有的方法都是通过一个 handler callback 返回数据的。这使得你可以通过某些异步的方式加载要求的数据 —— 理论上，你是可以按需在用到时再加载这些数据，但实际上我们绝不应该这么做。 </p><p>所有的方法都传入一个 CLKComplication 对象作为参数，它让你知道系统现在正为哪一种 complication 向你询问数据，这个对象只有一个字段叫 family ，这意味着在一个 Modular 表盘上，你无法区分同族的两个 complication 实例，但是不同族的可以。</p><p>因此，这个信息绝对是必须的 —— 不仅因为不同家族外观看起来不一样，也是为了让编译器匹配你返回的模板类型。</p><p><code>CLKComplicationDataSource</code> 协议里只有 <code>getSupportedTimeTravelDirections</code> 和 <code>getCurrentTimelineEntry</code> 两个方法是必须得实现的，但我们会先从一个可选的方法开始讲。</p><h1 id="样例模板"><a href="#样例模板" class="headerlink" title="样例模板"></a>样例模板</h1><p>我们要看的第一个方法是 <code>getLocalizableSampleTemplate</code> ，在文件的底部 —— 你有可能会需要在把 complication 添加到表盘之前先实现这个方法。</p><p>这个方法让你返回一个 complication 的 “样例” 外观，它是当用户在表盘配置视图中设置 complication 时用到的。这里应当展示一些随机数据，表现你的 complication 一般情况下的外观，就像你在应用的网站或者应用商店上放的截图那样的东西。</p><p>在这个方法中，我们需要返回一个 <code>CLKComplicationTemplate</code> 对象 —— 在实际的 timeline 中，我们也会返回一样的东西。不过这里不指定时间戳。对于两种 complication 家族，我们都用标准的 <code>CLKSimpleTextProvider</code> 来封装返回的文本。 在样例模板里，我们用 “50” 来代替真实值。</p><p>下面是代码：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLocalizableSampleTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTemplate?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"50"</span>)</span><br><span class="line">        handler (template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"50"</span>)</span><br><span class="line">        handler (template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>记得总是返回匹配给定 complication 家族的模板。不幸的是，好像没有可以在编译期检查这个过程的机制。</p><p>这里，我们为两种家族都选用了 “stack text” 模板，因此都有 <code>line1TextProvider</code> 和 <code>line2TextProvider</code> 属性。如果你选择另外的配置的话，可能的属性有 <code>imageProvider</code> ， <code>headerTextProvider</code> ， <code>ringStyle</code> 等等。</p><p>如果系统向我们请求其他我们不支持的 complication 类别的话，我们在默认 case 抛出断言 —— 但这不应该发生，因为我们已经禁用所有其他类型的 complication 。用 <code>preconditionFailure</code> 触发崩溃是为了确保自己不忘掉一些东西，最终版本其实应该返回 nil 更安全。</p><p>之所以先说这部分，是因为无论你在这个模板返回了什么，它都会被系统缓存。如果你改变了代码再次运行，你不会看到任何效果 —— 你需要从模拟器中删除 app ，重新安装以便更新版本。</p><p>现在，当你运行 app ，你可以编辑表盘（通过用力按压 MacBook 的 touchpad ，或者在菜单 Hardware &gt; Touch Pressure），选择一个 complication 空间，并且选择你的 complication ：</p><p><img src="/images/watch-face-editing-1.png" width="25%" height="25%" style="margin: 10 auto;"></p><p>注意，默认你的 app 名是 app target 的完整名，这会有点长。为了把它改成更可读的，打开 WatchKit app target 的 <code>Info.plist</code> (注意，是 app 而不是 extension 的) 然后把 “Bundle display name” 改成 “SmogWatch” 。</p><p>当你退出编辑模式并返回表盘，你会看到你放置 complication 的地方有一个空白的空间 —— 别急，我们接下来就着手处理这块。</p><h1 id="getSupportedTimeTravelDirections"><a href="#getSupportedTimeTravelDirections" class="headerlink" title="getSupportedTimeTravelDirections"></a>getSupportedTimeTravelDirections</h1><p>这个方法告知系统你的 app 在过去、未来、两个方向或者只有当前时刻拥有数据。因为之前提到过去的数据已经不再使用了，所以只有返回 <code>.forward</code> 或者空列表是有意义的。由于我们并不需要预测未来的空气质量，所以我们只需要返回一个空的列表：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSupportedTimeTravelDirections</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimeTravelDirections)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    handler ([])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里返回的东西决定了系统是否会调用 <code>getTimelineStartDate</code> ， <code>getTimelineEndDate</code> ， <code>getTimelineEntries (for:before:limit:withHandler:)</code> 和 <code>getTimelineEntries (for:after:limit:withHandler:)</code> 这些方法，以询问你 timeline 在两个方向上延展的长度，时点。如果我们返回 <code>[]</code> ，那么系统只会询问当前时点。</p><p>不过这些方法都是可选的，所以如果你都不实现它们， watchOS 会假定当前时点没有什么有趣的东西。</p><h1 id="getCurrentTimelineEntry"><a href="#getCurrentTimelineEntry" class="headerlink" title="getCurrentTimelineEntry"></a>getCurrentTimelineEntry</h1><p>这是整个协议核心的代码，它是我们返回最新数据点的地方。</p><p>timeline 数据是以一个或者多个 <code>CLKComplicationTimelineEntry</code> 对象返回的。一个 timeline 实体其实就是一个时间戳加上一个或者多个指派的数据 provider ，里面填充着你需要的数据。实体借由时间戳验证。</p><p>目前我们还没有实际拥有数据，不过别担心 —— 我们可以先返回一个静态数值，比如 75 ，就像样例模板中的做法一样。我们使用当前时间作为时间戳，因为根据前面方法返回的设定，我们不会被询问任何在当前时点之前的时段数据。</p><p>下面是 <code>getCurrentTimelineEntry</code> 的初始版本:</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentTimelineEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimelineEntry?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> entry: <span class="type">CLKComplicationTimelineEntry</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"75"</span>)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: <span class="type">Date</span>(), complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"75"</span>)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: <span class="type">Date</span>(), complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    handler (entry)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当你添加了以上两个方法，编译运行你的 app 到模拟器。你应该会在 complication 里看到我们配置的模板和数值：</p><p><img src="/images/watch-complication-75.png" width="25%" height="25%" style="margin: 10 auto;"></p><p>如果你还是没有看到效果，那可能是因为系统缓存了之前编译版本的状态。为了强制加载 complication ，你可以进入编辑模式，切到不同的 complication ，退出编辑模式。 然后再进入编辑模式，切回你的 complication 。</p><h1 id="可选的方法"><a href="#可选的方法" class="headerlink" title="可选的方法"></a>可选的方法</h1><p>在数据源协议中还有一些其他的协议，但针对我们的用途，我们只需要用到 <code>getTimelineEntries (for:after:limit:withHandler:)</code> 。这个方法询问我们早前传入的 timeline 时点之后的时点。当我们写的 app 需要提前了解某个时点时，会用到这个方法。例如，天气预报，日历事件，todo list 上预定的任务等。不过，大部分 app 只需要显示当前实体就够了。</p><p>我们在这个 app 中使用这个 API 的作用是，我们很可能需要在时点过去之后将未来版本的数据标记为过时。如果你查看的是 6 个小时前的空气质量，它很可能是没什么价值的，因为当前的空气很有可能已经发生显著的变化。在 Krakow ，这种变化可能发生在 2 个小时内。例如，起风或者风停了。所以，我们可能在几小时后自动隐藏掉当前数值，借助添加一个几小时后的 “重置” 数据来实现。如果我们成功地在每个小时更新了数据，那么备选的第二个时点的数据永远不会被展示，但是如果有些东西出错了，那么当时间变化足够长，会在时点到来时借助这个 API 来更新数据。</p><p>我认为 watchOS 之前应该也是这么干的，至少在 Time Travel 功能里是这么做的 —— 文档里也提到了。不过这本该是 <code>getTimelineStartDate</code> 和 <code>getTimelineEndDate</code> 方法存在的意义 —— 但是由于这两个 API 不起作用 (Time Travel)，所以实现它们也没意义。 </p><hr><h1 id="从网络上获取真实数据"><a href="#从网络上获取真实数据" class="headerlink" title="从网络上获取真实数据"></a>从网络上获取真实数据</h1><p>对于第一个版本，我们用使用 Małopolska 地区空气监控系统的公共数据 (仅限波兰) 。</p><p>前端通过一个挺复杂的 POST 请求，发送到 URL <a href="http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz" target="_blank" rel="noopener">http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz</a> ，然后解析返回的 Json 数据。</p><p>这个主题并不是跟 watchOS 特定相关，它是特定于 web API —— 所以这里不详细描述，下面是拉取和解析数据的完整代码：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">DataURL</span> = <span class="string">"http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KrakowPiosDataLoader</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> d = <span class="type">DateFormatter</span>()</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 不确定下面是否必须，安全起见 </span></span><br><span class="line">        <span class="comment">//see https://developer.apple.com/library/archive/qa/qa1480/</span></span><br><span class="line">        d.locale = <span class="type">Locale</span>(identifier: <span class="string">"en_US_POSIX"</span>)</span><br><span class="line"> </span><br><span class="line">        d.dateFormat = <span class="string">"dd.MM.yyyy"</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 确保我们用的是 CET 时区 —— 比如说你是在莫斯科 </span></span><br><span class="line">        <span class="comment">// 你在 2 月 19 号午夜之后请求 19.02.2019 （这时候在波兰还是 2 月 18 号）</span></span><br><span class="line">        <span class="comment">// 你将拿不到数据 </span></span><br><span class="line">        d.timeZone = <span class="type">TimeZone</span>(identifier: <span class="string">"Europe/Warsaw"</span>)!</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    }()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> dataStore = <span class="type">DataStore</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> session: <span class="type">URLSession</span> = {</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.ephemeral</span><br><span class="line">        config.timeoutIntervalForResource = <span class="number">10.0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: config)</span><br><span class="line">    }()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">queryString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> query: [<span class="type">String</span>: <span class="type">Any</span>] = [</span><br><span class="line">            <span class="string">"measType"</span>: <span class="string">"Auto"</span>,</span><br><span class="line">            <span class="string">"viewType"</span>: <span class="string">"Parameter"</span>,</span><br><span class="line">            <span class="string">"dateRange"</span>: <span class="string">"Day"</span>,</span><br><span class="line">            <span class="string">"date"</span>: dateFormatter.string (from: <span class="type">Date</span>()),</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//hardcoded ID for PM10 on a specific station</span></span><br><span class="line">            <span class="comment">//we'll make it configurable later</span></span><br><span class="line">            <span class="string">"viewTypeEntityId"</span>: <span class="string">"pm10"</span>,</span><br><span class="line">            <span class="string">"channels"</span>: [<span class="number">148</span>]</span><br><span class="line">        ]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> jsonData = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.data (withJSONObject: query, options: [])</span><br><span class="line">        <span class="keyword">let</span> json = <span class="type">String</span>(data: jsonData, encoding: .utf8)!</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//don't ask me, that's what the API expects</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"query=\(json)"</span></span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(<span class="number">_</span> completion: @escaping <span class="params">(Bool)</span></span></span> -&gt; ()) {</span><br><span class="line">        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="type">DataURL</span>)!)</span><br><span class="line">        request.httpBody = queryString ().data (using: .utf8)!</span><br><span class="line">        request.httpMethod = <span class="string">"POST"</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: sending request to %@ with %@ ..."</span>,</span><br><span class="line">            <span class="type">DataURL</span>, queryString ())</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> task = session.dataTask (with: request) { (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = error {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: received error: %@"</span>, <span class="string">"\(error)"</span>)</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: received response: %@"</span>,</span><br><span class="line">                    data != <span class="literal">nil</span> ? <span class="string">"\(data!.count) bytes"</span> : <span class="string">"(nil)"</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data = data {</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> obj = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject (with: data, options: []) {</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> json = obj <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] {</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> data = json [<span class="string">"data"</span>] <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] {</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> series = data [<span class="string">"series"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]] {</span><br><span class="line"> </span><br><span class="line">                                <span class="comment">//there would be more than one data series if we passed</span></span><br><span class="line">                                <span class="comment">//multiple "channel IDs" (e.g. for more than 1 station)</span></span><br><span class="line">                                <span class="keyword">if</span> <span class="keyword">let</span> first = series.first {</span><br><span class="line">                                    <span class="keyword">if</span> <span class="keyword">let</span> points = first [<span class="string">"data"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>]] {</span><br><span class="line"> </span><br><span class="line">                                        <span class="comment">//the data series is an array of up to 26 hourly</span></span><br><span class="line">                                        <span class="comment">//measurements; we only take the last one for now</span></span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> point = points.last {</span><br><span class="line">                                            <span class="keyword">let</span> date = <span class="type">Date</span>(</span><br><span class="line">                                                timeIntervalSince1970: <span class="type">Double</span>(point [<span class="number">0</span>])!</span><br><span class="line">                                            )</span><br><span class="line">                                            <span class="keyword">let</span> value = <span class="type">Double</span>(point [<span class="number">1</span>])!</span><br><span class="line"> </span><br><span class="line">                                            <span class="keyword">self</span>.dataStore.currentLevel = value</span><br><span class="line">                                            <span class="keyword">self</span>.dataStore.lastMeasurementDate = date</span><br><span class="line"> </span><br><span class="line">                                            <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: saving data:"</span> +</span><br><span class="line">                                                <span class="string">"%.0f at %@"</span>, value, <span class="string">"\(date)"</span>)</span><br><span class="line"> </span><br><span class="line">                                            success = <span class="literal">true</span></span><br><span class="line">                                        }</span><br><span class="line">                                    }</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> !success {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: no data found"</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            completion (success)</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        task.resume ()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不要忘记在最后用 <code>resume ()</code> 启动任务。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>我们向 API 请求 PM10 的数据，硬编码请求当天和特点地点。</li><li>我们只取最后的测量结果 (多数情况下是最近一两个小时的数据)</li><li>如果我们拿到数据，存储一个数字，表示 PM10 的浓度，以及测量的时间点</li><li>通知调用方我们拿到或者没有拿到数据</li></ul><p>上面的代码用了老式的 Json 解析方法，因为我认为这样比较容易理解。</p><p>我用老式的 <code>NSLog</code> 而不是 Swift 的 <code>print ()</code> ，是因为后者只会显示在 Xcode 的控制台，并不会记录到系统日志，所以在控制台 app 的诊断日志里看到，在某些情况下你需要在 app 没有连接 mac 时跟踪它的行为。</p><p>还有，注意我们是在前台请求数据，用最基本的 URL session 。这不是通常我们最理想的应用方案 —— 理想的，所有的请求都应该是在后台 URL sessions 中完成，不过这里只是一个最小可用原型，先保持这样吧。</p><p>不过我们通过把超时时间设置为每次请求不超过 10 秒钟来限制了 URL session。 这里 <code>timeoutIntervalForResource</code> 的用法，而不是 <code>timeoutIntervalForRequest</code> 或者 <code>timeoutInterval</code> 很重要，因为自上一次接收到数据包后，后面两个只会在空闲时间工作，而我们希望控制总的请求时间。之所以要控制总时间，是因为看起来这里边有一个针对后台任务的硬性限制，并且没有在文档中提到：如果一个 app 超出了 15 秒的后台运行时间，它会被立即杀死，崩溃报告如下：</p><blockquote><p>Termination Reason: CAROUSEL, Background App Refresh watchdog transgression. Exhausted wall time allowance of 15.00 seconds. Termination Description: SPRINGBOARD, CSLHandleBackgroundRefreshAction watchdog transgression: eu.mackuba.SmogWatch.watchkitapp.watchkitextension exhausted real (wall clock) time allowance of 15.00 seconds (…)</p></blockquote><p>为了便于你了解最后一次检测的时间点，我们把 <code>lastMeasurementDate</code> 时间戳存进了 <code>DataStore</code> ，这是一个我们可以用来实现之前提到的 “过时数据 特性的潜在结构。</p><p>那么这个 <code>DataStore</code> 究竟是什么？其实只是 <code>UserDefaults</code> ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">CurrentLevelKey</span> = <span class="string">"CurrentLevel"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">LastMeasurementDate</span> = <span class="string">"LastMeasurementDate"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataStore</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> defaults = <span class="type">UserDefaults</span>.standard</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Double?</span> {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> defaults.object (forKey: <span class="type">CurrentLevelKey</span>) <span class="keyword">as</span>? <span class="type">Double</span> }</span><br><span class="line">        <span class="keyword">set</span> { defaults.<span class="keyword">set</span>(newValue, forKey: <span class="type">CurrentLevelKey</span>) }</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> lastMeasurementDate: <span class="type">Date?</span> {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> defaults.object (forKey: <span class="type">LastMeasurementDate</span>) <span class="keyword">as</span>? <span class="type">Date</span> }</span><br><span class="line">        <span class="keyword">set</span> { defaults.<span class="keyword">set</span>(newValue, forKey: <span class="type">LastMeasurementDate</span>)}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后，我们需要添加一个例外域名到 WatchKit Extension target 的 App Transport Security 设置中，因为这个域名不支持 Https 。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionDomains<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>monitoring.krakow.pios.gov.pl<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionAllowsInsecureHTTPLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h1 id="显示真实数据"><a href="#显示真实数据" class="headerlink" title="显示真实数据"></a>显示真实数据</h1><p>为了实际加载数据，我们需要在某个地方调用这个类的方法。我们来看一看 <code>ExtensionDelegate</code> 这个类，它实现了 <code>WKExtensionDelegate</code> —— 基本上就是一个 WatchKit 版本的 <code>UIApplicationDelegate</code> 。就像所有的 app 代理， <code>WKExtensionDelegate</code> 有许多生命周期方法，这些方法会被系统在各种时刻调用： <code>applicationWillEnterForeground</code> ， <code>applicationDidBecomeActive</code> ， <code>applicationWillResignActive</code> 和 <code>applicationDidEnterBackground</code> 等等。</p><p>这里头我们目前唯一会用到的是 <code>applicationDidFinishLaunching</code> 。这个方法会在 app 进程启动时被调用 —— 无论是通过 app launcher 或者通过 Xcode ，又或者从后台启动。只要是 app 需要被唤起，并且之前已经被系统清理掉的时候，这个周期都会运行 (通常在晚上，被系统杀死的情况经常发生) 。</p><p>无论何时， app 启动或者在后台重启，我们都希望借助这个机会立即拉取最新的数据，如果我们得到响应，重新加载所有活动的 complication （活动的 complication 指那些在当前选择的表盘上显示的 complication）。</p><p>所以我们将这样做：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: applicationDidFinishLaunching ()"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> success {</span><br><span class="line">            <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了拉取数据，我们调用了 KrakowPiosDataLoader 类，然后在有任何新数据的情况下重载加载 complications ，否则的话就不必了。在 watchOS 上，不要浪费时间做无用功，这是一条通用的准则。</p><p>为了重新加载 complications ，我们得拿到活动 complication 的列表，这是借由全局共享的  <code>CLKComplicationServer</code> 实例来获得的，并且也通过它的 <code>reloadTimeline (for:)</code> 方法来重新加载那些活动的 complication 。如果打算在已经存在的 timeline 实体后追加新的 timeline 实体，我们也可以用另一个相似方法  <code>extendTimeline (for:)</code> ，两者的区别是前者我们希望立刻用新数据替换掉之前的数据。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadActiveComplications</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">let</span> server = <span class="type">CLKComplicationServer</span>.sharedInstance ()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> complication <span class="keyword">in</span> server.activeComplications ?? [] {</span><br><span class="line">        server.reloadTimeline (<span class="keyword">for</span>: complication)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码会触发一轮对你的 <code>CLKComplicationDataSource</code> 的调用 —— 有的时候是一会之后，不过通常几乎都是立刻发生。现在我们有了真实数据，我们可以回到之前写的 <code>getCurrentTimelineEntry</code> 方法，然后把占位的代码替换成实际的逻辑：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentTimelineEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimelineEntry?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> store = <span class="type">DataStore</span>()</span><br><span class="line">    <span class="keyword">let</span> entry: <span class="type">CLKComplicationTimelineEntry</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> valueLabel: <span class="type">String</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> lastMeasurement = store.lastMeasurementDate, <span class="keyword">let</span> level = store.currentLevel {</span><br><span class="line">        valueLabel = <span class="type">String</span>(<span class="type">Int</span>(level.rounded ()))</span><br><span class="line">        date = lastMeasurement</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        valueLabel = <span class="string">"--"</span></span><br><span class="line">        date = <span class="type">Date</span>()</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: valueLabel)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: date, complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: valueLabel)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: date, complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    handler (entry)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在，当我们运行 app 时，点击 home 按钮返回表盘时，我们会看到一个刚刚借助 API 加载的真实数据：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExtensionDelegate: applicationDidFinishLaunching ()</span><br><span class="line">KrakowPiosDataLoader: sending request to http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz with</span><br><span class="line">query={"viewTypeEntityId": "pm10", "measType": "Auto", "viewType": "Parameter", "dateRange": "Day",</span><br><span class="line">"date": "24.02.2019", "channels": [148]} ...</span><br><span class="line">KrakowPiosDataLoader: received response: 1553 bytes</span><br><span class="line">KrakowPiosDataLoader: saving data: 46.4462 at 2019-02-24 10:00:00 +0000</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/watch-complication-46.png" width="34%" height="34%" style="margin: 10 auto;"></p><hr><h1 id="安排更新"><a href="#安排更新" class="headerlink" title="安排更新"></a>安排更新</h1><p>最后的拼图是确保我们可以按照有规律的间隔加载新的数据并重新加载 complication 。有一些场景你可以更新 complications ：</p><ul><li>当你的 app 处于前台时，你总是可以做这件事 —— 但你无法依赖它定期发生。</li><li>当你接受到一些静默的推送通知时，尤其是专门为这种用途设计的 (借助 PushKit framework ，采用  PKPushTypeComplication 类型) —— 当你的数据以不规则间隔更新时，这种机制会有用 —— 当外部发生一些事件时。</li><li>当 iPhone app 以某种方式接收到新的数据并把它传输给 watch 时</li><li>通过计划定期的后台刷新 —— 当你希望拉取数据而不是被动等推送时，这种方式更好。</li></ul><p>注意，不管你采用哪种策略，对于我们刷新数据的频率以及完成刷新的用时，有许多限制。 (比如，每天不超过 50 个推送通知) —— 如果你用尽了所有的时间或者每天可用的推送数量，你将无法再在后台运行，有可能要等到第二天。对于这点约束，看起来没有什么特别好的方案可以绕过，你也不应该尝试去寻找这类方案。</p><p>既然我们知道城市监测站每小时发送一次新的测量数据，我们会使用计划好的后台刷新来更新我们的 complication ，并且会在 <code>ExtensionDelegate</code> 中完成。</p><p>为了确保我们的 app ，我们需要实现一样我称为 “后台刷新循环” 的东西：当 app 启动或者重启时，我们安排一次后台刷新，然后当 app 被这个后台刷新唤起时，我们做的第一件事就是安排下一次后台刷新，以确保若干时间后总有新的刷新被计划。</p><p>我们会在所有其他事情之前开始做刷新计划，因为我们无法知道在我们的 app 被挂起或者杀死之前还有多少可用的时间。否则，如果在我们设置下一次刷新之前 app 就被挂起，那么 app 就相当于没设闹钟就睡过去了，那么它将会睡过头。 😉</p><p>现在，让我们再看一下 <code>applicationDidFinishLaunching</code> 方法，我们需要在 web 请求发送之前增加一个新的方法调用 <code>scheduleNextReload ()</code> :</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: applicationDidFinishLaunching ()"</span>)</span><br><span class="line"> </span><br><span class="line">    scheduleNextReload ()</span><br><span class="line"> </span><br><span class="line">    <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> success {</span><br><span class="line">            <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="计算下一次刷新时间"><a href="#计算下一次刷新时间" class="headerlink" title="计算下一次刷新时间"></a>计算下一次刷新时间</h1><p>在计划下一次刷新前，我们首先需要定出下一次刷新的时机。</p><p>为了优化后台刷新的耗时，尽可能利用好珍贵的后台时间，思考清楚我们的数据究竟需要在何时和以何种频率改变。一个很好的例子是 —— 证券交易只发生在工作时间，不在工作时间内，股票价格不会变化，所以在夜间重载不会改变的数据是没有意义的。</p><p>我对获取数据的 API 做了一些测试，新的数据几乎总是 1 个整小时的 0 到 10 分钟内添加。所以我决定每小时请求一次刷新，总是在每小时的 15 分做这件事 (10:15 ， 然后 11:15， 然后 12:15 ，以此类推)。为了实现这种方式，我们需要一个辅助方法来让我们基于当前时间找到最接近 xx:15 的时间 —— 幸运的是，利用 NSCalendar API 很容易做到：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextReloadTime</span><span class="params">(after date: Date)</span></span> -&gt; <span class="type">Date</span> {</span><br><span class="line">    <span class="keyword">let</span> calendar = <span class="type">Calendar</span>(identifier: .gregorian)</span><br><span class="line">    <span class="keyword">let</span> targetMinutes = <span class="type">DateComponents</span>(minute: <span class="number">15</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> nextReloadTime = calendar.nextDate (</span><br><span class="line">        after: date,</span><br><span class="line">        matching: targetMinutes,</span><br><span class="line">        matchingPolicy: .nextTime</span><br><span class="line">    )!</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果和当前时间间隔小于 5 分钟，那么跳过，尝试下一个小时 </span></span><br><span class="line">    <span class="keyword">if</span> nextReloadTime.timeIntervalSince (date) &lt; <span class="number">5</span> * <span class="number">60</span> {</span><br><span class="line">        nextReloadTime.addTimeInterval (<span class="number">3600</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> nextReloadTime</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="计划后台刷新"><a href="#计划后台刷新" class="headerlink" title="计划后台刷新"></a>计划后台刷新</h1><p>最后，为了在计算好的未来时点请求更新，我们需要在 <code>WKExtension</code> (等价于 <code>UIApplication</code>) 上调用  <code>scheduleBackgroundRefresh</code> ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleNextReload</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">let</span> targetDate = nextReloadTime (after: <span class="type">Date</span>())</span><br><span class="line"> </span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: scheduling next update at %@"</span>, <span class="string">"\(targetDate)"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="type">WKExtension</span>.shared ().scheduleBackgroundRefresh (</span><br><span class="line">        withPreferredDate: targetDate,</span><br><span class="line">        userInfo: <span class="literal">nil</span>,</span><br><span class="line">        scheduledCompletion: { <span class="number">_</span> <span class="keyword">in</span> }</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你传入的日期是你希望你的 app 被唤起的时间。当然，系统会把它看做一种提示 —— 你的 app 实际被唤起的时间还可能取决于各种因素（我猜测这其中包含电量，充电状态，网络访问，你请求刷新的频率，你每次刷新的耗时，等等）。所以，不要假定你的 app 总是能在固定的间隔运行。</p><p>不过，基于我的测试，在实践中一个拥有一个活动 complication ，每隔一个小时更新的 app ，通常在 10 秒以后的请求时间，在白天的表现比在夜间充电的表现要好很多，或者 app 运行频繁，或者 app 处于 dock 但是没有 complication 时，后台任务被调用的机会更少。不在 dock 也不没有 complication 的 app ，几乎不被调用。</p><p><code>scheduledCompletion</code> 块在文档中被描述为 “A block that is called by the system after the background app refresh task has completed” ，但是实际上它是在下一个刷新任务计划完成时就被立即执行。不过由于它是一个可选的参数，你可以提供一个空的块。至于 <code>userInfo</code> ，它可以传递一些元数据给后台任务的 handler ，但这里我们用不上。</p><h1 id="处理后台任务"><a href="#处理后台任务" class="headerlink" title="处理后台任务"></a>处理后台任务</h1><p>watchOS 上的后台刷新是通过在各种时刻从后台唤起你的 app ，然后调用代理方法 <code>handle (_ backgroundTasks:)</code> ，传给它一个或者多个取决于上下文的 “后台任务”。这个方法对于你的 app 后台事务至关重要，不管你构建的 app 是什么类型，几乎一定要在这里做些事情。</p><p>任务的类型有不少，但你应当做跟当时接收到的任务相关的工作。比如有的任务是处理 URLSession 返回的数据，有的任务是处理 iPhone 返回的数据，有的任务是处理 Siri 快捷方式，但是这里我们要处理的是一种通过之前的 <code>scheduleBackgroundRefresh</code> 发起的任务 —— 这是一种最普通的 <code>WKApplicationRefreshBackgroundTask</code> 。这种任务意味着你的 app 是由于你自己的请求而被唤起的，以便你可以运行一些后台的 URL 请求，更新你的 complication 等等。</p><p>当 app 在后台被唤起时，在 <code>handle (_ backgroundTasks:)</code> 方法中，我们做的事情跟启动时的差不多 —— 我们计划下一次刷新，并尝试更新数据。注意，我们只用了 <code>WKApplicationRefreshBackgroundTask</code> ，忽略其他的任务类型。不过，在完成任务后，记得总是调用 <code>setTaskCompletedWithSnapshot ()</code> 方法，这很关键，即便对于那些被你忽略掉并且不处理的任务。不过，调用这个方法表明我们的事干完了，在这之后我们的 app 可能会被挂起。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(<span class="number">_</span> backgroundTasks: Set&lt;WKRefreshBackgroundTask&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> backgroundTasks {</span><br><span class="line">        <span class="keyword">switch</span> task {</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> backgroundTask <span class="keyword">as</span> <span class="type">WKApplicationRefreshBackgroundTask</span>:</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: handling WKApplicationRefreshBackgroundTask"</span>)</span><br><span class="line"> </span><br><span class="line">            scheduleNextReload ()</span><br><span class="line"> </span><br><span class="line">            <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> success {</span><br><span class="line">                    <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">                }</span><br><span class="line"> </span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: completed WKApplicationRefreshBackgroundTask"</span>)</span><br><span class="line">                backgroundTask.setTaskCompletedWithSnapshot (<span class="literal">false</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            task.setTaskCompletedWithSnapshot (<span class="literal">false</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>让 watchOS 模拟器运行 app 后台刷新任务需要一些技巧，即使你已经安排它们在一会之后运行。如果你测试时发现不工作，可以尝试随机切换 app ，主屏和表盘，直到后台刷新任务可以工作。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就这些，我们完成了！🎉 我们得到一个每小时运行的 app ，从 web API 加载新数据，显示到你选择的表盘上，你只要抬腕就能看到它。</p><p>依我看来，为了构建一个带 complication 的最小可行的 watch app ，你需要做这些事：</p><ol><li>确定你的 app 想要在 complication 上展示的最重要的东西。</li><li>确定你的 complication 内容什么时候改变，你的 timeline 存放什么以及存在哪里。</li><li>浏览 complication 家族以及对应可用的模板，确定哪些最适合你</li><li>实现从 web 或者系统 API 加载数据的代码</li><li>实现 complication 数据源要求的方法，以构建 <code>CLKComplicationTimelineEntry</code> 和 <code>CLKComplicationTemplate</code> 对象，以合适的方式展示你的内容。</li><li>确保你的 app 定期更新，用计划的后台刷新或者借助推送通知 (分析你的数据变化的模式，以便优化后台时间)</li><li>测试，测试，再测试，用任何你能想到的场景和组合 🙂</li></ol><p>如果你只是构建一个静态的 complication ，永远不更新，就像 Apple 的 “launcher” 型的 complications ， 比如 Breathe ， Maps ， Reminders 等等。那么，你只需要做这些事：</p><ol><li>为所有支持的 complications 挑选一个图标。</li><li>实现数据源方法，用 “single icon” 模板返回单一实体的 timeline 。</li></ol><p>这种情况下你不需要计划后台刷新以更新 complication ，因为它永远不变。不过，由于 complication 需要链接到真实 app 时，也有大量工作需要做。 😉</p><p>工程中的代码可以从这个仓库找到: <a href="https://github.com/mackuba/SmogWatch" target="_blank" rel="noopener">https://github.com/mackuba/SmogWatch</a> (master 分支最新代码，或者对应这篇文档的 post2 分支的版本)。 它是 WTFPL-licensed ，所以尽管拿去用，你可以分享给我你都做出什么好玩的东西！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;要做一个 watch app，逻辑上，你会先想到从主 UI 开始。毕竟，notfication 和 complication 是可选的。人们说到 app ，通常指的就是主 UI 。&lt;/p&gt;
&lt;p&gt;但是，如果要做一个在表盘用于浏览空气质量指数的 wa
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="watchOS" scheme="https://theinfinitegame.tech/tags/watchOS/"/>
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
  </entry>
  
  <entry>
    <title>watchOS 学习笔记 | Big Picture</title>
    <link href="https://theinfinitegame.tech/development/note-watchos-big-picture/"/>
    <id>https://theinfinitegame.tech/development/note-watchos-big-picture/</id>
    <published>2020-02-20T03:42:05.000Z</published>
    <updated>2020-02-20T07:01:30.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="watchOS-应用"><a href="#watchOS-应用" class="headerlink" title="watchOS 应用"></a>watchOS 应用</h1><p>相比 macOS，iOS 和 tvOS ，watchOS (目前为止) 并非是完全独立的平台，一定程度上依赖配对的 iPhone 。</p><blockquote><p>watchOS 6.0 之后，watch app 可以独立发布和安装，也就说，应用生态上可以独立了。但是，某些功能要想发挥最大的效用，还要借助 iPhone 设备的计算能力。毕竟，后者目前还是要强大很多。可以这么理解，当需要用到 watch 本身不具备的硬件能力时，如视频拍摄，你仍可以把 watch 视为控制器。这个跟人们看待早期智能手表的视角一致。</p></blockquote><h1 id="Watch-app-和扩展"><a href="#Watch-app-和扩展" class="headerlink" title="Watch app 和扩展"></a>Watch app 和扩展</h1><p>watchOS app 跟 iOS app 最显著的差异是前者被严格的分成了两部分。第一部分称为 Watch app —— 有点混淆对吧？正常理解，两部分加起来才是一个完整的 app 。但字面上，这个主要由 UI 构成的部分就叫 Watch app ，所以我们干脆以 UI 来代表，第二个部分是 WatchKit 扩展。两部分有各自独立的数据容器，如果需要共享容器中的文件，需要用到 <strong>App Groups</strong> 。</p><p>watch OS 6 引入 SwiftUI 后，情况变得有些复杂。因为 SwiftUI 中，UI 即代码。原来的 watch app 部分只有一个 hosting view 。</p><h1 id="这些年-watchOS-的变化"><a href="#这些年-watchOS-的变化" class="headerlink" title="这些年 watchOS 的变化"></a>这些年 watchOS 的变化</h1><p>watchOS 1 中，app UI 运行在 watch 上，但扩展运行在 iPhone 上。扩展可以很容易地与设备上的其他 iOS app 通信，但扩展和 watch UI 之间的通信是设备间的，因此整个 app 运行很慢。</p><p>watchOS 2 中，扩展被移到了 watch 上。watch app 和 iOS app 通信需要借助 <strong>WatchConnectivty framework</strong> 。因为扩展处于 watch 上，所以能用到 SDK 自然变少了。当然，后来各种缺失的 SDK 也被陆续添加到 watchOS 中。</p><p>watchOS 4 中，扩展和 UI 被合为一个进程运行。当然，这一点对开发者来说相对无感，唯一的效果是 app 运行的更快了。</p><p>watch OS 5 以前，WatchKit app 需要依赖 iPhone 的连接来完成大部分通信。它只能连接 iPhone 连接过的 “已知 Wi-Fi 网络” 。watch OS 5 引入了连接全新 WiFi 网络的能力。</p><p>在 watch OS 5 及之前的版本，watch app 总是要求有一个伴生的 iOS app 。watch app 是内置在 iOS app bundle 中，它的安装也是通过先安装 iOS app ，再间接下载到 watch 上来完成的。最近的 watch OS 6 ，watch app 真正意义上宣布独立。你既可以采用之前的 iOS app + watch app 的方式， 也可以只开发独立的 watch app 。watch app 不再是内置在 iOS app 中，两者被分隔在各自平台的 App Store 发布。因此，对于因特网的连接方式，最新的建议是 借助 <strong>URLSession</strong> ，<strong>CloudKit</strong> 等直接下载数据到 watch ，只有在真的需要跟 iPhone 交换数据时才用到 <strong>WatchConnectivity</strong> 。</p><hr><h1 id="多于一个用户接口"><a href="#多于一个用户接口" class="headerlink" title="多于一个用户接口"></a>多于一个用户接口</h1><p>iOS app 通常有一个主要的用户入口。人们想到 iOS app 的时候，通常想到的是主界面上的图标。当然，也有各种扩展可以访问 app 的不同部分，但是通常被认为是主 app 的附属。你使用 app 的主要姿势是打开主 app 。</p><p>来到 watchOS ，情况大不相同。主 UI ，根据你的用例，很有可能不是最常被使用的部分。其主要原因在于 iPhone 和 Apple Watch 完全不同的交互模式。你不可能像在 iPhone 上那样在 watch 的屏幕上花很长的时间浏览内容吧？很显然，那很不舒服。</p><p>对于 watchOS ，Apple 一直重复的关键词是 <strong>glances</strong> 或者说 <strong>glanceable</strong> 。期望的 app 交互方式是：抬起手腕，看表，做一两个点击（或者甚至都不点击），或者转一下数字表冠，然后放下手腕，回到现实。这一系列动作的平均时间是以秒计的。实际上，建议是在 2 秒内让用户找到目标信息 (glanceable) 或者执行动作 (actionable) 。</p><p>如果你用过 watchOS app ，你应该知道通过主 app 找到目标信息需要一点技巧。首先，你要在主屏上那一堆六边形网格中找到 app ，然后点击，等待加载，然后在 app 的不同屏之间寻找你要的东西。基于此，也取决于你的 app 类型，极有可能你的主 UI 只会偶尔被用到。 WatchKit app 实际上提供了一些其他的入口来交互，它们可能更重要。</p><h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>通知实际上是 watch 的一个绝佳的应用场景。花不到一秒的时间看一眼手表，比从口袋里掏出手机来省事不少吧？许多人会告诉你，他们戴 watch 的主要用途就是看通知。</p><p>但是，通知用的好不好，对不对，主要还是取决于你的 app 类型，通知的目的。比如，你的目的是不定期的通知用户某些事情发生了，通知可以是你的 app 很重要的一部分。典型的，提醒事项 app 。</p><p>watchOS 上通知的 UI 有三种变体：</p><ul><li>只有预制的静态信息</li><li>非交互式的动态信息</li><li>可交互的动态信息，watchOS 5 引入 </li></ul><p>watch OS 6 允许推送绕过 iPhone ，只到达 Apple Watch 的远程通知。</p><h3 id="Glances-Dock"><a href="#Glances-Dock" class="headerlink" title="Glances / Dock"></a>Glances / Dock</h3><p>watchOS 1 开始，引入了一种被叫做 <strong>glance</strong> 的界面，卡片式，可点击，水平滚动。借助 storyboard 上单独的场景构建。</p><p>watchOS 3 开始，<strong>glance</strong> 被废弃，由 <strong>dock</strong> 取代，后者是通过按压表侧的长按钮访问。它的工作方式和 glance 相似，但是卡片的外观是基于主 app 的实际 UI (类似 iOS 上的体验)，通过系统对 app 生命周期某些节点的快照来实现。当你完成滚动，选择了某个 app 后，系统会唤醒这个 app ，不久之后这个 app 实际的 live 视图会更新 dock 的静态图片。</p><p>watch OS 4 之后，dock 变成竖向滚动，跟 iOS 的体验更相似。</p><h3 id="Complications"><a href="#Complications" class="headerlink" title="Complications"></a>Complications</h3><p>“<strong>Complications</strong>“ 是 Apple 给表盘上的各种 widget 取的一个比较有逼格的名字。</p><img src="/images/watch-complications.png" width="68%" height="68%" style="margin: 10 auto;"><p>Complications 有很多不同的家族，为不同的表盘设计 —— 圆形的，矩形的，小的，大的。这些 complictions 的共同点是展示信息的空间极其有限，一直可见（激活状态），因此需要保持最新状态。</p><p>你可以想象，complication 的特点是不可能通过让 app 持续运行在后台，并且完全访问表盘的方式来实现的。因为这样做电池撑不住。</p><p>Apple 的解决方案是你需要周期性的提前提供一个包含给定时间范围的 <strong>timeline</strong> 数据给 complication 用于显示。系统存储这份数据，到时间点了自动切换到正确的状态。你不能在 complication 里随意显示内容 —— 你只能从给定的 complication 家族中选择预先定义好的模板，然后填充一些精心准备的，允许系统在必要时简化以便适配可用空间的数据。</p><p>这里面的一个挑战是：如何找出有用的东西，填充到这么小的空间里 —— 同时这也是一个能简化工作的约束，因为你只有有限的选项。</p><p>Apple 一开始就说了，complications 只对部分 app 有意义 —— 因而并非每个 app 都有一些关键信息，可以展示为一个数字或者一行文本。不过，从 watchOS 3 开始，官方建议所有的 app 都实现一个 complication ，即便这个 complication 只是一个静态的启动器。（个人认为这个要求对用户的意义在于，用户可以在表盘上添加特定 app 的 complication ，仅仅作为启动器也是有价值的）。技术层面，系统可以针对当前表格的启动器，做一些优化，以便 app 启动更快。</p><h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><p>最后一个入口就是 Siri 了， watchOS 5 以后，Siri 可以用于更多的用例，例如发消息，todo list 等等。</p><hr><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://mackuba.eu/2018/12/18/watchkit-adventure-1-the-big-picture/" target="_blank" rel="noopener">MacKuba 关于 WatchKit 的文章 1</a></p><p><a href="https://mackuba.eu/2019/03/06/watchkit-adventure-2-mvc/" target="_blank" rel="noopener">MacKuba 关于 WatchKit 的文章 2</a></p><p><a href="https://github.com/mackuba/SmogWatch" target="_blank" rel="noopener">MacKuba 的一个 apple watch 项目</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;watchOS-应用&quot;&gt;&lt;a href=&quot;#watchOS-应用&quot; class=&quot;headerlink&quot; title=&quot;watchOS 应用&quot;&gt;&lt;/a&gt;watchOS 应用&lt;/h1&gt;&lt;p&gt;相比 macOS，iOS 和 tvOS ，watchOS (目前为止) 并非
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="watchOS" scheme="https://theinfinitegame.tech/tags/watchOS/"/>
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
  </entry>
  
  <entry>
    <title>AR | ARKit 概览</title>
    <link href="https://theinfinitegame.tech/computer-tech/ar-arkit-overview/"/>
    <id>https://theinfinitegame.tech/computer-tech/ar-arkit-overview/</id>
    <published>2020-02-17T08:44:13.000Z</published>
    <updated>2020-02-17T09:28:20.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><ul><li><strong>运动跟踪 (motion tracking)</strong> 使得手机理解和追踪它相对于世界的位置。</li><li><strong>环境理解 (environmental understanding)</strong> 使得手机可以侦测各种表面的尺寸和位置：水平的，竖直的，成一定角度的，比如地面，咖啡桌或者墙面。</li><li><strong>光线评估 (light estimation)</strong> 使得手机可以估计环境当前的光照条件。</li></ul><hr><h1 id="ARKit"><a href="#ARKit" class="headerlink" title="ARKit"></a>ARKit</h1><h2 id="ARKit-3"><a href="#ARKit-3" class="headerlink" title="ARKit 3"></a>ARKit 3</h2><p>ARKit 3 带给人们不可思议的体验。通过 People Occlusion，ARKit 3 知道人们和 AR 对象在哪里，并适当地遮挡 scene。ARKit 3 使用 Motion Capture 跟踪人们的运动，将其输入到 AR scene 中。它还可以同时跟踪最多三张人脸，支持 collaborative sessions 等等。</p><h4 id="People-Occlusion"><a href="#People-Occlusion" class="headerlink" title="People Occlusion"></a>People Occlusion</h4><p>现在 AR 内容能呈现在人们的身后和前面，使 AR 体验更加沉浸化。同时，在大多数环境能实现绿幕风格的效果。</p><h4 id="Motion-Capture"><a href="#Motion-Capture" class="headerlink" title="Motion Capture"></a>Motion Capture</h4><p>用一台相机实时捕捉人们的运动。通过将人们身体的位置和运动，理解为一系列关节和骨骼，您可以使用运动和姿势作为 AR 体验的输入 —— 将人们放置在 AR 的中心。</p><h4 id="Simultaneous-Front-and-Back-Camera"><a href="#Simultaneous-Front-and-Back-Camera" class="headerlink" title="Simultaneous Front and Back Camera"></a>Simultaneous Front and Back Camera</h4><p>现在，你可以在前置和后置摄像头上同时使用人脸和世界跟踪。例如，用户可以只使用他们的脸部，与后置摄像头的 AR 内容交互。</p><h4 id="Multiple-Face-Tracking"><a href="#Multiple-Face-Tracking" class="headerlink" title="Multiple Face Tracking"></a>Multiple Face Tracking</h4><p>现在 ARKit 人脸跟踪可以一次跟踪最多三张人脸，使用 iPhone X, iPhone XS, iPhone XS Max, iPhone XR 和 iPad Pro 的 TrueDepth 摄像头。该摄像头为 Memoji 和 Snapchat 等前置摄像头的体验提供能力。</p><h4 id="Collaborative-Sessions"><a href="#Collaborative-Sessions" class="headerlink" title="Collaborative Sessions"></a>Collaborative Sessions</h4><p>通过多人之间的实时协作会话，您可以构建一个协作的 world map，让您更快地开发 AR 体验，让用户像进入多人游戏一样，更快地进入共享的 AR 体验。</p><h4 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h4><p>一次检测多达 100 幅图像，并自动地估计图像的物理大小。3D 对象检测更加稳定，因为对象在复杂环境中可以更好地被识别。现在，机器学习被用来更快地检测环境中的平面。</p><h2 id="Reality-Composer"><a href="#Reality-Composer" class="headerlink" title="Reality Composer"></a>Reality Composer</h2><p>Reality Composer 是一款针对 iOS 和 Mac 的功能强大的新应用，可以轻松创建交互式 AR 体验，而无需 3D 经验。可以使用 live linking ，在您的 Mac、iPhone 和 iPad 之间无缝地移动。 RealityKit 是一个全新的高级框架，包含 photo-realistic 渲染、相机特效、动画、物理等功能，专为 AR 而构建。</p><p>现在，任何人都可以快速地原型化和制作 AR 体验的内容，这些内容可以使用 Xcode 集成到应用程序中或者导出到 AR Quick Look 。Reality Composer 让您在 iOS 和 Mac 上构建动画和交互，以丰富您的 3D 内容。</p><h4 id="Built-in-AR-Library"><a href="#Built-in-AR-Library" class="headerlink" title="Built-in AR Library"></a>Built-in AR Library</h4><p>导入您自己的 USDZ 文件，或者利用内置 AR 库中数百个现成的虚拟对象。该库为各种 assets 利用 procedural content generation ，您可以自定义虚拟对象的大小、样式等。</p><h4 id="Animations-and-Audio"><a href="#Animations-and-Audio" class="headerlink" title="Animations and Audio"></a>Animations and Audio</h4><p>增加移动、缩放等动画，比如虚拟对象的 “摆动” 或 “旋转”。当用户点击对象、靠近对象或触发其他触发器，您可以选择要进行的操作。您还可以利用 spatial audio 为您的 AR 场景添加真实感。</p><h4 id="Seamless-Tools"><a href="#Seamless-Tools" class="headerlink" title="Seamless Tools"></a>Seamless Tools</h4><p>Reality Composer 被包含在 Xcode ，也是一款 iOS APP 。因此您可以在 iPhone 或 iPad 上 build 、 test 、 tune 和模拟 AR 体验。利用 live linking ，您可以在 Mac 和 iOS 之间快速切换，创建吸引人的复杂的 AR 体验。</p><h4 id="Record-and-Play"><a href="#Record-and-Play" class="headerlink" title="Record and Play"></a>Record and Play</h4><p>有了 iOS 版的 Reality Composer，您可以记录 AR 体验运行位置的传感器和摄像机数据，然后在构建 APP 时在 iOS 上播放这些数据。</p><h2 id="RealityKit"><a href="#RealityKit" class="headerlink" title="RealityKit"></a>RealityKit</h2><p>这个全新的高级框架是从头开始创建的，专门用于 AR ，包括 photo-realistic 渲染、相机特效、动画、物理等等。它还有一个 Swift API 。使用集成的 ARKit 、基于物理的渲染、变换和骨骼动画、 spatial audio 和刚体物理， RealityKit 使 AR 开发比以往任何时候都更快、更容易。</p><h4 id="World-class-Rendering-RealityKit"><a href="#World-class-Rendering-RealityKit" class="headerlink" title="World-class Rendering RealityKit"></a>World-class Rendering RealityKit</h4><p>使用基于物理的真实材质、环境反射、 grounding shadows 、 camera noise 、 motion blur 等，将虚拟内容与现实世界无缝融合，使虚拟内容与现实世界几乎无法区分。</p><h4 id="Scalable-Performance"><a href="#Scalable-Performance" class="headerlink" title="Scalable Performance"></a>Scalable Performance</h4><p>RealityKit 利用最新的 Metal 特性充分利用 GPU ，充分利用 CPU 缓存和多核，提供难以置信的流畅的视觉效果和物理模拟。因为它自动地伸展每个 iOS 设备的 AR 体验的性能，所以您只需要创建一个 AR 体验。</p><h4 id="Swift-API"><a href="#Swift-API" class="headerlink" title="Swift API"></a>Swift API</h4><p>容易使用但功能强大的 RealityKit 使用 Swift 丰富的语言特性并提供完整的功能。因此您可以更快地构建增强现实体验，而无需抄模板代码。</p><h4 id="Shared-AR-Experiences"><a href="#Shared-AR-Experiences" class="headerlink" title="Shared AR Experiences"></a>Shared AR Experiences</h4><p>RealityKit 使网络开发工作变得简单，例如保持一致的状态、优化网络流量、处理数据包丢失或 performing ownership transfers 。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关键技术&quot;&gt;&lt;a href=&quot;#关键技术&quot; class=&quot;headerlink&quot; title=&quot;关键技术&quot;&gt;&lt;/a&gt;关键技术&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;运动跟踪 (motion tracking)&lt;/strong&gt; 使得手机理解和追踪它相对于世界的
      
    
    </summary>
    
    
      <category term="computer-tech" scheme="https://theinfinitegame.tech/categories/computer-tech/"/>
    
    
      <category term="AR" scheme="https://theinfinitegame.tech/tags/AR/"/>
    
      <category term="ARKit" scheme="https://theinfinitegame.tech/tags/ARKit/"/>
    
  </entry>
  
  <entry>
    <title>计算方法 02 | 科学的起源</title>
    <link href="https://theinfinitegame.tech/social-science/quantitative-method-origin/"/>
    <id>https://theinfinitegame.tech/social-science/quantitative-method-origin/</id>
    <published>2020-02-08T06:15:52.000Z</published>
    <updated>2020-02-26T10:15:16.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="古典时期-Classical-Period"><a href="#古典时期-Classical-Period" class="headerlink" title="古典时期 (Classical Period)"></a>古典时期 (Classical Period)</h1><p>最早寻求事物的自然或俗世解释而非神的解释的思想家，是古希腊学者泰勒斯 (Thales)、毕达哥拉斯 (Pythagoras) 和德谟克利特 (Democritus) 等人。但最先思考如何获得知识的 是两千三百多年前的柏拉图 (Plato) 和亚里士多德 (Aristotle) 。</p><p>对柏拉图来说，外部世界及其中的事物，只是它们理想形式的不完美投射或影子。这些理想形式往往被描绘成在墙上投下影子。</p><p><img src="/images/sci-ori_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>柏拉图是一个 <strong>哲学实在论者 (philosophical realist)</strong> 。他认为 <strong>现实 (reality)</strong> 即理想世界，是独立于人的思想之外存在的。对他来说，这些理想并非只是我们心中的抽象概念，它们真实存在，但独立于物质世界之外。</p><p>他认为既然我们看到的物质世界是真实的 <em>不完美投射 (imperfect reflection)</em> ，我们就不能从感官经历中认识到 <strong>现实的本质 (the true nature of reality)</strong> 。他坚信理想形式的知识只能通过推理论证获得。所以柏拉图被称为 <strong>理性主义者 (rationalist)</strong> 。</p><p>他的学生亚里士多德也是个实在论者。他认为现实独立存在于人类的思想之外。但对亚里士多德来说，现实就是物质世界，没有单独的抽象形象存在。在如何了解事物本质上，他也与柏拉图意见相左。亚里士多德是 <strong>经验主义者 (empiricist)</strong> 。他认为感官经验准确地代表了现实。所以我们可以用感官去理解现实。他认为，归根结底知识来源于观察。但这并不意味着他仅对观察感兴趣，他依然将推理论证视作了解和解释自然的最佳方式。事实上，他建立了 <strong>形式逻辑 (formal logic)</strong> ，更确切地说是 <strong>三段论 (syllogism)</strong> 。</p><p><img src="/images/sci-ori_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>这有一个三段论的例子。</p><blockquote><p>“所有人都会死去，而所有希腊人都是人类，因此所有希腊人都会死。”</p></blockquote><p>如果两个前提为真，那么结论必然为真。把此结论当作新三段论的前提，我们就能积累知识。但这只在前提确实为真的情况下成立。看看这个：</p><blockquote><p>“所有哺乳动物都长毛，而猫都是哺乳动物，所以猫全都长毛。”</p></blockquote><p>第一个前提是错的，这就意味着结论不一定对，不是积累知识的好基础。</p><p>那么如何确保前提是正确的呢？你可以用另一个三段论来证明它。但当然你需要不停地证明这些前提，有一套你认为毫无争议的初始前提。亚里士多德认为，这些 <strong>基础前提 (fundamental premises)</strong> ，可以通过观察世界的基本形式或规律来决定。不巧他并未意识到他的某些观察选择性太强，导致一些基础前提在我们现在看来错得彻彻底底。比如，以他的观察为依据，昆虫有四条腿，男人比女人的牙齿多。</p><p>亚里士多德可能看到蜉蝣用四条腿走路得出了这个结论，但实际上蜉蝣与其他昆虫一样都有六条腿。也有可能他检查了自己和那些男性朋友的牙齿，但只查看了女佣的牙齿，她们更有可能因为营养不良而牙齿变少。他并没有意识到这点，他的观察是不准确的。即便如此，他和柏拉图的观念仍在近两千年内占据了主流。直到 16 世纪末期，人们才意识到他们的观点是有缺陷的。</p><p><img src="/images/sci-ori_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>他们时代之后的科学方法是如何发展的呢？古希腊人有很多科技进步。比如，托勒密 (Ptolemy) 将行星运动描述为：地球位于宇宙的中心，静止不动；其他行星，包括太阳都沿着各自的小轨道绕地球运动。必须要加上这些大环套小环，才能解释行星有时逆行的奇怪现象。</p><p>托勒密的模型能进行准确的预测，但人们并不认为它描述了真实的行星运动，它只能解释现象。</p><p><img src="/images/sci-ori_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>希腊城邦消亡后，在罗马帝国的兴衰更替间，以及中世纪的最初几百年，几乎没有任何科学进展。柏拉图和之后亚里士多德的哲学观点一直是主流，直到 16 世纪末新的科学革命拉开了启蒙时代的序幕。</p><p>让我们来看看哪些进步最终引导了革命。</p><p>首先，阿拉伯和波斯学者比如伊本・哈桑 (Ibn al-Hasan) ，比鲁尼 (Al Biruni) 和伊本西纳 (Ibn Sina) 开始使用系统观察和实验。强调无偏见的观察，而不只是逻辑推理。之后，在前人的基础上，英国的格罗斯泰斯特 (Grosseteste) 和罗杰・培根 (Roger Bacon) 提倡使用归纳 (induction) 与演绎 (deduction) 。</p><p><strong>归纳 (Induction)</strong> ，即通过特定观察得到一般解释。 <strong>演绎 (Deduction)</strong> ，即用一般解释预测特定结果。</p><p>第三个重大发展是印刷机的发明，这为科学革命创造了极好的条件。更多学者的成果得到了广泛的传播，其中就包括哥白尼 (Copernicus) 的《天体运行论》(De Revolutionibus Orbium Coelestium) ，这是引领科学革命的第四个重大发展。在哥白尼的新行星运动模型中，行星包括地球都围绕太阳运动。这与当时的宗教教义不符，教会接受亚里士多德和托勒密的模型，即地球位于宇宙中心。很多历史学家认为，哥白尼不敢发表他的成果，因为他害怕教会会因为违背教义惩罚他。但他最终还是发表了他的新模型，但加上了给教皇的特别献词，声称如果托勒密能炮制一个轨道怪异且只能解释现象的模型，那么他也应该享有同等的自由。他暗示他的模型仅仅是个实用的模型，而不是确切的表述。</p><p>他是否真心相信这一点也不得而知，不久他就与世长辞了。在这之后 60 年都没有引发骚动。很多人认为，科学革命和启蒙时代由哥白尼而始，但其他人认为荣誉应该归于第一个拒绝向天主教低头，坚持认为日心说模型才是现实的真实描述的人。</p><p>这个人就是伽利略・伽利雷 (Galileo Galilei) 。</p><hr><h1 id="启发-Enlightenment"><a href="#启发-Enlightenment" class="headerlink" title="启发 (Enlightenment)"></a>启发 (Enlightenment)</h1><p>伽利略 (Galileo) 被认为是现代科学之父，因为他开始将科学从哲学、伦理学和神学中分离，这些原来都在天主教的严格管控之下。</p><p>有人已经默默拥护基于 <strong>观察和实验 (observation and experimentation)</strong> 的科学方法，而不是使用 <strong>神学推理 (theological reasoning)</strong>，但伽利略是第一个这样光明正大做的人<br>。他也反对亚里士多德的几个理论，这些理论被天主教视为教义。</p><p>例如，他驳斥了亚里士多德说重物落地比轻物更快的观点。伽利略用了思想实验来证明这个观点，表明除了观察，他也重视 <strong>逻辑推理 (logical reasoning)</strong> 。当然，他最出名的是质疑亚里士多德和托勒密有关地球是宇宙中心的观点。他支持哥白尼的日心，即太阳是宇宙中心。伽利略对金星进行了系统的观察，发现行星只有绕太阳转而不是绕地球转才说得通。</p><p>哥白尼认为，日心说模型恰恰解释了这个现象，说明该模型准确预测了我们对行星的观察，但他却说这模型并非反映物理现实。相反，伽利略却毫无顾忌地声称地球就是绕着太阳转的。</p><p>天主教不喜欢伽利略离经叛道的想法。他们对伽利略进行宗教审判，把他软禁起来直到去世。</p><p><img src="/images/sci-ori_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>发明笛卡尔坐标系的 勒内・笛卡尔 (René Descartes) 和伽利略是同一时代的。虽然笛卡尔也反对亚里士多德许多的观点，但他同意知识应当基于 <strong>第一原理 (First principle)</strong> 。因为他认为我们的感官和思想很容易被欺骗，他决定放弃所有哪怕只有一点点疑问的想法。一旦移除了所有的怀疑，就只剩下一点可以确定 —— 即他在思考，那么他一定存在。我思故我在。</p><p><img src="/images/sci-ori_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>他最终得出结论：我们只能用 <strong>推理 (reasoning)</strong> 来了解世界本质。</p><p>弗朗西斯・培根 (René Descartes) 和笛卡尔一样，认为科学知识应当基于第一原理。但和笛卡尔相反，培根坚持认为这只能通过 <strong>归纳法 (inductive methods)</strong> 。归纳法就是把对特定实例的观察，用于总结普遍规律或解释。假设我每次碰到的天鹅都是白色的，我就能归纳出普遍规律：所有天鹅都是白色的。培根相信，不仅仅是第一原理，所有的知识都只能用归纳法获取，也就是这种基于感官经验总结出解释的方法。这就是为什么他被视作 <strong>经验主义 (empiricism)</strong> 之父。经验主义就是关于经验或观察。</p><p>大卫・休谟 (René Descartes) 把经验主义发挥到了极致 —— 只接受感官数据为知识来源，且摈弃与直接观察结果不符的理论概念。他认为现实的本质只由物体的特征组成，而不是物体本身。经验主义的极端形式叫做 <strong>怀疑主义  (skepticism)</strong> 。我来给你举个例子，比如有个实物 —— 一只猫。什么使得这只猫能成为猫 是它的各种属性 它的尾巴、胡须、颜色、皮毛、体型。如果把组成猫的属性都移走，那剩下的是啥都没了，猫的本质埋藏在其特征中。</p><p>休谟也指出了归纳法的问题：即使持续反复观察一个现象，但也没法保证下一次观察到的和前一次相同。</p><p>至少在欧洲人的长期观念中，所有的天鹅目击记录都证明天鹅是白色的。直到在澳州发现黑天鹅后，才知道原来还有黑的。换句话说，即使再多的验证观察，也不能确实证明关于世界的科学命题是真的。所以如果你要求所有的知识都只能基于观察，那么你永远不能确定你知道些什么。</p><p>19 世纪初，部分是针对休谟的怀疑主义， <strong>德国唯心主义 (German Idealism)</strong> 的哲学运动流行起来。唯心主义者相信我们的精神构筑了现实，我们对世界的体验是精神的重构，因此科学探索应当专注于通过自身推理能获得什么。唯心主义者主要关注的问题是非物质的东西，像自我、上帝、本质、存在和因果，他们也因使用模糊和过度复杂的语言而受到强烈批评。</p><p>在十九世纪第二次工业革命前夕，科学家开始对唯心主义者的形而上学失去耐心。在科学、医药和技术飞速发展的时代，他们对存在本质的思考变得越来越没用。在 20 世纪初，一种新的科学哲学登上舞台，提议彻底返回经验主义，这项运动叫做 <strong>逻辑实证主义 (logical positivism)</strong> 。</p><hr><h1 id="现代科学-Modern-Science"><a href="#现代科学-Modern-Science" class="headerlink" title="现代科学 (Modern Science)"></a>现代科学 (Modern Science)</h1><p>第一次世界大战过后，由于不满于德国那群专注于知识的第一原理和世界的本质的唯心主义者的 <strong>形而上学 (metaphysics)</strong> ，一群数学家、科学家和哲学家组成了维也纳学派 (Vienna Circle)。</p><p>维也纳学派的成员，摩里茲・石里克 (Moritz Schlick)、奥托・诺伊拉特 (Otto Neurath) 和鲁道夫・卡纳普 (Rudolf Carnap) 认为唯心主义者关于自我存在的问题毫无意义，因为这些问题无法回答。他们提出了新的科学哲学思想 ——  <strong>逻辑实证主义 (Logical Positivism)</strong> 。它重新将科学定义成是研究对世界有意义的命题。那么，要使一个命题有意义，它必须可验证，也就是有验证标准。这意味着要能确定命题的真实性。</p><p>有意义的命题有两种： <strong>分析命题 (analytic statements)</strong> 和 <strong>综合命题 (synthetic statements)</strong> 。</p><p>分析命题会 <strong>同义反复 (tautological)</strong> ，一定是真的。比如说，单身汉未婚，所有正方形都有四条边。这些是 <strong>先验命题 (priori statements)</strong> ，如定义和纯逻辑命题。它们不取决于世界的状态，因此也不需要通过观察来验证。它们可以被运用在数学和逻辑中，分析命题的新组合可以用形式逻辑验证。</p><p>综合命题依存于世界的状态。比如说，所有单身汉都快乐和所有猫天生都有尾巴。这些命题是 <strong>后验的 (posteriori)</strong> —— 它们只能通过观察验证。逻辑实证主义者认为，这些命题应始终可公开研究。同时，命题不许提及无法观察的实体，如电子或重力，因为它们无法被直接观察到。如果命题提及了无法观察的实体 或不是同义反复的，或不合逻辑的，或经验上不可验证的，那么它就是无意义的。这样一来，形而上学、神学和伦理学之类的主题，就完美地从科学中被剔除了。</p><p>当然，源自观察的标准和验证无法处理归纳法问题。明确证明或验证一个命题的确切证据永远都不够。总有可能在未来发现矛盾的地方。所以就把验证标准的强度弱化了，只要求确认而不是验证就可以了。</p><p>另一个非常严格的规则也必须改变了 —— 不许提及无法观察的实体造成了大麻烦：像电子、重力和抑郁这种无法被直接观察，但它们在科学解释中是不可或缺的。</p><p>这些以及归纳法问题，使逻辑实证主义出现了一个更温和版本 —— <strong>逻辑经验主义 (logical empiricism)</strong> 。</p><p>卡尔・波普尔 (Karl Popper) 也被戏称为维也纳学派的官方反对者，是他们的主要批判者之一。他认为要区分命题是否有意义，应建立在 <strong>可证伪性 (falsification)</strong> 的标准上，而不是能否 <strong>证实 (verification)</strong> 。</p><p>他认为，我们永远不能用观察来确切验证或证明一个命题，但我们可以用与之矛盾的证据有力驳斥。他认为一个命题必须有可证伪性才有意义。他提出科学家应该积极进行冒险的实验，它们能把找到与假说矛盾的证据的可能性最大化。如果我们找到了这样的反面证据，就能从中找到改进假说的线索。 <strong>只有反面证据缺失时 该假说才能暂时成立。</strong></p><p>现在，威拉德・冯・奥曼・奎因 (Willard Van Orman Quine) 证明，这个标准也有问题。在杜恒 - 奎因论题 (Duhem-Quine thesis) 中，他认为没有假说能够被单独验证，总有 <strong>背景假设 (background assumptions)</strong> 和 <strong>辅助假设 (supporting hypotheses)</strong> 来支持。如果找到了反面证据，根据波普尔的理论，我们的科学解释是错的，应该被驳回。但根据奎因的理论，我们总可以驳回某个背景假设或辅助假说，而不是科学解释本身。这样就挽救了原始假说。</p><p>托马斯・库恩 (Thomas Kuhn) 指出，科学并非脱胎于验证或证伪原则的严格应用。如果数据与假设不符，假设不会被立刻驳回或修改，科学是在一定的框架或 <strong>范式 (paradigm)</strong> 内进行。建立的假说要适用这个范式，意外结果使假说需要修正。但只要其适合范式即可。但当越来也多的反面证据累积起来，危机就出现了 这就导致了 <strong>范式转换 (paradigm shift)</strong> 。新的范式被采用，然后循而往复。</p><p><img src="/images/sci-ori_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>即使变成较弱形式的逻辑经验主义，逻辑实证主义也不能从波普尔、奎因等人的批判中幸存。所以，我们发展出一种更实用的科学哲学。如今的科学家采用 <strong>假说 - 演绎法 (hypothetico-deductive method)</strong>，其结合了归纳和演绎的方法；要求可证伪性；仅在假说有临时支持时接受重复确认。</p><p><img src="/images/sci-ori_8.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>哲学层面上，很多科学家可能会喜欢巴斯・范・弗拉森的 <strong>建构经验主义 (constructive empiricism)</strong> ，其主张科学是为了产生基于大量经验的理论。知识需要观察，但不可观察的实体也是允许的。接受一个科学理论并不意味永远认同 —— 这是对世界的真实表述。建构经验主义者认为，只要在观察范围内，即可接受科学主张为真实。该命题是否真实代表了不可观察的实体，我们无需判断，这只是目前对观察结果的最佳解释，仅此而已。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;古典时期-Classical-Period&quot;&gt;&lt;a href=&quot;#古典时期-Classical-Period&quot; class=&quot;headerlink&quot; title=&quot;古典时期 (Classical Period)&quot;&gt;&lt;/a&gt;古典时期 (Classical Perio
      
    
    </summary>
    
    
      <category term="social-science" scheme="https://theinfinitegame.tech/categories/social-science/"/>
    
    
      <category term="计量方法" scheme="https://theinfinitegame.tech/tags/%E8%AE%A1%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    
      <category term="社会科学" scheme="https://theinfinitegame.tech/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计量方法 01 | 科学是什么？</title>
    <link href="https://theinfinitegame.tech/social-science/quantitative-methods-what-science-is/"/>
    <id>https://theinfinitegame.tech/social-science/quantitative-methods-what-science-is/</id>
    <published>2020-02-07T06:40:56.000Z</published>
    <updated>2020-02-26T09:40:38.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非科学的方法-Non-scientific-Methods"><a href="#非科学的方法-Non-scientific-Methods" class="headerlink" title="非科学的方法 (Non-scientific Methods)"></a>非科学的方法 (Non-scientific Methods)</h1><p>为了知道为什么我们需要科学方法，让我们来看看在日常生活中人们的认知基于什么。</p><p><img src="/images/non-sci_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>人们可能会基于 <strong>直觉 (intuition)</strong> 或 <strong>信念 (belief)</strong> 而认为某事是正确的。</p><p>让我们来看下我对我的猫 Misha 所拥有的坚定信念：我相信 Misha 在所有人中最爱我 —— 我就是知道他爱我胜过其他所有人，我能在内心深处感受到。那么这种信念算不算是知识的坚实基础？并不是，简单地相信某件事并不会让它成真。我们坚信不疑的事情可能最后被证明是假的。还有，如果有人持相反的观点会怎样？如果我的未婚夫认为 Misha 爱他多一些呢？</p><p><img src="/images/non-sci_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p><strong>仅仅通过较量我们的观点，是无法得出谁对谁错的。</strong></p><p>我们可以数每个观点的支持人数，然后得到一个大部分或是 <strong>一致同意的观点 (consensus)</strong> ，但是这也不能作为知识的坚实基础。仅因为大部分人认同某事是并不意味着它就是真的。几世纪以来，几乎人人都认为地球是平的，但结果证明他们错了 —— 地球是圆的。</p><p>另一个知识的来源就是 <strong>权威 (authority)</strong> 的观点。这也不是一个很好的来源。一些诸如政治领袖、专家、科学家等权威的观点，也只是一种观点。权威或许能接触到更多或更好的知识，但他们出于个人利益也会推动自己的观点被大众接受，他们的职业和名誉都依赖于此。假设我的未婚夫找到了一个懂猫语的人，那人声称 Misha 更爱我的未婚夫。当然我会对这一专业观点表示怀疑，尤其当他是受我未婚夫雇佣的时候。我可以找到我自己的猫咪专家来和未婚夫的猫语者打擂台。但这时我们又有两个相反的观点了 —— 我们需要的是 <strong>证据 (evidence)</strong> 。</p><p>那么我们该如何用证据来解决 Misha 更爱谁的争论呢？</p><p>假设我总是 <strong>观察 (observe)</strong> 到每次下班回家后 Misha 总会过来坐在我的腿上而不是我未婚夫的腿上。我就运用了对客观世界，也就是对下班后 Misha 坐谁的腿上的 <strong>观察 (ovservation)</strong> 来证明我说的 Misha 更爱我这个 <strong>命题 (statement)</strong> 。</p><p>以 <strong>随机观察 (casual observation)</strong> 取证得到的认识，比前面其他方法了解到的认识更有根据一些，但这仍然不够好。 <em>因为人们并不十分擅长观察</em> 。我们倾向于 <strong>选择性观察</strong> ，并且记住与我们观念相符的事情。比如我可能恰好忘记了， Misha 在早饭的时候总是坐在我未婚夫的腿上。</p><p>除了选择性知觉外还存在许多 <strong>偏见 (bias)</strong> ，会让随机观察成为一个棘手的认识来源。我们运用 <strong>逻辑 (logic)</strong> 的能力也是如此。 <strong>逻辑推理 (logical reasoning)</strong> 得出的认识看上去是有坚实基础的，但 <strong>非形式逻辑推理 (informal logical reasoning)</strong> 并不总是具有一致性。人们在日常生活中进行推理时，总会不停地出现 <strong>谬误 (fallacy)</strong> 或 <strong>逻辑矛盾 (logical inconsistency)</strong> 。</p><p><img src="/images/non-sci_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>如果想获得更准确的认识，确定我们对世界的解释是正确的，那就还需要点别的东西。我们不能依赖于主观的、无法证实的来源 —— 诸如信念、观点、舆论。我们也不能相信随机观察和非形式逻辑，因为它们可能被我们的信念严重扭曲。</p><p>我们需要 <strong>系统观察</strong> ，摒弃任何偏见，辅以一致的逻辑。换言之 我们需要 <strong>科学方法</strong> 。</p><hr><h1 id="科学方法-Scientific-Method"><a href="#科学方法-Scientific-Method" class="headerlink" title="科学方法 (Scientific Method)"></a>科学方法 (Scientific Method)</h1><p>当我们试图解释世上事物运行原理时，为了确保知识有效，我们需要科学方法，而不是依靠观点、信念、随意观察和非形式逻辑。它们都太主观且容易出错。</p><p>科学方法基于 <strong>系统观察 (systematic observation)</strong> 和 <strong>逻辑一致性 (consistent logic)</strong> 。使用科学方法，增加了我们得出正确解释的机率。同时，我们也可以通过科学方法鉴定 <strong>科学主张 (scientific claim)</strong> 、 <strong>假说 (hypothesis)</strong> ，以及鉴定在我们实证研究中用来支撑假说的那些 <strong>经验证据 (empirical evidence)</strong> 的说服力。</p><p>科学方法有六大原则科学方法有六大原则。如果我们的研究符合这些原则，就能归为科学研究。</p><p><img src="/images/sci-method_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>这个假说亦可以与其他科学论断一较高下，为我们的世界提供尽可能最好的解释。</p><p>第一条原则是：假说应该可以 <strong>在实证中检验 (empirically testable)</strong> ，即支持或反驳假说的经验证据、物证或观测结果都是可以收集的。</p><p>比如我假设家里的猫爱我多于我未婚夫。要实证检验这个假说，我们需要收集观察结果或数据。但如何观察这只猫对我们的喜爱程度呢？我们不能询问猫的看法。假设我们都认为猫是无法像人类那样表达爱意的，那就没什么好观察的了。所以这条假说不符合实证可检验的原则。</p><p>第二原则是：<strong>可重复性 (replicability)</strong> 。一项研究及其发现结果都应该具有可重复性。这意味着重复原研究是可以得到一致结果的。</p><p>如果预期结果只出现了一次，或出现次数极少，那这个结果可能只是巧合。如果一个假说能被重复确认，它会更为可靠。所以一项研究需要经受住重复和复制的考验。比如我说服未婚夫认同 “猫在谁腿上呆得久就更喜欢谁” 这个评判标准。现在我观察到这周猫趴在我腿上的时间，是它呆在未婚夫腿上时间的两倍。那意味着我的假说是正确的吗？猫咪就爱我多一点吗？如果接下来几周这个观察结果保持不变，那么我的假说就是靠谱的。但如果观察了一周这只猫就死了怎么办？如此一来我们就无法验证这个假说了，这个研究再也无法重复。</p><p>要验证结果是否可重复，我们必须按原研究的条件和过程进行重复。假如我们处理过程不同，于是得到了别的结果，这表明原研究不可重复吗？答案当然是否定的。重复失败可能是由于我们改变了程序。</p><p>第三原则是 <strong>客观性 (objectivity)</strong> ，指他人能自行重复该实验而无需求助原研究者。“客观” 的字面意思是谁来进行研究不重要。基于假说跟其程序的描述，每个人都应该得到相同的结论。因此研究者提出的假说、概念、程序应尽量客观。这要求清楚明确地定义所有研究元素，不给主观解释留任何余地。</p><p>假设我认为猫咪拿脸蹭我是示爱的表现，但我没有明确告诉我未婚夫这一条，那么我衡量爱意的程序就是主观的。即使我们同时对猫进行系统性观察，结果仍然会因观察者而异。较之我未婚夫，我会认为猫示爱次数更多。这个例子中的结论是主观的，因此不具有可比性，而我们经常对此毫无自觉。如果我们没有明确讨论并就示爱标志达成共识，那么我们的猫咪爱意衡量程序则不够客观。</p><p>第四原则是 <strong>透明性 (transparency)</strong> 。保持透明度与客观性原则密切相关。在科学界，不论是你的支持者还是批评者，任何人都应该可以重复得出你的结论。这要求研究者共享他们建立的假设 —— 如何定义概念、使用了什么研究程序，还有一切和进行精确复制相关的所有信息。</p><p>第五原则指出一个假说应该具有 <strong>可证伪性</strong> 。可证伪性是一个非常重要的原则。如果你能想象出一种情形会使观察与假说出现矛盾，那么它就是可证伪的。如果我们想不出有什么样的反例存在，那这个假说就不可能被推翻。</p><p>比如你问一个有坚定宗教信仰的人，有什么证据可以证明他们的信仰是虚假的？不管你提出什么样的反例，他们可能都要争辩。这些事实并不违背自己的忠诚信仰。这种仅源于纯信念的观点，比如宗教，是不属于科学范畴的。如果对任何形式的证据，该假说都不接受其为反例，那这个假说根本没有讨论意义，也不用再寻求证实，因为结论已经在那里了。</p><p>我们要讲的第六点也是最后的原则是 <strong>逻辑一致性 (logical consistency)</strong> 。一个假说应该保持逻辑上的一致或连贯。这是指假说不会有任何自相矛盾的地方。比如 ，一个支撑假说的子假设是否与假说冲突。</p><p>我们观察得出的结论也应该保持逻辑一致性。这就是说，在整个过程中，研究者对正面或反面证据的标准应该一致。</p><p>让我继续用猫的例子进行说明。我的假说是猫更爱我，所以预测他会在我腿上呆更久。但要是它趴在我未婚夫腿上更久呢？我会说猫能察觉到趴在我腿上让我不舒服，因为他爱我多一些所以照顾我情绪便趴得少了。显然，这就是逻辑不一致。为了让观察结果符合我的假说，我对观察结果进行了 “再解读”。顺便一提，这也会让我的假说无法证伪。不管猫是否常趴我腿上，我都会得出它爱我的结论。</p><p>总结一下，科学方法要求我们构造的假说为实证可检验的，这就是说观察结果可以支撑或反驳假说；可重复性，也就是假说是可以被重复测试的；客观性，指他人可以独立检验这个假说；透明性，指假说与结果都公之于人，以便他人检验；可证伪性，指找到反例的可能性是存在的。最后，逻辑一致性是指假说本身保持内在的一致性，支持或反驳假说的观察结论也应逻辑一致。</p><p>最后一点，科学方法只在态度端正的情况下才有效。为了提出更好的假说，研究者们应该对自己和他人的研究持批判态度，所以他们应该做到公开透明、乐于接受批判。如果别人有更好的解释，就放弃他们心爱的假说。如此，科学界才能像进化系统一样 —— 只有最合适、最可靠的假说存留下来。</p><hr><h1 id="科学主张-Scientific-Claims"><a href="#科学主张-Scientific-Claims" class="headerlink" title="科学主张 (Scientific Claims)"></a>科学主张 (Scientific Claims)</h1><p>我已经讲过了有关我们周围世界的命题、假说以及解释，我没有准确解释就用了这些通用术语。是时候阐明清楚了。</p><p>关于周遭世界的科学主张，可分为不同类别。一些科学主张会比别的主张描述或解释更多现象。同样，某些科学主张对于我们周围的世界，命题、假说以及解释提供了更可信的描述或解释。我们发现某些主张会更准确一些，比起别的来有更多证据支持。</p><p>在科学中，最基本的主张是 <strong>观察 (observation)</strong> 。观察可以是对世界准确或不准确的 <strong>表达（(representation)</strong> 。</p><p>假设我观察我的猫：姜黄色毛，重 6.5 公斤。大多数科学家会接受这个观察结果，作为我们周围世界某一方面较为准确的投射 —— 假设体重秤有效且可靠的。但就解释力度而言，他们会发现这个观察非常无趣 —— 观察本身没有很大信息量，它不能描述属性间的一般联系，无法解释任何事。</p><p>但这不表示观察不重要。观察是经验科学的基础，但是观察本身不是很有用，观察本身是最无趣的科学主张，因为它没什么解释能力。观察在确定或反驳假说时会变得有用。</p><p><strong>假说 (hypothesis)</strong> 是一种 <strong>命题 (hypothesis)</strong> ，它描述了 <strong>属性 (hypothesis)</strong> 间的 <strong>模式 (pattern)</strong> 或一般关系。假说也可以对它描述的模式进行解释。我们建立这样一个假说：姜黄色猫一般都会超重，概率比其他颜色的猫要高得多。我可以用解释来延伸这个假说，就是毛色和肥胖间的相关性。比如，通过证明控制姜黄毛色和发出饱腹信号的基因是连锁的。</p><p>假说的 <strong>可信度范围 (plausibility)</strong> 可以从非常不确定到非常确定。一个假说若是没有支持，那么它就是不确定的。比如这是个新且未经检验的假说。假说也能被很多实证研究强烈支持，从而变得更确定。</p><p><img src="/images/sci-claim_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>假设的一种特殊类型就是 <strong>定律 (law)</strong> ，定律是对 <strong>关系 (relation)</strong> 或模式非常精确的描述 —— 精确到总是能用 <strong>数学公式 (mathematical equations)</strong> 表达。它们通常被证明得很完整，所以它们如此精确。比如，我把猫食盆从 56 米高的地方扔下去，且我知道万有引力常数，然后用牛顿的万有引力定律就能很准确地预测这个碗掉到地上要花多长时间。</p><p>定律能做出很精确的预测 但它们通常不会解释其描述的关系。在这里，是距离、时间和重力之间的关系。当然，社会科学方面的定律很少能表达成公式。我们对个人和人群的了解还太少，还不能得到如此精度的固定行为模式，并用来推测出科学定律。</p><p><img src="/images/sci-claim_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>好，接下来我们来讲讲 <strong>“理论 (theory)”</strong> 的概念。在日常生活中，理论意味着 <strong>未被证明的 (unsubstantiated)</strong> 命题，有根据的猜想。但是在科学中，理论指的是许多相关现象的总体解释。在自然和行为科学中，理论由被经验证据强烈支持的各种假说构成。在社会科学中，更多的是定性研究和历史比较的方法。当理论经受住了逻辑上、历史上或定性分析的驳斥时，可以认为该理论高度可信。</p><p><img src="/images/sci-claim_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>在科学范畴里，理论的解释最为完善，是我们拥有的最接近准确的东西，因为它们由经科学方法审视并留存的假说构成。当然，这不意味着科学理论是确定或真实的。世上有许多证明完备的理论最终也被取代了，比如牛顿力学就为相对论让路了。 <strong>科学的世界里没有确定性，只有暂时的最佳解释 (provisional best explanation)。</strong></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;非科学的方法-Non-scientific-Methods&quot;&gt;&lt;a href=&quot;#非科学的方法-Non-scientific-Methods&quot; class=&quot;headerlink&quot; title=&quot;非科学的方法 (Non-scientific Methods)&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="social-science" scheme="https://theinfinitegame.tech/categories/social-science/"/>
    
    
      <category term="计量方法" scheme="https://theinfinitegame.tech/tags/%E8%AE%A1%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    
      <category term="社会科学" scheme="https://theinfinitegame.tech/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之二十三 | 第一类错误和第二类错误</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-type-i-and-type-ii-errors/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-type-i-and-type-ii-errors/</id>
    <published>2020-02-03T05:58:06.000Z</published>
    <updated>2020-02-03T13:46:55.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一类错误和第二类错误"><a href="#第一类错误和第二类错误" class="headerlink" title="第一类错误和第二类错误"></a>第一类错误和第二类错误</h1><p>回忆一下此前提到过的庭审的例子。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。</p><p>在审判时，有四种可能的结果。一，被告确实有罪且被判有罪，这是个正确的决定。二，被告确实无辜且被判无罪，这也是正确的决定。三，被告实际上是无辜的，但被判有罪，这是错误的决定。四，被告实际上有罪的，但是被判无罪，这也是错误的决定。</p><p>这也是我们在实施显著性检验时会发生的情况。辩方观点类似零假设为真，而被告有罪则等效于零假设为假。判被告有罪类似拒绝零假设，而无罪释放则等同于不拒绝零假设。这会导致四种可能的情形。其中的两种，你做了正确的决定，包括零假设的确为真并且你没有拒绝它以及零假设的确为假并且你拒绝了它。但也有两种你做了错误的决定，包括零假设为真而你拒绝了它以及零假设的确为假而你没有拒绝它。第一个错误我们称为 <strong>第一类错误 (type I error)</strong> ，或者说 <strong>伪阳性 (false positive)</strong> 。第个错误我们称为 <strong>第二类错误 (type II error)</strong> ，或者说 <strong>伪阴性 (false negative)</strong> 。</p><img src="/images/t1t2_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>让我给你举个例子。想象你的零假设是：美国的持证水肺潜水者总体， 50% 有超过 35 小时的潜水经验。换言之， $ \pi = 0.5 $ 。备选假设是它是另外一个百分比，换言之， $ \pi \neq 0.5 $ 。你问了一组简单随机抽样的 500 个美国潜水者，你发现有 0.56 的比例有超过 35 小时的潜水经验。现在，假定你的零假设实际上是真的，当你决定基于你的样本数据拒绝零假设时，一个第一类错误就出现了。 </p><img src="/images/t1t2_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><a id="more"></a><p>如果零假设为真，抽样分布是像下面这样的：</p><img src="/images/t1t2_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如果你的显著性水平 $ \alpha $ 等于 0.05 ，通过查询 z 表得到临界值是 -1.96 和 1.96 。你的检验统计量落在拒绝域内。换言之，你要拒绝零假设。这件事情发生的概率是 0.025 加上 0.025 ，等于 0.05 。意味着第一类错误发生的概率等于显著性水平。</p><img src="/images/t1t2_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>由此，你可能想到要降低显著性水平。</p><img src="/images/t1t2_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>但是，这不一定是个好主意。如果你在零假设实际为真时降低了错误地拒绝它的概率，你实际上增加了零假设实际为假而你错误地没有拒绝它的概率。 </p><img src="/images/t1t2_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>犯第二类错误的概率我们称为 $ \beta $ 。</p><img src="/images/t1t2_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>计算 $ \beta $ 相当复杂，它依赖各种因素，例如 $ \alpha $ 的值，样本容量以及参数的真实值。基于这个原因，我们并不会去计算 $ \beta $ 的值，但重要的是你需要意识到，当我们试图降低某一类错误的概率时，另一类错误的概率会上升。</p><img src="/images/t1t2_8.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>当零假设为假时，并且你实施了检验，你希望检验的 <strong>功效 (power)</strong> 是高的。检验的功效是拒绝零假设的概率，给定它为假，换言之，一个检验的功效等于 1 减去第二类错误的概率，也就是 $ 1 - \beta $ 。</p><img src="/images/t1t2_9.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>为什么功效这么重要呢？是这样的，当你要实施一项研究之前，它可以帮助你确定你需要多少的参与者。在你实施完研究之后，它能帮助你确定结论不是统计显著的。</p><p>最后一个提示，在实践中，你永远无从得知某个决定正确与否。我们唯一能做的是控制做出不正确决定的概率。</p><hr><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>想象你是一个对鲸鲨感兴趣的潜水者，你想要知道这些巨大的动物平均的身长有多少。我们还假设你已经花费了很多年在世界各地研究了这些生物。这些年你已经测量了 258 头鲸鲨。因为你已经测量了世界各地的鲸鲨，我们假定这 258 头鲸鲨可以被看作一个简单随机样本。平均的长度等于 8.3 米，样本标准差是 3.4 米，并且鲸鲨长度的分布也近似正态分布。</p><img src="/images/t1t2ex_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在这一节中，我们将检验三种备选假设和一种零假设：鲸鲨总体的长度均值等于 8 米。第一个假设是总体均值不是 8 米。第二个假设是均值大于 8 米，第三个假设是总体均值小于 8 米。所有这几种情况中，我们都把显著性水平设为 0.10 。 </p><img src="/images/t1t2ex_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>首先，我们得检查我们的假定。如我之前说过的，鲸鲨的选择可以看作是简单随机抽样，并且我们也看到鲸鲨身长的分布近似正态。因此，我们没有理由预期总体分布会和正态分布差异巨大。再者，这也不是个问题，因为我们的样本量相当大。 </p><p>现在，让我们计算检验统计量，它的值对于几个假设都是一样的，毕竟，样本均值和零假设一样。</p><img src="/images/t1t2ex_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>代入公式， 8.3 减去 8 ，除以 3.4 除以 258 的平方根，等于大约 1.42 。</p><p>现在，我们开始第一个备选假设，它断言总体均值不是 8 米。我们画出相关的抽样分布，并显示零假设的值。我们需要基于 0.01 的显著性水平做双尾检验，查询 t 表格得到临界值 -1.66 和 1.66 ，检验统计量等于 1.42 不在拒绝域内因为我们不拒绝零假设。这意味着基于 0.10 的显著性水平，我们不能得出总体均值不是 8 的结论。</p><img src="/images/t1t2ex_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>第二个备选假设是总体均值大于 8 。抽样分布一样，但这一次我们做右尾检验。查询 t 表格得临界值是 1.29 ，这一次检验统计量是落在拒绝域内。因此在这种情况下，我们拒绝零假设，并且下结论总体的均值的确大于 8 。</p><img src="/images/t1t2ex_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>最后的备选假设是总体均值小于 8 。在这种情况下，我们做左尾检验，它是右尾的镜像，所以相关的临界值是 -1.29 。现在我们的检验统计量是 1.42 ，对于临界值时一个极端值，但它在分布的另一边。这意味着，它也不在拒绝域内，因此我们也不拒绝零假设。</p><img src="/images/t1t2ex_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>最后的例子显示，画出抽样分布很重要。否则，你可能会无法注意到检验统计量相对于临界值处于分布的另一边。不论检验的结果如何，有两件事是可以确定的。第一，鲸鲨真的很大。第二，教程即将结束，我要放假啦～感谢阅读！</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一类错误和第二类错误&quot;&gt;&lt;a href=&quot;#第一类错误和第二类错误&quot; class=&quot;headerlink&quot; title=&quot;第一类错误和第二类错误&quot;&gt;&lt;/a&gt;第一类错误和第二类错误&lt;/h1&gt;&lt;p&gt;回忆一下此前提到过的庭审的例子。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。&lt;/p&gt;
&lt;p&gt;在审判时，有四种可能的结果。一，被告确实有罪且被判有罪，这是个正确的决定。二，被告确实无辜且被判无罪，这也是正确的决定。三，被告实际上是无辜的，但被判有罪，这是错误的决定。四，被告实际上有罪的，但是被判无罪，这也是错误的决定。&lt;/p&gt;
&lt;p&gt;这也是我们在实施显著性检验时会发生的情况。辩方观点类似零假设为真，而被告有罪则等效于零假设为假。判被告有罪类似拒绝零假设，而无罪释放则等同于不拒绝零假设。这会导致四种可能的情形。其中的两种，你做了正确的决定，包括零假设的确为真并且你没有拒绝它以及零假设的确为假并且你拒绝了它。但也有两种你做了错误的决定，包括零假设为真而你拒绝了它以及零假设的确为假而你没有拒绝它。第一个错误我们称为 &lt;strong&gt;第一类错误 (type I error)&lt;/strong&gt; ，或者说 &lt;strong&gt;伪阳性 (false positive)&lt;/strong&gt; 。第个错误我们称为 &lt;strong&gt;第二类错误 (type II error)&lt;/strong&gt; ，或者说 &lt;strong&gt;伪阴性 (false negative)&lt;/strong&gt; 。&lt;/p&gt;
&lt;img src=&quot;/images/t1t2_1.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;让我给你举个例子。想象你的零假设是：美国的持证水肺潜水者总体， 50% 有超过 35 小时的潜水经验。换言之， $ \pi = 0.5 $ 。备选假设是它是另外一个百分比，换言之， $ \pi \neq 0.5 $ 。你问了一组简单随机抽样的 500 个美国潜水者，你发现有 0.56 的比例有超过 35 小时的潜水经验。现在，假定你的零假设实际上是真的，当你决定基于你的样本数据拒绝零假设时，一个第一类错误就出现了。 &lt;/p&gt;
&lt;img src=&quot;/images/t1t2_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之二十二 | 分步计划和置信区间</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-step-by-step-plan-and-ci/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-step-by-step-plan-and-ci/</id>
    <published>2020-02-03T01:47:28.000Z</published>
    <updated>2020-02-03T12:21:50.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分步计划"><a href="#分步计划" class="headerlink" title="分步计划"></a>分步计划</h1><p>比较以下两种期望。一，你期望超过半数的持证美国潜水者有超过 35 小时的潜水经验。二，所有持证美国潜水者的平均潜水时长超过 35 小时。第一眼，两个期望看起来很相似。但是，在第一个例子中，你面对的是比例，你感兴趣的是潜水经验超过 35 小时的潜水者的比例。而第二个例子中，你关心的是均值。你想知道潜水时长的均值。因此，当实施显著性检验时，你需要特别注意你的方法。</p><p>这一节中，我将以分布计划的方式来引导你。想象你问了一个容量是 500 个持证潜水者的简单随机样本，他们的潜水时长是多少个小时。假设你发现 0.57 的比例有超过 35 小时的潜水经验，时长均值是 35.5 小时，均值是 8 小时。在我们的样本中，<br>潜水经验的变量分布近似正态。下面是分布计划全图：</p><img src="/images/sbs_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>第一步，评估你面对的是比例还是均值，这个我们已经讨论过。第一个例子是比例，第二个例子是均值。</p><p>第二步，形式化你的假设。在比例的例子中，零假设是：$ \pi = \pi_0 $ ，在均值的例子中，零假设是 $ \mu = \mu_0 $ 。我们可以有三种类型的备选假设：如果你做双尾检验，是 $ \pi\neq\pi_0 $ 或者 $ \mu\neq\mu_0 $ ；如果你做单尾的右尾检验，是 $ \pi\geq\pi_0 $ 或者 $ \mu\geq\mu_0 $ ；如果你做单尾的左尾检验，是 $ \pi\leq\pi_0 $ ，$ \mu\leq\mu_0 $ 。我们零假设是： $ \pi=0.5,\mu=35 $ ，备选假设是 $ \pi\geq0.5,\mu\geq35 $ 。因此我们需要实施右尾检验。</p><p>第三步，检查你的假定是否满足。在两个例子中，随机化都是必要的。你的样本必须通过随机抽样的方法收集，或者说，随机化的实验。在比例的例子中，根据零假设的比例，样本容量乘以比例以及 1 减去样本容量再乘以比例，必须等于或者大于 15 。均值的例子则要求总体分布近似正态。但实践中，这一点只有样本容量很小，且做的是单尾检验时才重要。对于我们的例子，所有的假定都满足。</p><p>第四步，确定显著性水平 $ \alpha $ 。常用的显著性水平是 0.05 。我们的检验将基于 $ \alpha=0.05 $ 。</p><p>第五步，计算检验统计量。在比例的例子中，公式是 $ z = \frac {p-\pi_0}{se_0} , se_0 = \sqrt {\frac {\pi_0 (1-\pi_0)}{n}} $ ，在均值的例子中，公式是 $ t = \frac {\bar x-\mu_0}{se_0} , se_0 = \frac {s}{n} $ 。注意，在比例的案例中，我们使用 z 分布，而在均值的案例中，我们使用 t 分布。</p><p>第六步，抽取相关的抽样分布，展示零假设和检验统计量，补上拒绝域和对应的临界值。在比例的案例中，</p><p>第七步，评估你的检验统计量是否落在拒绝域内。</p><p>第八步，决定是否拒绝零假设。</p><p>第九步，解释你的发现。</p><p>在下结论之前，值得提醒的是，不拒绝零值假设并不暗含你就可以接受零值假设。在第二个例子中，我们不拒绝零值假设，即潜水时长等于 35 小时的假设，但并不能得出潜水时长就等于 35 小时的结论。</p><hr><h1 id="显著性检验和置信区间"><a href="#显著性检验和置信区间" class="headerlink" title="显著性检验和置信区间"></a>显著性检验和置信区间</h1><p>假设你问样本容量为 500 的水肺潜水者他们潜水了多少个小时，均值是 36 小时，标准差是 8 小时，变量的样本分布近似于正态。基于样本信息，你希望推断总体的参数 $ \mu $ ，这是我们所知的推断统计学 —— 基于样本信息得出样本所在总体的结论。  </p><p>推断统计学有两种方法。其一，通过均值的置信区间来推断区间估计。其二，用显著性检验来推断点估计。在这一节中，我将向你展示这两种方法其实关联密切。</p><img src="/images/sbs_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>假定你预期潜水时长的均值不是 35 小时，你将做一个显著性检验。我们对均值感兴趣，检验统计量如下：</p><img src="/images/sbs_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>零假设是： $ \mu = 35 $ ，备选假设是： $ \mu \neq 35 $ 。我们的假定满足，分析基于简单随机样本并且样本足够大，并且样本近似正态分布。检验统计量等于 36 减去 35 ，除以 8 除以 500 的平方根，等于 2.80 。抽样分布看起来是这样的。</p><img src="/images/sbs_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们可以通过查询 t 表找到对应双尾检验显著性水平 0.05 的临界点是 $ \pm1.984 $ 。因此我们的检验统计量落在拒绝域内。我们将拒绝零假设，得出潜水时长不等于 35 小时的结论。</p><p>现在，如果我们构造 95% 的置信区间，会发生什么呢？公式如下：样本均值，加减 95% 置信水平对应的 t 分数，乘以标准误差，这个标准误差等于标准差除以样本容量的平方根。相关的 t 分数是 1.984 ，代入公式，得到置信区间是 35.29 到 36.71 。由此我们有信心说，通过无限重复的抽样， 95% 的情况下区间会包含实际的总体均值。这个区间给了我们关于总体均值的一个有说服力的范围。和显著性测试一样，这个置信区间也告诉我们，总体的样本均值不是 35 。通常，双尾显著性检验的结果与置信区间的结果是一致的。</p><img src="/images/sbs_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>更准确的说，如果双尾显著性检验的 P 值等于或者小于 0.05 ，那么 95% 置信区间也不包含零假设的值。类似的，如果双尾检验的 P 值大于 0.05 ，那么 95% 置信区间将包含零假设的值。</p><img src="/images/sbs_5_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这听起来很合理，对吧？它以下图表示。你会看到，观察值 36 落在拒绝域内，而对应的置信区间也不包含零假设的总体均值。</p><img src="/images/sbs_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>现在假设观察到的均值是 35.5 ，而不是 36 ，这样的话，我们的检验统计量将变成 1.40 ，它不落在拒绝域内。我们因此不拒绝零假设，相似的，置信区间的两个端点编程 34.79 和 36.21 ，则包含了零假设的均值 35 。</p><img src="/images/sbs_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们可以有信息说，通过无限重复抽样， 95% 的情况区间会包含实际的总体均值。这意味着零假设有说服力，我们不该拒绝零假设。也说明了，构建置信区间的方法和双尾假设检验的方法虽然看起来不同，但是数学上是相关的，彼此一致。</p><img src="/images/sbs_8.jpg" width="68%" height="68%" style="margin: 10 auto;"><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分步计划&quot;&gt;&lt;a href=&quot;#分步计划&quot; class=&quot;headerlink&quot; title=&quot;分步计划&quot;&gt;&lt;/a&gt;分步计划&lt;/h1&gt;&lt;p&gt;比较以下两种期望。一，你期望超过半数的持证美国潜水者有超过 35 小时的潜水经验。二，所有持证美国潜水者的平均潜水时长超过 
      
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之二十一 | 假设检验和显著性检验</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-hypotheses-and-significance-test/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-hypotheses-and-significance-test/</id>
    <published>2020-02-02T05:57:35.000Z</published>
    <updated>2020-02-02T13:15:49.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h1><p>教程来到最后一个模块，很快我要放假了。明天我将背起行囊，出发去潜水。好吧，让我们再谨慎一点，我并不完全确定明天我能成行。我的航班可能延误，我可能睡过头误了航班，或者可能生病导致无法去潜水。总之，我期望明天出发，但我并不能完全地确定。或者说，不能 100% 确定。</p><p>当研究人员对于他们感兴趣的参数有所期待时，我们在讨论的是 <strong>统计假设 (statistical hypotheses)</strong> 。这一节将介绍统计假设。他们构成了 <strong>显著性检验 (significance testing)</strong> 方法中最主要的部分。一个统计假设，其实就是一个关于总体的期望。通常，假设会被形式化为一条对总体参数持有特定值或者落在特定范围的声明。这种声明是基于研究或者理论。基于样本的信息，我们评价一个假设靠谱与否。这个过程我们称为显著性检验，它是一种用样本数据来检验提前形式化的假设的方法。就像置信区间一样，显著性检验是一种推断统计学的方法。毕竟，我们也是用样本数据来推断关于总体参数的结论。</p><img src="/images/hypo_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们先来看 <strong>零假设检验 (null-hypothesis testing)</strong> ，在这种检验中，显著性检验基于两个假设， <strong>零假设 (null hypothesis)</strong> 和 <strong>备选假设 (alternative hypothesis)</strong> 。零假设以 $ H_0 $ 注记，备选假设以  $ H_a $ 注记。零假设断言你感兴趣的参数是某个特定值。它通常代表变量之间没有关联的情况，或者组与组之间没有差异的情况。它是一个当你的样本数据表明它不太可能发生时需要被拒绝的假设。而备选假设断言你感兴趣的参数落在另一个范围。通常，零假设和备选假设互斥。如果你做显著性测试，假设零假设为真，除非你的数据有很强的反面证据。</p><img src="/images/hypo_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>想象一个法庭的庭审。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。这正是显著性检验里发生的事情。辩护无辜相当于零假设，而有罪预期则等同于备选假设。</p><img src="/images/hypo_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在研究实践中，你对于参数的期望是以备选假设的方式出现，而零假设就是对立面，但它必须是一个单值，不能是一个范围。你只有在数据提供强力佐证时才能认定零假设成立。</p><img src="/images/hypo_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><a id="more"></a><p>举个例子，假设你有理由相信全体美国人中有 3% 有过水肺潜水的经历。那么这里的零假设和备选假设分别是什么呢？你的期望被视为备选假设。我们把它写下来， $ H_a:\pi\leq0.03 $ ，零假设是对立面，但必须表示为单一值，因此 $ H_0:\pi=0.03 $ 。</p><img src="/images/hypo_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>假设你对水肺潜水的最大深度很感兴趣。你有理由期望美国潜水者的最大潜水深度均值 <em>不是</em> 25 米。你的备选假设是 $ \mu\neq25 $ ，零假设是 $ \mu=25 $ 。很简单，不是吗？</p><img src="/images/hypo_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>记住这条：在显著性检验中，你总是假定你的零假设成立，如果你为备选假设找到足够的支撑，就拒绝零假设。如果你没有找到足够的证据，你就不能拒绝它。但没能拒绝零假设并不意味着零假设就是真的。你可以拿法庭的例子再回味一下。在庭审中，被告被假定无罪。如果有足够的证据证明他或者她有罪，则定罪。没有足够的证据，被告则不会被定罪。但这并不意味着你可以得出他或者她是无辜的结论。</p><!-- more --><h1 id="关于比例的检验"><a href="#关于比例的检验" class="headerlink" title="关于比例的检验"></a>关于比例的检验</h1><p>假定你对有多少美国人有过水肺潜水经历这个问题感兴趣，你也有理由相信少于 3% 的美国人有这种经历。这意味着你的备选假设是 $ \pi\leq0.03 $ ，你的零假设是 $ \pi=0.03 $ 。</p><p>这一节中，我们将学习如何在对比例感兴趣时实施显著性检验。我们是这样来实施检验的：先假定我们感兴趣的总体参数有某个值，在我们收集到来自总体的样本后估计这个值的可能性。因为我们看到是一个样本，所以聚焦在抽样分布。我们可以决定，比如给定总体比例是 0.03 时样本比例的抽样分布。看下图，我们这样来实施检验：评估标准差（因为面对的是抽样分布，所以是标准误差），样本观察到的比例远离总体比例，这个标准误差的数值我们称为 <strong>检验统计量 (test statistic)</strong> 。</p><img src="/images/tap_0.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>想象我们抽取了 1000 个美国人，受试者中有水肺潜水经历的人比例等于 0.02 。接下来，我们这么做：</p><img src="/images/tap_0_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>你看到一个样本比例的抽样分布，我们假定零值假设为真，总体比例确实等于 0.03 。那么一个样本比例为 0.02 的总体，有多大的可能性其比例真的是 0.03 呢？为了回答这个问题，我们计算检验统计量，或者说样本统计和假定的总体参数之间的偏移幅度。标准误差远离均值的数量用 z 分数表示，我们可以计算样本统计量距离总体均值有多少个 z 分数。 公式如下：</p><img src="/images/tap_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>先计算零假设的标准误差，它等于 0.03 乘以 0.97 再除以 1000 ，取平方根，大约是 0.005 。因为我们的检验统计量是 0.02 减去 0.03 ，除以 0.005 ，等于 -1.85 。这意味着当零假设为真时，我们的样本比例落在总体比例 1.85 个标准误差之下。 这是否足以拒绝零假设呢？</p><img src="/images/tap_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>基于这个信息，我们可以查询 z 表格，对应的概率值是 0.0322 ，这个概率值我们称为 <strong>P 值 (P-value)</strong> 。 P 值告诉我们，基于总体比例是 0.03 的前提，要找到一个比例是 0.02 的样本，可能性是很低的。但是否低到可以拒绝零假设了呢？这取决于我们选择 <strong>显著性水平 (significance level)</strong> 。在我们实施检验之前，我们需要决定 P 值要达到多小以拒绝零假设。最常用的显著性水平是 0.05 ，这时我们说样本提供了足够的证据拒绝零假设。我们的 P 值是 0.3222 ，小于 0.05 。所以如果我们把显著性水平设置在 0.05 ，我们需要拒绝零假设。这也被我们称为 <strong>拒绝域 (reject region)</strong> 。</p><img src="/images/tap_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>形成拒绝域边界的临界 z 值是 -1.64 ，你可以通过查询 z 表格得到它，它对应 0.05 概率的左尾。我们的检验统计量是 -1.85 ，落在拒绝域内。因此我们需要拒绝零假设，并且得出结论：美国有水肺潜水经历的人的比例低于 0.03 。我们说，这个结论是 <strong>统计显著的 (statistically significant)</strong> 。</p><img src="/images/tap_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在这个例子中，我们的检验基于备选假设是 $ \pi\leq0.03 $ 。因此，我们只聚焦在抽样分布的一边 —— 左边。这叫做 <strong>单尾检验 (one-tailed test)</strong> 。那如果我们的备选检验是 $ \pi\neq0.03 $ 呢？如果是那样的话，我们将不再只聚焦在分布的左边，而分布的两边。这种检验叫做 <strong>双尾检验 (two-tailed test)</strong> 。 </p><img src="/images/tap_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如果我们还是采用 0.05 作为显著性水平，这意味着左边对应的累积概率是 0.025 ，右边也是。同样可以查询 z 表得到，对应的拒绝域的临界点分别是 -1.96 和 1.96 。现在，我们的检验统计量 -1.85 不再落在拒绝域内，意味着我们不能再拒绝零假设 $ \pi = 0.03 $ 。这说明，选择单尾或者双尾检验，对于结论有重大的差别。实践中，双尾检验要常用的多。我的建议是，只有你有非常好的理论依据时才使用单尾检验。</p><p>现在，让我们来改变显著性水平，看看会发生什么。比如，我们可以显著性水平设置为 0.01 ，这意味着我们在 P 值小于 0.01 时拒绝零假设。如果做单尾检验， 0.01 的显著性水平对于 -2.33 。</p><img src="/images/tap_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在我们的例子中，检验统计量没有落在拒绝域，因此不拒绝零假设。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如你所见，选择单尾或者双尾检验，会强烈地改变结果。需要记住的是，大部分单尾或者双尾检验都是基于 0.05 的显著性水平。</p><img src="/images/tap_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><h1 id="关于均值的检验"><a href="#关于均值的检验" class="headerlink" title="关于均值的检验"></a>关于均值的检验</h1><p>你好奇潜水者会在水下待多长时间吗？这个时间取决于他们的氧气罐，经验，潜水深度以及许多其他因素。假设你有理由期望美国潜水者在携带平均水平的氧气罐下潜到平均深度，可以待在水下超过 60 分钟，并且假设你也接触到了 100 个有经验的美国水肺潜水者，测量了他们在携带平均水平的氧气罐待在平均深度下的时长。这个样本的均值是 62 分钟，标准差是 5 分钟。</p><p>你预期潜水者可以在水下待超过 60 分钟，这导致了下面这样一个零假设： $ \mu = 60 $ ，备选假设是 $ \mu\geq60 $ 。我们实施一个关于总体均值的显著性检验，抽样分布如下：</p><img src="/images/tam_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这是一个均值等于 60 的样本均值的抽样分布， 60 是零假设的值。那么基于这样一个总体，一个样本的均值等于 60 的可能性有多大呢？ 同样，为了回答这个问题，我们计算检验统计量，它是样本均值偏离总体均值的标准误差。你可能记得如何计算标准误差 —— 我们需要用总体的标准差，因为我们不知道这个值，需要用样本标准差估计。因为这隐含着额外的误差，我们引入 t 分布来取代 z 分布。</p><img src="/images/tam_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们的检验统计量是通过下面的公式计算：</p><img src="/images/tam_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>由样本均值减去零假设的均值，然后除以样本均值的标准误差。标准误差等于样本标准差除以样本容量的平方根。</p><p>我们先计算出标准误差， 5 除以 100 的平方根，得 0.5 。 62 减去 60 ，再除以 0.5 ，得到 4 。这是否足以拒绝零假设呢？仍然取决于显著性水平。让我们引入最常用的显著性水平 0.05 。做单尾检验，查询 t 表，临界值是 1.67 。</p><img src="/images/tam_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>注意到我们的自由度是 99 ，但表里向下最接近的是 60 ，我们需要查看 $ t_{90%} $ ，因为右尾累积概率 0.05 。你需要记住， $ t_{90%} $ 代表置信水平为 90% ，也就表示分布的两尾加起来有 10% ，左右尾各 0.05 。</p><p>结果如下，我们的检验统计量 4 落在拒绝域内，意味着我们需要拒绝总体均值是 60 分钟的零假设。</p><img src="/images/tam_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们可以总结，平均情况下，有经验的美国潜水者携带平均的氧气量潜到平均的深度，能够在水下待超过 60 分钟。如果我们的期望并不是超过 60 分钟，而是不等于 60 分钟呢？</p><img src="/images/tam_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这种情况下，我们做双尾检验。假设显著性水平设置为 0.01 ，左尾和右尾的累积概率分别为 0.005 。查表，对应的临界值分别为 -2.66 和 2.66 ，而我们的检验统计量是 4 。因此，我们还是要拒绝零假设，并对我们的发现做统计显著的结论。</p><img src="/images/tam_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>因为我们现在做了双尾检验，所以我们的临时结论现在变成了有经验的美国潜水者在携带平均氧气量，潜到平均深度后，能待在水下的平均时间不等于 60 分钟。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;假设&quot;&gt;&lt;a href=&quot;#假设&quot; class=&quot;headerlink&quot; title=&quot;假设&quot;&gt;&lt;/a&gt;假设&lt;/h1&gt;&lt;p&gt;教程来到最后一个模块，很快我要放假了。明天我将背起行囊，出发去潜水。好吧，让我们再谨慎一点，我并不完全确定明天我能成行。我的航班可能延误，我可能睡过头误了航班，或者可能生病导致无法去潜水。总之，我期望明天出发，但我并不能完全地确定。或者说，不能 100% 确定。&lt;/p&gt;
&lt;p&gt;当研究人员对于他们感兴趣的参数有所期待时，我们在讨论的是 &lt;strong&gt;统计假设 (statistical hypotheses)&lt;/strong&gt; 。这一节将介绍统计假设。他们构成了 &lt;strong&gt;显著性检验 (significance testing)&lt;/strong&gt; 方法中最主要的部分。一个统计假设，其实就是一个关于总体的期望。通常，假设会被形式化为一条对总体参数持有特定值或者落在特定范围的声明。这种声明是基于研究或者理论。基于样本的信息，我们评价一个假设靠谱与否。这个过程我们称为显著性检验，它是一种用样本数据来检验提前形式化的假设的方法。就像置信区间一样，显著性检验是一种推断统计学的方法。毕竟，我们也是用样本数据来推断关于总体参数的结论。&lt;/p&gt;
&lt;img src=&quot;/images/hypo_1.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;我们先来看 &lt;strong&gt;零假设检验 (null-hypothesis testing)&lt;/strong&gt; ，在这种检验中，显著性检验基于两个假设， &lt;strong&gt;零假设 (null hypothesis)&lt;/strong&gt; 和 &lt;strong&gt;备选假设 (alternative hypothesis)&lt;/strong&gt; 。零假设以 $ H_0 $ 注记，备选假设以  $ H_a $ 注记。零假设断言你感兴趣的参数是某个特定值。它通常代表变量之间没有关联的情况，或者组与组之间没有差异的情况。它是一个当你的样本数据表明它不太可能发生时需要被拒绝的假设。而备选假设断言你感兴趣的参数落在另一个范围。通常，零假设和备选假设互斥。如果你做显著性测试，假设零假设为真，除非你的数据有很强的反面证据。&lt;/p&gt;
&lt;img src=&quot;/images/hypo_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;想象一个法庭的庭审。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。这正是显著性检验里发生的事情。辩护无辜相当于零假设，而有罪预期则等同于备选假设。&lt;/p&gt;
&lt;img src=&quot;/images/hypo_3.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;在研究实践中，你对于参数的期望是以备选假设的方式出现，而零假设就是对立面，但它必须是一个单值，不能是一个范围。你只有在数据提供强力佐证时才能认定零假设成立。&lt;/p&gt;
&lt;img src=&quot;/images/hypo_4.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之二十 | 样本容量</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-sample-size/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-sample-size/</id>
    <published>2020-02-02T03:05:16.000Z</published>
    <updated>2020-02-02T03:43:13.026Z</updated>
    
    <content type="html"><![CDATA[<p>还是前面的新生儿父母睡觉减少时长的例子，由于我们无法去询问你家乡所有的年轻父母。我们采取简单随机抽样。一个很关键的问题是 —— 样本应该取多大。应该是 50 个就够了？或者 至少 300 个或者 1000 个？</p><p>这一节中，我们将分布讨论对均值和比例感兴趣的不同情况。</p><p>先从均值开始。样本容量主要取决于三个因素。首先是你想要的精度。记得吗，置信区间是通过点估计加减一个误差界限来得到的。你允许多大的误差界限，如果你希望它越小，那么你的样本容量就得越大。其次，你的样本容量还依赖你想要的置信水平。越大的置信水平，需要越大的样本容量。最后，数据的变异性也影响样本容量的选择。你的变量的标准差越大，你需要的样本容量也越大。公式如下：</p><p>$$ n = \frac {\sigma^2z^2}{m^2} $$</p><p>n 代表样本容量，m 代表误差界限，$ \sigma $ 代表总体的标准差， z 代表 z 分数。显而易见，你不知道总体的标准差，而且你还没抽取样本也不知道样本的标准差。所以，你需要利用 <strong>合理的猜测 (educated guess)</strong> 来估计一个值。</p><p>让我来演示这个过程是怎么样的。想象我们想要 95% 的置信水平，对应这个置信水平的 z 分数是 1.96 ，并且我不希望误差界限宽过 0.3 小时，就取 0.3 小时吧。现在我们可以填完这个公式的一部分了。现在我们需要对 $ \sigma $ 进行合理猜测了。如果已经存在这方面的研究而且你知道变量的标准差，可以简单地采纳这个标准差。但是，如果这样一个研究之前并未做过，就必须靠我们自己的猜测。我先假定某些父母根本没法睡，某些父母睡觉少于 5 个小时，并且父母们也不可能睡的比之前还多。因此，我们假定变量服从正态分布， 95% 的父母睡觉时间介于 0 到 5 个小时之间。均值是 2.5 小时，标准差是 1.25 小时。毕竟， 95% 是落在均值左右两个标准差范围内，两个标准差等于 2.5 ，那么一个标准差就是 1.25 。我们用这组数字完成公式，得到 66.69 ，取整，得出结论我们需要 67 个受试者。</p><p>对于比例感兴趣而不是均值的情况，也可以采取类似的方式。假设我们想知道新生儿在换尿布时便便的比例，我想要 99% 的置信水平，误差界限 0.10 。公式非常相似：</p><p>$$ n = \frac {p (1-p) z^2}{m^2} $$</p><p>m 是 0.10 ，z 可由查表得 2.58 ，它对应 99% 置信水平。我们不知道的是 p 。还是采用合理的猜测，或者采用一种被称为 <strong>安全方法 (safe approach)</strong> 的方式。你会发现 $ p (1-p) $ 的最大值是 0.25 ，它发生在 p = 0.5 的时候，于是我们用 p = 0.5 完成公式，0.5 乘以 0.5 乘以 2.58 的平方除以 0.10 的平方，得到 166.41 ，即 167 位受试者。</p><p>在理想世界中，你可以去寻求大样本，比如说 1000 位受试者或者更多。但是，在现实世界中，我们的时间有限，资源有限，无法抽取大样本。因此，计算所需的样本容量可以帮助我们把成本降到最低。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还是前面的新生儿父母睡觉减少时长的例子，由于我们无法去询问你家乡所有的年轻父母。我们采取简单随机抽样。一个很关键的问题是 —— 样本应该取多大。应该是 50 个就够了？或者 至少 300 个或者 1000 个？&lt;/p&gt;
&lt;p&gt;这一节中，我们将分布讨论对均值和比例感兴趣的不同
      
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之十九 | 比例的置信区间和置信水平</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-confidence-interval-for-proportion/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-confidence-interval-for-proportion/</id>
    <published>2020-02-02T02:28:44.000Z</published>
    <updated>2020-02-28T05:48:27.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比例的置信区间"><a href="#比例的置信区间" class="headerlink" title="比例的置信区间"></a>比例的置信区间</h1><p>在过去的几周中我认识到新生儿喜欢排便，频繁地排便。恰好我的女儿 Lois 尤其喜欢在特定的情况下排便 —— 在我给她换尿布的时候。我说真的，一旦她决定上厕所 (answer nature’s call) ，一上就是六次。是的，六次，发生在换尿布的过程中。</p><p><img src="/images/statistics_cip_1.jpg" width="33%" height="33%" style="margin: 10 auto;"></p><p>这正常吗？我不确定，但我知道我需要搞清楚。假定我随机问 100 个新生儿的父母，他们的宝宝是否喜欢在换尿布时排便。在这一节教程中，我会告诉你，如何基于这样一个研究，构建一个估计总体比例的置信区间。</p><p>假定我的 100 的受试者里有 17% 报告他们的宝宝喜欢在换尿布时排便， 83% 的受试者报告他们的宝宝不会这样做。我们由此得到一个 0.17 的比例，这个比例的新生儿父母的宝宝喜欢在换尿布时排便。当我们为比例构建置信区间时，我们引入样本比例的抽样分布。我们知道，只要样本足够大，这个抽样分布就是正态分布，并且均值等于总体比例 $\pi$ ，标准差 $\sigma<em>p$ 等于 $ \sqrt {\frac {\pi (1-\pi)}{n}} $ 。我们还知道，找到一个比例处于均值两个标准差范围内的样本的概率，同时也是总体的比例，是 0.95 。 更精确的说，如果我们对应概率的 z 分数，我们会得到 1.96 。这意味着我们有 95% 的机会确定我们的样本比例会落在总体比例 1.96 个标准差范围内，这被我们称为 <em>_误差界限 (margin of error)</em></em> 。我们用于计算 95% 置信区间的公式如下：</p><script type="math/tex; mode=display">p\pm1.96\sigma_p , \sigma_p = \sqrt {\frac {\pi (1-\pi)}{n}}</script><p>其中 1.96 是对应 95% 置信区间的 z 分数。所以上面的公式我们也可以写成：</p><script type="math/tex; mode=display">p\pm {Z_{95\%}}\sigma_p , \sigma_p = \sqrt {\frac {\pi (1-\pi)}{n}}</script><p>我们这里讨论的是 95% 的置信区间，意味着如果我们能从总体抽取无限多的样本，那么 95% 的情况下，我们的置信区间会包含总体比例 $\pi$ 。不过，你可能注意到，我们并不知道总体比例 $\pi$ 的值，所以就无从计算样本比例的抽样分布的标准差。因此，我们用一个估计值来代替总体参数 $\pi$ ，这个估计值来自样本统计量， $P$ ，由此得到下面的公式：</p><script type="math/tex; mode=display">p\pm {Z_{95\%}}(se) , se = \sqrt {\frac {p (1-p)}{n}}</script><p>就像我们为均值构建置信区间时一样，我们称这个估计的标准差为 <strong>标准误差 (standard error)</strong> ，又称为标准误。 作为与均值的置信区间的对比，在构建比例的置信区间时，我们并不使用 t 分布。不过，你的数据需要满足一个必要的假定。你必须要有至少 15 个成功和 15 个失败。换言之， $np \geq 15$ 并且 $n (1-p) \geq 15$ 。如果不满足，那 你就不能基于上面的公式计算置信区间。现在回到例子，我们有 0.17 的比例报告宝宝在换尿布时排便。公式如下：</p><script type="math/tex; mode=display">p\pm {Z_{95\%}}(se) , se = \sqrt {\frac {p (1-p)}{n}}</script><p>让我们先计算标准误差。0.17 乘以 0.83 ，除以 100 ，然后取平方根，结果是 0.038 。误差界限等于 1.96 乘以 0.038 ，约定于 0.07 。 0.17 减去 0.07 等于 0.10 ，0.17 加上 0.07 等于 0.24 。因此我们的置信区间是 0.10 到 0.24 。这意味着我们有 95% 的信心说，总体比例落在 0.10 到 0.24 之间。或者说，如果我们能抽取无限多容量为 100 的样本，那么对于每个样本我们计算这个误差界限下的置信区间，有 95% 的情况这个区间会包含总体的比例。这个 95% 置信区间说明，大部分宝宝并不喜欢在换尿布时排便。但另一方面，如果他们确实在这个时候排便了，也并奇怪。我们有 95% 的信心说有 10% 到 24% 的宝宝确实会在换尿布时排便。</p><hr><h1 id="置信水平"><a href="#置信水平" class="headerlink" title="置信水平"></a>置信水平</h1><p>95% 的置信区间，告诉我们对于我们的点估计有 95% 的可信度，这个点估计可以是均值或者比例。或者说，如果能够抽取无限多的样本，近似于我们当前的样本，对所有的样本基于相同的误差界限计算 95% 的置信区间。那么 95% 的情况下，总体的参数值回落在这个置信区间内。同时也意味着， 5% 的情况，这个方法会产生一个不包含实际总体参数的区间。</p><p>如果你希望减少错误推断的可能性，你可以诉诸更大的置信区间，比如说 99% 。这一节中，我将向你演示如何改变置信水平，以及这么做会带来什么结果。</p><p>99% 置信区间和 95% 置信区间的唯一区别是不同的 z 分数，通过查询 z 表，代入公式，最终我们算得 99% 置信区间是 0.07 到 0.27 。对于 90% 的置信区间，结果是 0.11 到 0.23 。</p><p>我以图形演示，你会看到，更高的置信水平导致更宽的置信区间。换言之，我们想获得可信度越高的推断，那么就要接受更宽的误差界限。因此，我们需要在可信度和精度之间折中。在多数情况下，我们采用 95% 置信区间。</p><p><img src="/images/statistics_cil.jpg" width="33%" height="33%" style="margin: 10 auto;"></p><p>这个原理同样适用于均值的置信区间，区别在于在比例中，我们查询相关的 z 分数而在均值的案例中，我们查询相关的 t 分数，并且均值的计算中还要用到自由度，即 n 减去 1 。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;比例的置信区间&quot;&gt;&lt;a href=&quot;#比例的置信区间&quot; class=&quot;headerlink&quot; title=&quot;比例的置信区间&quot;&gt;&lt;/a&gt;比例的置信区间&lt;/h1&gt;&lt;p&gt;在过去的几周中我认识到新生儿喜欢排便，频繁地排便。恰好我的女儿 Lois 尤其喜欢在特定的情况下排便
      
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之十八 | 均值的推断和置信区间</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-inference-and-confidence-interval/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-inference-and-confidence-interval/</id>
    <published>2020-02-01T03:03:48.000Z</published>
    <updated>2020-02-27T09:08:54.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统计推断"><a href="#统计推断" class="headerlink" title="统计推断"></a>统计推断</h1><p>这一节我们以睡眠为例。假设你通常每晚睡 8 个小时，你突然做了年轻爸爸或者年轻妈妈，你的睡眠时间减少到每晚 5 个小时，这意味着每晚减少 3 个小时，相当于每周 20 个小时，每年 1000 个小时，差不多 40 天。换言之，如果你家宝宝继续保持他 / 她的睡眠时间，一年之后你会比之前少睡 大约 40 天。</p><p>回到统计学，想象你想要知道你家乡的年轻父母在孩子刚出生那一年减少了多少睡眠。在这一节中我们将讨论统计推断。我们会基于样本信息，得出关于总体的结论。我们将会区分两种统计推断的方法，一种叫 <strong>统计估计 (statistical estimation)</strong> ，另一种叫 <strong>假设检验 (hypothesis testing)</strong> 。在这篇教程中，我们将先了解统计估计。 </p><p>有两种方式估计总体参数的值，其一叫 <strong>点估计 (point estimate)</strong> ，它是一个对于总体参数的最佳猜想。其二是 <strong>区间估计 (interval estimate)</strong> ，它是一个我们预期参数会落在的范围。 </p><p>想象我们抽取了 60 个受试者样本，有了第一个小孩后每晚减少的睡眠小时数均值为 2.6 小时。这个均值是一个对于总体均值很好的点估计。换言之，$ \bar x $ ，是一个对于 $ \mu $ 的很好的点估计。不过，单一的点估计无法告诉我们估计是否接近我们感兴趣的总体参数。因此，研究人员通常还希望知道点估计可能的准确度。他们借由计算区间估计来显示这种准确度。</p><p>区间估计是一个最有可能包含总体实际参数值的数字区间。基于我们的样本均值 2.6 小时，我们可以预测，比如说，你家乡新生儿父母每晚睡眠减少的平均小时数介于 2.3 小时到 2.9 小时之间。</p><p>这个区间包含总体参数值的概率，被我们称为 <strong>置信水平 (confidence level)</strong> ，置信水平总是一个接近 1 的值，多数情况下是 0.95 。接下来我们将讨论有 95% 置信水平的区间。</p><a id="more"></a><hr><h1 id="已知总体标准差，求均值的置信区间"><a href="#已知总体标准差，求均值的置信区间" class="headerlink" title="已知总体标准差，求均值的置信区间"></a>已知总体标准差，求均值的置信区间</h1><p>假设我们知道 60 个年轻父母的样本在第一个小孩出生后睡眠减少小时数的标准差是 0.9 小时，也知道总体的标准差是 1.1 小时。（实践中，不太可能知道这个参数，但这里我们先假定你知道）</p><p>这一节中，我们将学习如何基于样本信息和总体的标准差来构造 <strong>置信区间 (confidence interval)</strong> 。首先，我们来解释一下这样一个置信区间应该如何解读。</p><p>为了构造一个置信区间，我们需要用到样本均值的抽样分布。毕竟，我们是在处理一个来自总体的样本。 我们知道，只要样本足够大，抽样分布就是正态分布的，并且均值等于总体的均值，标准差等于总体的标准差除以样本数 n 的平方根。我们还知道，找到距离样本均值少于等于两个标准差的概率是 0.95 。更精确的，如果查询对应概率的 z 分数，我们会得到 -1.96 和 1.96 。</p><p>这意味着我们有 95% 的机会令样本均值落在总体均值 1.96 个标准差范围内。 1.96 个标准差的距离我们称为 <strong>误差界限 (margin error)</strong> 。误差界限告诉我们用样本均值 $ \bar x $ 估计总体均值的准确程度。 95% 置信区间的公式如下：</p><p><img src="/images/ci_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>它是由点估计或者样本均值加减误差界限，即 1.96 个标准差。注意我们是在处理样本均值的抽样分布。因此分布的标准差等于 $ \frac {\sigma}{\sqrt {n}} $ 。接下来请集中注意力，因为过程会有点复杂。 </p><p>假设你抽取一个样本，样本均值由某个点表示，从均值往两侧有一根线表示误差界限。它们一起构成了 95% 的置信区间。如果样本均值落在红色区域，则置信区间包含总体均值 $ \mu $ 。如果样本均值不落在红色区域，则置信区间不包含总体均值 $ \mu $ 。我们讨论的是 95% 的置信区间，这意味着随机选择一个样本，它包含总体均值的概率是 0.95 ，不包含总体均值的 0.05 。换言之，如果我们抽取无限多个样本， 95% 的情况，我们的置信区间会包含总体的均值。</p><p>现在让我们回到例子。例子中样本均值是 2.6 小时。总体标准差 1.1 。样本容量是 60 ，现在我们有了计算置信区间需要的全部数字。公式如下：</p><script type="math/tex; mode=display">\bar x\pm1.96\sigma_{\bar x}</script><p>我们知道 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ ，即 $ \frac {1.1}{\sqrt {60}} $ ，得到 0.142 。接下来计算误差界限， 1.96 乘以 0.142 ，约等于 0.28 。样本均值等于 2.6 ，因此 95% 置信区间是 2.6 减去 0.28 到 2.6 加上 0.28 的区间，即 2.32 到 2.88 。我们可以说，我们有 95% 的信心确定这个区间包含了实际的总体均值。更精确地说，如果我们从总体中抽取无限多个大小为 60 的样本，并且对于每个样本，我们计算误差界限， 95% 的情况下，总体的均值会落在样本的置信区间内。</p><p><img src="/images/ci_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>如果新生儿父母的这种境况会持续一年，我们有 95% 的信息说，这些人会减少 2.32 乘以 365 小时到 2.88 乘以 365 小时的睡眠时间，或者说， 846.8 小时到 1,051.2 小时，又或者说， 35.3 到 43.8 个整天。</p><hr><h1 id="未知总体标准差，求均值的置信区间"><a href="#未知总体标准差，求均值的置信区间" class="headerlink" title="未知总体标准差，求均值的置信区间"></a>未知总体标准差，求均值的置信区间</h1><p>95% 置信区间用于评估总体的均值，它告诉我们我们有 95% 的信息这个区间包含实际的总体均值。利用这个公式 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ ，你可以计算区间的两个端点。这个公式有一个问题，为了计算置信区间，你需要知道总体的标准差。然而，我们通常并不知道这个参数。毕竟，我们本来就在用样本推测总体的参数。</p><p>这一节中，我们将学习如何在不知道总体参数的情况下做出推断。解决方案是我们估计总体的标准差，因而我们要引入另一个分布，它叫 <strong>T 分布</strong> 。让我来告诉它如何工作。</p><p>想象我们问了 60 个年轻家庭他们在有了第一个孩子之后睡眠时间少了多少个小时，均值是 2.6 小时，标准差是 0.9 小时。为了构建一个 95% 的置信区间，我们需要用到 $\bar x\pm1.96 \sigma<em>{\bar x}$ ，<br>或者可以写成 $\bar x\pm {Z</em>{95 \%}} \sigma_{\bar x}$ 。这一次，我们不知道总体的标准差。</p><p><img src="/images/ci_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>因此我们用样本的标准差来估计总体的标准差，公式变成: $\bar x\pm {Z_{95 \%}} s_e$ ，其中 $ s_e = \frac {s}{\sqrt {n}} $</p><p><img src="/images/ci_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>我们把 $ se $ 这个估计的抽样分布的标准差称为 <strong>标准误差 (standard error)</strong> 。但是因为我们现在是估计标准差，所以我们在计算中引入了额外的误差。基于此，我们引入另一个分布， z 分布。由于额外的误差，我们现在使用 T 分布，公式如下。</p><p>$\bar x\pm {t_{95 \%}} se$</p><p><img src="/images/ci_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>现在让我来详细解释 t 分布和 t 分数。 t 分布跟标准正态分布非常之相似，它是钟形的，对称的，并且均值是 0 。但是，它有一点点区别。 因为我们现在是估计抽样分布的标准差，我们引入了额外的误差。当我们的样本比较小时，这个误差很可观。 t 分布将这小样本的这个误差考虑在内了，因此它比标准正态分布稍微宽一点，标准差更大一些。如下：</p><p><img src="/images/ci_5_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>黑色的分布是标准正态分布，蓝色的分布是 t 分布。 t 分布的准确形状取决于样本容量。样本越大，t 分布越接近标准正态分布。更准确的说， t 分布的形状取决于单一个参数，我们称为 <strong>自由度 (degrees of freedom)</strong> ，以 $ df $ 注记。 t 分布中的自由度等于样本容量 n - 1 。这意味着我们实际上有许多不同的 t 分布，每一个都有单独的 $ df $。比如，自由度为 2 的 t 分布：</p><p><img src="/images/ci_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>自由度为 5 的 t 分布：</p><p><img src="/images/ci_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>自由度为 30 的 t 分布：</p><p><img src="/images/ci_8.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>可以看到，当我们有 30 或者更大自由度时， t 分布几乎就等同于标准正态分布。更准确的说，标准正态分布其实就是自由度等于无限的 t 分布。 </p><p><img src="/images/ci_9.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>同标准正态分布和 z 分数一样，我们也可以为特定的 t 分数寻找累积概率。重要的区别在于，这些概率依赖于自由度。当你计算一个 95% 置信区间时，你可以为所有可能的自由度找到对应 95% 置信水平的 t 分数，这个表格称为 <strong>t 表格</strong> ，它和 z 表格类似。</p><p><img src="/images/ci_10.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>让我用睡眠时间的例子来演示。样本中睡眠减少小时数的均值是 2.6 小时，标准差是 0.9 小时，样本容量是 60 。计算 95% 置信区间的公式：</p><p><img src="/images/ci_11.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>让我们从标准误差开始，它等于样本标准差除以 n 的平方根，即 0.9 除以 60 的平方根，得到 0.116 。我们的标准误差，或者说，估计的样本均值的抽样分布的标准差等于 0.116 。为了计算误差界限，我们需要用标准误差乘以 95% 置信区间的 t 分数。如你所知， t 分数取决于自由度。自由度 df 等于 n - 1 。我们有 60 个样本，因此 60-1 的 50 。在 t 表格中，我们在列中查找 95% 置信水平，在行中查找 59 自由度。因为表格中没有报告 59 自由度，我们向下取 50 自由度。对应的 t 分数是 2.009 。</p><p><img src="/images/ci_12.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>因此我们用 0.116 乘以 2.009 ，大约 0.23 。从样本均值 2.6 中加减这个值后，得到我们的置信区间是 2.37 到 2.83 。我们有 95% 的信心认为这个区间包含实际的总体均值。</p><p>为了计算总体均值的置信区间，有两个假定需要满足。首先，你的数据是随机获取的。换言之，样本必须是随机样本，否则你的发现就不是合法的。其次，总体必须近似正态分布。这一点可能是个问题，因为总体中的许多变量可能并不是正态分布的。不过，好消息是，采用 t 分布来构造置信区间，可以有效对抗第二个假设破坏。也就是说，即使违反了假设，这种统计方法仍然是健壮的。最后，在基于 t 分布构造置信区间是，你还需要对异常值保持机警。如果数据里有异常值，那么这个方法可能会失效。因此要记得在开始之前检查数据。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;统计推断&quot;&gt;&lt;a href=&quot;#统计推断&quot; class=&quot;headerlink&quot; title=&quot;统计推断&quot;&gt;&lt;/a&gt;统计推断&lt;/h1&gt;&lt;p&gt;这一节我们以睡眠为例。假设你通常每晚睡 8 个小时，你突然做了年轻爸爸或者年轻妈妈，你的睡眠时间减少到每晚 5 个小时，这意味着每晚减少 3 个小时，相当于每周 20 个小时，每年 1000 个小时，差不多 40 天。换言之，如果你家宝宝继续保持他 / 她的睡眠时间，一年之后你会比之前少睡 大约 40 天。&lt;/p&gt;
&lt;p&gt;回到统计学，想象你想要知道你家乡的年轻父母在孩子刚出生那一年减少了多少睡眠。在这一节中我们将讨论统计推断。我们会基于样本信息，得出关于总体的结论。我们将会区分两种统计推断的方法，一种叫 &lt;strong&gt;统计估计 (statistical estimation)&lt;/strong&gt; ，另一种叫 &lt;strong&gt;假设检验 (hypothesis testing)&lt;/strong&gt; 。在这篇教程中，我们将先了解统计估计。 &lt;/p&gt;
&lt;p&gt;有两种方式估计总体参数的值，其一叫 &lt;strong&gt;点估计 (point estimate)&lt;/strong&gt; ，它是一个对于总体参数的最佳猜想。其二是 &lt;strong&gt;区间估计 (interval estimate)&lt;/strong&gt; ，它是一个我们预期参数会落在的范围。 &lt;/p&gt;
&lt;p&gt;想象我们抽取了 60 个受试者样本，有了第一个小孩后每晚减少的睡眠小时数均值为 2.6 小时。这个均值是一个对于总体均值很好的点估计。换言之，$ \bar x $ ，是一个对于 $ \mu $ 的很好的点估计。不过，单一的点估计无法告诉我们估计是否接近我们感兴趣的总体参数。因此，研究人员通常还希望知道点估计可能的准确度。他们借由计算区间估计来显示这种准确度。&lt;/p&gt;
&lt;p&gt;区间估计是一个最有可能包含总体实际参数值的数字区间。基于我们的样本均值 2.6 小时，我们可以预测，比如说，你家乡新生儿父母每晚睡眠减少的平均小时数介于 2.3 小时到 2.9 小时之间。&lt;/p&gt;
&lt;p&gt;这个区间包含总体参数值的概率，被我们称为 &lt;strong&gt;置信水平 (confidence level)&lt;/strong&gt; ，置信水平总是一个接近 1 的值，多数情况下是 0.95 。接下来我们将讨论有 95% 置信水平的区间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
</feed>
