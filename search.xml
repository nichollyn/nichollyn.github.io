<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计算方法 02 | 起源</title>
    <url>/social-science/quantitative-method-origin/</url>
    <content><![CDATA[<h1 id="古典时期"><a href="#古典时期" class="headerlink" title="古典时期"></a>古典时期</h1><p>最早寻求事物的自然或俗世解释而非神的解释的思想家，是古希腊学者泰勒斯 (Thales)、毕达哥拉斯 (Pythagoras) 和德谟克利特 (Democritus) 等人。但最先思考如何获得知识的 是两千三百多年前的柏拉图 (Plato) 和亚里士多德 (Aristotle) 。</p>
<p>对柏拉图来说，外部世界及其中的事物，只是它们理想形式的不完美投射或影子。这些理想形式往往被描绘成在墙上投下影子。</p>
<img src="/images/sci-ori_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>柏拉图是一个 <strong>哲学实在论者 (philosophical realist)</strong> 。他认为 <strong>现实 (reality)</strong> 即理想世界，是独立于人的思想之外存在的。对他来说，这些理想并非只是我们心中的抽象概念，它们真实存在，但独立于物质世界之外。</p>
<p>他认为既然我们看到的物质世界是真实的 <em>不完美投射 (imperfect reflection)</em> ，我们就不能从感官经历中认识到 <strong>现实的本质 (the true nature of reality)</strong> 。他坚信理想形式的知识只能通过推理论证获得。所以柏拉图被称为 <strong>理性主义者 (rationalist)</strong> 。</p>
<p>他的学生亚里士多德也是个实在论者。他认为现实独立存在于人类的思想之外。但对亚里士多德来说，现实就是物质世界，没有单独的抽象形象存在。在如何了解事物本质上，他也与柏拉图意见相左。亚里士多德是 <strong>经验主义者 (empiricist)</strong> 。他认为感官经验准确地代表了现实。所以我们可以用感官去理解现实。他认为，归根结底知识来源于观察。但这并不意味着他仅对观察感兴趣，他依然将推理论证视作了解和解释自然的最佳方式。事实上，他建立了 <strong>形式逻辑 (formal logic)</strong> ，更确切地说是 <strong>三段论 (syllogism)</strong> 。</p>
<img src="/images/sci-ori_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这有一个三段论的例子。</p>
<blockquote>
<p>“所有人都会死去，而所有希腊人都是人类，因此所有希腊人都会死。”</p>
</blockquote>
<p>如果两个前提为真，那么结论必然为真。把此结论当作新三段论的前提，我们就能积累知识。但这只在前提确实为真的情况下成立。看看这个：</p>
<blockquote>
<p>“所有哺乳动物都长毛，而猫都是哺乳动物，所以猫全都长毛。”</p>
</blockquote>
<p>第一个前提是错的，这就意味着结论不一定对，不是积累知识的好基础。</p>
<p>那么如何确保前提是正确的呢？你可以用另一个三段论来证明它。但当然你需要不停地证明这些前提，有一套你认为毫无争议的初始前提。亚里士多德认为，这些 <strong>基础前提 (fundamental premises)</strong> ，可以通过观察世界的基本形式或规律来决定。不巧他并未意识到他的某些观察选择性太强，导致一些基础前提在我们现在看来错得彻彻底底。比如，以他的观察为依据，昆虫有四条腿，男人比女人的牙齿多。</p>
<p>亚里士多德可能看到蜉蝣用四条腿走路得出了这个结论，但实际上蜉蝣与其他昆虫一样都有六条腿。也有可能他检查了自己和那些男性朋友的牙齿，但只查看了女佣的牙齿，她们更有可能因为营养不良而牙齿变少。他并没有意识到这点，他的观察是不准确的。即便如此，他和柏拉图的观念仍在近两千年内占据了主流。直到 16 世纪末期，人们才意识到他们的观点是有缺陷的。</p>
<img src="/images/sci-ori_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>他们时代之后的科学方法是如何发展的呢？古希腊人有很多科技进步。比如，托勒密 (Ptolemy) 将行星运动描述为：地球位于宇宙的中心，静止不动；其他行星，包括太阳都沿着各自的小轨道绕地球运动。必须要加上这些大环套小环，才能解释行星有时逆行的奇怪现象。</p>
<p>托勒密的模型能进行准确的预测，但人们并不认为它描述了真实的行星运动，它只能解释现象。</p>
<img src="/images/sci-ori_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>希腊城邦消亡后，在罗马帝国的兴衰更替间，以及中世纪的最初几百年，几乎没有任何科学进展。柏拉图和之后亚里士多德的哲学观点一直是主流，直到 16 世纪末新的科学革命拉开了启蒙时代的序幕。</p>
<p>让我们来看看哪些进步最终引导了革命。</p>
<p>首先，阿拉伯和波斯学者比如伊本・哈桑 (Ibn al-Hasan) ，比鲁尼 (Al Biruni) 和伊本西纳 (Ibn Sina) 开始使用系统观察和实验。强调无偏见的观察，而不只是逻辑推理。之后，在前人的基础上，英国的格罗斯泰斯特 (Grosseteste) 和罗杰・培根 (Roger Bacon) 提倡使用归纳 (induction) 与演绎 (deduction) 。</p>
<p><strong>归纳 (Induction)</strong> ，即通过特定观察得到一般解释。 <strong>演绎 (Deduction)</strong> ，即用一般解释预测特定结果。</p>
<p>第三个重大发展是印刷机的发明，这为科学革命创造了极好的条件。更多学者的成果得到了广泛的传播，其中就包括哥白尼 (Copernicus) 的《天体运行论》(De Revolutionibus Orbium Coelestium) ，这是引领科学革命的第四个重大发展。在哥白尼的新行星运动模型中，行星包括地球都围绕太阳运动。这与当时的宗教教义不符，教会接受亚里士多德和托勒密的模型，即地球位于宇宙中心。很多历史学家认为，哥白尼不敢发表他的成果，因为他害怕教会会因为违背教义惩罚他。但他最终还是发表了他的新模型，但加上了给教皇的特别献词，声称如果托勒密能炮制一个轨道怪异且只能解释现象的模型，那么他也应该享有同等的自由。他暗示他的模型仅仅是个实用的模型，而不是确切的表述。</p>
<p>他是否真心相信这一点也不得而知，不久他就与世长辞了。在这之后 60 年都没有引发骚动。很多人认为，科学革命和启蒙时代由哥白尼而始，但其他人认为荣誉应该归于第一个拒绝向天主教低头，坚持认为日心说模型才是现实的真实描述的人。</p>
<p>这个人就是伽利略・伽利雷 (Galileo Galilei) 。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>social-science</category>
      </categories>
      <tags>
        <tag>计量方法</tag>
        <tag>社会科学</tag>
      </tags>
  </entry>
  <entry>
    <title>计量方法 01 | 科学是什么？</title>
    <url>/social-science/quantitiative-methods-what-science-is/</url>
    <content><![CDATA[<h1 id="非科学的方法"><a href="#非科学的方法" class="headerlink" title="非科学的方法"></a>非科学的方法</h1><p>为了知道为什么我们需要科学方法，让我们来看看在日常生活中人们的认知基于什么。</p>
<img src="/images/non-sci_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>人们可能会基于 <strong>直觉 (intuition)</strong> 或 <strong>信念 (belief)</strong> 而认为某事是正确的。</p>
<p>让我们来看下我对我的猫 Misha 所拥有的坚定信念：我相信 Misha 在所有人中最爱我 —— 我就是知道他爱我胜过其他所有人，我能在内心深处感受到。那么这种信念算不算是知识的坚实基础？并不是，简单地相信某件事并不会让它成真。我们坚信不疑的事情可能最后被证明是假的。还有，如果有人持相反的观点会怎样？如果我的未婚夫认为 Misha 爱他多一些呢？</p>
<img src="/images/non-sci_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p><strong>仅仅通过较量我们的观点，是无法得出谁对谁错的。</strong></p>
<p>我们可以数每个观点的支持人数，然后得到一个大部分或是 <strong>一致同意的观点 (consensus)</strong> ，但是这也不能作为知识的坚实基础。仅因为大部分人认同某事是并不意味着它就是真的。几世纪以来，几乎人人都认为地球是平的，但结果证明他们错了 —— 地球是圆的。</p>
<p>另一个知识的来源就是 <strong>权威 (authority)</strong> 的观点。这也不是一个很好的来源。一些诸如政治领袖、专家、科学家等权威的观点，也只是一种观点。权威或许能接触到更多或更好的知识，但他们出于个人利益也会推动自己的观点被大众接受，他们的职业和名誉都依赖于此。假设我的未婚夫找到了一个懂猫语的人，那人声称 Misha 更爱我的未婚夫。当然我会对这一专业观点表示怀疑，尤其当他是受我未婚夫雇佣的时候。我可以找到我自己的猫咪专家来和未婚夫的猫语者打擂台。但这时我们又有两个相反的观点了 —— 我们需要的是 <strong>证据 (evidence)</strong> 。</p>
<p>那么我们该如何用证据来解决 Misha 更爱谁的争论呢？</p>
<p>假设我总是 <strong>观察 (observe)</strong> 到每次下班回家后 Misha 总会过来坐在我的腿上而不是我未婚夫的腿上。我就运用了对客观世界，也就是对下班后 Misha 坐谁的腿上的 <strong>观察 (ovservation)</strong> 来证明我说的 Misha 更爱我这个 <strong>命题 (statement)</strong> 。</p>
<p>以 <strong>随机观察 (casual observation)</strong> 取证得到的认识，比前面其他方法了解到的认识更有根据一些，但这仍然不够好。 <em>因为人们并不十分擅长观察</em> 。我们倾向于 <strong>选择性观察</strong> ，并且记住与我们观念相符的事情。比如我可能恰好忘记了， Misha 在早饭的时候总是坐在我未婚夫的腿上。</p>
<p>除了选择性知觉外还存在许多 <strong>偏见 (bias)</strong> ，会让随机观察成为一个棘手的认识来源。我们运用 <strong>逻辑 (logic)</strong> 的能力也是如此。 <strong>逻辑推理 (logical reasoning)</strong> 得出的认识看上去是有坚实基础的，但 <strong>非形式逻辑推理 (informal logical reasoning)</strong> 并不总是具有一致性。人们在日常生活中进行推理时，总会不停地出现 <strong>谬误 (fallacy)</strong> 或 <strong>逻辑矛盾 (logical inconsistency)</strong> 。</p>
<img src="/images/non-sci_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果想获得更准确的认识，确定我们对世界的解释是正确的，那就还需要点别的东西。我们不能依赖于主观的、无法证实的来源 —— 诸如信念、观点、舆论。我们也不能相信随机观察和非形式逻辑，因为它们可能被我们的信念严重扭曲。</p>
<p>我们需要 <strong>系统观察</strong> ，摒弃任何偏见，辅以一致的逻辑。换言之 我们需要 <strong>科学方法</strong> 。</p>
<hr>
<h1 id="科学方法"><a href="#科学方法" class="headerlink" title="科学方法"></a>科学方法</h1><p>当我们试图解释世上事物运行原理时，为了确保知识有效，我们需要科学方法，而不是依靠观点、信念、随意观察和非形式逻辑。它们都太主观且容易出错。</p>
<p>科学方法基于 <strong>系统观察 (systematic observation)</strong> 和 <strong>逻辑一致性 (consistent logic)</strong> 。使用科学方法，增加了我们得出正确解释的机率。同时，我们也可以通过科学方法鉴定 <strong>科学主张 (scientific claim)</strong> 、 <strong>假说 (hypothesis)</strong> ，以及鉴定在我们实证研究中用来支撑假说的那些 <strong>经验证据 (empirical evidence)</strong> 的说服力。</p>
<p>科学方法有六大原则科学方法有六大原则。如果我们的研究符合这些原则，就能归为科学研究。</p>
<img src="/images/sci-method_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这个假说亦可以与其他科学论断一较高下，为我们的世界提供尽可能最好的解释。</p>
<p>第一条原则是：假说应该可以 <strong>在实证中检验 (empirically testable)</strong> ，即支持或反驳假说的经验证据、物证或观测结果都是可以收集的。</p>
<p>比如我假设家里的猫爱我多于我未婚夫。要实证检验这个假说，我们需要收集观察结果或数据。但如何观察这只猫对我们的喜爱程度呢？我们不能询问猫的看法。假设我们都认为猫是无法像人类那样表达爱意的，那就没什么好观察的了。所以这条假说不符合实证可检验的原则。</p>
<p>第二原则是：<strong>可重复性 (replicability)</strong> 。一项研究及其发现结果都应该具有可重复性。这意味着重复原研究是可以得到一致结果的。</p>
<p>如果预期结果只出现了一次，或出现次数极少，那这个结果可能只是巧合。如果一个假说能被重复确认，它会更为可靠。所以一项研究需要经受住重复和复制的考验。比如我说服未婚夫认同 “猫在谁腿上呆得久就更喜欢谁” 这个评判标准。现在我观察到这周猫趴在我腿上的时间，是它呆在未婚夫腿上时间的两倍。那意味着我的假说是正确的吗？猫咪就爱我多一点吗？如果接下来几周这个观察结果保持不变，那么我的假说就是靠谱的。但如果观察了一周这只猫就死了怎么办？如此一来我们就无法验证这个假说了，这个研究再也无法重复。</p>
<p>要验证结果是否可重复，我们必须按原研究的条件和过程进行重复。假如我们处理过程不同，于是得到了别的结果，这表明原研究不可重复吗？答案当然是否定的。重复失败可能是由于我们改变了程序。</p>
<p>第三原则是 <strong>客观性 (objectivity)</strong> ，指他人能自行重复该实验而无需求助原研究者。“客观” 的字面意思是谁来进行研究不重要。基于假说跟其程序的描述，每个人都应该得到相同的结论。因此研究者提出的假说、概念、程序应尽量客观。这要求清楚明确地定义所有研究元素，不给主观解释留任何余地。</p>
<p>假设我认为猫咪拿脸蹭我是示爱的表现，但我没有明确告诉我未婚夫这一条，那么我衡量爱意的程序就是主观的。即使我们同时对猫进行系统性观察，结果仍然会因观察者而异。较之我未婚夫，我会认为猫示爱次数更多。这个例子中的结论是主观的，因此不具有可比性，而我们经常对此毫无自觉。如果我们没有明确讨论并就示爱标志达成共识，那么我们的猫咪爱意衡量程序则不够客观。</p>
<p>第四原则是 <strong>透明性 (transparency)</strong> 。保持透明度与客观性原则密切相关。在科学界，不论是你的支持者还是批评者，任何人都应该可以重复得出你的结论。这要求研究者共享他们建立的假设 —— 如何定义概念、使用了什么研究程序，还有一切和进行精确复制相关的所有信息。</p>
<p>第五原则指出一个假说应该具有 <strong>可证伪性</strong> 。可证伪性是一个非常重要的原则。如果你能想象出一种情形会使观察与假说出现矛盾，那么它就是可证伪的。如果我们想不出有什么样的反例存在，那这个假说就不可能被推翻。</p>
<p>比如你问一个有坚定宗教信仰的人，有什么证据可以证明他们的信仰是虚假的？不管你提出什么样的反例，他们可能都要争辩。这些事实并不违背自己的忠诚信仰。这种仅源于纯信念的观点，比如宗教，是不属于科学范畴的。如果对任何形式的证据，该假说都不接受其为反例，那这个假说根本没有讨论意义，也不用再寻求证实，因为结论已经在那里了。</p>
<p>我们要讲的第六点也是最后的原则是 <strong>逻辑一致性 (logical consistency)</strong> 。一个假说应该保持逻辑上的一致或连贯。这是指假说不会有任何自相矛盾的地方。比如 ，一个支撑假说的子假设是否与假说冲突。</p>
<p>我们观察得出的结论也应该保持逻辑一致性。这就是说，在整个过程中，研究者对正面或反面证据的标准应该一致。</p>
<p>让我继续用猫的例子进行说明。我的假说是猫更爱我，所以预测他会在我腿上呆更久。但要是它趴在我未婚夫腿上更久呢？我会说猫能察觉到趴在我腿上让我不舒服，因为他爱我多一些所以照顾我情绪便趴得少了。显然，这就是逻辑不一致。为了让观察结果符合我的假说，我对观察结果进行了 “再解读”。顺便一提，这也会让我的假说无法证伪。不管猫是否常趴我腿上，我都会得出它爱我的结论。</p>
<p>总结一下，科学方法要求我们构造的假说为实证可检验的，这就是说观察结果可以支撑或反驳假说；可重复性，也就是假说是可以被重复测试的；客观性，指他人可以独立检验这个假说；透明性，指假说与结果都公之于人，以便他人检验；可证伪性，指找到反例的可能性是存在的。最后，逻辑一致性是指假说本身保持内在的一致性，支持或反驳假说的观察结论也应逻辑一致。</p>
<p>最后一点，科学方法只在态度端正的情况下才有效。为了提出更好的假说，研究者们应该对自己和他人的研究持批判态度，所以他们应该做到公开透明、乐于接受批判。如果别人有更好的解释，就放弃他们心爱的假说。如此，科学界才能像进化系统一样 —— 只有最合适、最可靠的假说存留下来。</p>
<hr>
<h1 id="科学主张"><a href="#科学主张" class="headerlink" title="科学主张"></a>科学主张</h1><p>我已经讲过了有关我们周围世界的命题、假说以及解释，我没有准确解释就用了这些通用术语。是时候阐明清楚了。</p>
<p>关于周遭世界的科学主张，可分为不同类别。一些科学主张会比别的主张描述或解释更多现象。同样，某些科学主张对于我们周围的世界，命题、假说以及解释提供了更可信的描述或解释。我们发现某些主张会更准确一些，比起别的来有更多证据支持。</p>
<p>在科学中，最基本的主张是 <strong>观察 (observation)</strong> 。观察可以是对世界准确或不准确的 <strong>表达（(representation)</strong> 。</p>
<p>假设我观察我的猫：姜黄色毛，重 6.5 公斤。大多数科学家会接受这个观察结果，作为我们周围世界某一方面较为准确的投射 —— 假设体重秤有效且可靠的。但就解释力度而言，他们会发现这个观察非常无趣 —— 观察本身没有很大信息量，它不能描述属性间的一般联系，无法解释任何事。</p>
<p>但这不表示观察不重要。观察是经验科学的基础，但是观察本身不是很有用，观察本身是最无趣的科学主张，因为它没什么解释能力。观察在确定或反驳假说时会变得有用。</p>
<p><strong>假说 (hypothesis)</strong> 是一种 <strong>命题 (hypothesis)</strong> ，它描述了 <strong>属性 (hypothesis)</strong> 间的 <strong>模式 (pattern)</strong> 或一般关系。假说也可以对它描述的模式进行解释。我们建立这样一个假说：姜黄色猫一般都会超重，概率比其他颜色的猫要高得多。我可以用解释来延伸这个假说，就是毛色和肥胖间的相关性。比如，通过证明控制姜黄毛色和发出饱腹信号的基因是连锁的。</p>
<p>假说的 <strong>可信度范围 (plausibility)</strong> 可以从非常不确定到非常确定。一个假说若是没有支持，那么它就是不确定的。比如这是个新且未经检验的假说。假说也能被很多实证研究强烈支持，从而变得更确定。</p>
<img src="/images/sci-claim_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假设的一种特殊类型就是 <strong>定律 (law)</strong> ，定律是对 <strong>关系 (relation)</strong> 或模式非常精确的描述 —— 精确到总是能用 <strong>数学公式 (mathematical equations)</strong> 表达。它们通常被证明得很完整，所以它们如此精确。比如，我把猫食盆从 56 米高的地方扔下去，且我知道万有引力常数，然后用牛顿的万有引力定律就能很准确地预测这个碗掉到地上要花多长时间。</p>
<p>定律能做出很精确的预测 但它们通常不会解释其描述的关系。在这里，是距离、时间和重力之间的关系。当然，社会科学方面的定律很少能表达成公式。我们对个人和人群的了解还太少，还不能得到如此精度的固定行为模式，并用来推测出科学定律。</p>
<img src="/images/sci-claim_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>好，接下来我们来讲讲 <strong>“理论 (theory)”</strong> 的概念。在日常生活中，理论意味着 <strong>未被证明的 (unsubstantiated)</strong> 命题，有根据的猜想。但是在科学中，理论指的是许多相关现象的总体解释。在自然和行为科学中，理论由被经验证据强烈支持的各种假说构成。在社会科学中，更多的是定性研究和历史比较的方法。当理论经受住了逻辑上、历史上或定性分析的驳斥时，可以认为该理论高度可信。</p>
<img src="/images/sci-claim_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在科学范畴里，理论的解释最为完善，是我们拥有的最接近准确的东西，因为它们由经科学方法审视并留存的假说构成。当然，这不意味着科学理论是确定或真实的。世上有许多证明完备的理论最终也被取代了，比如牛顿力学就为相对论让路了。 <strong>科学的世界里没有确定性，只有暂时的最佳解释 (provisional best explanation)。</strong></p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>social-science</category>
      </categories>
      <tags>
        <tag>计量方法</tag>
        <tag>社会科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二十三 | 第一类错误和第二类错误</title>
    <url>/data-science/statistics-type-i-and-type-ii-errors/</url>
    <content><![CDATA[<h1 id="第一类错误和第二类错误"><a href="#第一类错误和第二类错误" class="headerlink" title="第一类错误和第二类错误"></a>第一类错误和第二类错误</h1><p>回忆一下此前提到过的庭审的例子。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。</p>
<p>在审判时，有四种可能的结果。一，被告确实有罪且被判有罪，这是个正确的决定。二，被告确实无辜且被判无罪，这也是正确的决定。三，被告实际上是无辜的，但被判有罪，这是错误的决定。四，被告实际上有罪的，但是被判无罪，这也是错误的决定。</p>
<p>这也是我们在实施显著性检验时会发生的情况。辩方观点类似零假设为真，而被告有罪则等效于零假设为假。判被告有罪类似拒绝零假设，而无罪释放则等同于不拒绝零假设。这会导致四种可能的情形。其中的两种，你做了正确的决定，包括零假设的确为真并且你没有拒绝它以及零假设的确为假并且你拒绝了它。但也有两种你做了错误的决定，包括零假设为真而你拒绝了它以及零假设的确为假而你没有拒绝它。第一个错误我们称为 <strong>第一类错误 (type I error)</strong> ，或者说 <strong>伪阳性 (false positive)</strong> 。第个错误我们称为 <strong>第二类错误 (type II error)</strong> ，或者说 <strong>伪阴性 (false negative)</strong> 。</p>
<img src="/images/t1t2_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我给你举个例子。想象你的零假设是：美国的持证水肺潜水者总体， 50% 有超过 35 小时的潜水经验。换言之， $ \pi = 0.5 $ 。备选假设是它是另外一个百分比，换言之， $ \pi \neq 0.5 $ 。你问了一组简单随机抽样的 500 个美国潜水者，你发现有 0.56 的比例有超过 35 小时的潜水经验。现在，假定你的零假设实际上是真的，当你决定基于你的样本数据拒绝零假设时，一个第一类错误就出现了。 </p>
<img src="/images/t1t2_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<a id="more"></a>

<p>如果零假设为真，抽样分布是像下面这样的：</p>
<img src="/images/t1t2_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果你的显著性水平 $ \alpha $ 等于 0.05 ，通过查询 z 表得到临界值是 -1.96 和 1.96 。你的检验统计量落在拒绝域内。换言之，你要拒绝零假设。这件事情发生的概率是 0.025 加上 0.025 ，等于 0.05 。意味着第一类错误发生的概率等于显著性水平。</p>
<img src="/images/t1t2_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>由此，你可能想到要降低显著性水平。</p>
<img src="/images/t1t2_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>但是，这不一定是个好主意。如果你在零假设实际为真时降低了错误地拒绝它的概率，你实际上增加了零假设实际为假而你错误地没有拒绝它的概率。 </p>
<img src="/images/t1t2_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>犯第二类错误的概率我们称为 $ \beta $ 。</p>
<img src="/images/t1t2_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>计算 $ \beta $ 相当复杂，它依赖各种因素，例如 $ \alpha $ 的值，样本容量以及参数的真实值。基于这个原因，我们并不会去计算 $ \beta $ 的值，但重要的是你需要意识到，当我们试图降低某一类错误的概率时，另一类错误的概率会上升。</p>
<img src="/images/t1t2_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>当零假设为假时，并且你实施了检验，你希望检验的 <strong>功效 (power)</strong> 是高的。检验的功效是拒绝零假设的概率，给定它为假，换言之，一个检验的功效等于 1 减去第二类错误的概率，也就是 $ 1 - \beta $ 。</p>
<img src="/images/t1t2_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>为什么功效这么重要呢？是这样的，当你要实施一项研究之前，它可以帮助你确定你需要多少的参与者。在你实施完研究之后，它能帮助你确定结论不是统计显著的。</p>
<p>最后一个提示，在实践中，你永远无从得知某个决定正确与否。我们唯一能做的是控制做出不正确决定的概率。</p>
<hr>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>想象你是一个对鲸鲨感兴趣的潜水者，你想要知道这些巨大的动物平均的身长有多少。我们还假设你已经花费了很多年在世界各地研究了这些生物。这些年你已经测量了 258 头鲸鲨。因为你已经测量了世界各地的鲸鲨，我们假定这 258 头鲸鲨可以被看作一个简单随机样本。平均的长度等于 8.3 米，样本标准差是 3.4 米，并且鲸鲨长度的分布也近似正态分布。</p>
<img src="/images/t1t2ex_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在这一节中，我们将检验三种备选假设和一种零假设：鲸鲨总体的长度均值等于 8 米。第一个假设是总体均值不是 8 米。第二个假设是均值大于 8 米，第三个假设是总体均值小于 8 米。所有这几种情况中，我们都把显著性水平设为 0.10 。 </p>
<img src="/images/t1t2ex_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>首先，我们得检查我们的假定。如我之前说过的，鲸鲨的选择可以看作是简单随机抽样，并且我们也看到鲸鲨身长的分布近似正态。因此，我们没有理由预期总体分布会和正态分布差异巨大。再者，这也不是个问题，因为我们的样本量相当大。 </p>
<p>现在，让我们计算检验统计量，它的值对于几个假设都是一样的，毕竟，样本均值和零假设一样。</p>
<img src="/images/t1t2ex_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>代入公式， 8.3 减去 8 ，除以 3.4 除以 258 的平方根，等于大约 1.42 。</p>
<p>现在，我们开始第一个备选假设，它断言总体均值不是 8 米。我们画出相关的抽样分布，并显示零假设的值。我们需要基于 0.01 的显著性水平做双尾检验，查询 t 表格得到临界值 -1.66 和 1.66 ，检验统计量等于 1.42 不在拒绝域内因为我们不拒绝零假设。这意味着基于 0.10 的显著性水平，我们不能得出总体均值不是 8 的结论。</p>
<img src="/images/t1t2ex_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>第二个备选假设是总体均值大于 8 。抽样分布一样，但这一次我们做右尾检验。查询 t 表格得临界值是 1.29 ，这一次检验统计量是落在拒绝域内。因此在这种情况下，我们拒绝零假设，并且下结论总体的均值的确大于 8 。</p>
<img src="/images/t1t2ex_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>最后的备选假设是总体均值小于 8 。在这种情况下，我们做左尾检验，它是右尾的镜像，所以相关的临界值是 -1.29 。现在我们的检验统计量是 1.42 ，对于临界值时一个极端值，但它在分布的另一边。这意味着，它也不在拒绝域内，因此我们也不拒绝零假设。</p>
<img src="/images/t1t2ex_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>最后的例子显示，画出抽样分布很重要。否则，你可能会无法注意到检验统计量相对于临界值处于分布的另一边。不论检验的结果如何，有两件事是可以确定的。第一，鲸鲨真的很大。第二，教程即将结束，我要放假啦～感谢阅读！</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二十二 | 分步计划和置信区间</title>
    <url>/data-science/statistics-step-by-step-plan-and-ci/</url>
    <content><![CDATA[<h1 id="分步计划"><a href="#分步计划" class="headerlink" title="分步计划"></a>分步计划</h1><p>比较以下两种期望。一，你期望超过半数的持证美国潜水者有超过 35 小时的潜水经验。二，所有持证美国潜水者的平均潜水时长超过 35 小时。第一眼，两个期望看起来很相似。但是，在第一个例子中，你面对的是比例，你感兴趣的是潜水经验超过 35 小时的潜水者的比例。而第二个例子中，你关心的是均值。你想知道潜水时长的均值。因此，当实施显著性检验时，你需要特别注意你的方法。</p>
<p>这一节中，我将以分布计划的方式来引导你。想象你问了一个容量是 500 个持证潜水者的简单随机样本，他们的潜水时长是多少个小时。假设你发现 0.57 的比例有超过 35 小时的潜水经验，时长均值是 35.5 小时，均值是 8 小时。在我们的样本中，<br>潜水经验的变量分布近似正态。下面是分布计划全图：</p>
<img src="/images/sbs_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>第一步，评估你面对的是比例还是均值，这个我们已经讨论过。第一个例子是比例，第二个例子是均值。</p>
<p>第二步，形式化你的假设。在比例的例子中，零假设是：$ \pi = \pi_0 $ ，在均值的例子中，零假设是 $ \mu = \mu_0 $ 。我们可以有三种类型的备选假设：如果你做双尾检验，是 $ \pi\neq\pi_0 $ 或者 $ \mu\neq\mu_0 $ ；如果你做单尾的右尾检验，是 $ \pi\geq\pi_0 $ 或者 $ \mu\geq\mu_0 $ ；如果你做单尾的左尾检验，是 $ \pi\leq\pi_0 $ ，$ \mu\leq\mu_0 $ 。我们零假设是： $ \pi=0.5,\mu=35 $ ，备选假设是 $ \pi\geq0.5,\mu\geq35 $ 。因此我们需要实施右尾检验。</p>
<p>第三步，检查你的假定是否满足。在两个例子中，随机化都是必要的。你的样本必须通过随机抽样的方法收集，或者说，随机化的实验。在比例的例子中，根据零假设的比例，样本容量乘以比例以及 1 减去样本容量再乘以比例，必须等于或者大于 15 。均值的例子则要求总体分布近似正态。但实践中，这一点只有样本容量很小，且做的是单尾检验时才重要。对于我们的例子，所有的假定都满足。</p>
<p>第四步，确定显著性水平 $ \alpha $ 。常用的显著性水平是 0.05 。我们的检验将基于 $ \alpha=0.05 $ 。</p>
<p>第五步，计算检验统计量。在比例的例子中，公式是 $ z = \frac {p-\pi_0}{se_0} , se_0 = \sqrt {\frac {\pi_0 (1-\pi_0)}{n}} $ ，在均值的例子中，公式是 $ t = \frac {\bar x-\mu_0}{se_0} , se_0 = \frac {s}{n} $ 。注意，在比例的案例中，我们使用 z 分布，而在均值的案例中，我们使用 t 分布。</p>
<p>第六步，抽取相关的抽样分布，展示零假设和检验统计量，补上拒绝域和对应的临界值。在比例的案例中，</p>
<p>第七步，评估你的检验统计量是否落在拒绝域内。</p>
<p>第八步，决定是否拒绝零假设。</p>
<p>第九步，解释你的发现。</p>
<p>在下结论之前，值得提醒的是，不拒绝零值假设并不暗含你就可以接受零值假设。在第二个例子中，我们不拒绝零值假设，即潜水时长等于 35 小时的假设，但并不能得出潜水时长就等于 35 小时的结论。</p>
<hr>
<h1 id="显著性检验和置信区间"><a href="#显著性检验和置信区间" class="headerlink" title="显著性检验和置信区间"></a>显著性检验和置信区间</h1><p>假设你问样本容量为 500 的水肺潜水者他们潜水了多少个小时，均值是 36 小时，标准差是 8 小时，变量的样本分布近似于正态。基于样本信息，你希望推断总体的参数 $ \mu $ ，这是我们所知的推断统计学 —— 基于样本信息得出样本所在总体的结论。  </p>
<p>推断统计学有两种方法。其一，通过均值的置信区间来推断区间估计。其二，用显著性检验来推断点估计。在这一节中，我将向你展示这两种方法其实关联密切。</p>
<img src="/images/sbs_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假定你预期潜水时长的均值不是 35 小时，你将做一个显著性检验。我们对均值感兴趣，检验统计量如下：</p>
<img src="/images/sbs_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>零假设是： $ \mu = 35 $ ，备选假设是： $ \mu \neq 35 $ 。我们的假定满足，分析基于简单随机样本并且样本足够大，并且样本近似正态分布。检验统计量等于 36 减去 35 ，除以 8 除以 500 的平方根，等于 2.80 。抽样分布看起来是这样的。</p>
<img src="/images/sbs_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们可以通过查询 t 表找到对应双尾检验显著性水平 0.05 的临界点是 $ \pm1.984 $ 。因此我们的检验统计量落在拒绝域内。我们将拒绝零假设，得出潜水时长不等于 35 小时的结论。</p>
<p>现在，如果我们构造 95% 的置信区间，会发生什么呢？公式如下：样本均值，加减 95% 置信水平对应的 t 分数，乘以标准误差，这个标准误差等于标准差除以样本容量的平方根。相关的 t 分数是 1.984 ，代入公式，得到置信区间是 35.29 到 36.71 。由此我们有信心说，通过无限重复的抽样， 95% 的情况下区间会包含实际的总体均值。这个区间给了我们关于总体均值的一个有说服力的范围。和显著性测试一样，这个置信区间也告诉我们，总体的样本均值不是 35 。通常，双尾显著性检验的结果与置信区间的结果是一致的。</p>
<img src="/images/sbs_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>更准确的说，如果双尾显著性检验的 P 值等于或者小于 0.05 ，那么 95% 置信区间也不包含零假设的值。类似的，如果双尾检验的 P 值大于 0.05 ，那么 95% 置信区间将包含零假设的值。</p>
<img src="/images/sbs_5_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这听起来很合理，对吧？它以下图表示。你会看到，观察值 36 落在拒绝域内，而对应的置信区间也不包含零假设的总体均值。</p>
<img src="/images/sbs_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在假设观察到的均值是 35.5 ，而不是 36 ，这样的话，我们的检验统计量将变成 1.40 ，它不落在拒绝域内。我们因此不拒绝零假设，相似的，置信区间的两个端点编程 34.79 和 36.21 ，则包含了零假设的均值 35 。</p>
<img src="/images/sbs_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们可以有信息说，通过无限重复抽样， 95% 的情况区间会包含实际的总体均值。这意味着零假设有说服力，我们不该拒绝零假设。也说明了，构建置信区间的方法和双尾假设检验的方法虽然看起来不同，但是数学上是相关的，彼此一致。</p>
<img src="/images/sbs_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二十一 | 假设检验和显著性检验</title>
    <url>/data-science/statistics-hypotheses-and-significance-test/</url>
    <content><![CDATA[<h1 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h1><p>教程来到最后一个模块，很快我要放假了。明天我将背起行囊，出发去潜水。好吧，让我们再谨慎一点，我并不完全确定明天我能成行。我的航班可能延误，我可能睡过头误了航班，或者可能生病导致无法去潜水。总之，我期望明天出发，但我并不能完全地确定。或者说，不能 100% 确定。</p>
<p>当研究人员对于他们感兴趣的参数有所期待时，我们在讨论的是 <strong>统计假设 (statistical hypotheses)</strong> 。这一节将介绍统计假设。他们构成了 <strong>显著性检验 (significance testing)</strong> 方法中最主要的部分。一个统计假设，其实就是一个关于总体的期望。通常，假设会被形式化为一条对总体参数持有特定值或者落在特定范围的声明。这种声明是基于研究或者理论。基于样本的信息，我们评价一个假设靠谱与否。这个过程我们称为显著性检验，它是一种用样本数据来检验提前形式化的假设的方法。就像置信区间一样，显著性检验是一种推断统计学的方法。毕竟，我们也是用样本数据来推断关于总体参数的结论。</p>
<img src="/images/hypo_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们先来看 <strong>零假设检验 (null-hypothesis testing)</strong> ，在这种检验中，显著性检验基于两个假设， <strong>零假设 (null hypothesis)</strong> 和 <strong>备选假设 (alternative hypothesis)</strong> 。零假设以 $ H_0 $ 注记，备选假设以  $ H_a $ 注记。零假设断言你感兴趣的参数是某个特定值。它通常代表变量之间没有关联的情况，或者组与组之间没有差异的情况。它是一个当你的样本数据表明它不太可能发生时需要被拒绝的假设。而备选假设断言你感兴趣的参数落在另一个范围。通常，零假设和备选假设互斥。如果你做显著性测试，假设零假设为真，除非你的数据有很强的反面证据。</p>
<img src="/images/hypo_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>想象一个法庭的庭审。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。这正是显著性检验里发生的事情。辩护无辜相当于零假设，而有罪预期则等同于备选假设。</p>
<img src="/images/hypo_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在研究实践中，你对于参数的期望是以备选假设的方式出现，而零假设就是对立面，但它必须是一个单值，不能是一个范围。你只有在数据提供强力佐证时才能认定零假设成立。</p>
<img src="/images/hypo_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<a id="more"></a>

<p>举个例子，假设你有理由相信全体美国人中有 3% 有过水肺潜水的经历。那么这里的零假设和备选假设分别是什么呢？你的期望被视为备选假设。我们把它写下来， $ H_a:\pi\leq0.03 $ ，零假设是对立面，但必须表示为单一值，因此 $ H_0:\pi=0.03 $ 。</p>
<img src="/images/hypo_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假设你对水肺潜水的最大深度很感兴趣。你有理由期望美国潜水者的最大潜水深度均值 <em>不是</em> 25 米。你的备选假设是 $ \mu\neq25 $ ，零假设是 $ \mu=25 $ 。很简单，不是吗？</p>
<img src="/images/hypo_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>记住这条：在显著性检验中，你总是假定你的零假设成立，如果你为备选假设找到足够的支撑，就拒绝零假设。如果你没有找到足够的证据，你就不能拒绝它。但没能拒绝零假设并不意味着零假设就是真的。你可以拿法庭的例子再回味一下。在庭审中，被告被假定无罪。如果有足够的证据证明他或者她有罪，则定罪。没有足够的证据，被告则不会被定罪。但这并不意味着你可以得出他或者她是无辜的结论。</p>
<!-- more -->

<h1 id="关于比例的检验"><a href="#关于比例的检验" class="headerlink" title="关于比例的检验"></a>关于比例的检验</h1><p>假定你对有多少美国人有过水肺潜水经历这个问题感兴趣，你也有理由相信少于 3% 的美国人有这种经历。这意味着你的备选假设是 $ \pi\leq0.03 $ ，你的零假设是 $ \pi=0.03 $ 。</p>
<p>这一节中，我们将学习如何在对比例感兴趣时实施显著性检验。我们是这样来实施检验的：先假定我们感兴趣的总体参数有某个值，在我们收集到来自总体的样本后估计这个值的可能性。因为我们看到是一个样本，所以聚焦在抽样分布。我们可以决定，比如给定总体比例是 0.03 时样本比例的抽样分布。看下图，我们这样来实施检验：评估标准差（因为面对的是抽样分布，所以是标准误差），样本观察到的比例远离总体比例，这个标准误差的数值我们称为 <strong>检验统计量 (test statistic)</strong> 。</p>
<img src="/images/tap_0.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>想象我们抽取了 1000 个美国人，受试者中有水肺潜水经历的人比例等于 0.02 。接下来，我们这么做：</p>
<img src="/images/tap_0_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你看到一个样本比例的抽样分布，我们假定零值假设为真，总体比例确实等于 0.03 。那么一个样本比例为 0.02 的总体，有多大的可能性其比例真的是 0.03 呢？为了回答这个问题，我们计算检验统计量，或者说样本统计和假定的总体参数之间的偏移幅度。标准误差远离均值的数量用 z 分数表示，我们可以计算样本统计量距离总体均值有多少个 z 分数。 公式如下：</p>
<img src="/images/tap_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>先计算零假设的标准误差，它等于 0.03 乘以 0.97 再除以 1000 ，取平方根，大约是 0.005 。因为我们的检验统计量是 0.02 减去 0.03 ，除以 0.005 ，等于 -1.85 。这意味着当零假设为真时，我们的样本比例落在总体比例 1.85 个标准误差之下。 这是否足以拒绝零假设呢？</p>
<img src="/images/tap_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>基于这个信息，我们可以查询 z 表格，对应的概率值是 0.0322 ，这个概率值我们称为 <strong>P 值 (P-value)</strong> 。 P 值告诉我们，基于总体比例是 0.03 的前提，要找到一个比例是 0.02 的样本，可能性是很低的。但是否低到可以拒绝零假设了呢？这取决于我们选择 <strong>显著性水平 (significance level)</strong> 。在我们实施检验之前，我们需要决定 P 值要达到多小以拒绝零假设。最常用的显著性水平是 0.05 ，这时我们说样本提供了足够的证据拒绝零假设。我们的 P 值是 0.3222 ，小于 0.05 。所以如果我们把显著性水平设置在 0.05 ，我们需要拒绝零假设。这也被我们称为 <strong>拒绝域 (reject region)</strong> 。</p>
<img src="/images/tap_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>形成拒绝域边界的临界 z 值是 -1.64 ，你可以通过查询 z 表格得到它，它对应 0.05 概率的左尾。我们的检验统计量是 -1.85 ，落在拒绝域内。因此我们需要拒绝零假设，并且得出结论：美国有水肺潜水经历的人的比例低于 0.03 。我们说，这个结论是 <strong>统计显著的 (statistically significant)</strong> 。</p>
<img src="/images/tap_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在这个例子中，我们的检验基于备选假设是 $ \pi\leq0.03 $ 。因此，我们只聚焦在抽样分布的一边 —— 左边。这叫做 <strong>单尾检验 (one-tailed test)</strong> 。那如果我们的备选检验是 $ \pi\neq0.03 $ 呢？如果是那样的话，我们将不再只聚焦在分布的左边，而分布的两边。这种检验叫做 <strong>双尾检验 (two-tailed test)</strong> 。 </p>
<img src="/images/tap_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果我们还是采用 0.05 作为显著性水平，这意味着左边对应的累积概率是 0.025 ，右边也是。同样可以查询 z 表得到，对应的拒绝域的临界点分别是 -1.96 和 1.96 。现在，我们的检验统计量 -1.85 不再落在拒绝域内，意味着我们不能再拒绝零假设 $ \pi = 0.03 $ 。这说明，选择单尾或者双尾检验，对于结论有重大的差别。实践中，双尾检验要常用的多。我的建议是，只有你有非常好的理论依据时才使用单尾检验。</p>
<p>现在，让我们来改变显著性水平，看看会发生什么。比如，我们可以显著性水平设置为 0.01 ，这意味着我们在 P 值小于 0.01 时拒绝零假设。如果做单尾检验， 0.01 的显著性水平对于 -2.33 。</p>
<img src="/images/tap_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在我们的例子中，检验统计量没有落在拒绝域，因此不拒绝零假设。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如你所见，选择单尾或者双尾检验，会强烈地改变结果。需要记住的是，大部分单尾或者双尾检验都是基于 0.05 的显著性水平。</p>
<img src="/images/tap_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h1 id="关于均值的检验"><a href="#关于均值的检验" class="headerlink" title="关于均值的检验"></a>关于均值的检验</h1><p>你好奇潜水者会在水下待多长时间吗？这个时间取决于他们的氧气罐，经验，潜水深度以及许多其他因素。假设你有理由期望美国潜水者在携带平均水平的氧气罐下潜到平均深度，可以待在水下超过 60 分钟，并且假设你也接触到了 100 个有经验的美国水肺潜水者，测量了他们在携带平均水平的氧气罐待在平均深度下的时长。这个样本的均值是 62 分钟，标准差是 5 分钟。</p>
<p>你预期潜水者可以在水下待超过 60 分钟，这导致了下面这样一个零假设： $ \mu = 60 $ ，备选假设是 $ \mu\geq60 $ 。我们实施一个关于总体均值的显著性检验，抽样分布如下：</p>
<img src="/images/tam_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是一个均值等于 60 的样本均值的抽样分布， 60 是零假设的值。那么基于这样一个总体，一个样本的均值等于 60 的可能性有多大呢？ 同样，为了回答这个问题，我们计算检验统计量，它是样本均值偏离总体均值的标准误差。你可能记得如何计算标准误差 —— 我们需要用总体的标准差，因为我们不知道这个值，需要用样本标准差估计。因为这隐含着额外的误差，我们引入 t 分布来取代 z 分布。</p>
<img src="/images/tam_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们的检验统计量是通过下面的公式计算：</p>
<img src="/images/tam_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>由样本均值减去零假设的均值，然后除以样本均值的标准误差。标准误差等于样本标准差除以样本容量的平方根。</p>
<p>我们先计算出标准误差， 5 除以 100 的平方根，得 0.5 。 62 减去 60 ，再除以 0.5 ，得到 4 。这是否足以拒绝零假设呢？仍然取决于显著性水平。让我们引入最常用的显著性水平 0.05 。做单尾检验，查询 t 表，临界值是 1.67 。</p>
<img src="/images/tam_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>注意到我们的自由度是 99 ，但表里向下最接近的是 60 ，我们需要查看 $ t_{90%} $ ，因为右尾累积概率 0.05 。你需要记住， $ t_{90%} $ 代表置信水平为 90% ，也就表示分布的两尾加起来有 10% ，左右尾各 0.05 。</p>
<p>结果如下，我们的检验统计量 4 落在拒绝域内，意味着我们需要拒绝总体均值是 60 分钟的零假设。</p>
<img src="/images/tam_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们可以总结，平均情况下，有经验的美国潜水者携带平均的氧气量潜到平均的深度，能够在水下待超过 60 分钟。如果我们的期望并不是超过 60 分钟，而是不等于 60 分钟呢？</p>
<img src="/images/tam_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这种情况下，我们做双尾检验。假设显著性水平设置为 0.01 ，左尾和右尾的累积概率分别为 0.005 。查表，对应的临界值分别为 -2.66 和 2.66 ，而我们的检验统计量是 4 。因此，我们还是要拒绝零假设，并对我们的发现做统计显著的结论。</p>
<img src="/images/tam_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因为我们现在做了双尾检验，所以我们的临时结论现在变成了有经验的美国潜水者在携带平均氧气量，潜到平均深度后，能待在水下的平均时间不等于 60 分钟。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二十 | 样本容量</title>
    <url>/data-science/statistics-sample-size/</url>
    <content><![CDATA[<p>还是前面的新生儿父母睡觉减少时长的例子，由于我们无法去询问你家乡所有的年轻父母。我们采取简单随机抽样。一个很关键的问题是 —— 样本应该取多大。应该是 50 个就够了？或者 至少 300 个或者 1000 个？</p>
<p>这一节中，我们将分布讨论对均值和比例感兴趣的不同情况。</p>
<p>先从均值开始。样本容量主要取决于三个因素。首先是你想要的精度。记得吗，置信区间是通过点估计加减一个误差界限来得到的。你允许多大的误差界限，如果你希望它越小，那么你的样本容量就得越大。其次，你的样本容量还依赖你想要的置信水平。越大的置信水平，需要越大的样本容量。最后，数据的变异性也影响样本容量的选择。你的变量的标准差越大，你需要的样本容量也越大。公式如下：</p>
<p>$$ n = \frac {\sigma^2z^2}{m^2} $$</p>
<p>n 代表样本容量，m 代表误差界限，$ \sigma $ 代表总体的标准差， z 代表 z 分数。显而易见，你不知道总体的标准差，而且你还没抽取样本也不知道样本的标准差。所以，你需要利用 <strong>合理的猜测 (educated guess)</strong> 来估计一个值。</p>
<p>让我来演示这个过程是怎么样的。想象我们想要 95% 的置信水平，对应这个置信水平的 z 分数是 1.96 ，并且我不希望误差界限宽过 0.3 小时，就取 0.3 小时吧。现在我们可以填完这个公式的一部分了。现在我们需要对 $ \sigma $ 进行合理猜测了。如果已经存在这方面的研究而且你知道变量的标准差，可以简单地采纳这个标准差。但是，如果这样一个研究之前并未做过，就必须靠我们自己的猜测。我先假定某些父母根本没法睡，某些父母睡觉少于 5 个小时，并且父母们也不可能睡的比之前还多。因此，我们假定变量服从正态分布， 95% 的父母睡觉时间介于 0 到 5 个小时之间。均值是 2.5 小时，标准差是 1.25 小时。毕竟， 95% 是落在均值左右两个标准差范围内，两个标准差等于 2.5 ，那么一个标准差就是 1.25 。我们用这组数字完成公式，得到 66.69 ，取整，得出结论我们需要 67 个受试者。</p>
<p>对于比例感兴趣而不是均值的情况，也可以采取类似的方式。假设我们想知道新生儿在换尿布时便便的比例，我想要 99% 的置信水平，误差界限 0.10 。公式非常相似：</p>
<p>$$ n = \frac {p (1-p) z^2}{m^2} $$</p>
<p>m 是 0.10 ，z 可由查表得 2.58 ，它对应 99% 置信水平。我们不知道的是 p 。还是采用合理的猜测，或者采用一种被称为 <strong>安全方法 (safe approach)</strong> 的方式。你会发现 $ p (1-p) $ 的最大值是 0.25 ，它发生在 p = 0.5 的时候，于是我们用 p = 0.5 完成公式，0.5 乘以 0.5 乘以 2.58 的平方除以 0.10 的平方，得到 166.41 ，即 167 位受试者。</p>
<p>在理想世界中，你可以去寻求大样本，比如说 1000 位受试者或者更多。但是，在现实世界中，我们的时间有限，资源有限，无法抽取大样本。因此，计算所需的样本容量可以帮助我们把成本降到最低。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十九 | 比例的置信区间和置信水平</title>
    <url>/data-science/statistics-confidence-interval-for-proportion/</url>
    <content><![CDATA[<h1 id="比例的置信区间"><a href="#比例的置信区间" class="headerlink" title="比例的置信区间"></a>比例的置信区间</h1><p>In the last couple of weeks I have<br>learned that newborn babies like to poo. They like to poo a lot. And it happens to be the case that my<br>daughter Lois especially likes to poo under specific circumstances. That is,<br>precisely when I’m changing her diaper. Seriously, once she decided to<br>answer nature’s call six times. I repeat, six times during<br>the diaper changing process. Is that normal? I’m not sure, but<br>I know how I could check it. Suppose that I asked a simple<br>random sample of 100 new parents if their baby likes to defecate while<br>his or her diaper is being changed. In this video, I’ll tell you how we can,<br>on the basis of such a study, construct a confidence interval to<br>estimate a population proportion. Say that 17% of my 100<br>respondents reported their babies like to poo while<br>the diapers is being changed. 83% reported their babies don’t do that. We thus have a proportion of 0.17, whose babies like to poo while<br>the diaper is being changed. When we construct<br>a confidence interval for a proportion, we employ the sampling<br>distribution of the sample proportion. We know that, as long as the sample is<br>large enough, this sampling distribution is normally distributed with a mean that<br>is equal to the population proportion, pi. And a standard deviation that is<br>equal to the square root of pi multiplied with one minus pi divided by n. We also know that the probability of<br>finding a sample proportion of less than about two standard deviations of the mean,<br>which is the population proportion, is 0.95. More precisely, if we look up the z score<br>which corresponds to this probability, we’ll find a value of 1.96. This means that we have a 95% chance<br>that our sample proportion will fall within 1.96 standard deviations<br>of our population proportion. This is what we call the margin of error. The formula with which we can compute<br>a 95% confidence interval looks like this. p plus and<br>minus 1.96 times the standard deviation of the sampling distribution<br>of the sample proportion. 1.96 is the z score that corresponds<br>to the 95% confidence level. So we could also write, p plus and minus the z score for the 95%<br>confidence level times the standard deviation of the sampling distribution<br>of the sample proportion. We’re talking about a 95% confidence level<br>here, that means that we can say that if we would draw an infinite number of<br>samples from a population in 95% of the cases, our confidence interval<br>would contain population proportion pi. However, as you might have noticed, we don’t know the value of<br>population proportion pi. So it is impossible to compute a standard<br>deviation of the sampling distribution of the sample proportion. We therefore substitute the population<br>parameter pi with an estimate, and this estimate is our sample statistic, P. This leads to the following formula. p plus and minus the z score for the 95%<br>confidence level times the estimated standard deviation of the sample<br>distribution of the sample proportion. Just like when we constructed the<br>confidence interval for a mean, we call this estimated standard deviation of the<br>sampling distribution the standard error. In contrast with the confidence interval<br>for a mean, when it comes to constructing a confidence interval for a proportion, we<br>don’t make use of the t distribution. And just stick with the standard<br>normal distribution. However, your data need to<br>satisfy one essential assumption. You should have at least 15 successes and<br>15 failures. In other words, n times p and n times 1 minus p need to be<br>larger than or equal to 15. If this is not the case, you cannot compute a confidence interval<br>on the basis of the discussed formula. Okay, let’s go back to our example. We have a proportion of 0.17 that reports that the baby poos while<br>the diaper is being changed. This is the formula we use. Let’s first compute the standard error. It’s the square root of 0.17<br>times 0.83 divided by 100. That makes about 0.038. The margin of error then<br>is 1.96 times 0.038. That’s about 0.07. 0.17 minus 0.07 equals 0.10 and 0.17 plus 0.07 equals 0.24. So our confidence interval<br>ranges from 0.10 to 0.24. This means that we can be 95% confident<br>that the population proportion falls between 0.10 and 0.24. Or, in other words,<br>if we would draw an infinite number of samples with n equals<br>100 from a population, and for every sample we would compute confidence<br>intervals with this margin of error, in 95% of the cases the population value<br>would fall within the confidence interval. This 95% confidence interval<br>demonstrates that most babies don’t like to poo while their<br>diaper is being changed. On the other hand,<br>it’s not that exceptional if they do poo. We can be 95% confident<br>that between 10 and 24% does poo during the changing process. Thank God, nothing is wrong<br>with my little baby, Lois. In fact, my theory is that my<br>daughter’s pooing habits are good news. That might well indicate that<br>she will be toilet trained soon. After all,<br>she doesn’t like to poo in the diaper. Now, let’s hope that later on,<br>she does like to poo in the toilet.</p>
<hr>
<h1 id="置信水平"><a href="#置信水平" class="headerlink" title="置信水平"></a>置信水平</h1><p>The 95% confidence interval, tells us that we can be 95%<br>confident that our point estimate, which could be a mean or a proportion,<br>falls within our confidence interval. Or in other words, it tells us that if we<br>would draw an infinite number of samples, similar to our extra sample and<br>for every sample, we would compute a 95% confidence<br>interval with a similar margin of error. In 95% of the cases, the population value would fall<br>within this confidence interval. This, of course, also means that<br>in 5% of the cases, this method will produce an interval that does not<br>contain the actual population parameter. If you would like to reduce the chance of<br>an incorrect inference, you could go for a larger confidence interval,<br>such as, for instance, 99%. In this video, I will tell you how<br>you can change your confidence level. And what the consequences are,<br>of doing so. Imagine you asked a sample<br>of 100 new parents, if the babies like to answer nature’s<br>call, during the diaper changing process. 17% reported that, this is the case. Our sample, proportion p,<br>thus equals 0.17. The formula to compute a 95% confidence<br>interval for a proportion is, p plus and minus the z score for the 95% confidence<br>level, times the standard error, which equals the square root of p,<br>multiplied with 1, minus p divided by n. You can look up a z score for<br>a 95% confidence level, in the z table. Look at this standard<br>normal distribution here. When you have a 0.95 probability,<br>that your value falls within z standard errors from the mean, that means, that<br>0.025 probability falls in the two tails. If you look up the z scores,<br>which are displayed here in the z table, we find values of plus or minus 1.96. You can see that here. We can now easily compute the interval,<br>that’s 0.17 plus and minus 1.96 times the standard error<br>which is the square root of 0.17, times 0.83, divided by 100. This leads to a confidence interval<br>with the end point 0.10 and 0.24. You can now imagine, that it is not so difficult to construct intervals<br>with other confidence levels. Let’s first look at the 99%<br>confidence interval. This is the formula. p plus or minus the z score for the 99% confidence<br>level, times the standard error. The only difference is,<br>the different z score. Look at this standard normal distribution. When you have a 0.99 probability that your<br>value falls within z standard errors from the mean, that means, that 0.005<br>probability falls in the two tails. If we look up the z scores,<br>which are indicated here. We find values of plus and minus 2.58. You can see that here. We can now compute the interval. That is 0.17, plus and minus 2.58,<br>times the standard error. Which was 0.038. This leads to a confidence interval<br>with the endpoints 0.07 and 0.27. For the 90% confidence level,<br>we find a z score of 1.645. This leads to a confidence<br>interval of 0.17, plus and minus 1.645, times 0.038. That makes a confidence interval<br>with the endpoints of 0.11 and 0.23. I have here displayed confidence<br>intervals graphically. You can see that a higher confidence level<br>leads to a wider confidence interval. In other words, the more confident we<br>are that we draw a correct inference, the larger of margin of error. That means, that we have to compromise<br>between confidence and precision. As one gets better, the other gets worse. We never settle for a 100% confidence<br>interval, because the margin of error then is far too large, which means that our<br>conclusions are not very informative. In most cases,<br>the 95% confidence interval is used. We can also use other confidence intervals<br>when we construct a confidence interval to estimate a population mean. Suppose, we’ve asked a sample<br>of 30 new parents in Amsterdam, how much hours of sleep they’ve lost<br>after the first child was born. The mean is 2.6 hours per night. And the standard deviation<br>is 0.9 hours per night. This is the formula we use,<br>to construct a 95% confidence interval. x-bar, plus and minus the t score for<br>the 95% confidence level, times the standard error. Which equals the sample<br>standard deviation, divided by the square<br>root of the sample size. Now, what is the t score for<br>95% confidence level? That’s dependent on the degrees of<br>freedom, which equals n minus 1. That is, 30 minus 1 is 29. In the t table, we should look in<br>the column of the 95% confidence level and in the row of 29 degrees of freedom. That gives a t score of 2.045. The confidence interval becomes 2.6<br>plus and minus 2.045, times 0.9, divided by the square root of 30. That gives an interval from 2.26 to 2.94. If we would want to construct an interval<br>with a confidence level of 99%, we simply replace the t score for the 95%<br>level with the t score for the 99% level. You can look it up in the table,<br>it’s 2.756. The confidence interval is 2.6 plus and<br>minus 2.756, times 0.9,<br>divided by the square root of 30. That leads to an interval<br>from 2.15 to 3.05. You can also easily do that for<br>other confidence levels. Let me conclude this video by<br>giving you a step by step plan for constructing a confidence interval. First, decide which confidence<br>level you want to use. For instance, do you settle for<br>the regular 95% level? Or do you want to be more confident and<br>less precise? Or more precise and less confident? Second, decide if you’re dealing<br>with a proportion or a mean. If you’re interested in a proportion,<br>you work with the z distribution, and if you’re interested in a mean,<br>you have to use the t distribution. So, in the case of a proportion,<br>you look up the relevant z score and in the case of a mean,<br>you look up the relevant t score. Don’t forget,<br>that if you’re interested in a mean, you should also compute the degrees of<br>freedom which is equal to n minus 1. Third, compute the endpoints<br>of the confidence interval. And finally, four,<br>interpret the results substantively. That’s it. If you’re not 95% confident now that<br>you can construct a confidence interval yourself, rewatch<br>the last couple of videos.</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十八 | 均值的推断和置信区间</title>
    <url>/data-science/statistics-inference-and-confidence-interval/</url>
    <content><![CDATA[<h1 id="统计推断"><a href="#统计推断" class="headerlink" title="统计推断"></a>统计推断</h1><p>这一节我们以睡眠为例。假设你通常每晚睡 8 个小时，你突然做了年轻爸爸或者年轻妈妈，你的睡眠时间减少到每晚 5 个小时，这意味着每晚减少 3 个小时，相当于每周 20 个小时，每年 1000 个小时，差不多 40 天。换言之，如果你家宝宝继续保持他 / 她的睡眠时间，一年之后你会比之前少睡 大约 40 天。</p>
<p>回到统计学，想象你想要知道你家乡的年轻父母在孩子刚出生那一年减少了多少睡眠。在这一节中我们将讨论统计推断。我们会基于样本信息，得出关于总体的结论。我们将会区分两种统计推断的方法，一种叫 <strong>统计估计 (statistical estimation)</strong> ，另一种叫 <strong>假设检验 (hypothesis testing)</strong> 。在这篇教程中，我们将先了解统计估计。 </p>
<p>有两种方式估计总体参数的值，其一叫 <strong>点估计 (point estimate)</strong> ，它是一个对于总体参数的最佳猜想。其二是 <strong>区间估计 (interval estimate)</strong> ，它是一个我们预期参数会落在的范围。 </p>
<p>想象我们抽取了 60 个受试者样本，有了第一个小孩后每晚减少的睡眠小时数均值为 2.6 小时。这个均值是一个对于总体均值很好的点估计。换言之，$ \bar x $ ，是一个对于 $ \mu $ 的很好的点估计。不过，单一的点估计无法告诉我们估计是否接近我们感兴趣的总体参数。因此，研究人员通常还希望知道点估计可能的准确度。他们借由计算区间估计来显示这种准确度。</p>
<p>区间估计是一个最有可能包含总体实际参数值的数字区间。基于我们的样本均值 2.6 小时，我们可以预测，比如说，你家乡新生儿父母每晚睡眠减少的平均小时数介于 2.3 小时到 2.9 小时之间。</p>
<p>这个区间包含总体参数值的概率，被我们称为 <strong>置信水平 (confidence level)</strong> ，置信水平总是一个接近 1 的值，多数情况下是 0.95 。接下来我们将讨论有 95% 置信水平的区间。</p>
<a id="more"></a>

<hr>
<h1 id="已知总体标准差，求均值的置信区间"><a href="#已知总体标准差，求均值的置信区间" class="headerlink" title="已知总体标准差，求均值的置信区间"></a>已知总体标准差，求均值的置信区间</h1><p>假设我们知道 60 个年轻父母的样本在第一个小孩出生后睡眠减少小时数的标准差是 0.9 小时，也知道总体的标准差是 1.1 小时。（实践中，不太可能知道这个参数，但这里我们先假定你知道）</p>
<p>这一节中，我们将学习如何基于样本信息和总体的标准差来构造 <strong>置信区间 (confidence interval)</strong> 。首先，我们来解释一下这样一个置信区间应该如何解读。</p>
<p>为了构造一个置信区间，我们需要用到样本均值的抽样分布。毕竟，我们是在处理一个来自总体的样本。 我们知道，只要样本足够大，抽样分布就是正态分布的，并且均值等于总体的均值，标准差等于总体的标准差除以样本数 n 的平方根。我们还知道，找到距离样本均值少于等于两个标准差的概率是 0.95 。更精确的，如果查询对应概率的 z 分数，我们会得到 -1.96 和 1.96 。</p>
<p>这意味着我们有 95% 的机会令样本均值落在总体均值 1.96 个标准差范围内。 1.96 个标准差的距离我们称为 <strong>误差界限 (margin error)</strong> 。误差界限告诉我们用样本均值 $ \bar x $ 估计总体均值的准确程度。 95% 置信区间的公式如下：</p>
<img src="/images/ci_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>它是由点估计或者样本均值加减误差界限，即 1.96 个标准差。注意我们是在处理样本均值的抽样分布。因此分布的标准差等于 $ \frac {\sigma}{\sqrt {n}} $ 。接下来请集中注意力，因为过程会有点复杂。 </p>
<p>假设你抽取一个样本，样本均值由某个点表示，从均值往两侧有一根线表示误差界限。它们一起构成了 95% 的置信区间。如果样本均值落在红色区域，则置信区间包含总体均值 $ \mu $ 。如果样本均值不落在红色区域，则置信区间不包含总体均值 $ \mu $ 。我们讨论的是 95% 的置信区间，这意味着随机选择一个样本，它包含总体均值的概率是 0.95 ，不包含总体均值的 0.05 。换言之，如果我们抽取无限多个样本， 95% 的情况，我们的置信区间会包含总体的均值。</p>
<p>现在让我们回到例子。例子中样本均值是 2.6 小时。总体标准差 1.1 。样本容量是 60 ，现在我们有了计算置信区间需要的全部数字。公式如下：</p>
<p>$$ \bar x\pm1.96\sigma_{\bar x} $$</p>
<p>我们知道 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ ，即 $ \frac {1.1}{\sqrt {60}} $ ，得到 0.142 。接下来计算误差界限， 1.96 乘以 0.142 ，约等于 0.28 。样本均值等于 2.6 ，因此 95% 置信区间是 2.6 减去 0.28 到 2.6 加上 0.28 的区间，即 2.32 到 2.88 。我们可以说，我们有 95% 的信心确定这个区间包含了实际的总体均值。更精确地说，如果我们从总体中抽取无限多个大小为 60 的样本，并且对于每个样本，我们计算误差界限， 95% 的情况下，总体的均值会落在样本的置信区间内。</p>
<img src="/images/ci_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果新生儿父母的这种境况会持续一年，我们有 95% 的信息说，这些人会减少 2.32 乘以 365 小时到 2.88 乘以 365 小时的睡眠时间，或者说， 846.8 小时到 1,051.2 小时，又或者说， 35.3 到 43.8 个整天。</p>
<hr>
<h1 id="未知总体标准差，求均值的置信区间"><a href="#未知总体标准差，求均值的置信区间" class="headerlink" title="未知总体标准差，求均值的置信区间"></a>未知总体标准差，求均值的置信区间</h1><p>95% 置信区间用于评估总体的均值，它告诉我们我们有 95% 的信息这个区间包含实际的总体均值。利用这个公式 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ ，你可以计算区间的两个端点。这个公式有一个问题，为了计算置信区间，你需要知道总体的标准差。然而，我们通常并不知道这个参数。毕竟，我们本来就在用样本推测总体的参数。</p>
<p>这一节中，我们将学习如何在不知道总体参数的情况下做出推断。解决方案是我们估计总体的标准差，因而我们要引入另一个分布，它叫 <strong>T 分布</strong> 。让我来告诉它如何工作。</p>
<p>想象我们问了 60 个年轻家庭他们在有了第一个孩子之后睡眠时间少了多少个小时，均值是 2.6 小时，标准差是 0.9 小时。为了构建一个 95% 的置信区间，我们需要用到 $\bar x\pm1.96 \sigma_{\bar x}$ ，<br>或者可以写成 $\bar x\pm {Z_{95 %}} \sigma_{\bar x}$ 。这一次，我们不知道总体的标准差。</p>
<img src="/images/ci_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此我们用样本的标准差来估计总体的标准差，公式变成: $\bar x\pm {Z_{95 %}} s_e$ ，其中 $ s_e = \frac {s}{\sqrt {n}} $</p>
<img src="/images/ci_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们把 $ s_e $ 这个估计的抽样分布的标准差称为 <strong>标准误差 (standard error)</strong> 。但是因为我们现在是估计标准差，所以我们在计算中引入了额外的误差。基于此，我们引入另一个分布， z 分布。由于额外的误差，我们现在使用 T 分布，公式如下。</p>
<p>$\bar x\pm {t_{95 %}} s_e$</p>
<img src="/images/ci_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在让我来详细解释 t 分布和 t 分数。 t 分布跟标准正态分布非常之相似，它是钟形的，对称的，并且均值是 0 。但是，它有一点点区别。 因为我们现在是估计抽样分布的标准差，我们引入了额外的误差。当我们的样本比较小时，这个误差很可观。 t 分布将这小样本的这个误差考虑在内了，因此它比标准正态分布稍微宽一点，标准差更大一些。如下：</p>
<img src="/images/ci_5_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>黑色的分布是标准正态分布，蓝色的分布是 t 分布。 t 分布的准确形状取决于样本容量。样本越大，t 分布越接近标准正态分布。更准确的说， t 分布的形状取决于单一个参数，我们称为 <strong>自由度 (degrees of freedom)</strong> ，以 $ df $ 注记。 t 分布中的自由度等于样本容量 n - 1 。这意味着我们实际上有许多不同的 t 分布，每一个都有单独的 $ df $。比如，自由度为 2 的 t 分布：</p>
<img src="/images/ci_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>自由度为 5 的 t 分布：</p>
<img src="/images/ci_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>自由度为 30 的 t 分布：</p>
<img src="/images/ci_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以看到，当我们有 30 或者更大自由度时， t 分布几乎就等同于标准正态分布。更准确的说，标准正态分布其实就是自由度等于无限的 t 分布。 </p>
<img src="/images/ci_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>同标准正态分布和 z 分数一样，我们也可以为特定的 t 分数寻找累积概率。重要的区别在于，这些概率依赖于自由度。当你计算一个 95% 置信区间时，你可以为所有可能的自由度找到对应 95% 置信水平的 t 分数，这个表格称为 <strong>t 表格</strong> ，它和 z 表格类似。</p>
<img src="/images/ci_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我用睡眠时间的例子来演示。样本中睡眠减少小时数的均值是 2.6 小时，标准差是 0.9 小时，样本容量是 60 。计算 95% 置信区间的公式：</p>
<img src="/images/ci_11.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我们从标准误差开始，它等于样本标准差除以 n 的平方根，即 0.9 除以 60 的平方根，得到 0.116 。我们的标准误差，或者说，估计的样本均值的抽样分布的标准差等于 0.116 。为了计算误差界限，我们需要用标准误差乘以 95% 置信区间的 t 分数。如你所知， t 分数取决于自由度。自由度 df 等于 n - 1 。我们有 60 个样本，因此 60-1 的 50 。在 t 表格中，我们在列中查找 95% 置信水平，在行中查找 59 自由度。因为表格中没有报告 59 自由度，我们向下取 50 自由度。对应的 t 分数是 2.009 。</p>
<img src="/images/ci_12.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此我们用 0.116 乘以 2.009 ，大约 0.23 。从样本均值 2.6 中加减这个值后，得到我们的置信区间是 2.37 到 2.83 。我们有 95% 的信心认为这个区间包含实际的总体均值。</p>
<p>为了计算总体均值的置信区间，有两个假定需要满足。首先，你的数据是随机获取的。换言之，样本必须是随机样本，否则你的发现就不是合法的。其次，总体必须近似正态分布。这一点可能是个问题，因为总体中的许多变量可能并不是正态分布的。不过，好消息是，采用 t 分布来构造置信区间，可以有效对抗第二个假设破坏。也就是说，即使违反了假设，这种统计方法仍然是健壮的。最后，在基于 t 分布构造置信区间是，你还需要对异常值保持机警。如果数据里有异常值，那么这个方法可能会失效。因此要记得在开始之前检查数据。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十七 | 样本比例的抽样分布</title>
    <url>/data-science/statistics-sampling-distribution-of-sample-proportion/</url>
    <content><![CDATA[<h1 id="抽样分布比例"><a href="#抽样分布比例" class="headerlink" title="抽样分布比例"></a>抽样分布比例</h1><p>想象你住在巴黎，你知道所有的学生中有 0.10 的比例把自己看做嬉皮士。你想要知道这个比例的抽样分布是什么样的。注意，在这里计算总体均值是没有什么意义的。因为你感兴趣的变量是一个二元标量。学生们可以选择认定自己是或者不是嬉皮士。均值和这样一个二元变量无关。</p>
<p>在本节教程中，我将解释一个总体比例的抽样分布是长什么样。你知道巴黎有 10% 的学生认为自己是嬉皮士，这意味着总体比例，用 $ \pi $ 注记，等于 0.10 。现在想象我们从这个总体中抽取 200 个学生。样本的比例，用 $ p $ 注记，将会是一个接近 0.10 的数字，比如 0.09 或者 0.12 。</p>
<p>如果抽取了 5 组样本，样本比例可能如下：</p>
<img src="/images/sdp_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这样样本比例的直方图可能如下：</p>
<img src="/images/sdp_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有五个值，全部都出现一次，它们的概率都是 0.2 。现在，你抽取 25 组样本，分布可能如下：</p>
<img src="/images/sdp_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>抽取 50 个样本，分布如下：</p>
<img src="/images/sdp_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>无限多组样本，分布如下：</p>
<img src="/images/sdp_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是样本比例的抽样分布，分布的均值是 0.10 ，等于总体的比例。为了表明我们是处理抽样分布的均值，均值被注记为 $ \mu_p $ ，下标 p 是为了说明我们正在处理的分布的分数不是个体的分数，而是样本比例。如你所见，逻辑上和样本均值的抽样分布一模一样。</p>
<a id="more"></a>

<img src="/images/sdp_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在样本均值的抽样分布案例中，如果总体本身是正态分布或者样本容量足够，那抽样分布是近似钟形的。通用最小需要 30 个样本数。在样本比例的抽样分布中，只有当你拥有至少 15 个正向的 case 以及至少 15 个负向 case 的前提下，你才能确信分布是钟形的，即至少 15 个嬉皮士和 15 个非嬉皮士。公式表达如下：</p>
<p>$$ n\pi \geq 15 $$<br>$$ n (1 - \pi) \geq 15 $$</p>
<p>这对于我们的例子意味着什么呢？首先，样本容量和总体比例的乘积必须大于等于 15 。在我们的案例中，即 200 乘以 0.10 ，等于 20 个嬉皮士。其次，总体比例和 $ 1 - \pi $ 的乘积必须大于等于 15 。在我们的案例中，即 200 乘以 (1-0.10)，等于 200 乘以 0.90 ， 等于 180 个非嬉皮士。 因此我们可以下结论，抽样分布将会是钟形的，因为 20 和 180 都大于 15 。有一个相当直接的公式可以计算样本比例的抽样分布的标准差。我们以 $ \sigma_p $ 注记标准差，你知道 $ \sigma $ 代表标准差，而添加的 p 则表明我们正在讨论的是样本比例的抽样分布。 为了计算这个标准差，公式如下：</p>
<p>$$ \sigma_p = \sqrt {\frac {\pi (1-\pi)}{n}} $$ </p>
<p>在我们的案例中，标准差算出来是 0.02 。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>对于二元类别变量，计算总体均值和标准差没有意义。取而代之的是，我们计算分类变量的比例。对于二元变量，我们只有总体的比例 $ \pi $ 。</li>
<li>相似的逻辑也适用于样本。我们也只有样本比例 p 。对于样本比例的抽样分布来说，我们的确有均值和标准差。只要知道总体的比例，抽样分布的这些参数也很容易计算出来。</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十六 | 样本均值的抽样分布和中心极限定理</title>
    <url>/data-science/statistics-sampling-distribution-and-central-limit-theorem/</url>
    <content><![CDATA[<h1 id="抽样分布"><a href="#抽样分布" class="headerlink" title="抽样分布"></a>抽样分布</h1><p>研究人员经常会用样本来推断样本所处的总体。为了做这件事，他们需要用到统计世界中非常重要的一种概率分布 —— <strong>抽样分布 (sampling distribution)</strong> 。</p>
<p>这一节中，我将向你解释抽样分布是什么。需要特别注意的是，抽样分布是帮助研究人员基于仅仅一个样本得出关于总体结论的桥梁。另外说明，在这节教程中，我们假装自己知道总体是什么样的。因为在研究实践中，我们通过永远都无法得知总体的全貌。这一步对于理解推断统计学至关重要。</p>
<p>好吧，让我们进入正题。想象有一群北欧的嬉皮士组织了一场胡子节庆典。庆典将在挪威首都奥斯陆附近的一个小岛举行。显然，你能想到庆典的受众是有胡子的男性。组织售出了 5,000 张门票，并且提供了往来小岛的免费运送。</p>
<img src="/images/sdl_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>拥有门票的人将在奥斯陆的港口集结。组织将他们随即分装到运送乘客前往该岛的船上，每条船搭载 30 名庆典的粉丝。</p>
<img src="/images/sdl_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，有一艘船迷失在挪威的群岛间。雪上加霜的是，手机网络崩溃了，因此组织无法联系上船长，船上的乘客也无法联系上组织。所有组织决定派出一些雇员去搜寻走失的船只。你正是其中的一名雇员。在历经里半个多小时的搜寻后，你看到一艘失事的船，上面有大约 30 个人。Yes，终于找到他们了。你正准备通过对讲机向组织报告失联船只已找到，这时你再看了一眼船上的乘客。你发现乘客都是一些带着小孩的家庭。这很奇怪，去胡子节的船上，不是应该都是一些随机选取的有胡子的成年男人吗？而不是一些带着小孩的年轻家庭。你认定这艘船不太可能是你要找的船，决定继续搜寻。果然，不久之后证明你的决定是明智的。你前面遇到的那艘船是一艘运送人们去另外一个岛上的家庭公园的船。</p>
<p>为什么要讲这个故事呢？这么说吧，如果你理解上面那个故事里 “你” 决策的原因，你就会理解抽样分布背后的基本思想。它是这样的，如果你从总体中抽取一个简单随机样本，那么它是不太可能强烈地区域于样本所处的总体的。在我们的案例中，人们正前往胡子节，他们构成了总体。一艘载有 30 个从总体中随机选取的人的船就是一个简单随机样本。</p>
<img src="/images/sdl_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>实际上，所有从奥斯陆港口前往庆典小岛的船都可以看做是一个简单随机样本。当然，每艘船都和其他船不一样，但大部分船都会包含大比例的有胡子的男人。不太可能有一艘船上都是各种年轻家庭。当然，有某些家庭参加胡子节是可能的，但是随机遇到一艘船，全部都是年轻家庭，则是非常不太可能发生的。</p>
<img src="/images/sdl_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假设你决定测量每艘船的平均胡子长度。每艘船有 30 个人。想象 5,000 个庆典参与者的平均胡子长度时 10.3 毫米，即均值是 10.3 毫米。你还知道胡子的长度在总体中服从一个钟形的分布。在一艘船上，你可能遇到胡子平均长度是 9.4 毫米，另一艘则可能是 10.8 。但是，不太可能遇到一艘船，上面的人平均胡子长度是 3.4 毫米，或者 19.2 毫米。因为这些船上的人的胡子的平均值可以看作是样本的均值，我们用 $ \bar x $ 来注记。</p>
<img src="/images/sdl_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<a id="more"></a>

<p>现在想象你正看着三艘船，概率分布可能长这样：</p>
<img src="/images/sdl_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>一艘船的均值是 9.9 ，一艘是 10.7 ，还有一艘是 10.2 。我们一共有三艘，所以每个均值的概率是 0.33 。现在想象有 17 艘船，40 艘船，100 艘船，你会发现胡子均值长度的分布会越来越接近钟形分布，并且，你会发现分布的均值接近 10.3 ，跟总体的均值一模一样。</p>
<img src="/images/sdl_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果你仔细琢磨一下，就发现这并不奇怪。你会期望，在绝大多数情况下，样本的均值和总体的均值接近。某一艘船的均值可能高一点，另一艘船的均值可能低一点。但是，当你看到许多船时，你会期望所有这些不同船的均值的均值，就等于总体的均值。</p>
<img src="/images/sdl_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，想象你的总体包含了所有的挪威男人。你知道这个总体的胡子长度均值是 1.22 毫米，并且变量服从一个钟形分布。如果你抽取一个 30 人的简单随机样本，你会发现均值接近总体均值，比如 1.34 毫米。你再抽取另一个随机样本，均值可能是 1.19 毫米，也很接近总体均值。如果你重复五次，你会得到五个不同的值，但是都很接近总体的均值。</p>
<img src="/images/sdl_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>当我们可以抽取无限多个样本时，分布将会是一个完美的钟形，均值是精确的 1.22 毫米，跟总体均值一样。我们把这种分布称为 <strong>样本均值的抽样分布 (sampling distribution of the sample mean)</strong> ，它是这样一种分布：你从总体中无限抽取样本，计算所有样本的均值。</p>
<img src="/images/sdl_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>目前为止，你应当意识到，在实际的研究中，我们不可能从某个总体中抽取无限多的样本。但是，你需要知道，如果我们能这么做，这个分布的均值将等于总体的均值，这正是我们把这个分布称为样本均值的抽样分布的原因。不要把这个和样本或者数据分布混淆在一起，这只是实际抽取的一个样本的分布，只针对实际收集的数据而言。</p>
<hr>
<h1 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h1><p>如果你从钟形分布的总体中取无限个样本，来自这个无限个样本的均值分布将会是钟形的。并且这种样本均值的分布将会和总体均值完全一样。我们将此分布称为样本均值的抽样分布。</p>
<p>在这一节中，我将讨论 <strong>中心极限定理 (central limit theorem)</strong> —— 推理统计学中，最重要的公式之一。 </p>
<img src="/images/sdl_11.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>中心极限定理表明，假设样本量足够大，样本均值 $ \bar X $ (x 的均值) 的抽样分布近似正态分布，即使这个变量在总体中并不是正态分布。这不是很神奇吗？不用理会变量在总体中是如何分布的，样本均值的抽样分布总是如此，总是近似正态分布，只要样本量足够大。作为足够大的指导，通常使用 30 或更大的样本。</p>
<img src="/images/sdl_12.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你们可以看这些总体分布可能的形状。这是当你取样本容量 n=30 时，样本均值的抽样分布图。记住，这意味着你从总体中抽取了无数个由 30 个调查对象组成的随机样本，在分布中显示所有生成的样本均值。</p>
<p>你应该意识到，在实践中，根本不可能抽取无数个样本。但是，好消息是根本不需要抽取多个样本来确定样本分布的形状。 因为如果它是正态分布，你可以通过两个参数来描述它的形状，即均值和标准差。因此，估计这两个参数就足够了。正如我之前告诉你的那样，抽样分布的均值等于总体分布的均值。我们可以这样表示，$ \mu_{\bar x} = \mu $，$ \mu $ 代表总体的均值，$ \mu_{\bar x} $ 代表样本均值的均值。 </p>
<p>想象你对挪威男人的平均胡须长度感兴趣。总体包括所有挪威男子，$ \mu $ 是总体的平均胡须长度。我们假设它是 1.22 毫米。对于样本均值的均值，如果我们从总体中抽取无数个样本，并记下每个样本中的平均胡须长度，我们就会得到这个分布的平均值，等于总体均值 1.22 。$ \bar X $ 是用来强调抽样分布中的分数是样本均值，而不是个体的分数。换句话说，总体分布的平均值是所有挪威男性的胡子长度得分的平均值。抽样分布的均值是从该人群中抽取的无限多个样本的样本平均值。</p>
<img src="/images/sdl_13.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果我们知道总体分布如何，我们可以轻松的计算出样本的标准差。抽样分布的标准差的符号化是 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ 。添加 $ \bar x $ 下标是为了表明我们正在谈论抽样分布的标准差，其中分数是样本均值，或者换句话说，$ \bar x $ 的 $ \mu $。$ \sigma $ 代表总体的标准差， n 代表样本的大小。此公式表明抽样分布的标准差受两个特征影响。首先，它受总体标准差的影响，假设 n 等于 30 ，你的总体标准差是 1 ，你的抽样分布的标准差等于 1 除于根号 30 ，等于 0.18 。如果你的总体标准差增加至 2 ，样本的标准差变成 2 除于根号 30 ，即 0.37 ，如果你的总体标准差变成 3，样本的标准差变成 0.55 ，等等。</p>
<p>所以，如果总体分布的的标准差增加，抽样分布的标准差也会增加。换句话说，总体方差越大，样本均值的方差越大。这在直觉上是合理的，对吧？如果你从人群中胡须长度差异很大的人群中抽取 30 个受试者的各种样本，你可以预期这些样本的相互之间的差异比你从几乎没有差异的总体中抽取各种样本的差异更大。你的抽样分布的标准差，也会受到样本容量的影响。再看看这个公式。假设总体标准差等于 2 。现在，如果 n=30 ，$ \sigma_{\bar x} $ 等于 2 除于根号 30 ，等于 0.37 。 如果 n=100 ，你的抽样分布的标准差将变为 2 除于根号 100 ，等于 0.2 。如果 n = 500 ，你的 $ \sigma_{\bar x} $ 变为 0.09 。</p>
<img src="/images/sdl_14.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这表明，一个更大的样本量导致抽样分布的标准差更小。这在直觉上也是合理的。如果总体中的挪威男性的平均胡子长度为 1.22 毫米，你只有两个受访者作为样本，找到一个更高的平均值并不奇怪。如果你抽取了五个样本，你的样本均值是看起来像这样。</p>
<img src="/images/sdl_15.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，想象一下你抽取了一个 1000 个受试者的样本，这个样本的均值不太可能是 5 或者 10 毫米。毕竟，长胡子的人会被完全没有胡子的人抵消。如果你抽取五组样本，样本均值可能看起来像这样。</p>
<img src="/images/sdl_16.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>它们都将非常接近总体平均值 1.22 毫米。所以你的样本容量越大，样本均值越接近总体均值，样本分布的标准差越小。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>中心极限定理告诉你：无论变量在总体中分布如何，只要样本容量至少为 30 ，样本平均值的抽样分布都近似正态分布。</li>
<li>抽样分布的均值 $ \mu_{\bar x} $ 等于总体均值 $ \mu $ ，抽样分布的标准差 $ \sigma_{\bar x} $ 等于总体分布的标准差 $ \sigma $ 除于 $ \sqrt {n} $。</li>
</ul>
<hr>
<h1 id="三种分布"><a href="#三种分布" class="headerlink" title="三种分布"></a>三种分布</h1><p>许多社会的、政治的以及宗教的团体有它们自己的神圣文字。嬉皮士，也有它们自己的 “圣经”，这是一本名叫 “On the Road” 的书。这一节中，我们对于纽约市的嬉皮士花了多少时间读这本书感兴趣。</p>
<p>假设我们知道总体，所有嬉皮士读这本书的平均时长是 943 分钟。我们还知道，总体的标准差等于 212 分钟。你从总体中做简单随机抽样抽取了 200 个受试者。这个样本中的平均阅读时长是 867 分钟，标准差 188 分钟。</p>
<p>这一节，我将介绍对于研究项目十分重要的三种分布 —— <strong>总体分布 (population distribution)</strong> ，<strong>样本分布 (sample distribution)</strong> ， <strong>抽样分布 (sampling distribution)</strong> 。我将向你展示，如果计算针对特定分数的选择性个体的概率。 </p>
<p>第一个分布，总体分布，它看起来像这样，近似钟形，均值 943 分钟，标准差 212 分钟，主体是纽约的嬉皮士们。</p>
<p>第二个分布，数据分布或者是样本分布，它是样本数据的分布，看起来像这样。它跟总体分布一样，近似钟形，均值 867 分钟，和总体均值 943 分钟相差不大。标准差 188 分钟。</p>
<img src="/images/sdl_17.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>注意，样本统计里采用罗马字母注记，而总体里采用希腊字母注记。</p>
<p>第三种分布，样本均值的抽样分布，它就像下面这样：</p>
<img src="/images/sdl_18.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>根据中心极限理论，它是正态分布的。在这个分布中，主体不是分布中的个体，而是来自纽约嬉皮士的 200 个受试者样本的一个不确定的数字。样本均值的抽样分布的均值，是这些不确定样本均值的均值。具体的数值，等于总体分布均值的数值，即 943 分钟。为了说明我们正在讨论的是抽样分布，我们添加 $ \bar x $ 下标来表明是样本均值的均值而不是个体分数的均值。抽样分布的标准差，等于总体标准差，除以 n 的平方根，即 212 ，除以 200 的平方根，得到 15 。</p>
<p>你需要记住的是，第三个分布是一个理论上的分布。我们并不实际地收集无限多的样本。那是不可能做到的，也不必做到。因为只要我们知道总体的均值和标准差，我们就能知道抽样分布长什么样。正态分布的一个大好处是，我们可以通过把原始分数变换成 z 分数，以及引入 z 表格，找出概率。</p>
<p>现在，想象你从总体中选择一个随机样本，这个嬉皮士阅读时长大于等于 1000 分钟的概率是多大呢？</p>
<p>首先，我们需要知道一个嬉皮士阅读那本书的时长等于 1000 分钟距离均值有多少个标准差。我们在总体中计算这个人的 z 分数，z 分数是 1,000 减去 943 ，除以 212 ，等于 0.27 。我们感兴趣的是这个值右边的区域。查询 z 表格，我们发现选中一个阅读时长大于等于 1,000 分钟的嬉皮士的概率是 39% 。现在，想象我们抽取 200 个嬉皮士。这个样本均值大于等于 1,000 分钟的概率是多少？千万注意，这是一个完全不同的问题。我们不是在讨论从总体中选取一个特定的人，而是在讨论基于总体中的特定样本的统计学。因此，我们不用总体分布，而是样本均值的抽样分布。通常，过程是相同的，只不过我们用的是不一样的均值和标准差。这里， z 分数计算过程如下。我们从感兴趣的均值，即 1000 ，减去抽样分布的均值，即 943 ，然后除以抽样分布的标准差，即 212 除以 200 的平方根，即 15 。因此， (1000 - 943) / 15 ，最后得到 z 分数是 3.8 。查询 z 表格，我们发现抽取一个样本的平均阅读时长均值大于等于 1,000 分钟的概率是 0.01% 。</p>
<img src="/images/sdl_19.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>决定选用哪种分布时，需要十分小心。如果你是对选择的独立个体感兴趣，应当使用总体分布；但如果你是对选择的样本感兴趣，应当使用抽样分布。在实际的研究实践中，混淆总体和抽样分布几乎不可能发生。因为你永远无从知道总体的全貌。你唯一可以确定的是你的样本长什么样。</li>
</ul>
<p>接下来，我们会学习如何在缺少总体分布信息的情况下，利用好抽样分布。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十五 | 样本和抽样</title>
    <url>/data-science/statistics-sample-and-sampling/</url>
    <content><![CDATA[<h1 id="样本和目标总体"><a href="#样本和目标总体" class="headerlink" title="样本和目标总体"></a>样本和目标总体</h1><blockquote>
<p>几乎所有的统计研究都基于样本。</p>
</blockquote>
<p>想象你试图知道伦敦有多少学生以嬉皮士自居，但你几乎不可能去问全部的学生这个问题。所以你决定采样，比方说 200 个调查对象，并估计有多少人把自己看做嬉皮士。</p>
<p>关于统计的一个好处是，它能基于仅仅这 200 个调查对象，即样本，帮助你得出关于伦敦所有学生的结论，即目标总体。这一节中，我将详细解释样本和目标总体。</p>
<p><img src="/images/sampling_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>如果你从目标总体约 300,000 个学生中选择 200 个调查对象作为样本，基本上你正在聚焦于总体的一个子集。如果你测量一组变量，比如性别，年龄，所在学校，等等。你可以做所有的计算，比如单一变量分析，包括众数、平均数和标准差，或者双变量分析，计算皮尔逊相关系数或者做回归分析。所有这些数字性总结都完全是基于样本，它们被称为 <strong>统计数字 (statistics)</strong> 。通常，这种总结样本数据的方法被称为 <strong>描述统计 (descriptive statistics)</strong> 。不过，在实际的研究实践中，我们经常对特定样本的总结不感兴趣 —— 我们的实际目标是对潜在的目标总体做出推断。</p>
<p><img src="/images/sampling_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>在我们的案例中，所有 300,000 个学生都在伦敦。如果我们借由样本中得到的数据推断关于总体的结论，那我们就是在使用 <strong>推断统计学 (inferential statistics)</strong> 的方法。 统计数字以罗马字母显示。例如，$ \bar x $ 代表平均数， s 是样本的标准差。 参数则以希腊字母显示， μ 代表总体的平均值， σ 代表总体的标准差。 </p>
<p><img src="/images/sampling_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>想象你问这 200 个调查对象他们觉得自己有多大程度上把自己看做嬉皮士。他们可以从 0 到 10 表示自己嬉皮士的程度， 0 代表他 / 她根本不认为自己是嬉皮士，而 10 代表一个人完全将自己视为嬉皮士。</p>
<p>现在想象样本的 “嬉皮士值” 均值是 3.12 ，核心问题变成：目标总体的均值是多少？推断统计学可以帮助我们解答这类问题。</p>
<a id="more"></a>
<h1 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h1><p>推断统计学指的是基于样本数据来得出对于总体的结论的一系列方法。可以想象，为了理解推断统计学的方法，学会如何抽取样本是至关重要的。这一节中，我将把好的抽样方法和坏的抽样方法放在一起一同讨论。同时，我会讨论到你在抽样过程中可能遭遇的各种 <strong>偏差 (bias)</strong> 。</p>
<p>样本是总体的子集，此外再无其他。对于推断统计学的方法来说，并非所有的样本都合用。你需要的是 <strong>代表性样本 (representative samples)</strong> 。换言之，你需要你的样本是总体的一个微型版本。为了达到这个目的，一个不错的方法是抽取 <strong>简单随机抽样 (simple random sample)</strong> 。这意味着你确信总体中的每一个对象都有相同的机会被选中。</p>
<p><img src="/images/sampling_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>回到嬉皮士的例子。你决定抽取 200 个调查对象。平均的嬉皮士值是 3.12 ，总体包含伦敦所有的学生，感兴趣的参数是总体的均值，样本包含 200 个被选中的学生。</p>
<p>你将用于推断总体均值的统计数据是样本的统计均值。为了得出结论，我们希望样本是简单随机样本。如何确保这一点呢？</p>
<p><img src="/images/sampling_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>首先，你需要搞清楚总体是怎样的。我们已经知道，总体是全体伦敦学生。</p>
<p>第二步，得到全部主体的名单，我们称之为 <strong>抽样框 (sampling frame)</strong> 。想象伦敦有一个组织拥有所有学生的概况信息，包括他们的通信录细节。进一步的，这个组织愿意和你共享名单。你让计算机从名单中随机抽取 200 个学生。这样一来，你就得到了一个简单随机样本。</p>
<p>下一步是确定你如何触达你的 200 个调查对象。在面对面的采访中，你和调查对象在相同的房间，面对面提问。这么做到的好处是调查对象比较有可能参与，缺点是这样收集数据太昂贵了。另一个选项是通过电话采访，这么做开销小很多，但通常调查对象在电话上耐心有限，因此采访时间短暂。你还可以让调查对象填写问卷。因为他们可以在线完成调查，所以也是很便宜的选项，缺点是他们很可能不参与。</p>
<p>与此同时，你会遭遇各种形式的偏差。第一个是 <strong>覆盖偏差 (undercoverage)</strong> ，它指的是采样数据框没有囊括所有的个体。在伦敦学生的例子中，如果学生的清单不完整，就会发生这种偏差。有的学生没有机会被纳入样本。</p>
<p>还有 <strong>抽样偏差 (sampling bias)</strong> ，它指的是每个个体被纳入样本的机会不是均等的。当你的抽取做不到随机时，这种偏差就会发生。举个例子，如果你选择在街上随机接触人群，我们称为 <strong>任意抽样</strong> 或者 <strong>便利抽样 (convenience sample)</strong> 。它并非随机，因为有些人比其他人更少上街，他们被纳入样本的机会就更小。</p>
<p>其三，在你取得样本后，还有一种形式的偏差，它叫 <strong>无应答偏差 (nonresponse bias)</strong> 。某些被选中的主体可能拒绝参与实验，或者就是无法触达。还有些同意参与的调查对象只愿意回到特定的部分问题。</p>
<p>问题在于，这些不参与的情况可能不同于总体样本。无论它是覆盖偏差，抽样偏差或者无应答偏差。因为这些个人没有机会被抽样或者被抽样的机会更小，抑或这些个人拒绝回答某些问题，我们可能高估或者低估调查的目标。</p>
<p>简言之，我们的判断 (estimation) 会因某些分群的 <strong>表达不足 (under-representation)</strong> 或者 <strong>过表达 (overrepresentation)</strong> 出现偏差。</p>
<p>最后，还有 <strong>反应偏差 (response bias)</strong> 。在这个案例中，实际给定的反应是有偏差的。有可能，因为调查者问了某些前置的其他问题或者调查对象认为某些答案是社会不能接受的。有可能某个学生认为自己是个嬉皮士，但他认为调查者不喜欢嬉皮士于是就告诉调查者他不是。在我们的案例中，评估可能因为某些回应的 <strong>系统性误表达 (misrepresentations)</strong> 而出现偏差。</p>
<p><img src="/images/sampling_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>因此，在抽取样本时，你需要确保抽样是简单随机抽样，尽可能将各种形式的偏差降到最低。不过，很多情况下我们几乎不可能做到简单随机抽样。所幸，有另外两种随机抽样方式一样奏效。</p>
<p>在介绍它们之前，让我们先重温一下简单随机抽样的工作方式。如果你的总体中包含了所有的伦敦学生，你打算抽取 200 个学生的样本。你把所有学生的名字写在纸上。你把所有的纸放进箱子里，然后随机抽 200 张纸。这就是简单随机抽样。</p>
<p>第一个替代方案是 <strong>随机多阶段整群抽样 (random multi-stage cluster sample)</strong> 。它的工作方式如下：首先，你在总体中标识出大量的 <strong>整群 (cluster)</strong> ，比如，根据学生注册的不同的教育程序，每种程序用一个桶表示。把学生的纸按照注册的教育程序放入不同的桶中。接下来，你随机选几个桶，然后从这些桶中选取代表学生的纸，这样就得到了样本。多阶段整群抽样在你无法拿到很完整抽样数据框，或者简单随机抽样太昂贵时是一个很好的替代方案。</p>
<p>第二个替代方案是 <strong>分层随机抽样 (stratified random sample)</strong> 。现在，你将总体分成独立的组，这些组我们称为 <strong>层 (strata)</strong> 。例如，伦敦的各所大学，每个大学用一个盒子表示。你把学生的名字按照他们注册的大学放进不同的盒子里。接下来，你从每个盒子里随机挑出名字。所有这些名字就构成了你的样本。这种方法的好处是你可以确信样本中每一层都有足够的个体，缺点是你需要数据框，你还需要知道每个调查对象属于哪一层。</p>
<p>有一个重要的警告。大样本无法弥补糟糕的抽样步骤。如果你的样本不够随机，尽管你可以一直增加抽样数，你的样本也永远不会变得更好。假设你的样本是随机的，那大样本理论上总是更好的。不过，一旦你超过了某个临界点，样本量的增加对于总体参数评估准确度的影响就微乎其微了。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十四 | 二项分布</title>
    <url>/data-science/statistics-binomial-distribution/</url>
    <content><![CDATA[<p>对于离散随机变量，有一个最重要的概率分布，它是 <strong>二项分布 (binomial distribution)</strong> 。二项分布处于二元数据。因为二元数据的情况非常多，所以二项分布使用频繁。</p>
<p>让我们从例子开始，你会在这些例子中看到两种结果。比如，参加会议是否迟到，投票赞成或者反对，噪音等级超过 80 分贝或者没有。当你收集这类现象的试验时，成功或者失败的数字服从二项分布。例如，你可以考虑每 25 个与会人员，有多少个迟到，或者投反对票的人有几个。</p>
<img src="/images/bd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>下面是你可以确定一个随机变量服从二项分布的条件：首先，每一个试验成功的概率相同；其次，试验在统计上是独立的 —— 即一个试验的结果不会影响其他试验。</p>
<img src="/images/bd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>实际上，你发现二项分布的三个要素。首先，试验现象有两种结果，并且成功概率是常量。这种实验被称为 <strong>伯努利试验验 (Bernoulli trial)</strong> 。其次，你观察试验结果 n 次。第三，你对成功的结果计数，记为 x 。这三个元素被结合成一个公式，它给出了在 n 次试验中取得特定数量成功结果的概率。公式如下：</p>
<p>$$ P (x) = \frac {n!}{x!(n - x)!} p^x (1 - p)^{n-x}, x = 0,1,2,…,n $$</p>
<p>你可以直接把 n，x 和 p 填进公式从而获得答案。</p>
<img src="/images/bd_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如公式所示，随机变量 x 只能取 0 到 n 的值。这很合理，因为你只能有有限次成功，0 ，1 ， 2 ，直到 n 。因此这个公式是一个概率质量函数，它直接给出了匹配每个可能的 x 的概率值，你不必像考虑概率密度函数那样考虑区间。</p>
<img src="/images/bd_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>感叹号不常见，它表示 <strong>阶乘法 (factorial)</strong> ，即把所有从 1 到指定的整数全部相乘的结果。例如， 4 阶乘等于 1 乘以 2 乘以 3 乘以 4 。 公式前部的这个阶乘的除法实际上是给出了无视顺序，从 n 个元素中选出 x 个元素的方法，它也被称为 <strong>二项系数 ( binomial coefficient)</strong> ，有的时候也速记为 $ C^x_n $ 。</p>
<p>现在，让我们把二项公式应用到特定的例子里吧。想象你每天通勤的路线上需要经过一座吊桥。这桥有 10% 的时间是打开的，但打开时机是随机的。那么你在一周中碰到 0 ， 1， 2 ，直到 5 天的概率是多少呢？</p>
<img src="/images/bd_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>实验有 5 次试验，遇到打开的桥的概率是 0.1 。因此，这里的二项分布的概率如下：</p>
<img src="/images/bd_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果你把 6 个概率和 x 相乘并加总，你会发现这个值等于 1 。本应如此。</p>
<a id="more"></a>

<p>让我们借助同一个例子，移到一个相关的问题，如果 5 天内最多一天遭遇打开的吊桥，这个概率怎么算呢？可以很好地利用上面的概率表，我们要找的是没遇到打开的吊桥和有一天遇到打开的吊桥的情况，两个概率之和是 0.92 。</p>
<img src="/images/bd_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>为了回答最后一个问题，我们需要利用累积的二项概率分布，即给定所有结果，低于或者等于某个成功数量的概率。方程如下：</p>
<p>$$ F (x) = P (X \leq x) = \sum_{k = 0}^{x} \frac {n!}{k!(n - k)!} p^k (1 - p)^{n - k} $$</p>
<p>这个公式跟二项概率质量函数几乎相同，除了在前面做了求和，并且把所有的 x 替换成了符号 k 。</p>
<p>现在让我们来看一下二项分布的形状。它是离散的，意味着它只会给出 0 , 1 , 2, 之类的概率。</p>
<img src="/images/bd_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有趣的是，二项分布的形状会根据参数的变化而变化。基于参考，分布可以是 <strong>右偏态 (right-skewed)</strong> 的，或者 <strong>左偏态的 (left-skewed)</strong> 的，或者是对称的。</p>
<img src="/images/bd_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这三个分布显示 20 个成功概率不同的试验。第一个成功概率是 0.1 ，第二个成功概率是 0.5 ，第三个是 0.9 。</p>
<img src="/images/bd_11.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>一般来说，成功概率更低的二项分布是右偏态的，而成功概率高的是左偏态的。通过水平对齐，你会发现中间分布的顶点低于两边的，因此它更分散。这是二项分布很有趣的一个属性。实际上，二项分布的标准差取决于 p ，均值也是。二项分布的均值就等于 p ，它的标准差等于 n 乘以 p 乘以 (1 - p)，然后求平方根。当 p 等于 0 或者 1 时，标准差等于 0 。当 p 等于 0.5 时，它的标准差达到最大。</p>
<img src="/images/bd_12.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>二项分布是一个离散概率分布，用于只有两个独立互斥结果的随机变量 —— 成功或者失败。它给出了对于随机变量的 n 个结果，其中 x 个成功的概率。也叫做试验成功的概率。</li>
<li>二项分布假定所有试验的概率 p 都是固定的，它的均值等于 n 乘以 p ，标准差等于 n 乘以 p 乘以 (1 - p)，然后求平方根。</li>
<li>二项分布根据 p 的变化可以向右或者向左偏斜，或者对称。当 p 接近 0 时是右偏态，当 p 接近 1 时是左偏态。二项分布公式如下：<br>$$ P (x) = \frac {n!}{x!(n - x)!} p^x (1 - p)^{n-x}, x = 0,1,2,…,n $$<br>速记为 $$ X \sim B (N, P) $$</li>
<li>二项分布的累积概率分布公式如下：<br>$$ F (x) = P (X \leq x) = \sum_{k = 0}^{x} \frac {n!}{k!(n - k)!} p^k (1 - p)^{n - k} $$</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十三 | 正态分布</title>
    <url>/data-science/statistics-the-normal-distribution/</url>
    <content><![CDATA[<h1 id="正态分布-normal-distribution-的函数形式"><a href="#正态分布-normal-distribution-的函数形式" class="headerlink" title="正态分布 (normal distribution) 的函数形式"></a>正态分布 (normal distribution) 的函数形式</h1><p>在所有的概率分布中，有一个特别出众，我们经常遇到。它就是 <strong>正态分布 (normal distribution)</strong> 。</p>
<p>在本节中，我们会学习它的重要属性。正态分布又被称为 <strong>高斯分布 (gaussian distribution)</strong> 。它是对称的，钟形，以均值 μ 和 标准差 σ 为特征。分布的最高点是均值的位置，宽度则由标准差指定。均值 μ 和 标准差 σ 被称为正态分布的 <strong>参数 (parameters)</strong> 。</p>
<img src="/images/nd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>正态分布的累积概率分布是一个 <strong>S 函数曲线 (sigmoideal shape)</strong> ，均值处于概率为 0.5 的地方，标准差决定了曲线的陡峭程度。</p>
<img src="/images/nd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>随机变量 X 有一个均值 μ ，标准差 σ 的正态分布，可以速记为：</p>
<p>$$ X \sim N (\mu, \sigma^2) $$ </p>
<p>而下面这个等式描述了完整的概率密度：</p>
<p>$$ f (x)=\frac {1}{\sqrt {2\pi}\sigma} e^{-0.5\left (\frac {x-\mu}{\sigma}\right)^2} $$ </p>
<p>这个方程之所以重要，并非因为它第一眼看起来很复杂 —— 包含了三个重要的数学常量，$ \pi $，$ e $ 和 2 的平方根，还因为它连接了统计国王和物理世界。这个方程可以描述粒子扩散的过程。如果你释放一个扩散物，比如放一块糖到茶里，茶里的糖将按照这个方程的规律扩散。不仅流体是这样，大气中的颗粒物，道路交通，社会中的信息，都遵循这个分布的规律。</p>
<a id="more"></a>

<p>同时，我们会频繁地遇见高斯分布，是因为根据 <strong>中心极限定理 (central limit theorem)</strong> ，各种独立的随机过程组合之后，就会产出这种分布。不过，让我们不要跑题。我将通过拆解的方式来解释这个方程。</p>
<p>整个方程给出了随机变量 X 的概率密度，整个函数是一个 <strong>指数函数 (exponential function)</strong> ，前面是一个常数，然后指数部分包括小 x ，即随机变量可能取得的值。观察指数部分，从 x 中减去平均数，然后除以 σ ，这实际上是在计算 z 分数。所以随机变量的值在参与到方程后续的计算之前先做了标准化。</p>
<img src="/images/nd_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在让我们聚焦到 e 之前的常数。在没有常数之前，曲线之下的面积是跟着 σ 变化的。但是通常乘以这个常量，这块面积变成了精确的 1 。这个常量的值实际上正是曲线顶部的高度，也就是 x 等于 μ 的地方。</p>
<img src="/images/nd_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>正态概率分布有一个违反直觉的属性 —— 当逼近极大或者极小的 x 时，概率接近于 0 ，但实际永远不可能是 0 。</p>
<img src="/images/nd_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这导致一个事实：随机变量的值可以往负无穷大和正无穷大无限伸展。即使这些值是极小的概率，但仍然满足所有概率之和等于 1 的规律。</p>
<img src="/images/nd_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>最终确定之前，让我们回到 μ 和 σ 这两个参数，它们决定正态分布曲线的位置和形状。下图是一个西欧男性在一周中每天上班路上花的通勤时间。平均的通勤时间是 3 分钟，标准差 6 分钟，而同一个国家的西欧女性，通勤均值更小，但是标准差更大。你会发现，曲线越宽，顶点越低。</p>
<img src="/images/nd_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>曲线还有一个属性 —— 当 x 轴的单位变化时， y 轴的单位也会发生变化。比如，你用小时而不是分钟来表示时间时，概率密度就从每分钟变成了每小时。</p>
<img src="/images/nd_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>正态分布或者说高斯概率密度函数，是对称的钟形曲线，其对应的累积概率函数是 S 形曲线。位置和形状完全由两个参数描述，均值和标准差。均值决定曲线的中点，而标准差决定曲线的宽度。曲线越宽，则顶点必定越低。因为曲线下的面积始终等于 1 。</li>
<li>对于一个均值为 63 ，标准差为 12 的变量 x ，速记如下：<br>$$ X \sim N (63, 12^2) $$<br>正态分布方程如下：<br>$$ f (x)=\frac {1}{\sqrt {2\pi} 12} e^{-0.5\left (\frac {x-63}{12}\right)^2} $$</li>
<li>这种方程不但描述了概率分布，也描述物理世界中许多过程的结果，其中的许多扩散形式十分重要。</li>
</ul>
<hr>
<h1 id="正态分布的概率计算"><a href="#正态分布的概率计算" class="headerlink" title="正态分布的概率计算"></a>正态分布的概率计算</h1><p>如果我们知道某个随机变量的概率分布，那我们就可以计算变量落在某个区间的概率。</p>
<p>这一节中吗，我将通过一个具体的例子来解释这类计算是如何进行的。</p>
<p>概率密度函数，经常被缩写为 pdf ，给出了随机变量每单位的概率。下面是一个出租车司机日常等待时间的 pdf 。在 y 轴你看到是每小时的概率， x 轴是以小时为单位的概率。现在，假设你是一个出租车司机，你想要知道一天中等待时间超过 7 小时的概率。你需要计算面积区域。基于图像，你可以粗造地估计面积。</p>
<img src="/images/pdf_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>借助累积概率函数，也可以做到这一点，并且更精确。通过 x 轴 7 个小时的位置读取对应的 y 轴上的概率，再从 1 中减去这个概率。因为你关心的是长于 7 个小时而不是短于 7 个小时的概率。</p>
<img src="/images/pdf_1_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，让我们应用此前了解到的正态分布的等式。它是一个中点位于 μ ，宽度由 σ 定义的 pdf 形状。对应的累积概率函数在下方。</p>
<img src="/images/pdf_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有趣的是，尽管曲线会随着 μ 和 σ 变化，距离中点一个 σ 的区间，对应的概率始终不变。</p>
<img src="/images/pdf_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我演示一下，假设一条曲线的均值是 20 ，标准差是 9 ，另一条曲线的均值是 30 ，标准差是 6 。对两条 pdf ，从均值减去一个标准差到均值加上一个标准差的区域，曲线之下的面积都是 0.68 。无论 μ 和 σ 分布是多少，所有的正态分布都满足这个情况。</p>
<img src="/images/pdf_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在把区间扩展到围绕均值正负两个 σ ，区间对应的概率大致是 0.95 。</p>
<img src="/images/pdf_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>再扩展到正负三个 σ ，区间对应的概率大致是 0.997 。</p>
<img src="/images/pdf_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>统计计算中经常用到一个、两个、三个 σ 区间的概率值。</p>
<img src="/images/pdf_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我通过一个练习来演示一下一个、两个、三个 σ 的规则。假设你在一周中花在通勤上的时间服从正态分布，均值 40 分钟，标准差 10 分钟。 那 95% 的状态下，你的通勤时间会落在哪个范围。是的，它在均值减两个标准差到均值加两个标准差的区间。在这里，就是从 40 分钟减去 20 分钟到 40 分钟加上 20 分钟的区间。</p>
<img src="/images/pdf_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我假定你想要知道通勤超过 50 分钟的概率，在已知平均时间是 40 分钟，标准差是 10 分钟以及一个 σ 规则的前提下，你会如何计算呢？为了解答这个问题，你需要一点创造力 —— 你知道正态分布是对称的。因此有一半的概率落在均值的一侧，继而可以知道从均值减去一个标准差到均值这个区间，概率是 0.68 的一半，即 0.34 ，于是，小于 50 分钟的概率就是 0.5 加上 0.34 ，即 0.84 。然后取补集，即 1 - 0.84 ，等于 0.16 。</p>
<img src="/images/pdf_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>基于概率密度函数，你可以计算随机变量落在给定区间的概率，通过估算曲线在那个范围下的面积。借助累积概率函数，通过读取 y 轴对应的概率值也能做到这一点，并且更精确。</li>
<li>对于一个服从正态分布的变量来说，围绕均值的区间，有一个固定的概率对应关系。</li>
</ul>
<hr>
<h1 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a>标准正态分布</h1><p>在计算器和计算机还不得的时代，正态分布有一种非常重要的特殊形态 ——  <strong>标准正态分布 (standard normal distribution)</strong> ，也被称为 <strong>z 分布 (z-distribution)</strong> 。不过即便在今天，标准正态分布仍被高频使用，用于快速计算和呈现分析结果。</p>
<p>这一节中，我将解释标准正态分布的属性和应用。</p>
<p>尽管距离均值 1 个， 2 个， 3 个标准差的概率值很有分析的价值，仍有许多不在这些位置上的情况需要计算概率。</p>
<img src="/images/snd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>举个例子，比如距离均值 1.3 个标准差的概率。实际上，为了表示距离均值任意数量个标准差的意思，我们选择字母 z 。 这些 z 值的概率分布是一个均值为 0 ，标准差为 1 的正态分布，也被叫做为标准正态分布，或者 z 分布。</p>
<img src="/images/snd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>z 分布的累积分布常常用表格来呈现。下面这份表格给出一个正态分布的随机变量的累积概率，位置通过均值加上 z 个标准差偏移来确定。</p>
<img src="/images/snd_2_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这份表格同时展示了 z 值和关联的累积概率。</p>
<img src="/images/snd_2_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如你所见，从值 -2.00 开始，以很小的步长增长，要累积到接近 1 的地方，列表会很长。因此，我们通常采用另外一种更简洁的形式来呈现 —— 用 z 值第 1 位小数作为一条边，第 2 位小数作为另一条边。</p>
<img src="/images/snd_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>基于这样一个表格，你能够基于给定的 z 值，快速地找到与之关联的累积概率。比如，为了找到 z 值等于 1.41 的累积概率，你先选择 1.4 ， 然后选择 0.01 ，最后找到对应的概率是 0.92 。</p>
<img src="/images/snd_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>但如果我们是从一个普通的正态分布开始，该如何拿到 z 呢？首先，你需要这样考虑：对于一个随机变量 X 的某个值 x ，要把它看成均值加上 z 个标准差偏移。这个时候，你想知道 z ，可以反过来借由 x ，均值和标准差。把等式做一个调整，你发现 z 值等于随机变量的观察值与均值之差，再除以标准差。</p>
<img src="/images/snd_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我们把上面的变换应用到实例中。想象一群绿脚大雁每年秋天都要从波罗的海地区迁徙到欧洲的大西洋海岸。迁徙持续时间服从均值为 4 天，标准差为 1.3 天的正态分布。现在，要计算这群大雁在 6 天内到达迁徙目的地的概率。</p>
<img src="/images/snd_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>首先，你需要对 6 天做 <strong>z 变换 (z transform)</strong> ，通过 x 减去均值，然后除以标准差，得到 1.54 。下一步，在表格中查询 z 值，找到匹配的概率概率。</p>
<img src="/images/snd_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如你所见，这个 z 值匹配的是概率 0.9382 ，这就是针对前面问题的答案 —— 这群大雁在 6 天内完成迁徙的概率。</p>
<img src="/images/snd_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果是迁徙时间介于两天到五天之间，你又会怎么计算呢？下面是问题的正式描述：</p>
<img src="/images/snd_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>首先，计算小于 5 天的概率，然后计算小于 2 天的概率。然后将两个概率相减，就得到要求的范围： 2 天到 5 天。小于 5 的概率是 0.78 ，小于 2 的概率是 0.06 。从 2 到 5 的概率等于两者之差，即 0.72 。</p>
<img src="/images/snd_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，让我们休息一下。我们已经看到，可以把任意正态分布转换成标准正态分布或者说 z 分布的变量，通过减去均值再除以标准差来实现。然后，借助表格化的分布数据，我们能找到小于某个值、大于某个值或者介于两个值之间的概率。因此，如果你已经有一个概率了，你想反过来找出对应的随机变量的值，这时候要怎么做呢？</p>
<p>别担心，做法几乎相同，只需要反过来。还是用前面大雁迁徙的粒子。假设它们平均需要 4 天，标准差 1.3 天来完成迁徙。那么，你可以找出迁徙持续时间的十分位。</p>
<img src="/images/snd_12.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>持续时间的十分位意思是迁徙时间少于所有情况中的 10% 的情况，或者多于所有情况中的 90% 的情况。首先，你通过查表看到最接近概率 0.1 的 x 的值，它是 - 1.28 ，然后借助公式 $ x = μ + zσ $ ，你得到 x 的值时 2.34 天。</p>
<img src="/images/snd_13.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>最后，我想强调的是， z 变换适用于任意类型的数值数据，它会得到一个均值为 0 ，标准差为 1 的数据集，并且不包含对数据潜在分布的假定。因此，标准化数据是一个好方法，尤其是你想在不同的案例间做比较的时候。不过， z 变换并不能自动地创造出服从 z 分布并且能允许你计算概率的数据。你要得到 z 分布的数据，前提是数据本来就服从正态分布，并且你能算出均值和标准差。</p>
<img src="/images/snd_14.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li>z 变换可以应用于标准化数据，取得一个均值为 0 ，标准差为 1 的数据集，无论原始数据集是何种分布。当已知数据富服从正态分布时，可以基于 z 分数，借助对应 z 分数的累积概率表格来做概率计算。</li>
<li>对于给定的 x ，你通过从中减去均值，再除以标准差的方式来获得 z 。 z 表格提供了匹配 z 值的累积概率。这些概率指的是随机变量小于或者等于 x 的概率。相反地，对于给定的概率，你可以在表格中找出 z 值，然后计算出匹配这个值的 x 。</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十二 | 随机变量的平均数和方差</title>
    <url>/data-science/statistics-mean-and-variance-of-random-variable/</url>
    <content><![CDATA[<h1 id="随机变量的平均数"><a href="#随机变量的平均数" class="headerlink" title="随机变量的平均数"></a>随机变量的平均数</h1><p>在了解了随机变量的概率分布之后，我们可以开始对这种变量进行计算了。</p>
<p>首先，你需要知道，<strong>总结性统计 (summary statistics)</strong> ，跟观测数据相似，都能用来捕捉分布的本质。这一节中，我们要来研究概率分布的平均数，以及我们在调整随机变量或者组合随机变量之后，平均数如何变化。</p>
<p>以下将一个随机变量的平均数以 $ μ $ 注记，它表示对许多观测值预期的平均结果，因此也被称为随机变量的 <strong>期望值 (expected value)</strong> ，以 $ E $ 注记。</p>
<p>一个离散随机变量的平均数是所有可能的值乘以概率权重之后的均值，因此它等于每个可能的值乘以概率，然后加总。对于连续随机变量，同样的规则也适用。为了应对连续性，加总的计算被替换成积分 (integral) ，概率也不像离散那样被定义为 i ，而是 x 的函数。 </p>
<p>举个例子，假设你正在一个熟悉的街区日常漫步，路上会经过三个交通灯。每等一个交通灯会使整个漫步多花 2 分钟。对于这三组交通灯的等待，你记录了等 0 个 到等 3 个的频率，下面是概率表：</p>
<img src="/images/mvorv_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你预期的等待时间计算方法如下，最后会得到 2 分 12 秒。有趣的是， 2 分 12 秒这个值实际永远不会发生。你要么不用等，要么就是等 2， 4， 6 分钟中的某个时间。</p>
<p>现在，让我们来审视一下随机变量的平均数。如果我们给随机变量 x 乘上一个系数再加上一个值， 变成 $ a + bx $ ，那么平均值会变成 $ μ_{a+bx} $ 。</p>
<a id="more"></a>

<p>现在回到我们的例子。由于你找到一条捷径，旅程节省了一分钟。但同时，交通灯变得更忙了 —— 等待时间增加到 2 分 30 秒，即增加了 25% 。你抄近路省出的时间对应方程里的 a ，等待时间增长系数 1.25 对应 b 。新的概率分布通过下面这张表格呈现。</p>
<img src="/images/mvorv_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>新的等待时间平均值变为 1 分 45 秒。</p>
<p>现在让我们来看看两个随机变量相加或者相减的时候回发生什么。结果是：两个相加或者相减的随机变量的平均值也是它们各自平均值的简单求和或者求差。这个结论甚至不要求两个变量相互独立。</p>
<img src="/images/mvorv_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>举个例子，假设你想要计算一个礼拜的等待时间的平均值，那你只需要把每天的平均值加起来就可以了：</p>
<img src="/images/mvorv_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>平均值，或者一个离散随机变量的期望值，是变量所有可能的值乘以它们的概率，然后求和。如果随机变量通过乘法或者加上常数改变，那么平均值会发生相同的变化。</li>
<li>几个随机变量的平均值加总在一起是它们平均值的总和，即便这几个变量在统计上不一定是独立的。</li>
</ul>
<hr>
<h1 id="随机变量的方差"><a href="#随机变量的方差" class="headerlink" title="随机变量的方差"></a>随机变量的方差</h1><p>在平均数之后，你需要了解的第二个总结性统计指标是随机变量的方差，即离散程度的度量。</p>
<p>这一节中，我们要来研究概率分布的方差，以及我们在调整随机变量或者组合随机变量之后，方差如何变化。</p>
<p>一个随机变量 X 的方差 var (X) 是以它与平均值的差值的平方的期望来定义的：</p>
<p>$$ var (X) = E [(X - μ)^2] $$</p>
<p>如果你想基于概率分布算出方差，它其实是变量可能的值与平均值之差的平方，然后加总或者积分。<br>连续随机变量的方差：<br>$$ \int {(X - μ)^2f (x) dx} $$<br>离散随机变量的方差：<br>$$ \sum {(x_i - μ)^2P (x_i)} $$</p>
<p>连续随机变量的方差比较复杂一些，用到了积分。离散随机变量看起来就简单一些。</p>
<p>举个例子，这个离散分布给出了一年中你可能遭遇交通事故的风险。平均风险是 0.04 ，即每 25 年一次。</p>
<img src="/images/mvorv_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>首先，你计算出事故次数和平均值之差，然后平方，乘上对应的概率，最后加总。事故风险的方差看起来接近 0.06 ，标准差 0.24 左右。</p>
<p>现在，让我们来看看，如果通过给随机变量加一个 a 或者乘以 b ，方差会发生什么变化。</p>
<img src="/images/mvorv_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>当你将两个 a 放定义方差的等式中变换时，你会发现常量 a 消失了，而因子 b 被平方了。因此，通过加或者减一个值到随机变量，它的方差不变。但通过乘以一个数 b ，它的方差会变成原始方差乘以 b 的平方。标准差，即方差的平方根，则跟随因子 b 一起变化。</p>
<p>举个例子，你是否经历过晴天人们更愿意跟你打招呼，阴天更不爱搭理你的情景呢？下面图中上方是一个阴天时你走在街上每分钟遇到的点头或者微笑次数的分布。平均每分钟 1.4 次，方差 0.84 。而图中下方是晴天时的数据，你发现大家变得更友好了，具体来说，友好的倍数是 2 。</p>
<img src="/images/mvorv_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>理论告诉我们，平均值应该变成 2 倍于 1.4 ，即 2.8 ，而方差应该变为 4 倍，即 3.36 。让我们检视一下新的分布的方差。</p>
<img src="/images/mvorv_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这个表格展示了具体的步骤。从微笑或者点头次数减去平均值得到差值，平方，乘以概率，最后加总，确实是 3.36 。</p>
<p>现在让我们来看看如果把两个随机变量相加或者相减会怎么样。对于随机变量 X 和 Y ，两者之和的方差是两者各自方差的和再加上 2 乘以 X 和 Y 之间的 <strong>协方差 (covariance)</strong> 。而两者之差的方差是两者各自方差的和再减去 2 乘以 X 和 Y 之间的协方差。</p>
<img src="/images/mvorv_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>下面这两个更完整的等式则适用于 X 和 Y 各自有因子 a 的情况。</p>
<img src="/images/mvorv_9_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这些等式适用于任意两个相加或者相减的随机变量，而且显而易见，它们要求你知道两个变量之间的协方差。然而，协方差信息通常是不可得的，因此我们这里不考虑通用的情况，而是先考虑一个更严格的案例，即变量之间不相关的情况。这样会使问题简单很多，因为两个不相关变量之间的协方差是 0 ，后面 1 项就从等式中消失了。</p>
<img src="/images/mvorv_9_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此，在不相关变量之间，相加或者相减都无关紧要了，方差总是两个方差之和。你还可以把等式泛化到任意多个随机变量之和。</p>
<img src="/images/mvorv_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>还有一个值得注意的点是，随机变量相加的标准差总是小于独立的随机变量标准差相加之和。这看起来很合理，因为随机变量结合之后，有一些变异性会被抵消。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>随机变量的方差，是这个变量所有可能的值减去它的平均值，乘以概率，然后平方，最后加总或者积分。<br>$$ 连续随机变量：\int {(X - μ)^2f (x) dx} $$<br>$$ 离散随机变量：\sum {(x_i - μ)^2P (x_i)} $$ </li>
<li>给随机变量增加常量不会改变方差，但因子会导致方差变为因子平方倍。</li>
<li>几个不相关随机变量相加或者相减的方差等于这些变量各自方差之和。标准差是方差的平方根，因此为了得到调整后的标准差，你需要先得到调整后的方差。</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十四 | 二项分布</title>
    <url>/data-science/statistics-probability-distributions/</url>
    <content><![CDATA[<h1 id="随机变量和概率分布"><a href="#随机变量和概率分布" class="headerlink" title="随机变量和概率分布"></a>随机变量和概率分布</h1><p>随机变量的随机性其实并不像它的名字传递的那样多。这一节教程中，我将通过随机变量的可能结果和它们对应的概率来描述 <strong>概率分布 (probability distribution)</strong> 。换句话说，随机分布使随机性具体化，并且提供了一条在计算中使用随机变量的道路。当我们观察个体或者对象的时候，我们可以关注每个个体的若干个属性，这些属性就叫做 <strong>变量</strong> 。</p>
<p>现在，想象你收集了一份数据，并且决定重复实验。你能够找到相同的试验个体来测量变量，或者能找到相近的个体。不管采用哪一种，你会发现你的变量的值每次都不一样。这就是所谓的变量。举个例子，你测量一个人的身高几次，每次的结果可能会有几毫米到 1 厘米的偏离，这取决于你测量的时间在一天中的时刻，你的测量设备的精度，等等。</p>
<p>通常我们预料变量的值具有随机的变异性。如果这种概率的随机性是中肯的，则这个变量被称为 <strong>随机变量 (random variable)</strong> 。随机变量可以有一组可能的值，每个值都和概率关联。因此，如果随机变量的样本足够大，不同值的相对频率就接近概率。为了让表达更清晰，让我们用斜体的大写字母来表示随机变量，小写字母来表示它取到的值。</p>
<p>即 <strong><em>X</em></strong> 为随机变量，$ x_1, x_2, x_3, … $ 为随机变量的值。</p>
<p>随机变量有两种，一种是 <strong>离散的 (discrete)</strong> ，一种是 <strong>连续的 (continuous)</strong> 。离散随机变量可以有一组可数数量的不同值，比如 0 / 1 / 2 / 3 。实际上，如果一个随机变量只能取得有限数量的不同值，那它必定是离散的。离散随机变量的例子很多，比如一个家庭里小孩的数量。连续随机变量则可以取得无限数量的可能值。它通常是测量。为了演示无限性，假设一个身高值测出来是 3.1 米，如果换更精确的测量仪器，也许能测到 3.14 米。更精确的仪器，也许还能测到 3.145 米。换言之，通过更精确的测量，或者放大操作，无限数量的结果是可能的。年龄，温度，速度，这些都可以是连续随机变量的例子。</p>
<p>随机变量的值可以很方便地通过随机分布来呈现。随机分布的呈现形式可以是表格，图或者数学方程，并且是通过随机变量的每个取值关联的概率列表来定义的。</p>
<img src="/images/pd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>根据定义，每个随机变量都有一个概率分布，离散随机变量的概率分布叫 <strong>概率质量函数</strong> ，而连续随机变量的概率分布叫概率密度函数。至于为什么有这种区别，稍后解释。</p>
<a id="more"></a>

<p>对于离散随机变量来说，通过列出每种可能的结果，容易看出概率。假设变量 <strong><em>X</em></strong>  接收 1, 2, 3, 或者 4 。那么下面这张表就列出了每种结果的概率。分布还可以用概率直方图来描述，这跟频率表或者频率直方图的用法如出一撤。</p>
<img src="/images/pd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>对于连续随机变量，可以采用图表。下图中的概率分布并没有在 y 轴上给出概率，而给出了 <strong>概率密度 (probability density)</strong> 。为了获得概率，你需要考虑曲线某个区间下方的区域而非曲线的高度。概率就是由这块区域的面积给出的。</p>
<img src="/images/pd_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>y 轴之所以要采用密度是因为你的随机变量单位可能会改变。比如，你表示的长度由米改成厘米，这个时候密度相应改变，而区域的面积不应该变化。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>随机变量是一个由随机现象产生多种可能结果的变量。当结果有限可数时，它是离散的；当结果数量无限时，它是连续的。</li>
<li>概率分布为随机变量可取得的每个值指定概率。离散随机变量的概率分布叫概率质量函数，而连续随机变量的概率分布叫概率密度函数，它的概率值时通过概率曲线指定区间下的面积来获得的。</li>
<li>概率密度函数可以以表格、图表或者方程的形式呈现。</li>
</ul>
<hr>
<h1 id="累积概率分布"><a href="#累积概率分布" class="headerlink" title="累积概率分布"></a>累积概率分布</h1><p>你已经了解了基本的概率规则，也了解了概率分布，是时候向你介绍累积概率分布了。<br>首先看看下面这个简单的离散随机分布。你能找出 X 的值是 2 或者 3 的概率吗？</p>
<img src="/images/cpd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>答案可以通过把 x 是 2 或者 x 是 3 的概率相加得到。因此这个值是 0.7 。</p>
<img src="/images/cpd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>表格上列出的概率，或者说概率质量函数 x 轴上的概率，全部都是互斥。因此任意概率的并集实际上就是这些概率值之和。相似的，根据补集的规则， X 大于等于 1 的概率等于 1 减去 x 是 1 的概率，也就是 0.9 。 </p>
<img src="/images/cpd_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在让我们往下接着走。基于概率分布，我们很容易计算出小于或者等于某个值的概率。举个例子， x<br>小于或者等于 1 的概率是 0.1 。 x 小于或者等于 2 的概率是 0.1 加上 0.3 ，也就是 0.4 。</p>
<img src="/images/cpd_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这种概率被称为 <strong>累积概率 (cumulative probability)</strong> 。 全部累积概率的列表被称为 <strong>累积概率分布 (cumulative probability distribution)</strong> ，或者 <strong>累积分布函数 (cumulative distribution function)</strong> 。这个累积概率分布的概率直方图可以像下面这样：</p>
<img src="/images/cpd_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>对于概率密度函数也是如此。例如，下面这个概率密度函数，对应旁边的累积分布。</p>
<img src="/images/cpd_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有趣的部分是， y 变量从概率密度变成了概率。</p>
<img src="/images/cpd_61.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如你所见，累积概率函数从 0 开始，持续增加到最大值 1 。所有结果的概率之和等于 1 。累积分布，特别是它的图形化形式，十分便于回答两个问题。</p>
<img src="/images/cpd.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你可以在 x 轴上选择随机变量的某个值，然后在 y 轴上找到观察值的哪一部分小于或等于该值。或者相反，你可以在 y 轴上选择一个分数，然后在 x 轴上找到相应的阈值。对于这个阈值，有一个简短的叫法是 <strong>分位 (quantile)</strong> 。举个例子，对于累积概率 0.1 以下的阈值，就称为 0.1 分位。因此累积概率分布实际上展示了随机变量的分位。举个例子，你会发现，对于累积概率 0.5 ，你找到其实就是随机变量的中位数，对于累积概率 0.25 ，你找到是随机变量的四分位。</p>
<img src="/images/cpd_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>值得注意的是，对称概率分布下，中位数和平均数一致。</p>
<img src="/images/cpd_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此，对于对称分布，找到平均值的地方，累积概率也是 0.5 。 </p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>随机变量的累积概率是获取一个小于或者等于某个阈值的概率。另一方面，累积概率体现了随机变量的分位。举个例子，累积概率 0.5 代表随机变量中位数被找到的地方。</li>
<li>跟概率分布一样，累积概率分布也可以以表格、图表或者方程的形式呈现，通过从小到大计算随机变量的概率实现。</li>
<li>随机变量从 0 持续增加到 1 。在对称概率分布下，中位数和平均数一致。</li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十 | 条件概率和独立性</title>
    <url>/data-science/statistics-conditional-probability-and-independence/</url>
    <content><![CDATA[<h1 id="联合概率和边际概率"><a href="#联合概率和边际概率" class="headerlink" title="联合概率和边际概率"></a>联合概率和边际概率</h1><blockquote>
<p>对有趣现象的计数，在日常生活中常常转换成比例，最终变为概率。利用概率估算的力量，可以更好地理解这些现象之间的关系或做出预测。 <strong>联合概率 (joint probability)</strong> 和 <strong>边际概率 (marginal probability)</strong> 是两个在这种情况下会用到的重要概率类型。在这一节教程中，我将解释联合概率和边际概率的含义，并展示它们的属性。</p>
</blockquote>
<p>想象你在沙滩上观察你的海滩同伴。你会注意到三种不同类型的活动 —— 它们是互斥的。有的休息，他们都坐在或躺在沙滩上。有的玩，这些人到处乱跑，建造沙堡或站在水中。最后，有的在游泳。此外，你还可以按性别区分。所以你观察到的每个人都是一个案例.</p>
<p><img src="/images/conditional_p_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>在数据集中，性别和活动是变量。你最终得到以下结果的列联表。总共计了 113 人，其中有 79 人在休息，有 20 人在玩，并且他们中只有 14 人在游泳。女性和男性的数量，分别是 62 和 51 。</p>
<p><img src="/images/conditional_p_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>这些数字实际上是每行和每列变量位于此表边缘的总和，因此被称为边际值。请注意，这与口语上 “边缘的”，即并不重要的，并不是一回事。在表中边际值代表对于单个变量的说明，没有关于任何其他变量。例如说休息的人数不考虑性别。</p>
<p><img src="/images/conditional_p_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>现在，我们打开这个频率表通过将每个单元格数字除以总数 113 得到比例的表格。</p>
<p><img src="/images/conditional_p_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>在此表中，中心块包含六个位置，它们加起来等于一。同时，每列中的比例加总到底部的边缘行中的值，每行中的比例加总到右边的边缘列中的值。并且边缘行的值加起来等于边缘列的值加起来。</p>
<a id="more"></a>
<p>你的计数可以看作随机样本，测量在海滩的人的活动和性别分布，于是你会想到把比例看作概率。在中间区域，是活动与性别的交集。例如，给定的人是男性，正在游泳。这些值称为 <strong>联合概率 (conditional probability)</strong> 。 <strong>联合概率只是各种事件的交集概率的简称</strong> 。</p>
<p>我们的每个联合概率关联的事件都与表中任何其他联合概率关联的事件互斥，因为每个人在海滩上只被放置在六个互斥事件之一。同时，联合概率形成一系列完全穷尽的事件，因为案例中不会出现其他的可能活动和性别的组合。因此，联合概率总和为一。</p>
<p><img src="/images/conditional_p_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>在边缘的地方，你可能期望有 <strong>边际概率</strong> 。是的，这些概率仅考虑一个变量。例如，给定的人是男性，无论其活动如何，或者给定在玩，不论性别。边际概率来自联合概率的并集。例如休息的概率，玩耍的概率和游泳概率。因此，这里适用加法规则，即概率相加。</p>
<p><img src="/images/conditional_p_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>因此，如果你的原始计数不可得，但有联合概率，你始终可以计算出边际概率 —— 通过求和。相反，如果只给你边际概率，你将无法在每种情况下反推出联合概率。</p>
<p><img src="/images/conditional_p_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>当你在对源自一个随机样本或者试验中的现象计数时，可以把它们转换成概率。</li>
<li>如果观察多个随机变量，可以计算出这些变量的联合概率和边际概率。</li>
<li>联合概率是变量间某些结果交集的概率，而边际概率是每个变量所有结果概率的总和。</li>
<li>典型的例子里，如果变量有两个，列联表示组织数据的绝佳形式。联合概率放在中间，边际概率放在边缘。所有的联合概率加起来等于 1 ，它们在两个方向上分布加总得到一个边际概率。</li>
<li>你总是可以通过加总，基于联合概率算出边际概率；但仅有边际概率，不借助额外的假定是无法算出联合概率的。</li>
</ul>
<hr>
<h1 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h1><p>术语 <strong>条件 (condition)</strong> 意味着取决于别的东西。和日常语言中的概率上下文或多或少具有相同的含义。</p>
<p>其正式定义是：给定另外一件事已发生，这件事件发生的可能性。数学符号如下：</p>
<script type="math/tex; mode=display">P (A | B)</script><p>即给定 B 发生或以 B 为条件，事件 A 发生。垂直线是 “给定” 的速记，或者说 “有条件” 的速记。条件概率的计算公式是：</p>
<script type="math/tex; mode=display">P (A | B) = \frac {P (A \cap B)}{P (B)}</script><p>即事件 A 和事件 B 都发生的概率除以事件 B 发生的概率。也可以用下面的文氏图来说明：</p>
<p><img src="/images/conditional_p_8.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>该图强调 A 和 B 的交集概率只能小于或等于 B 的概率。</p>
<p>让我们应用方程到一个熟悉的例子。你考虑了沙滩上的人们进行的各种活动，也可以按性别区分人们。将结果转换一张有概率的表。现在，有了这些变量，活动和性别，如何举出一个条件概率的例子？具体来说，是你知道一个结果发生的概率，然后要计算这个结果发生后，其他结果再发生的概率。让我们举一个具体的例子。你将估算一个概率 —— 该人是男性，且则该人正在休息。</p>
<p>为了算得这个概率，应用前面说到的公式，联合概率除以是男性的概率。因此， 0.3 除以 0.45 。</p>
<p><img src="/images/conditional_p_9.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>现在我有一个问题要问你。你能计算给定活动的性别概率吗？方法一样：</p>
<p><img src="/images/conditional_p_10.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>因此，根据联合概率和边际概率，您可以计算出条件概率。虽然条件概率方程很简单，但它还有更多可以挖掘。再看一下方程式，如果两边都乘以事件 B 的边际概率，你就得到了一个计算联合概率的公式。</p>
<p>这其中隐含的意思是，如果交给你一项任务：找到事件 A 和事件 B 的联合概率，如果你不知道 A 和 B 之间是否独立，你需要同时拿到 B 的概率和给定 B 发生 A 的条件概率，或者拿到 A 的概率和给定 A 发生 B 的条件概率。</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><ul>
<li>条件概率是指给定另一件事已发生时某件事的概率。</li>
<li>表明上看不是很特别，但条件概率是很多概率估算的核心。</li>
<li>数学上，给定 B 的 A 的条件概率等于 A 和 B 的联合概率除以概率 B 。</li>
<li>条件概率的定义，也适用于不论是否独立的事件的联合概率。给定 B 的 A 的条件概率可以看成是 B 发生后，样本空间缩小到 B 时 A 发生的概率。</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之九 | 概率和集合</title>
    <url>/data-science/statistics-probability-and-sets/</url>
    <content><![CDATA[<h1 id="集合基础-——-理论概念"><a href="#集合基础-——-理论概念" class="headerlink" title="集合基础 —— 理论概念"></a>集合基础 —— 理论概念</h1><p>在这篇教程中，我将介绍一些重要概念，它们是关于 <strong>集合 (set)</strong> ，即项的数据集。这对于理解概念以及得出概率的计算规则十分有用。同时，集合的特殊性还在于它不仅可用于概率演算，还用在逻辑学中。</p>
<p>让我们开始吧。如之前的教程中提到的，样本空间是随机现象所有结果的数据集。举个例子，抛一枚硬币两次，有四种可能的结果。事件是样本空间的子集。例如，最后一次抛硬币你得到正面朝上。</p>
<p><img src="/images/set_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>我们看到，一个样本空间可以两个或更多结果完全不同的事件。比如，抛硬币两次，0 次正面朝上，1 次正面朝上， 2 次正面朝上。它们被称为 <strong>互斥 (disjoint)</strong> 的事件。另外一个术语叫 <strong>互不相容 (mutually exclusive)</strong> 。</p>
<p>有一对特殊的互斥事件，某个事件和它的对立面 (即这个事件不发生的事件)。这种上下文中，对立的事件被称为 <strong>补集 (complement)</strong> 。比如，这里可以是没有正面朝上和其他三种情况互为补集。</p>
<p><img src="/images/set_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>你也可以有多个事件共同填满完整的样本空间。这些事件被称为 <strong>完全穷尽 (collectively exhaustive)</strong> 事件。如果它们彼此不重叠，就是 <strong>相互独立，完全穷尽 (disjoint collectively exhaustive)</strong> 。互斥事件相关联的概率之和小于或者等于 1 ，完全穷尽事件的概率之和等于 1 。</p>
<p><img src="/images/set_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>直觉上很容易理解这些概念，它们可以通过 <strong>文氏图 (Venn diagrams)</strong> 来表达。文氏图通过简单的几何形状来呈现集合或者集合的部分。</p>
<a id="more"></a>
<p>这些矩形描绘同一个样本空间，在空间中，有一个事件 A ，剩下的部分都是事件 A 的补集。同一个样本空间里，还有另外一个事件 B ，和 A 不重叠。因此它们两者是互斥的。</p>
<p>如果我们把这个文氏图应用于两次抛硬币的实验，你能把四个不同的结果放进图中并且描述事件吗？</p>
<p><img src="/images/set_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>可以是这样的，只有一次正面朝上是事件 A ，有两次正面朝上是事件 B 。 A 的补集会包含两次反面朝上和两次正面朝上。</p>
<p><img src="/images/set_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>还用文氏图，两次抛硬币的实验也可以是这样的：</p>
<p><img src="/images/set_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>两个事件， A 和 B ，相互之间有重叠。 A 是事件 “第二次结果是正面朝上”， B 是事件 “只有一次正面朝上”。结果 “反面，正面” 会同时落在两个事件之内。“反面，反面” 也属于样本空间的一部分，但不落在 A 和 B 任何一个事件内。两个事件重叠的部分被称为 <strong>交集 (intersection)</strong> 。</p>
<p>事件 A 和 事件 B 的交集可以速记为:</p>
<script type="math/tex; mode=display">A \cap B</script><hr>
<p>现在，让我们来找出两个事件交集的概率。如果两个事件是互斥的，事件很简单。交集的概率为 0 。如果两个事件并不互斥，即它们重叠，事情就稍微有点复杂。</p>
<p>假定我们正在处理的是独立事件。也就是说，例子中抛出第二个正面的事件的概率不受只抛出一个正面的事件的影响。对于独立事件 A 和 B ，它们的交集的概率是两者各自概率的乘积。</p>
<p>这里，事件 A 有两种情况，所以概率是 2 / 4 。事件 B 的情况相同，概率也是 2 / 4 。因此，最后的交集的概率等于两者概率乘积，也就是 1 / 4 。</p>
<p><img src="/images/set_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>样本空间中不共享任何结果的事件被称为 <strong>互斥事件</strong> 或者 <strong>互不相容</strong> 。</li>
<li>多个事件一起填满整个样本空间，则把它们称为 <strong>完全穷尽</strong> 事件。</li>
<li>如果样本空间里只有两个互斥事件构成完全穷尽，那么它们互为 <strong>补集</strong> 。</li>
<li>互斥事件的概率之和小于或者等于 1 。完全穷尽事件的概率之和等于 1 。</li>
<li>事件 A 和 B 的 <strong>交集</strong> 同时是两个事件的一个子集，这个子集包含了 A 的一部分，并且这部分也是 B 的一部分。独立事件 A 和 B 的交集是通过事件 A 的概率和事件 B 的概率乘积来计算的。对于互斥事件，按照定义，交集属性等于 0 。</li>
</ul>
<hr>
<h1 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h1><p>这一节中，我将介绍 <strong>并集 (Union)</strong> 的概念和并集的概率。并集在现实生活中会导致一个比其各个部分集合的总和具有更多新属性的实体吗？很遗憾，在概率理论中，这种魔力是不存在的。并集只是<br>需要特别注意 —— 不要将事情加倍计算。</p>
<p>还是贝壳的例子，你在海滩上随机捡三个贝壳。周围只有两种贝壳， Q 和 R 。两种类型的贝壳数量相等并且你可以认为有无数。在这种情况下，样本空间包括八个结果。整个实验的树形图如下。</p>
<p><img src="/images/union_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>获得任何组合的概率的八分之一。让我们设定，总共捡起一个 R 贝壳作为事件 A ，总共捡起两个 R 贝壳作为事件 B 。如果我们对事件 A 发生或事件 B 发生，或者 A 和 B 同时发生感兴趣。</p>
<p><img src="/images/union_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>以这种方式组合事件被称为 “并集”，速记为:</p>
<script type="math/tex; mode=display">A \cup B</script><p>要计算关于事件 A 和 B 的并集的概率，你必须求出两个事件的总和，然后减去 A 和 B 的交集。减去交集的原因是它被计数了两次。拿到一个 R 贝壳的概率 —— 事件 A ，是八分之三。<br>拿到两个 R 贝壳的概率同样也是八分之三，它们的总和是八分之六，即四分之三。</p>
<p>实际上，事件 A 和 B 不分享任何结果，即他们不相交的，则他们的交集概率为零。因此，并集的概率是四分之三。</p>
<p><img src="/images/union_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>现在，考虑两个不同的事件。 事件 C ，你选择的第一个贝壳将会是 R 贝壳。事件 D ，最后一个贝壳 是 R 贝壳。显然，这两个事件不是互斥的，因为它们有重叠。事件 C 和 D 的交集包括<br>第一个贝壳是 R 贝壳，同时第三个贝壳也是 R 贝壳的情况。</p>
<p><img src="/images/union_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>通过将 C 的概率加到 D 的概率，再减去 C 和 D 的交集来找到 C 和 D 的并集，是四分之三。</p>
<p><img src="/images/union_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>现在挑战升级 —— 事件 A ， B ， C 和 D 的并集是？如果你把方程式机械地应用过来，事情会有些乏味，因为会有不少加法和减法的计算。</p>
<script type="math/tex; mode=display">P (A \cup B \cup C \cup D) = P (A) + P (B) + P (C) + P (D) \\ - (P (A \cap B) + P (B \cap C) + P (C \cap D) + P (A \cap C) + P (A \cap D) + P (B \cap D) + P (A \cap B \cap C \cap D))</script><p><img src="/images/union_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>不过，由于总的样本空间中并没有特别多的基本事件，这里有一个更简单的方法。你可以列出八个<br>基本事件，然后检查它们出现在四个组合事件中的哪一个。最后，你会发现只有一个基本事件不发生在组合事件中。从四个组合事件来看，有七个基本事件的结果是四个组合事件中的某一个的部分。因此，并集的概率是这七个基本事件之和，即八分之七。</p>
<p><img src="/images/union_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>多个事件的并集是这样一个事件：它包含原始事件的所有结果，并且没有重复。</li>
<li>几个事件的并集概率是各个事件的概率之和减去事件之间的交集的概率。</li>
<li>对于两个事件，等式为 $ P (A \cup B) = P (A) + P (B) - P (A \cap B) $ 。如果事件 A 和 B 互斥，则交集的概率为零。并集方程简化为 $ P (A \cup B) = P (A) + P (B) $。</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之八 | 样本空间、事件和树形图</title>
    <url>/data-science/statistics-sample-space-events-tree-diagrams/</url>
    <content><![CDATA[<h1 id="样本空间-sample-space"><a href="#样本空间-sample-space" class="headerlink" title="样本空间 (sample space)"></a>样本空间 (sample space)</h1><p><em>海滩是一个多变的环境 —— 尤其当天气很好的时候，有许多人，需要可以做的事情和可以看的风景。这一节教程里，海滩是我们的背景。我将向你解释几个可以帮助我们找到概率的概念，以及一个可视化的辅助工具 —— <strong>树形图 (tree diagram)</strong> 。</em></p>
<p>这是一个温暖的下午，你可以来点下午茶。幸运的是，你所在的海滩上，有一个卖下午茶的摊位。不过，茶点几乎快卖完了，只剩下一种类型的冰淇淋和两瓶软饮料。</p>
<img src="/images/sample_space.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有点不走运的是，有三个人排在你前面。不过还有个好消息是，摊主只卖给每个顾客一件东西。由于你实在很渴望喝到眼前这冰爽的饮料，你不禁开始寻思，“我喝到饮料的机会有多大呢？” </p>
<img src="/images/sample_space_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>注意，你并不清楚其他顾客会做出的决定，所以他们的购买对你来说全部都是随机事件。第一个顾客可能买饮料或者冰淇淋，在这件事发生之后，第二个顾客拥有同样的选项，然后轮到第三个顾客。如果前面的两位顾客都买了饮料，那她就只剩冰淇淋可以选，否则的话，她也还有两个选项。</p>
<p>通过下面这幅树形图，你排序了所有可能的随机试验结果。看起来有 7 种可能的组合。这里所有随机现象的里列表我们称为 <strong>样本空间 (sample space)</strong> 。</p>
<a id="more"></a>

<img src="/images/sample_space_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果一个随机试验有离散的结果，比如我们的这个案例，一种描绘样本空间的便捷方式是通过树形图列出所有的可能性。就像上图中我们已经做的那样。在一个树形图中，有一些中间结果的划分，跟最终分支如出一撤。任何结果，包括结果的组合，被称为 <strong>事件 （event）</strong>，因此， <strong>一个事件其实就是一个样本空间的子集</strong> 。在这个特定的案例中，你关心的事件，不走运的那些 —— 没有饮料喝了，反之，还能买到饮料。 </p>
<p>任何一个随机事件都有与之关联的概率，并且小的事件可以组合成大的事件。量化这些事件的概率，可以通过实验。实验可以包含在一段足够长的时间内，观察冰淇淋和饮料的销售情况。但这里时间不够，当第一个顾客正在思考要买什么的时候，你就必须做出自己的决定了。于是你诉诸另外一种策略 —— 对样本空间里的结果做出有说服力的假设。</p>
<p>你假定每一种事件发生的机会相等 —— 每个顾客选冰淇淋和饮料的概率都是 0.5 。在这种方式中，你可以依赖通用的概率规则。概率处于 0 到 1 之间，所有可能的结果，例如，所有选项在树形图里以节点表示，它们最终的总和也等于 1 。借助它们，你可以很快得到答案。这个答案可能帮助你做出决定：是应该保持乐观，在队伍中等着轮到自己，还是应该开始考虑寻求别的方式购买饮料。</p>
<p>不过，要记得，经过所有事件都已经展开，你并不知道你对于概率的评估是否正确。虽然你收集了排在你前面的三个顾客的试验信息，但对于整个购买冰淇淋和饮料这种事情来说。你的信息极其有限，并没有办法推导出十分精确的概率估算。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>样本空间是所有随机现象的结果的集合，而事件是样本空间的子集，它对应某一个随机变量的结果或者一组可能的结果。</li>
<li>每个事件都有概率。为了找到这些概率，你可以用到树形图。在树形图中，你可以创建样本空间，并对各种事件显式地做出假设。为了量化树形图里每个事件的概率，你可以进行实验。</li>
<li>某些时候，你可以对样本空间里的结果做出有说服力的假设，然后基于推理估计出它们的概率。</li>
<li>在任何案例中，通用的概率规则都适用于树形图。任意事件的概率都处于 0 和 1 之间，而最终所有可能的结果的概率总和等于 1 。</li>
</ul>
<hr>
<h1 id="用树形图量化概率"><a href="#用树形图量化概率" class="headerlink" title="用树形图量化概率"></a>用树形图量化概率</h1><p>当你在思考随机现象并且把注意力放在事件之间的关系以及它们在树形图中的概率时，你已经开始计算概率和评估某件事发生的可能性。</p>
<p>下面我会解释实践中树形图中的概率是如何量化的。还是上面那个例子。下面这张图显示，你假定每个顾客都有 0.5 的概率选择冰淇林或者饮料。通用概率规则适用于树形图里的每一个节点。具体来说，如果你观察图中的第一个顾客，有两个分支，每个分支 0.5 的概率。到第二个顾客，有两对分支，每对占 0.5 的概率，一对里的两个分支又各占 0.5 的概率。</p>
<p>如果这个时候轮到你了，你需要沿着一条路径，从第一个顾客的某个购买结果算到第二个顾客的某个购买结果。在树形图中，通过计算这条路径上所有概率的乘积来找出最终组合的事件的概率。</p>
<p>两个顾客之后，你还有多大的机会买到饮料呢？至少得剩一瓶饮料吧，满足这个情况的事件分支有三条，像图示中那样，总的概率是 0.75 。</p>
<img src="/images/tree_diagram.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>还有没有更快的算法呢？—— 利用所有概率的总和等于 1 这个规则。所以 1 减去 两瓶饮料都卖出去的概率会给到我们相同的答案。</p>
<p>现在我们加大难度，考虑第三个顾客了。这里有一点特殊。她在四个分支中有三个拥有两个选项，但在两瓶饮料都卖完的这个分支上，只有一个选项 —— 买冰淇淋。同时在这里，规则也需要被满足，即所有概率的总和等于 1 ，所以这个单分支的概率就等于 1 。</p>
<img src="/images/tree_diagram_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在我们回到你买到饮料的机会上。我们需要算出四条分支的概率总和，即轮到你之前最多一瓶饮料被卖掉的概率总和。每条分支的概率等于 0.5 的三次方，即 0.125 ，加起来是 0.5。</p>
<img src="/images/tree_diagram_1_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<hr>
<p>上面我们演示了利用树形图找出概率的变量，但也有必要指出一些需要注意的事情。首先是树形图可以很从容地处理小问题，对于理解有很多结果的随机现象，它并不是很适合 —— 它会变得很庞大，无助于保持概览。</p>
<img src="/images/tree_diagram_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>其次，为了实际应用树形图来量化概率，需要每个节点的概率规格。这在有的时候是很容易的，比如你假定每个选项机会均等，并且独立于前面的选择。另一方面，它也可能很困难。</p>
<p>举个例子，假如第二个顾客的购买选择会受到第一个顾客的影响怎么办呢？</p>
<img src="/images/tree_diagram_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在树形图中，你可以创建样本空间，并对各种事件显式做出假定，包括每个事件的概率，它们在序列之中的相互独立性。</li>
<li>你可以在树形图中计算组合事件的概率。为了计算沿着一系列分支的从起点到结果的概率，所有的概率需要相乘。而为了找到某个包含很多种结果的事件的概率，所有这些结果的概率则需要相加。</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之七 | 概率和随机性</title>
    <url>/data-science/statistics-probability-and-randomness/</url>
    <content><![CDATA[<h1 id="随机性-（randomness）"><a href="#随机性-（randomness）" class="headerlink" title="随机性 （randomness）"></a>随机性 （randomness）</h1><p>识别和理解随机性，和推断它是一样重要的技能。它们不仅在统计分析中有用，对于每天发生在我们身边的日常事物，同样有意义。这篇教程中，我将向你解释为什么人们如此不擅长应对随机性。</p>
<p>想象你在海滩上看着海浪翻滚，然后你注意到一枚美丽的贝壳，它的个头和形状明显地异于周围其它贝壳。于是你想想看附近还有有没有这种贝壳。这是一项无法预见的行动计划 —— 贝壳可能是随机分布在这个巨大的海滩上的。因此，你找到另外一枚同类贝壳的时间是不确定的，甚至你都可能找不到一枚相似的。</p>
<p>你开始思考这件事，然后你意识到随机性几乎在日常生活中无处不在。所以，无怪乎我们有丰富的词汇来描述它，比如不确定性、机会、风险、可能性。还有，变异性和不确定性的程度能够非常精细地描述随机性。</p>
<p>看看下面这组词汇：罕有、少见、有时、普通、频繁、经常。有意思的是，某件事是否随机，不仅是现象自身的特性，也很大程度上取决于我们对它的认识。假如你之前就来过这片海滩，你可能已经发现过这种贝壳，从而改变这一次的搜索策略，以便增加找到更多这种贝壳的机会。你搜索的尺度也有关系，如果在很小的区域做一个短暂的搜索，可能不是很有把握找到新贝壳，但是搜索时间延长，搜索区域扩大，找到机会就会增大。</p>
<p>尽管有这么多的词汇，以及我们在日常经验中熟记随机性的能力，我们其实一点都不擅长量化地评估随机性。一方面，我们在真实的随机数据中寻找各种 “模式”。你一定听过一个词叫 “宿命”。另一方面，我们自身又无法制造随机熟记。有一个失败尝试的案例 —— 下图中左边的通过拼接得到的贝壳随机分布的地图，实际上是分布太规则的。而右边那幅是现实的随机分布模式，看起来有更多聚集在一起的 “簇”。</p>
<p><img src="/images/randomness.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<a id="more"></a>
<p>另外一个被我们用来解释随机性的例子叫 “赌徒谬误” —— 它的错误之处在于用一系列前面发生的随机现象预测未来的随机现象。人们没有意识到的是，如果你连续掷出了四次 6 ，感觉上不太可能再第五次掷出 6 。然后，这个投掷的结果为 6 的概率之前是 六分之一，之前是，现在还是。</p>
<p><img src="/images/randomness_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>我们之所以应对随机性孱弱，原因在于我们的大脑倾向于用记忆模式的方式衡量随机性。考量到这一点，为了量化随机性、理性思考随机性并且产出现实可行的随机模式，学习正确的方法十分重要。它们帮助我们避免错误，更准确和更有效地对我们周遭的世界做出预测。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>随机性并非一个现象的内在属性，它同时取决于我们对它的知识，观察方法以及我们关注它的尺度。尽管有大量表达随机性的词汇，人类天生不擅长量化评估它。我们困于宿命论，困于对某些纯随机模式的过度解读，这些操作同时也不利于构建随机性。</p>
<hr>
<h1 id="概率-probability"><a href="#概率-probability" class="headerlink" title="概率 (probability)"></a>概率 (probability)</h1><blockquote>
<p>坚持不懈，终有所成。</p>
</blockquote>
<p>尽管已经有很多关于这个概念的箴言和引证，我想再加一句 —— “毅力战胜一切”。这一节中，我将一步步引导你学会用概率来量化随机性。</p>
<p>人类的大脑也许并不是很适合回答随机性。但幸运的是，有一个基础的机制，它的运转极大地简化了我们的生活 —— 随机性会发生变化，从事物可变、案例稀少且无法预测，到事物恒定、案例庞大且可以预测。对于这个基础，我们甚至有一个数学上的证据，它就是 <strong>大数定律</strong> 。它有赖于独立性，也就是说，某个随机现象的结果，不受之前结果的影响。</p>
<p>让我举个例子，说明大数定律在现实生活中是长什么样子。还是想象你在海滩，决定搜寻贝壳。很快，你发现了海滩一共有四种类型的贝壳，随机分布，数量相等，就像下图这样：</p>
<p><img src="/images/possibility.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>现在，你需要数出一个 Q 贝壳的分数，可以通过选取操作来完成。比如，随机选 20 个贝壳，然后计算这 20 个样本里 Q 贝壳的数量。结果如下：</p>
<p><img src="/images/possibility_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>如你所见，20 个贝壳只有 2 个 Q 贝壳。 <strong>相对频率 (relative frequency)</strong> 是十分之一。基于你的推理，这个分数本来应该是在四分之一左右。 但是，你也知道，小样本的不规则性，是随机性的本质。所以呢？“保持冷静，继续前进。”</p>
<p><img src="/images/possibility_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>不着急下结论，继续选取更多的贝壳，观察比例如何变化，一直演化到四分之一 —— 这种比例被称为 <strong>“累积比例 (cumulative proportion)”</strong> 。</p>
<p><img src="/images/possibility_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>每一次你随机选取新的贝壳时，都被看作是一次可能带来 Q、R、S、T 四种贝壳之一的机会实现。用概率的术语来说，操作的结果，也就是你拿到的贝壳的类型，被称为 <strong>事件 (event)</strong> 。选取贝壳的这个行为被称为 <strong>独立试验 (independent trial)</strong> 。整个做这么多试验的事情被称为 <strong>实验 (experiment)</strong> 。在计算相对频率的时候，因为你用贝壳总数除每一种类型的贝壳，有两个属性将始终满足：每一个类型的概率将大于等于 0 或者小于等于 1 ；所有随机现象的结果的概率总和将等于 1 。</p>
<p><img src="/images/possibility_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>不过，现在让我们回到现实。生活并不是海滩，当然也不会有随机分布的贝壳。在日常生活中，纯粹的独立试验并不常见。通常，在随机事件之间存在 <strong>相互依赖 (interdependent)</strong> 。尽管如此，通过简化的假定，概率经常还是可以被很好地量化。此外，你需要拿到充足数量的样本，以便大数定律能发挥作用，确保你要估计的概率接近它的实际值。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>概率是一种量化随机性的方法，它可以用相对频率的均值来表示。根据这个定义，概率会始终大于等于 0 ，并 IE 小于等于 1 。所有可能事件的概率总和等于 1 。</li>
<li>正式的定义用到了实验、事件和独立试验的概念。某个事件的概率是通过它出现在整个实验中的相对频率来计算的。实验包含一系列独立试验。举个例子，掷骰子是一个事件，而每次掷出是一个独立试验。</li>
<li>让大数定律发挥作用的好方法是保持冷静，持续试验，直到 <strong>累积概率 (cumulative probability)</strong> 不怎么变化为止。</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之六 | 回归</title>
    <url>/data-science/statistics-regression/</url>
    <content><![CDATA[<h1 id="回归-——-找到-“那根线”！"><a href="#回归-——-找到-“那根线”！" class="headerlink" title="回归 —— 找到 “那根线”！"></a>回归 —— 找到 “那根线”！</h1><p>最近的一项研究表明，吃大量的巧克力可能是个好主意。</p>
<img src="/images/regression.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这个散点图展示了一个国家每个人年均消费的巧克力数量。可以看出，一年中人们吃的巧克力数量，跟这个国家每百万人口中的诺贝尔奖获得者人数，呈正相关性。</p>
<p>注意，这个散点图里的巧克力消耗量显示为自变量，而诺贝尔奖获得者人数显示为因变量。</p>
<p>散点图里分析的单位是国家。如你所见，相关性很高。实际上，这里的皮尔逊相关系数是 0.93 。这说明，多吃巧克力虽然可能令你发胖，但同时也让你变聪明。皮尔逊相关系数告诉我们，两个连续变量之间的线性相关性有多强，这种线性相关性被显示为一根直线。在我们的案例中，是这条线。</p>
<img src="/images/regression_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这就是我们所说的 <strong>回归线 (regression line)</strong> 。在本节教程中，我将告诉你如何找到回归线。重要的是要知道我们如何找到这条线，而不仅仅是因为回归线向你展示了两个变量之间的关系。 <em>找到回归线是许多统计分析的基础。</em></p>
<p>那么，我们如何找到回归线呢？想象你正在绘制散点图里每一条可能的直线。所以，你像下面这样画了许多可能的线。这是一组数量巨大的线。实际上，这几乎不可能做到。不过，暂时想象你有超能力 —— 你能做到这一点。</p>
<a id="more"></a>

<img src="/images/regression_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>接下来，你可以测量每条可能的线与每个案例之间的距离。在我们的例子，即线到每个国旗之间的距离。</p>
<p>让我给你举一个基于随机线的例子，比如，下面这个。测量日本和线的之间的垂直距离，西班牙和线之间的距离等等。直到你知道你的研究中每个案例的距离。</p>
<img src="/images/regression_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>每一个距离都被称为 <strong>残差 (residual)</strong>，你最终会得到正的残差，它们以线之上的案例到线之间的蓝色线段展示；以及负的残差，它们以线之下的案例到线之间的红色线段展示。</p>
<p>你为每一条可能的线测量残差。最终，我们选择一条能够 <em>使得残差的平方和最小的线</em> ，这便是我们要找的那根线。</p>
<img src="/images/regression_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>为什么是残差的平方和呢？因为正的残差和负的残差会相互抵消。</p>
<p>最佳拟合的线被称为 <strong>回归线</strong> ，分析的方法被称为 <strong>普通最小二乘回归 (ordinary least squares regression)</strong> ，这是指我们找到这条线的方式。</p>
<p>在实践中，几乎不可能绘制每一条可能的线和残差的和。幸运的是，数学家已经找到了寻找回归线的技巧。我不会解释这个把戏在这里是如何运作的，因为它相当复杂。目前为止，知道它基于残差的平方和就已经足够了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>你学到两件事：第一，你学会如何计算并寻找回归线；第二，你了解到，吃巧克力很可能有助于你通过这门课程。:D</p>
</blockquote>
<hr>
<h1 id="回归-——-描述-“那根线”"><a href="#回归-——-描述-“那根线”" class="headerlink" title="回归 —— 描述 “那根线”"></a>回归 —— 描述 “那根线”</h1><p>回归线是最好地描述两个变量之间线性关系的直线。但我们要如何描述这条线的样子呢？</p>
<p>这是一个非常重要的问题，因为通过用公式描述，我们可以很容易地把 <strong>回归的分析 (regression analysis)</strong> 传达给其他人，预测其他国家的诺贝尔奖获得者人数，以及确定不符合该模式的国家。基于此散点图中的回归线，我们可以预测：每年巧克力人均消费量为 6 公斤的国家，平均每 1000 万个人中有 11 位诺贝尔奖获得者。</p>
<img src="/images/regression_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>同样，基于同一条线，我们将预测一个每年人均巧克力消费量为 11 公斤的国家，平均每 1000 万人中 会有 25 个诺贝奖获得者。</p>
<img src="/images/regression_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>对大多数国家来说，这一预测并不完全正确。毕竟，大多数国家并不恰好在回归线上。然而，这是我们能做出的最好的预测 —— 根据我们掌握的信息。</p>
<img src="/images/regression_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有一个简单的公式，我们可以用它来描述回归线。这就是那个公式。 </p>
<p>$$\hat y = a + bx$$</p>
<p>$\hat y$ 不是 y 的实际值，但它表示 y 的预测值。例如，当 x 等于 12 时， $\hat y$ 等于 28 。 请注意，在这种情况下， y 的实际值为 33 。但是， y 的预测值是回归线上的 y 的值。这意味着，正好在回归线上所有的值是 $\hat y$ 。</p>
<p>a 就是我们所说的 <strong>截距</strong> ，它是一个常数。当 x 等于 0 时，它是 y 的预测值。换句话说，当回归线上 y 的预测值与 y 轴的相交时， x 等于 0 。在我们的案例里，它是 -5.63 。请注意，这个值没有实质性的含义。不可能每 1000 万人中有 -5.63 名诺贝尔奖获得者。它只有一个目的：描述回归线的数学性质。</p>
<p>b 就是我们所说的 <strong>回归系数 (regression coefficient)</strong> 或 <strong>斜率 （regression slope）</strong> 。 它是当 x 增加一个单位时， $\hat y$ 的变化。在我们的例子中，我们看到当 x 增加一个单位，例如，从 4 到 5， y 的预测值增加 2.80 个单位。</p>
<p>因为是一条直线，回归线的斜率是处处相等的。所以，如果我们看看当 x 从 8 增加到 9 时会发生什么， $\hat y$ 也是增加 2.80 单位。我们案例中的回归系数为 2.80 。这可以推导出下面这个 <strong>回归方程 (regression equation)</strong>。 </p>
<p>$$ \hat y = 5.63 + 2.80x $$</p>
<p>请看这两条回归线。它们具有相同的回归系数或 b 值。 当 x 增加一个单位时，第一条线和第二条线的 y 值增长的量是一样的。但是，这些线具有不同的截距，或一个值。毕竟，它们在不同的位置上穿过 y 轴。</p>
<img src="/images/regression_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这两条回归线具有不同的回归系数。当 x 增加一个单位时，第一条线上的 $\hat y$ 比第二号线上的 $\hat y$ 增加地更多。然而，这两条线的截距是相同的，因为它们在同一个点穿过 y 轴。</p>
<img src="/images/regression_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我已经对你说过了，我们可以用回归线来预测 y 值 —— 基于给定的 x 值。我们还可以使用回归公式进行预测。让我们用一个回归公式。 $\hat y = -5.63 + 2.80x$ 。我们可以使用公式预测 y 值。如果 x = 3.5，该怎么办？我们得到 -5.63 + (2.80 * 3.5)。 这就得出了 4.17 。 所以这里的 $\hat y = 4.17$ 。 如果 x = 10.21，该怎么办？ 然后你得到 -5.63 + (2.80 x 10.21) 。 这使得 $\hat y$ 等于 22.96 。 当我们只看回归线时，我们得到了相同的值。对于 x 值等于 3.5 时，我们得到的预测 y 值约为 4 。 对于 x 值等于 10.21 时，我们得到的 $\hat y$ 值约为 23 。 你已经可以看到，使用公式有一个巨大的优势 —— 你可以做出更精确的预测。</p>
<p>通常情况下，计算机会为你找到回归线，所以你不需要自己计算。然而，当你知道你的变量的均值和标准差，以及相应的皮尔逊系数，你可以通过两个公式计算回归方程。</p>
<p>$$b = r\left (\frac {s_y}{s_x}\right)$$<br>$$a = \bar y - b (\bar x)$$</p>
<p>第一个公式通过将皮尔逊的回归系数乘以 y 的标准差，再除以 x 的标准差。这表明了回归系数事实上是皮尔逊系数的一个不标准化的版本。当 pearson 的 r 等于 0 时，回归系数等于 0 。当皮尔逊的 r 是一个正数，回归系数也是正数，当皮尔逊系数为负时，回归系数也是负的。</p>
<img src="/images/regression_11.jpg" width="68%" height="68%" style="margin: 10 auto;">
这些是我们的研究的均值、标准差和皮尔逊系数。因此，为了找到回归系数，我们乘以 0.93 * (11.87/3.95)，结果是 2.79 。第二个公式用回归系数乘 x 的均值，之后从 y 的均值减去结果来计算截距。

<p>所以 13.17-(2.79 * 6.71) 。 这样就可以得到 -5.55 了。回归方程为 -5.55 + 2.79 x 。</p>
<p>与这一个计算机算出的回归方程的不同是由舍入误差导致的。我用汇总均值、标准差和皮尔逊系数来计算，这导致了一个不太精确的回归方程。因此，在使用这些公式时，尽量减少舍入。恭喜你成功完成了这个教程的上半部分！现在，你可以进行回归分析并计算预测值了。了解回归的基础知识是至关重要的，因为能够了解之后的推理回归过程。</p>
<p>所以多看这篇教程几次。:D</p>
<blockquote>
<p>如果自变量 x 是你看这篇教程的次数，并且因变量 y 是你掌握的回归分析的知识，当你这样做时，回归分析的回归斜率将是一个正数。</p>
</blockquote>
<p>如果你不明白上面这句话意味着什么，立即重温这篇教程吧。</p>
<hr>
<h1 id="回归-——-“那根线有多适用？”"><a href="#回归-——-“那根线有多适用？”" class="headerlink" title="回归 —— “那根线有多适用？”"></a>回归 —— “那根线有多适用？”</h1><p>在这一节，我们来研究回归线对你的数据有多适用。</p>
<p>为什么需要关注回归线的适用程度呢？因为我们希望知道回归分析预测因变量的准确性有多高。回归线适用数据的程度是用一种称为 <strong>R 方 (r-squared)</strong> 的方法来表示的。</p>
<p>想象一下，你身处一个有 99 个其他学生的班级，你刚刚参加完一场统计学的考试。你的教授手上已经拿到随机选取的 20 个学生的考试成绩。教授想要分享这 20 个学生的考试成绩，但同时不想让大家知道这些学生是谁。因此，她匿名了这些分数的主人。</p>
<img src="/images/r_squared.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是你看到的分数。因为是匿名的，你无从得知哪个学生拿到哪个分数。注意，最低分数是 0 ，最高分数是 10 。现在，想象你被要求预测你邻桌同学的分数。你怎么预测得到的分数会更靠谱呢？一个显而易见的答案是，用这 20 个分数的平均值，这个值时 6.8 。现在，继续想象教授还给了你这 20 个分数对应学生上一次统计学考试的分数，同样也是匿名的。结果如下：</p>
<img src="/images/r_squared_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，你会如何预测你邻桌的分数呢？是的，你可以利用到回归分析了。下面是回归线和 <strong>回归方程 (regression equation)</strong> 的散点图。</p>
<img src="/images/r_squared_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你会发现，那些在之前的考试中取得高分的同学趋向于在这一次考试中也拿到高分。实际上，你可以用这条回归线和对应的回归方程对分数做出预测。当你问到你的邻桌他之前的分数，你可以用回归线预测他这一次考试最有可能的分数。</p>
<img src="/images/r_squared_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>想象上一次分数是 8.1 ，代入回归方程，得到 2.80 加 (0.59 乘以 x)，等于 7.6 。因此，这一次的分数最有可能是 7.6 。这是什么意思呢？当你只有一个变量的信息时，你做出的预测的准确性要远远低于你拥有两个相关变量信息的情况。R 方就是一个告诉你用回归线预测因变量而不是平均值这种方式有多适用的程度。</p>
<p>再回到我们的散点图。我加了一根水平线，用以表示这次考试分数的平均值。</p>
<img src="/images/r_squared_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这根线之所以是水平的，是因为平均值是一个定值 6.8 ，它不会改变。可以看到，每个观察值和回归线的残差，相比于它们到平均值的残差，总体要小得多。</p>
<img src="/images/r_squared_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这表明，回归线的预测效果明显好于平均值。</p>
<p>在我们的案例中， R 方是 0.69 。这表示使用回归线预测错误的可能性比你使用平均值要小 69% 。 R 方也经常用另外一种说法来解释 —— 它是指你的因变量的方差，多大程度上可以由自变量的方差来解释。</p>
<p>一个变量的方差告诉你各个观察值相对于平均值的离散程度。因此，在我们的案例中，这一次考试分数的方差中的 69% ，可以被前一次考试的分数预测。用可视化的方式表达这种解释，可以用到两个圆。</p>
<img src="/images/r_squared_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>左边的圆表示自变量的方差，右边的圆表示因变量的方差。重叠的部分就是 R 方，或者说 <strong>可解释方差 (explained variance)</strong> 。当重叠部分很小时， R 方很小，重叠部分很大时， R 方很大。</p>
<img src="/images/r_squared_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你需要了解一个很重要的事实 —— R 方和皮尔逊相关系数关联紧密。实际上，正如它的名字指示的， R 方就是皮尔逊相关系数的平方。因此，要计算 R 方，只要算出皮尔逊系数然后平方就行了。</p>
<p>这也说明 R 方总是一个正数。在我们的案例中，皮尔逊相关系数等于 0.83 。平方得到 R 方 0.69 。注意，如果两个变量的线性相关性是完美的，那么皮尔逊相关系数和 R 方都是 1 。如果完全线性无关，那皮尔逊相关系数和 R 方都是 0 。</p>
<p>但是，你需要记住： R 方的含义和皮尔逊相关系数很不同。皮尔逊相关系数告诉你两个变量之间是否存在正的或者负的相关性，以及这种相关性有多强。而 R 方并没有告诉你两个变量之间关联的方向。不过，它告诉你两件事，一是回归线预测相对于平均值预测优胜多少，二是因变量的方差有多少是可以被自变量的方差解释的。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之五 | 相关性</title>
    <url>/data-science/statistics-correlation/</url>
    <content><![CDATA[<p>很多人喜欢吃巧克力，但多数人吃巧克力是比较谨慎的。因为吃了太多巧克力，很有可能会增加体重。在这一期的教程中，我将讨论如何使用表格和图表展示 <em>两个变量之间的关系</em> 。这有助于发现两个变量之间是否存在 <strong>相关性 (correlation)</strong> 。</p>
<h1 id="列联表-Contingency-Tables"><a href="#列联表-Contingency-Tables" class="headerlink" title="列联表 (Contingency Tables)"></a>列联表 (Contingency Tables)</h1><p>我们来进一步研究吃巧克力和体重之间的关系。</p>
<p>假设我在我们学校选择了 200 名女学生。她们身高都是一米七。这样，身高就是一个常数，不会影响体重或吃巧克力。让学生报告体重及每周巧克力消费情况。体重可以选择这样几个类别：小于 50 公斤； 50 至 69 公斤； 70 至 89 公斤和 90 公斤或以上。巧克力消费量可以选择这样几个类别：每周少于 50 克；每周 50 至 150 克；每周超过 150 克。</p>
<p>结果如下，这里看到的是 <strong>列联表</strong> 。 <strong>列联表</strong> 能够显示 <strong>两个定序或定类变量之间的关系</strong> 。 它类似于频率表，但主要区别在于 <strong>频率表始终只考虑一个变量，而列联表考虑两个变量</strong> 。</p>
<a id="more"></a>
<p>在我们的研究中，有两个变量：体重和巧克力消费量。</p>
<p><img src="/images/crosstab.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>该表显示我们有 33 个体重小于 50 公斤的样本 其中 27 人每周吃巧克力少于 50 克。还可以看到，每周有 90 人吃 50 至 150 克巧克力，其中 7 个体重 90 公斤及以上。</p>
<p>这种情况下，该表并不能提供两个变量之间的相关性信息，因为列和行包含不同数量的个案 —— 计算百分比可以提供更多洞察力。这种情况下，我们计算列的百分比，这意味着对于每个单元格，我们计算该单元格中的案例百分比，与相应列中的案例总数进行比较。</p>
<p>结果如示：</p>
<p><img src="/images/crosstab_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>我们也可以将这些百分比表示为比例: 45％ 则变为 0.45， 38％ 变为 0.38 。我们将这些比例称为 <strong>条件比例 (conditional proportions)</strong> —— 因为形成需要以另一个变量为前提条件。在这种情况下，该变量是巧克力消费量。</p>
<p><img src="/images/crosstab_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>我们也可以忽略巧克力消费的信息，并使用表格边缘的计数。这些都是 <strong>边际比例 (marginal proportions)</strong> 。例如， 33 除以 200 等于 0.17 。这个比例显示，研究中比例是 0.17 或 17％ 的受访者中，重量不到 50 公斤。</p>
<p><img src="/images/crosstab_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>这是什么意思呢？ 在每周吃巧克力超过 150 克的样本中， 56％ 的人体重达 90 公斤及以上；吃巧克力少于 50 克的样本中，只有 5％ 体重为 90 公斤或以上；另外，那些吃巧克力不到 50 克的人， 45％ 的人体重不到 50 公斤，而吃巧克力超过 150 克的人，只有 2％ 的体重不到 50 公斤。</p>
<p><img src="/images/crosstab_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>这些百分比表明：吃更多巧克力的人也更容易超重，而少吃巧克力的人也更可能体重较小。换句话说，<em>百分比表明巧克力消费量与体重之间存在相关性。</em></p>
<hr>
<h1 id="散点图-Scatterplot"><a href="#散点图-Scatterplot" class="headerlink" title="散点图 (Scatterplot)"></a>散点图 (Scatterplot)</h1><ul>
<li>列联表对定类和定序变量很有用，但不适用于定量变量。<em>对于定量变量，散点图更合适。</em> 假设没有提供类别，而是让 200 名女性给出确切的体重，例如 65 或 72 公斤。假设也要求他们告知每周吃巧克力的确切重量，例如每周可以是 64 克或 99 克。现在，有比之前更精确的信息展示定量变量，巧克力消费和体重之间关系的最佳方法是使用 <strong>散点图</strong> 。</li>
</ul>
<p>制作散点图，我们绘制两条线，称之为 <strong>轴</strong> 。我们将水平轴称为 <strong>X 轴</strong> 。这里展示的是 <strong>自变量 (independent variable)</strong> ，垂直轴称为 <strong>Y 轴</strong> ，我们用它来表示 <strong>因变量 (dependent variable)</strong> 。如果因变量和自变量之间没有区别，则 Y 轴和 X 轴上的位置是一个选择问题。在我们的例子中，自变量是巧克力消耗量，因变量是体重。</p>
<p>假如我们的研究表明，最少的巧克力消耗等于每周零克，最高的量是每周 700 克。我们在 x 轴上标注这些值；同样，体重的最小值为 40 公斤，最大值为 110 公斤。</p>
<p><img src="/images/scatterplot.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>接着我们在此图中显示每个人，为样本中的所有人做标注，这就绘制出了一幅散点图。散点图一目了然地显示巧克力消费量与体重之间存在相关性：吃的巧克力越多，体重就越高。</p>
<p><img src="/images/scatterplot_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<hr>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><blockquote>
<p>大家学到了什么呢？不止于巧克力消耗量和体重的相关关系，我想大多数人已经意识到了：我们可以通过表格和图表显示 <strong>两个变量之间的关系</strong> ，<strong>当研究中的变量是定类或定序变量时，我们使用列联表；当它们是定量测量时，我们使用散点图</strong> 。</p>
</blockquote>
<hr>
<h1 id="皮尔逊积矩相关系数-Pearson’s-r"><a href="#皮尔逊积矩相关系数-Pearson’s-r" class="headerlink" title="皮尔逊积矩相关系数 (Pearson’s r)"></a>皮尔逊积矩相关系数 (Pearson’s r)</h1><p>散点图一目了然地表明两个变量之间存在很强的相关性，但 <strong>这种相关性有多强</strong> ？我们现在将要讨论最常用的相关性度量方法之一 —— <strong>皮尔逊积矩相关系数</strong> 。皮尔逊相关系数最重要的优点之一是：它用一个数字表示两个变量之间线性相关的 <strong>方向</strong> 和 <strong>强度</strong> 。</p>
<p>巧克力消费和体重之间的关系可以用这条直线来描述。因为所有案例都紧密围绕这条线，所以可以得出结论，这是一个相当强的相关性关系。</p>
<p><img src="/images/pearsonsr.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>另一个需要注意的点是，直线向上延伸，表明更多的巧克力消耗与更高的体重相关。因此，也可以说存在 <strong>正相关</strong> 关系。结论：这里存在一个强正向线性关系。</p>
<p>然而，变量也可以以不同的方式相关联。</p>
<p><img src="/images/correlation.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>在上图的第一幅图中，可以看到变量 x 和 y 之间存在相当强的正向线性关系，如同巧克力消费和体重的示例一样；而在第二幅图中，存在一个相当强的负向线性相关性 —— 直线向下表示当变量 x 上升时，变量 y 下降。第三幅图也可以看到正向线性关系，但是它比之前的强度要小得多 —— 因为每个案例都远离直线。第四幅图则是一个完全负向线性相关。之所以说完全的，是因为所有案例都完全落在线上。</p>
<p>但两个变量之间的相关性不必是线性的。在第五幅图中，可以看到变量 x 和 y 之间的关系。最能代表两个变量之间关系的线并不是直线。相反，是一个 U 形线，我们称之为曲线关系。</p>
<blockquote>
<p>散点图有助于我们总体评估相关性是强还是弱，但它并没有告诉我们这种关系强度到底是多少。皮尔逊相关系数恰巧可以展示确切数字 —— 更具体地说，皮尔逊相关系可以告诉我们 <strong>两个定量变量之间线性关系的方向和精确强度</strong> 。正皮尔逊相关系数表示相关性为正，而负系数表示相关性为负。</p>
</blockquote>
<p>系数的大小表示 <strong>观测结果围绕数据假想最佳拟合直线的紧密程度</strong> 。<em>皮尔逊相关系数是始终介于 -1 和 1 之间的数字：负 1 表示完全负相关；正 1 表示完全正相关； 0 表示完全没有相关性。</em></p>
<p>那如何计算皮尔逊相关系数呢？试想巧克力消费和体重的研究不是 200 个样本，而是四个样本。</p>
<p>下面是数据矩阵和散点图：</p>
<p><img src="/images/pearsonr_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>可以看到两个变量的每个值的组合在图形中变为一个圆点。要计算皮尔逊相关系数，我们需要这个公式：</p>
<script type="math/tex; mode=display">r = \frac {\sum {Z_xZ_y}}{n - 1}</script><p>这是什么意思呢？首先将所有原始分数改为 z 分数，换句话说，标准化所有数值 —— 原因是我们希望皮尔逊相关系数是介于 -1 和 1 之间的数字 。如果不进行标准化，相关性将会以原始数据呈现。</p>
<p>首先，我们计算两个变量的均值：变量 x 的值为 162.5 ，即巧克力消耗量；变量 y 的值为 71.25 ，即体重。然后计算两个变量的标准差， x 的结果为 110.9 ， y 的结果为 18.4。再然后计算每个案例的 z 分数，从每个值中减去均值，然后除以标准差。</p>
<p>为自变量的每个值，即巧克力消耗量，因变量的每个值，即体重，进行如此计算。下一步，计算 y 值 z 分数和 x 值 z 分数的乘积。 </p>
<p><img src="/images/pearsonr_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>计算公式的最后一部分，将所有这些 z 分数的乘积相加，将得数除以 n 减 1。所以在我们的例子中，皮尔逊相关系数是 2.78 除以 (4 - 1) ，等于 0.93 。这是什么意思呢 —— 这意味着巧克力消费与体重之间存在强烈的正向线性关系。</p>
<blockquote>
<p>一个重要注意事项：即使关系是非线性的，也可以随时计算皮尔逊相关系数。因此，<em>在计算皮尔逊相关系数之前，要先检查散点图看变量是否存在线性相关</em> ，这一点非常重要。如果不存在，就不要计算皮尔逊相关系数，因为它就不能提供太多变量关系信息。</p>
</blockquote>
<p>例如，下面这个散点图显示 x 和 y 之间存在强烈的 <strong>曲线关系</strong> 。如果计算皮尔逊相关系数，会得到一个非常低的值，负 0.15 。这并不能说相关性较弱，只能说线性相关性较弱。</p>
<p><img src="/images/pearsonr_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>计算四个样本的皮尔逊相关系数是相当容易的。但是，可以想象，当样本是 200 个时，这几乎是不可能完成的任务。幸运的是，每个统计程序都可以快速计算皮尔逊相关系数。然而，重要的是要了解皮尔逊相关系数究竟意味着什么。了解公式的含义也很重要，它可以帮你更好地理解变量的相关性，也可能会帮你决定 “每周吃多少巧克力。” :)</p>
</blockquote>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之四 | Z-score</title>
    <url>/data-science/statistics-z-scores/</url>
    <content><![CDATA[<blockquote>
<p>通俗解释 z-score ，即 z-score 是对某一原始分值进行转换，变成的一个标准分值，该标准分值可使得原来无法比较的数值变得可比。</p>
</blockquote>
<h1 id="Z-score"><a href="#Z-score" class="headerlink" title="Z-score"></a>Z-score</h1><p>本教程中我们还继续沿用前面教程中足球队的例子。</p>
<img src="/images/z-score.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你在这里看到的是所谓的球员纹身占比，以纹身占身体的百分比表示。点图和标准差表明，第二队的分布比第一队的变化更大。</p>
<p>有时研究人员会问：一个特定的观测结果是常见还是特例。为了回答这个问题，研究人员会用 <strong>一个数与平均数的差再除以标准差</strong> 。这个数字就是我们所说的 z 分数。在这篇教程中，我将解释如何计算 z 分数，以及它们的用处。</p>
<p>我们先来看看第一队的分布情况。平均数是 15 ，标准差是 2.5 。为了计算 z 分数，我们使用这个公式：</p>
<p>$$ z = \frac {(x - \bar x)}{s} $$</p>
<p>这个公式不是很复杂，它告诉你如何计算感兴趣的数值。该数值与平均数之差，再除以标准差。</p>
<a id="more"></a>

<p>来看看纹身占比是 10.8％ 意味着什么。该值的 z 分数是 10.8 减去 15 再除以 2.5 等于负 1.68 。所以 z 分数是负 1.68 。你可以为所有数值进行如此计算。如果这样做，这些就是结果。</p>
<img src="/images/z-score_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>请注意，最终会得到负 z 分数和正 z 分数。负 z 分数表示低于平均数的值；正 z 分数表示高于平均数的值。因为平均数是分布的平衡点，所以负的和正的 z 分数相互抵消。换句话说，如果将所有 z 分数相加，结果为 0 。</p>
<p>好的，不过如何知道某个 z 分数是低还是高呢？</p>
<p>这取决于分布和前后关系。有一个黄金定律：如果变量的直方图是钟形的，那么 68％ 的观测值在 z 分数 -1 和 1 之间， 95％ 在 z 分数 -2 和 2 之间， 99％ 在 z 分数 -3 和 3 之间。这意味着对于这种类型的分布， z 分数大于 3 或小于 -3 ，可以被认定是特例。</p>
<img src="/images/z-score_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>但是，如果分布严重偏向右侧，如下图所示，较大的正 z 分数会更常见，因为分布的右侧有更多极值。</p>
<img src="/images/z-score_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>类似，如果分布严重偏向左侧 则较大的负 z 分数会更常见，因为分布的左侧存在更多极值。</p>
<img src="/images/z-score_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>无须考虑形状，适用于任何分布的规则。 <strong>75％ 的数据必须落在 z 分数正负 2 之内。</strong></p>
<img src="/images/z-score_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>且 <strong>89％ 的数据在 z 分数正负 3 之间。</strong> </p>
<img src="/images/z-score_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此， z 分数本身就在一定程度上，给出了关于观测极端程度的信息。如果要比较不同的分布， z 分数就更有用了。比如，来看一下 19.3 的体重是否常见：</p>
<img src="/images/z-score_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在第 1 组中，这并不常见。 z 分数为 19.3 减去 15 再除以 2.5 ，等于 1.72 。在第 2 组中， 19.3 的 z 分数等于 19.3 减去 15 除以 8 等于 0.54 。这表明在第 2 组中， 19.3 的体重更常见。在第 2 组中， z 分数是 0.54 ，在第 1 组中，是 1.72 。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果我们将原始分数重新编码为 z 分数，就是 <strong>将变量标准化</strong> 。 <strong>标准化</strong> 意味着我们用 z 分数 替换原始度量中测量的分数，其优点是我们可以一眼看出特定分数是相对常见还是特殊。</p>
<p>因此，一个球员纹身占比是五分之一是否异常，这取决于球队或你想比对的另一组数据。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之三 | 测量集中趋势和离散程度</title>
    <url>/data-science/statistics-measures-of-central-tendency-and-dispersion/</url>
    <content><![CDATA[<h1 id="众数、中位数和平均数"><a href="#众数、中位数和平均数" class="headerlink" title="众数、中位数和平均数"></a>众数、中位数和平均数</h1><p>在前一篇教程中，我们学会通过图表概述分布。这同样适用于描述分布的中心位置，有三种主要方式，它们分别是：<strong>众数</strong> (mode) ，<strong>中位数</strong> (median) 和 <strong>平均数</strong> (mean) 。</p>
<p>这三个 m 通常被称为集中趋势的度量。</p>
<p>找到众数很容易，<strong>它是出现频次最高的值。</strong> 换句话说，就是最常见的结果。</p>
<p>如果测量定类或定序变量，<em>众数通常用作衡量集中趋势。</em></p>
<p>在下面这个饼图中，可以看到西班牙主要球赛中球员来自哪些大洲。</p>
<div id="echarts8458" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts8458'));
        // 指定图表的配置项和数据
        var option = {
    title : {
        text: ' 西班牙主要足球比赛中的球员国籍分布 ',
        x:'center'
    },
    tooltip : {
        trigger: 'item',
        formatter: "{a} <br/>{b} : {c} ({d}%)"
    },
    legend: {
        orient: 'vertical',
        left: 'left',
        data: [' 欧洲 ',' 北美 ',' 南美 ',' 非洲 ',' 亚洲 ']
    },
    series : [
        {
            name: ' 国籍 ',
            type: 'pie',
            radius : '55%',
            center: ['50%', '60%'],
            data:[
                {value:280, name:' 欧洲 '},
                {value:16, name:' 北美 '},
                {value:56, name:' 南美 '},
                {value:32, name:' 非洲 '},
                {value:16, name:' 亚洲 '}
            ],
            itemStyle: {
                emphasis: {
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: 'rgba (0, 0, 0, 0.5)'
                }
            }
        }
    ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>

<p>饼图使众数一目了然，是欧洲 70％ 的球员来自欧洲</p>
<p><strong><em>这里的众数是欧洲</em></strong> ，是最常出现的类别的名称，但众数不是 70％ 。这只是该特定类别的观测百分比。可能有多个众数。试想有一个足球运动员，拥有十分分裂的球迷，其中一些觉得他非常和善，而另一些则认为他非常蛮横。来给这个球员起个名，Franco Galton。</p>
<a id="more"></a>

<p>试想你选取西班牙 500 名受访者作为代表样本，询问他们对 Franco Galton 的看法，受访者可以在 0 到 10 的范围内表明他们认为他的和善程度。 0 表示非常蛮横， 10 表示非常和善。</p>
<img src="/images/two_mode.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假设这是本研究得出的直方图形状，可以看到西班牙人分歧很大，有些人觉得 Galton 非常和善，有些人觉得他非常蛮横。正如所见，分布有 两个众数，即 3 和 8 这显然是双众数分布。</p>
<p>集中趋势的第二个衡量指标是中位数：<strong>观测值从最小到最大排序时，中位数就是观测值的中间值。</strong></p>
<p>试想你还问了七位受访者，对另一著名球员 Tomas Bayez 的看法。假设这是他的研究数据矩阵，这里的众数是 8 ，是频次最高的值。</p>
<img src="/images/median.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>要计算中位数，首先必须将所有数值从低到高排序，然后选择中间值。所以这里的中位数是 8 。如果案例是偶数而非奇数，那就稍微复杂点了。试想受访者是 8 人，他们对 Tomas Bayez 的看法。</p>
<img src="/images/median_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>数值是从低到高排列的。但是，在这种情况下，没有单个中间值。该如何解决这个问题呢？我们取两个中间数值的平均值 7 和 8 相加除以 2 等于 7.5 。因此，中位数是 7.5 。请注意，中位数将分布分为两个相等的部分。 50％ 的值低于中位数， 50％ 的值高于中位数。</p>
<p>集中趋势的第三个衡量指标，是最常用的一个，也可能是你已经非常熟悉的，就是平均数。</p>
<p><strong>平均数是所有观测值之和除以观测个数</strong>。</p>
<p>$$ \bar x = \frac {\sum {x}}{n} $$</p>
<p>上面是用于计算平均值的公式。它看起来比较复杂，公式的含义是： x 横线表示变量 x 的平均数，等于 x 的总和除以样本个数，由 n 表示。</p>
<p>举个例子，借用 Tomas Bayez 的研究。公式告诉我们首先求总和， 6 加 7 ，加 7 ，加 8 ，加 8 ，加 8 ，加 9 ，等于 53 ，现在再除以 n 。样本量是 7 ，因此 53 除以 7 等于 7.6 平均数是 7.6 。</p>
<img src="/images/mean.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以将平均数视为数据的平衡点。试想我们将重量平衡放置，那么平均数就是天平中心点。其中一侧的总重量恰好等于另一侧。</p>
<img src="/images/mean_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在大家已经熟悉了这三个 m 。可以通过各种方式轻松计算一组数字的中间值，但报告时，该使用哪种中心趋势呢？</p>
<p><strong>这部分取决于变量的测量级别。</strong> 如果是定类测量，则无法计算中位数或平均数，因为我们无法对定类变量进行数值运算，也不能对它们进行排序。<strong>当变量是定类变量时 唯一适合的集中趋势度量是众数。</strong></p>
<p>如果是定量变量该怎么办呢？</p>
<p>试想你在家乡足球俱乐部的一个食堂里，你想计算所有在场人士的平均收入和中位收入，包括你自己，其他 5 位客人和吧员。</p>
<img src="/images/mean_and_median.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是数据矩阵，平均数约为 35,000 ，中位数恰好是 35,000 ， 它们彼此非常接近。使用哪一个来描述分布中心都无所谓。但现在，著名足球运动员 Franco Galton 走进食堂，比如他每年收入大约 7000 万 ，这时中位数略微增加到 36,000 ，然而，平均数却超过 800 万。</p>
<img src="/images/mean_and_median_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们说 Franco Galton 是这个分布的异常值。他的收入远高于其他所有人，他的收入对平均收入产生不成比例的影响。在这种情况下，计算中位数描述分布中心比平均数更合理。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>描述分布中心可以使用三种方法：众数，中位数和平均数。如果变量是定类的，则使用众数；如果是定量的，则使用中位数或平均数 —— 如果有异常值或分布高度偏离，使用中位数。如果不是，那就使用平均数。</p>
<hr>
<h1 id="全距、四分位距和箱线图"><a href="#全距、四分位距和箱线图" class="headerlink" title="全距、四分位距和箱线图"></a>全距、四分位距和箱线图</h1><p>你可能已经注意到了，纹身在足球运动员中越来越受欢迎。特别是所谓的纹身袖在球场上正在兴起。纹身袖，正如其名，是指满胳膊的纹身。</p>
<p>你对球员纹身占身体的比例感兴趣吗？</p>
<p>试想有两支球队，这里看到的是点图，表示两队中纹身占身体的百分比变量分布。水平线代表这个变量，原点代表每个团队中的 11 个人。</p>
<img src="/images/range.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>第一队队员纹身占比大约是 10％ 到 20％ 之间。在第二支球队中，球员的纹身占比差异很大，百分比范围是 0% 到大约 30％ 之间。因此，这个团队彼此差异很大。但是两队众数，中位数和平均数却相同。两队的众数都是 14.1 ，中位数和平均数都是 15 。<em>这表明为了充分描述分布，我们需要集中趋势度量之外的信息。</em> 这一节我将向大家展示我们还需要了解有关数据变化或离散的信息，讨论两种变异性测量，即：<strong>全距</strong> 和 <strong>四分位距</strong> ，还将讨论所谓的 <strong>箱线图</strong> —— 这是一个非常有用的图表，可以很好地呈现分布中的数值如何离散。</p>
<p>全距是最简单的变异性度量：它是 <strong>最高值和最低值之间的差值</strong> 。</p>
<img src="/images/range_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>再来看看我们的两支球队：第一队的球员中最大纹身占比是 19.3％ ， 占比最小的是 10.8％ ，范围是 19.3 减去 10.8 等于 8.5 ；第二队的球员中最大纹身占比是 27.7％ ，占比最小的是 0％ 。因此，范围是 27.7 减去 0 等于 27.7 。这清晰地显示第二队的变化范围比第一队的变化范围更大。全距是易于理解且易于计算的变异性度量。但是，在许多情况下，它并没有很好地呈现数据的变异性。 <em>原因是它只考虑了极值。。</em> 看看这两个分布，它们的范围相同，但一目了然第二个分布的变异性与第一个非常不同。</p>
<p>另一个更好的测量变异性的方法是 <strong>四分位距</strong> ，因为它省略了极值，它将分布分为四个相等的部分。因此，如果分布看起来是这样的。</p>
<img src="/images/range_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以这样切分，将得分最低的 25％ 划为一组，得分最高的 25％ 划为一组，中间的两个 25％ 再分两组。</p>
<p>这种划分分布方式称为四分位距，一共有三个 <strong>四分位</strong> ，以下称为 Q1 ， Q2 ， Q3 。</p>
<p>如你所见，第二个四分位 Q2 将分布分为两个相等的部分。毕竟， 50％ 的值低于该值， 50％ 高于该值。<br>因此 Q2 与中位数相同。 <strong>四分位距是第三和第一个四分位之间的距离</strong>。换句话说，四分位距是 Q3 减去 Q1 。下面让我通过纹身占比来展示计算过程。</p>
<img src="/images/range_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是第二队的分布情况。首先，寻找中位数或者换句话说 Q2 。这很简单，中间数值是 15 ；可以通过查找中位数左侧数值的中间值找到 Q1 ，是 8.7 ；可以通过相同的策略在右侧找到 Q3 是 19.3 。现在，四分位距是 Q3 减去 Q1 即 19.3 减去 8.7 等于 10.6 。四分位距的主要优点是它不受异常值的影响，因为它没有考虑低于 Q1 或高于 Q3 的观测值。然而，在研究中寻找潜在的异常值可能仍然有用。 <strong>根据经验，如果观测值低于第一个四分位 1.5 个四分位距或高于第三个四分位 1.5 个四分位距则为异常值。</strong></p>
<p>在描述中心和变异性以及检测异常值时，有一种特定类型的图非常有用，该图称为 <strong>箱线图</strong> 。</p>
<p>Q1，Q2 和 Q3 在箱形图中一目了然，最小值不是异常值，最大值不是异常值。</p>
<img src="/images/range_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是基于前一个示例的箱形图。<strong>箱体</strong> 本身代表分布中心的 50％ 。换句话说，从 Q1 到 Q3 。 <strong>箱高</strong> 代表四分位距，箱内的 <strong>水平线</strong> 是中位数，换句话说，即 Q2 。箱体上面和下面的线称为 <strong>箱须</strong> 。它们包含除异常值以外的其他值，异常值用点单独标记。这里没有点，所以这个箱形图没有任何异常值。</p>
<img src="/images/range_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如何确定箱须的长度呢？让我们回到之前示例中的数值，我们检测到了 Q2 ， Q1 和 Q3 以及四分位距。我们知道低于 Q1 1.5 倍四分位距的或高于 Q3 1.5 倍四分位距的值是异常值。这里的四分位距是 10.6 。所以 1.5 乘以 10.6 等于 15.9 ， Q1 为 8.7 ，因此所有低于 8.7 减去 15.9 等于 -7.2 的值都是异常值。这里不存在这样的值，所以下末端没有异常值，这里的最小值是 0 。 Q3 是 19.3 ，因此，高于 19.3 加上 15.9 等于 35.2 的值都是异常值。我们也没有这么高的数值，所以上末端也没有异常值。箱须的上末端等于最大值，即 27.7 。</p>
<p>我们来看一下第一队的箱形图，如果比较两个箱形图，我们立即就能看到两个分布的变异性差别很大。</p>
<img src="/images/range_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>请记住，分布的中心只能告诉你部分信息。为了了解的更完整，还要 <strong>评估分布的变异性</strong>。箱线图使用三个四分位数，异常值以及剔除异常值后的数据范围，以紧凑的方式显示分布的重要信息。</p>
<hr>
<h1 id="方差和标准差"><a href="#方差和标准差" class="headerlink" title="方差和标准差"></a>方差和标准差</h1><p>在足球运动员中，纹身越来越受欢迎。试想，你想知道球员纹身的身体占比。</p>
<img src="/images/tatto.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这里看到的点图表示纹身占比的分布，由两队球员纹身占身体的百分比表示。一目了然，在第一队中纹身占比的变化远小于第二队。这种变异性可以通过 <strong>全距离</strong> 或 <strong>四分位距</strong> 来测量。也可以用箱线图表示 在此可以看到相关的箱线图。在本节中，将讨论统计研究中经常使用的另外两种变异性度量，即 <strong>方差</strong> 和 <strong>标准差</strong> 。</p>
<p>与许多其他变异性度量相比，方差和标准差的巨大优势在于：<strong>它们考虑了所有变量的数值</strong> 。</p>
<p>让我们从方差开始。这是方差的公式：</p>
<p>$$ s^2 = \frac {\sum {(x - \bar x)^2}}{n - 1} $$</p>
<p>s 的平方代表方差。将每次的观测值 x 减去 x 的平均值 （x 拔），然后将所有这些值平方后相加，结果是我们所说的平方和，接下来将平方和除以样本的大小 n 减去 1 。我们现在将公式应用于纹身占比的示例，以了解它在实践中的工作原理。</p>
<img src="/images/variance.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>第一步是计算平均值，这些值的平均值等于 15 ； 第二步是从每个观测值中减去平均值。我们来取第一个值，0 从这个值中减去平均值 0 减去 15 是负 15 。我们对样本中所有的值都这样计算。算完后，我们发现有负数，也有正数。这并不奇怪，因为均值是这些数值的中间点或平衡点。事实上，均值的负差和正差相抵 ，结果的总和等于 0 。换句话说，这些值的总和等于 0 。</p>
<p>因此，我们不使用 <strong>原始差值</strong>，而是使用 <strong>差的平方</strong> 。</p>
<p>接下来，我们对所有这些计算值进行平方。</p>
<p>根据公式，接下来我们需要将所有这些值相加。现在得数是平方差的总和，换句话说，平方和。这个数等于 639.74 。然后将平方和除以 n 减 1 。在我们的例子中， n 是 11 ，所以 n 减去 1 等于 10 。 639.74 除以 10 等于 63.97 ，这就是方差。</p>
<p><strong>方差越大，变异性越大。这意味着方差越大，数值越离散。</strong></p>
<img src="/images/variance_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这里显示的第一队的方差约为 6.33 ，从点图和箱线图中已经可：第 2 队中纹身占比的较大差异，也由较大的方差表示。</p>
<p>方差的一个重要缺点是：方差的度量是经过平方的变量度量。毕竟，我们平方了正差和负差，以便它们不会相互抵消。</p>
<p>有一个非常简单的方案可以解决这个问题。我们只取方差的平方根 —— 我们称之为 <strong>标准差</strong> 。标准差可以被看作观测值与平均值的平均距离。<strong>标准差越大，数据的变异性越大。</strong></p>
<p>$$ s = \sqrt {\frac {\sum {(x - \bar x)^2}}{n - 1}} $$</p>
<p>因此在我们的例子中，第一队的标准差是 6.33 的平方根，等于 2.52 。第二队的标准差是 63.97 的平方根，等于 8.0 。标准差是最常使用的离散度量。然而，在许多统计方法中，方差也起着重要作用。在本节教程中，大家了解了它们密不可分，可以轻松从一个推演出另一个。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二 | 数据可视化</title>
    <url>/data-science/statistics-descriptive-statistics/</url>
    <content><![CDATA[<blockquote>
<p>当我们向他人呈现数据时，通常需要将数据 “<strong>总结</strong>” 成各种图表的形式，例如频率表、饼图、条形图、散点图和直方图等。</p>
</blockquote>
<h1 id="统计案例、变量和测量级别"><a href="#统计案例、变量和测量级别" class="headerlink" title="统计案例、变量和测量级别"></a>统计案例、变量和测量级别</h1><blockquote>
<p>如果你对足球非常感兴趣，你想知道所有细节：比如某个球员有多少进球，某个球队赢了多少场比赛或者在某场足球比赛中有多少次点球。统计学知识，将帮助你成为足球或任何其他运动的真正专家。</p>
</blockquote>
<p>进球得分，赢得比赛，判罚点球，这些都可以被看作 <strong>变量</strong> 和 <strong>统计案例</strong> 。</p>
<blockquote>
<p><strong>变量</strong> 是事件或者人物的特征， <strong>统计案例</strong> 就是那个事或那个人。</p>
</blockquote>
<p>来讲得更具体一点。想象一下，你最喜欢的球队，你对足员的某些特征感兴趣：你想知道他 / 她的体重，头发颜色，年龄以及在最近的比赛中得分的总数。所有这些球员的特征都是变量，球员本身就是统计案例。</p>
<p>另一个例子，可能你对个别球员的特征不是那么感兴趣，而对他们所效力的球队特征感兴趣。例如，你可能想了解每个西班牙球队，以及它们所在的城市，他们队服的主色调是什么，以及球队去年有多少进球。这些特征也都是变量。但是，这里的统计案例不是个别球员，而是这些人所效力的球队。</p>
<p>在一项研究中，<em>案例可以是许多不同的事物。</em> 可以是个别球员和球队，也可以是公司，学校甚至是国家。</p>
<p><strong>案例的每个特征都可以成为变量</strong> —— 只要它符合一个基本的标准：即是变化的</p>
<p>这是什么意思呢？ 让我们回到示例。以球队为案例，并以团队所在的城市为变量。你关注每个西班牙球队，所以会有很多不同的城市：一支球队来自巴塞罗那，其他球队来自马德里，瓦伦西亚或塞维利亚。换句话说，城市是有变化的。</p>
<a id="more"></a>

<p>现在让我们关注另一个特征，不是城市，而是球队所在的国家。对于每一个球队而言，它们的国家都是西班牙 这些球队都是西班牙球队。这表示它们之间没有差异：没有一支球队会来自西班牙以外的其他国家。出于这个原因，这个特征不是变量，而是常量。</p>
<p>可以想象，我们可以有许多不同类型的变量代表非常不同的特征。因为这个原因，还有一些其他原因（我之后会讨论到）区分不同的 <strong>测量级别</strong> 至关重要，</p>
<p>最简单的测量是 <strong>定类测量</strong> 。<strong>定类变量由彼此不同的各种类别组成 变量之间没有顺序关系。</strong> 这意味着无法区别一个类别比另一个更好或更差，更多或更少。一个例子是球员的国籍，各种类别，例如西班牙，法国或墨西哥。彼此不同，但没有排名顺序；另一个例子是球员性别或球队所在城市。</p>
<p>第二级测量是 <strong>定序测量</strong>：<strong>变量的类别之间不仅存在差异，还存在顺序</strong> 。例如球赛的排名：可知谁是冠军，谁是第二，第三，等等。但是，通过查看排名，你不可能知道类别之间的差异大小 例如，你不知道第一名比第二名好多少。</p>
<p><em>定类和定序测量都可以称为分类变量。</em></p>
<p>下一级测量是 <strong>定距测量</strong>。在定距变量中：<strong>我们有不同的类别和顺序，类别之间也有相似的区间</strong>。 一个例子是球员的年龄。我们可以说，18 岁的球员与 16 岁的球员，年龄不同。另外，我们可以说这个球员年纪大些。就年龄而言，我们也可以说：18 岁球员和 16 岁球员之间的年龄差异，类似于 14 岁球员和 12 岁球员之间的年龄差异。</p>
<p>最高级的测量是 <strong>定比测量</strong> 。它类似于定序测量，但另外还有一个有意义的零点。例如球员的身高，以厘米为单位。它们在类别上存在差异，有一定的顺序，有相似的间隔，也有一个有意义的零点。身高为 0 厘米意味着没有高度。请注意，我们不能说年龄有一个有意义的零点：因为零岁并不意味着没有年龄，因此年龄是定距变量。</p>
<p>定距和定比变量就是我们所说的 <strong>定量变量</strong> ，因为类别由数值表示。</p>
<p>定量变量也可以分为 <strong>离散变量</strong> 和 <strong>连续变量</strong> 。如果某类别形成一组单独的数字，则变量是离散的。例如，球员的进球数：球员可以进一球或两球，但不能是 1.21 球。如果变量值形成区间，则变量是连续的。一个例子是玩家的高度：有人可能是 170 厘米或 171 厘米高，也可能是，比如说，170.2461 厘米高。我们没有一组单独的数字，而是一个无限的数值区域。</p>
<h2 id="区分测量级别的意义"><a href="#区分测量级别的意义" class="headerlink" title="区分测量级别的意义"></a>区分测量级别的意义</h2><p>为什么区分这些不同的测量等级如此重要。因为 <strong>我们用来分析数据的方法，取决于变量的测量水平</strong>。 </p>
<p>然而，在实践中， <em>区别有时会变得模糊。</em> 例如，对于许多统计分析，定距和定比测量之间的差异并不重要。此外，许多统计学家认为，如果定类测量有十分类甚至更多分类，就可以定量分析这些变量。</p>
<p>一个例子是调查问卷，问题是从 0 到 10 之间你如何评价某个球员。在形式上，这是一个定类变量，但在实践中，你可以讨巧将其视为定量变量。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从案例，变量和这些变量的衡量水平来考虑球员，球队和比赛，可以让你对足球有更结构化的理解。</p>
<hr>
<h1 id="数据矩阵"><a href="#数据矩阵" class="headerlink" title="数据矩阵"></a>数据矩阵</h1><p>我们已经知道实施一项研究，可以根据案例和变量来考虑。接下来，我将讨论如何排布和展示你的案例和变量。</p>
<p>想象一下，你对西班牙顶级球赛 “西班牙甲级联赛” 感兴趣。你感兴趣的案例是联赛的个体球员，你关注的变量是年龄，体重，进球数量，会籍和头发颜色。</p>
<p>排布所有这些信息的最佳方式是通过 <strong>数据矩阵</strong> 。数据矩阵是所有统计研究的核心要素：它是所有案例和变量的概述。 <strong>案例显示在行中</strong> ，它的范围从 1 号球员一直到 400 号球员。</p>
<table>
<thead>
<tr>
<th>球员</th>
<th>年龄</th>
<th>体重</th>
<th>进球数</th>
<th>会籍</th>
<th>头发颜色</th>
</tr>
</thead>
<tbody><tr>
<td>球员 1</td>
<td>18</td>
<td>72.6</td>
<td>0</td>
<td>Real Zaragoza</td>
<td>金发</td>
</tr>
<tr>
<td>球员 2</td>
<td>21</td>
<td>71.4</td>
<td>0</td>
<td>Real Betis</td>
<td>黑发</td>
</tr>
<tr>
<td>球员 3</td>
<td>26</td>
<td>74.8</td>
<td>8</td>
<td>Sevilla</td>
<td>黑发</td>
</tr>
<tr>
<td>球员 4</td>
<td>22</td>
<td>76.8</td>
<td>12</td>
<td>Barcelona</td>
<td>黑发</td>
</tr>
<tr>
<td>球员 5</td>
<td>22</td>
<td>74.1</td>
<td>17</td>
<td>Valencia</td>
<td>其他</td>
</tr>
<tr>
<td>球员 6</td>
<td>27</td>
<td>78.9</td>
<td>3</td>
<td>Real Sociedad</td>
<td>其他</td>
</tr>
<tr>
<td>球员 7</td>
<td>30</td>
<td>80.3</td>
<td>2</td>
<td>Real Madrid</td>
<td>金发</td>
</tr>
<tr>
<td>球员 8</td>
<td>24</td>
<td>73.3</td>
<td>1</td>
<td>Athletic Bilbao</td>
<td>褐发</td>
</tr>
<tr>
<td>球员 9</td>
<td>23</td>
<td>76.9</td>
<td>5</td>
<td>Valencia</td>
<td>褐发</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>球员 24</td>
<td>26</td>
<td>.</td>
<td>0</td>
<td>Malaga</td>
<td>黑发</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>球员 400</td>
<td>26</td>
<td>77.2</td>
<td>0</td>
<td>Atheletic Madrid</td>
<td>其他</td>
</tr>
</tbody></table>
<p>这里没有显示名字，这意味着这里的名称是匿名的。 <strong>变量显示在列中</strong> 。我们有五个变量：年龄，体重 进球数，会籍和头发颜色。表格单元格中显示的值通常称为 <strong>观测值</strong> 。这里 80.3 表示 7 号球员的体重是 80.3 公斤，这里的八分表示三号球员已经进了八球。</p>
<p>我们看到的不是一个完整的数据矩阵，只是其中一部分。完整的矩阵无法单屏呈现，因为它有 400 行，因为我们有 400 名球员。省略号已经明确表示只取了矩阵的一部分。</p>
<p>来看看我们的数据矩阵是否包含异常值。嘿，其中的 24 号球员，我们看不到体重数值。目前，我们已经囊括了这些不完整的案例。但是，如果后续分析需要完整的数据矩阵，我们可能必须删除它们。</p>
<p>所有统计分析都需要数据矩阵。但是，你通常不会向其他人提供完整的数据矩阵。原因是数据矩阵通常很大。在我们的例子中，有 400 行，并且也没有清楚地概述数据矩阵中包含的统计信息。</p>
<p>当我们将数据矩阵中的信息呈现给其他人时，经常以表格和图形的形式进行数据摘要。想象一下，你想要概述西班牙足球比赛中关于球员头发颜色的信息。较好的方法是制作频率表。频率表显示案例中 <strong>变量数值的分布</strong> 。* 频率表就是变量的所有可能值的列表，连同每个值的观测次数。*</p>
<p>这是一个基于发色变量的示例，我们可以区分四个类别 金发，棕色，黑色和其他。</p>
<table>
<thead>
<tr>
<th>发色</th>
<th>频率</th>
<th>百分比</th>
<th>累积百分比</th>
</tr>
</thead>
<tbody><tr>
<td>金色</td>
<td>76</td>
<td>19</td>
<td>19</td>
</tr>
<tr>
<td>褐色</td>
<td>134</td>
<td>33.5</td>
<td>52.5</td>
</tr>
<tr>
<td>黑色</td>
<td>160</td>
<td>40</td>
<td>92.5</td>
</tr>
<tr>
<td>其他</td>
<td>30</td>
<td>7.5</td>
<td>100</td>
</tr>
<tr>
<td>总计</td>
<td>400</td>
<td>100</td>
<td></td>
</tr>
</tbody></table>
<p>可以看到 76 名球员是金发， 160 名球员是黑发。注意，这些值相加是 400，所以没遗漏任何头发颜色的数据。</p>
<p>我们还可以通过百分比表示相对频率。在第二列中，可以看到百分比。可以一眼看出 7.5％ 球员是其他发色， 19％ 的球员是金发。将 76 除以 400 再乘以 100 得到 19 。</p>
<p>有时，研究人员使用累积百分比。这也很容易计算，累积百分比就是每个类别的百分比之和。所以可以看到 19 加 33.5 等于 52.5 金发和棕色头发占比 52.5 。</p>
<p>在这个例子中，我们讨论了一个分类变量，头发颜色。如果处理定量变量怎么办？以体重为例，计算每个特定个体的体重百分比是没有意义的。因为那样我们最终会得到无数的类别 —— 频率表将显示：比如两个人的体重为 65.3 公斤，一个人体重 65.4 公斤，等等。这几乎没比原始数据矩阵提供额外的有用信息。</p>
<p>研究人员通常会建立新的 <strong>顺序分类</strong> 来解决这类问题。可以做成，例如，第一类包含那些小于 60 公斤的球员；第二类，体重在 60 到 69.9 公斤之间的；下一类，介于 70 和 79.9 之间的；接着介于 80 和 89.9 之间的；最后一类， 90 公斤及以上。像下面这样：</p>
<table>
<thead>
<tr>
<th>体重</th>
<th>频率</th>
<th>百分比</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; 60</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>60-69.9</td>
<td>69</td>
<td>17.25</td>
</tr>
<tr>
<td>70-29.9</td>
<td>273</td>
<td>68.25</td>
</tr>
<tr>
<td>80-89.9</td>
<td>45</td>
<td>11.25</td>
</tr>
<tr>
<td>&gt;= 90</td>
<td>5</td>
<td>1.25</td>
</tr>
<tr>
<td>总计</td>
<td>400</td>
<td>100</td>
</tr>
</tbody></table>
<p>虽然这样你可能会丢失信息，但优点是可以获得更好的概述。我们说你已经 <strong>重新编码了变量</strong> 。体重变量本是定量变量，但现在变成了一个只有五个类别的定序变量。</p>
<p>将定量变量重新编码为定序变量非常容易。但是，反过来是不可能的：你无法将定序变量重新编码为定量变量。所以，你该了解 —— <strong>数据矩阵是所有统计分析的根源</strong> 。它是数据的概述。但是，如果你想将发现呈现给他人，可以使用 <strong>数据摘要</strong> 。一个非常好的总结方法是制作 <strong>频率表</strong> 。如有必要，你可以将定量变量重新编码为定序变量。</p>
<hr>
<h1 id="信息图和各种数据分布形状"><a href="#信息图和各种数据分布形状" class="headerlink" title="信息图和各种数据分布形状"></a>信息图和各种数据分布形状</h1><h2 id="定类变量"><a href="#定类变量" class="headerlink" title="定类变量"></a>定类变量</h2><p>如果想研究西班牙主要足球比赛中的球员来自哪里，下面这个频率表可能就是结果：</p>
<table>
<thead>
<tr>
<th>国籍</th>
<th>频率</th>
<th>百分比</th>
</tr>
</thead>
<tbody><tr>
<td>欧洲</td>
<td>280</td>
<td>70</td>
</tr>
<tr>
<td>北美</td>
<td>16</td>
<td>4</td>
</tr>
<tr>
<td>南美</td>
<td>56</td>
<td>14</td>
</tr>
<tr>
<td>非洲</td>
<td>32</td>
<td>8</td>
</tr>
<tr>
<td>亚洲</td>
<td>16</td>
<td>4</td>
</tr>
<tr>
<td>总计</td>
<td>400</td>
<td>100</td>
</tr>
</tbody></table>
<p>可以看到 280 名球员来自欧洲， 16 名来自北美， 56 名来自南美， 32 名来自非洲， 16 名来自亚洲。</p>
<p>我还添加了相对百分比，你可能希望通过图表展示百分比，有两种可能的方法。</p>
<div id="echarts2383" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts2383'));
        // 指定图表的配置项和数据
        var option = {
    title : {
        text: ' 西班牙主要足球比赛中的球员国籍分布 ',
        x:'center'
    },
    tooltip : {
        trigger: 'item',
        formatter: "{a} <br/>{b} : {c} ({d}%)"
    },
    legend: {
        orient: 'vertical',
        left: 'left',
        data: [' 欧洲 ',' 北美 ',' 南美 ',' 非洲 ',' 亚洲 ']
    },
    series : [
        {
            name: ' 国籍 ',
            type: 'pie',
            radius : '55%',
            center: ['50%', '60%'],
            data:[
                {value:280, name:' 欧洲 '},
                {value:16, name:' 北美 '},
                {value:56, name:' 南美 '},
                {value:32, name:' 非洲 '},
                {value:16, name:' 亚洲 '}
            ],
            itemStyle: {
                emphasis: {
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: 'rgba (0, 0, 0, 0.5)'
                }
            }
        }
    ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>

<p>这里是一个 <strong>饼图</strong> 。要概述的变量类别是通过饼图 <strong>切片</strong> 展示在饼图中，切片表示每个类别的百分比，一目了然 —— 几乎四分之三的足球运动员来自欧洲。</p>
<p>另一种概述数据的方法是 <strong>柱状图</strong> ，它可以非常清楚地展示数据在各个变量类别上的分布。</p>
<div id="echarts9271" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts9271'));
        // 指定图表的配置项和数据
        var option = {
    xAxis: {
        type: 'category',
        data: [' 欧洲 ', ' 北美 ', ' 南美 ', ' 非洲 ', ' 亚洲 ']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        label: {
            normal: {
                show: true,
                position: 'insideTop'
            }
        },
        data: [280, 16, 56, 32, 16],
        type: 'bar'
    }]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>

<p>柱形的高度代表每个类别观测值的百分比。</p>
<h2 id="饼图和柱状图的优劣"><a href="#饼图和柱状图的优劣" class="headerlink" title="饼图和柱状图的优劣"></a>饼图和柱状图的优劣</h2><p>两种图表都各有优，缺点。饼图的一个优点是，可以立即看出大约 75％ 的球员来自欧洲，不进行点计算就无法轻松地从柱状图中辨别出这些信息。但是，另一方面，从饼图中不容易检索每个类别的确切球员数量。例如，在柱状图中，可以轻松地看到有 50 多名球员来自南美洲。</p>
<p><strong>如果变量的类别数量增加，柱图优于饼图。</strong> 例如，想象一下，不是球员所在大洲，而是他们出生的某个具体国家。图呈现的效果将非常非常混乱。出于美学原因，你可能会在饼图中使用不同颜色，但所有这些信息使饼图不易于理解。在这种情况下，柱状图会更合理。柱状图也会包含大量信息。但它会比花里胡哨的饼图更容易理解。</p>
<h2 id="定量变量"><a href="#定量变量" class="headerlink" title="定量变量"></a>定量变量</h2><p>前面讲了定类变量，那么定量变量又要怎么处理呢？</p>
<p>一种可能性是 <strong>气泡图</strong> 。这个想法很简单，想象一下有 10 个球员身高信息，用厘米表示。</p>
<p>下面是数据矩阵。</p>
<table>
<thead>
<tr>
<th>球员</th>
<th>身高</th>
</tr>
</thead>
<tbody><tr>
<td>球员 1</td>
<td>176</td>
</tr>
<tr>
<td>球员 2</td>
<td>180</td>
</tr>
<tr>
<td>球员 3</td>
<td>165</td>
</tr>
<tr>
<td>球员 4</td>
<td>177</td>
</tr>
<tr>
<td>球员 5</td>
<td>167</td>
</tr>
<tr>
<td>球员 6</td>
<td>170</td>
</tr>
<tr>
<td>球员 7</td>
<td>175</td>
</tr>
<tr>
<td>球员 8</td>
<td>178</td>
</tr>
<tr>
<td>球员 9</td>
<td>174</td>
</tr>
<tr>
<td>球员 10</td>
<td>172</td>
</tr>
</tbody></table>
<p>首先，绘制一条水平线，并以规则的间隔标记可能的数值，如下所示。</p>
<img src="/images/singleAxis_bubble_scatter.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>接下来，对于每次观测在水平线上的数值之上标记一个点，像就这样：</p>
<img src="/images/singleAxis_bubble_scatter_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以想象，当只有若干观测结果时，气泡图很不错。但是，当样本巨大时，会变得混乱。 100 个球员的样本，看起来是这样的：</p>
<img src="/images/singleAxis_bubble_scatter_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果有很多观测结果时，研究人员通常会使用另一种类型的图表：<strong>直方图</strong></p>
<p>这就是一例：</p>
<img src="/images/histogram.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>直方图在某种意义上类似于柱状图，它使用柱形来描绘变量可能数值的频率或相对频率。但是，有一个重要的区别： <strong>直方图中的柱点是相互接触的</strong>。</p>
<p>该接触表示区间比率变量的数值呈现连续标度。比如，我们对西班牙足球运动员的体重感兴趣，如果测量数值非常详细，比如 83.9 或 74.5 公斤，为每一个值绘制一个单独的柱形是没有意义的。相反，我们构建 <strong>区间</strong> 。</p>
<img src="/images/histogram_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p> 在此图中，有 10 个 区间，每个区间 5 公斤，第一个区间范围从 47.5 公斤到 52.5 公斤 显示 50 ，因为 50 是该区间的中间。对于创建的区间的数量，没有固定的规则。但是，重要的是区间数值必须相同，所以在此图中都是五公斤。可以一眼看出大多数球员的体重约为 75 公斤，还可以看到，重量小于 60 或大于 90 是非常罕见的。 </p>
 <img src="/images/histogram_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如图所见，此直方图具有特定形状，它是钟形的，有一个 <strong>峰值</strong> 且两侧近似对称。你会经常遇到钟形分布，但并非所有直方图都是钟形。</p>
<p>直方图也可以向左或向右 <strong>倾斜</strong> 。偏斜的直方图不是对称的，因为分布的一侧比另一侧延伸得更远。</p>
<img src="/images/histogram_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有的直方图向左倾斜，而有的直方图向右倾斜。向右倾斜的直方图变量是西班牙比赛中球员的年收入。与球员的平均收入相比，收入很少的球员不会很多。但是，也会有一些球员比大多数球员赚的多得多。因此，右尾更长。</p>
<p>直方图也可能有两个峰值：设想两队六到八岁球员之间的足球比赛。比赛结束后，所有的孩子和父母都去食堂喝东西。</p>
<p>你感兴趣的问题是，食堂里的人年龄如何分布。在这种情况下，年龄变量的直方图有两个峰值。毕竟，食堂里的孩子是 6 到 8 岁的孩子和他们的父母，他们最有可能在 30 到 40 岁之间。</p>
<p>因此，可能在 7 岁左右达到峰值，在 35 岁左右再达到峰值。我们说这个变量是双峰而不是单峰。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇教程最重要的一个内容是：通过图表概述数据是一个好主意。<strong>如果处理定类或定序变量，你应该制作饼图或柱图。如果变量是定距或者定比变量，则应绘制直方图。</strong> 永远不要忘记查看变量的形状，它是钟形且对称的吗？它是单峰，还是双峰？分布是否倾斜？ <strong>评估分布的形状至关重要</strong>， 因为它可能影响你之后使用的统计方法。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之一 | 引言</title>
    <url>/data-science/statistics-basic-introduction/</url>
    <content><![CDATA[<h1 id="学习统计学的意义"><a href="#学习统计学的意义" class="headerlink" title="学习统计学的意义"></a>学习统计学的意义</h1><p>乍一看，统计学可能很吓人，但实际上，统计学并不可怕。它可以关乎很有趣的事，比如足球、潜水、巧克力，很有趣的人，比如潮人、出租车司机和婴儿。</p>
<p>至少有三个原因，让统计学至关重要。</p>
<ul>
<li>首先，我们周围有很多统计学，包括新闻，还有科学工作。</li>
<li>其次，统计学知识将帮你开展自己的研究。你该如何分析你得到的信息？该采用哪种方法？</li>
<li>第三，也是最后一点，分析数据可以帮助我们了解有趣的世界。</li>
</ul>
<h1 id="统计学的两种类型"><a href="#统计学的两种类型" class="headerlink" title="统计学的两种类型"></a>统计学的两种类型</h1><p>我们将统计学分为两种类型： <strong>描述统计学</strong> 和 <strong>推断统计学</strong> 。当我们谈论 <strong>描述统计学</strong> 时，我们指的是概述信息的方法。我们可以通过图表来概述信息，比如饼图或条线图或者诸如平均值，百分比或相关系数等数字。<strong>推断统计学</strong> 是仅根据有限数据案例，推断有关整体的结论。</p>
<h1 id="教程导览"><a href="#教程导览" class="headerlink" title="教程导览"></a>教程导览</h1><p>教程会分为七个模块。前两个模块主题是描述统计学；接下来的三个模块，将介绍之后在推断统计学中用到的方法：我们会讨论 <strong>概率</strong> ，<strong>概率分布</strong> 和 <strong>抽样分布</strong> ；在最后的两个模块中，我们将介绍推断统计学方法， <strong>如何估计置信区间</strong> 以及 <strong>如何进行假设检验</strong> 。</p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>不需要额外的知识，学校里学的足够了。你需要的是对方法论和数据的兴趣，以及最重要的东西 —— <strong>激情</strong> ！</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>用 “流水线” 设计拆解复杂处理流程</title>
    <url>/programming/break-down-complexity-with-pipelines/</url>
    <content><![CDATA[<ul>
<li>本文的主要价值： <strong>提供一种抽象复杂逻辑，达成功能复用的思路</strong></li>
<li>关键词： <strong>语义提炼</strong> 、 <strong>动态具名</strong></li>
<li>本文约 4000 字，建议阅读时间 30 分钟。 </li>
</ul>
<hr>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在软件开发时常常遇到一种场景：随着产品功能的扩展，出现了多个具备高度相似性的功能单元。这些功能单元可能有着相似的交互逻辑，提供同类的输入数据和输出数据。并且对于用户来说，它们共同处理同一个元素。举个例子，比如一款修图 app ，它包含了一组编辑功能，每个功能都作用于一张图片，处理之后的图片还可以作为其他功能的输入。作为编辑工具，在每个功能内部，还可能都需要支持撤销和重做这样的用户操作。容易想到，这些功能间存在着许多可以进行复用设计的代码。</p>
<p>本文基于我曾经从事的一款图像处理应用开发过程中的一次代码重构的实践所做的回顾发起，期望达到记录和分享的目的。</p>
<h1 id="重构的具体背景"><a href="#重构的具体背景" class="headerlink" title="重构的具体背景"></a>重构的具体背景</h1><p>请先看下面这幅图：</p>
<p><img src="/images/image_modules.jpg" alt="重构前的图像功能模块结构"></p>
<p>图中的元素很少，但细心的读者可能留意到了：图中的 “ <strong>内存图像管理 + 效果处理</strong> ” 是一个 “ <strong>黑盒子</strong> ”。那么这个黑盒子是一件好事还是坏事呢？</p>
<p>既然我们对这种设计做了重构，那么这里重点来探讨一下它的缺点。 黑盒子的优点部分，作为思考题留给读者。</p>
<p>在具体业务场景下，我发现旧有设计的两个问题：</p>
<ul>
<li>图像处理接口粒度太大，难以复用代码； </li>
<li>黑盒子把 <strong>图像管理</strong> 和 <strong>图像效果处理</strong> 这两件事包在了一起，使得外部难以灵活的接触和使用图像。 </li>
</ul>
<a id="more"></a>

<hr>
<h1 id="重构的设计思路-——-“流水线”-概念的提炼"><a href="#重构的设计思路-——-“流水线”-概念的提炼" class="headerlink" title="重构的设计思路 —— “流水线” 概念的提炼"></a>重构的设计思路 —— “流水线” 概念的提炼</h1><p>问题一在重构时也得到了解决，但与本文要表达的设计思想关联不大，就此略过。为了解决问题二，我引入了两个概念：“ <strong>流水线</strong> ” 和 “ <strong>例程</strong> ”。相信对于从事计算机领域工作的读者来说，这两个词不会陌生。</p>
<blockquote>
<p><strong>流水线</strong> pipeline， [计] 又称管道，管线。<br><strong>例程</strong> routine, [计] 程序；日常工作；例行公事</p>
</blockquote>
<p>在具体代码实现中， Pipeline 相当于内存中的图像状态机，提供了基本的管理图像的能力，例如加入图像，删除图像，复制图像，移动图像等。 Routine 相当于各个图像功能单元中通用的事务，比如每个图像功能单元都需要在其开始运作时从某处获得一份初始图像，并在其结束运作时输出一份 <strong>最终的</strong> 图像到另一处。我们约定， Routine 中的事务会基于 Pipeline 来完成。它的含义是：每个 Routine 都会包含一组基于一个或者多个 Pipeline 的典型操作，然后再加上每个 Pipeline 的差异化操作（即后文会提到的 <strong>差异化的图像处理步骤</strong> ），共同构成一个完整的具体场景下的图像功能单元。</p>
<p>下文中我们不妨把 “<strong>流水线</strong>” 的释义直接替换成 “<strong>管道</strong>” ，因为后面用到的一些比喻性的描述我觉得用 “管道” 一词衍生出来会比用 “流水线” 更自然一些。接着我们对 “管道” 这个意象再做进一步的挖掘，可以有下面一些对应关系（表格中左侧的概念只是我的比喻，读者可自行体会，这里不会全部详细解读）</p>
<table>
<thead>
<tr>
<th>比喻</th>
<th>原对象</th>
</tr>
</thead>
<tbody><tr>
<td>“管道”</td>
<td>图像状态机</td>
</tr>
<tr>
<td>“流体”</td>
<td>图像</td>
</tr>
<tr>
<td>“节点”</td>
<td>图像状态</td>
</tr>
<tr>
<td>“流动”</td>
<td>图像状态流转</td>
</tr>
<tr>
<td>“锋面”(流体的最前端)</td>
<td>当前正在处理的图像状态</td>
</tr>
<tr>
<td>“连通性”</td>
<td>状态机内的图像以及图像状态机之间都是可串联的</td>
</tr>
</tbody></table>
<p>“流体” 是一个名词，它对应的是图像，涉及到存储模型。根据 “流体” 的特性我们推断管道里的图像存储模型应该会被设计为平行结构。</p>
<p>请读者联想一下 &lt; <strong>化妆 / 整容 VS 软件上美化照片上的人脸</strong> ** &gt; 这种类比关系，再想一下两者在存储模型和工序这两个方面有什么异同？</p>
<p>回到正题，我配了五幅图来描述管道在具体实现中的五个特性：</p>
<ol>
<li><p>流体由一系列节点（即图像状态）组成。图像状态的含义构成了我们对某一个图像的本征性认知。通俗的说，图像状态能够帮助我们在特定场景下把不同的图像区分开来。举个例子，协同开发的两位开发者对于 “美颜” 和 “滤镜” 这两个步骤的认知达成了共识。于是我们就可以建立两个节点：“美颜”、“滤镜”，然后在开发过程中使用这两个节点来协作。注意到图像状态不是图像本身，图像状态的代码实现上我们可以使用一个极轻量的数据结构 —— 字符串。它体现的是 <strong>占位符思想</strong> ，而占位符的重要好处是它是 <em>可预见的（基于认知共识）、可预置的（它很轻量）、可固化的（可复用性代码的一个诉求）</em> 。 </p>
</li>
<li><p>管道通过衔接节点构成连通。在节点中有必要特别提出 “同位节点” 的描述。它指的是几个步骤在同一个图像上先后发生。在时间上有先后但在空间上始终操作同一份存储。后面会再用到这个描述。</p>
</li>
</ol>
<p><img src="/images/flow_connectivity.jpg" alt="流体和连通性"></p>
<ol start="3">
<li><p>流动的流体会有一个 <strong>最前部</strong> ，好像水流的最前端，又称 “锋面” (Waterfront) ，对应着管道中的所有图像在同一时间里只会有一个图像处于可操作的状态，这个状态代表着 <strong>图像的变化趋势</strong> 。具体到代码中的实现可能会是一组带有同步关键字的方法加上一个唯一的当前状态的指针。开发者通过引导和操刀这个趋势，把图像引向最终要呈现出来的样子。在图示中，我们有意使用了绿色代表原始的、最初的，使用红色代表成熟的、完全体的。 Pipeline 专注于做一件事，就是把图像从一种状态转化为另外一种状态。这期间可能要经历很多个节点，而 Waterfront 的意义就在于它保证了 Pipeline 的操刀者可以明确地知道这一刻只有他自己在引导图像的流向而没有别人会干扰到这件事。</p>
</li>
<li><p>流动可以是双向的（相比生产车间的 “流水线”，释义替换为 “管道” 更自然的原因是后者可以实现双向流动，对应着图像可以实现反向编辑或者说撤销到一个处理步骤之前的状态）</p>
</li>
<li><p>流体如果分流则可以出现多个 “锋面”，对应着图像的并行处理。</p>
</li>
</ol>
<p><img src="/images/waterfront_and_flow.jpg" alt="锋面和流动"></p>
<hr>
<h1 id="管道的具体实现"><a href="#管道的具体实现" class="headerlink" title="管道的具体实现"></a>管道的具体实现</h1><p>如前文所述，“流体” 即图像，做简单的封装即可。我们主要需要实现的是 “<strong>节点</strong>” 和 “<strong>锋面</strong>”， “<strong>流动</strong>” 和 “<strong>连通</strong>”。</p>
<h2 id="节点的实现方案和意义"><a href="#节点的实现方案和意义" class="headerlink" title="节点的实现方案和意义"></a>节点的实现方案和意义</h2><p>我们先来看一种典型的图像处理过程中可能会采用的代码写法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 图像 xyz 的描述 </span></span><br><span class="line">Image xyz; </span><br><span class="line"><span class="comment">// 图像 ijk 的描述 </span></span><br><span class="line">Image ijk;</span><br><span class="line"><span class="comment">// 图像 abc 的描述 </span></span><br><span class="line">Image abc; </span><br><span class="line"> 其他图像及其描述...</span><br><span class="line"><span class="comment">// 图像的 getters：</span></span><br><span class="line">getXYZ ();</span><br><span class="line">getIJK ();</span><br><span class="line">getABC ();</span><br><span class="line"> 其他图像的 getter...</span><br></pre></td></tr></tbody></table></figure>

<p>不难发现，如上的代码无法复用，因为每一个图像的引用被赋予了非常具体的含义，同样的写法不会完全适用于另外一个图像处理场景，因为另外那个图像处理场景可能不会用到描述为 ijk 的图像，可能会用到描述是 uvw 的图像。因此采取这种写法会遇到的一个典型问题是：每新增一个图像处理场景，我们是不是需要新增若干个特定描述的图像声明？在代码层面，这无疑会造成冗余。</p>
<p>这里的图像引用，其实就是我们所说的图像管道里的某个 “节点”。要对 “节点” 实现代码复用要怎么做呢？通过分析上面的写法中代码不能复用的根源是图像引用的用途被具体定义（同时也是被具体约束），我想到，那么为什么不能把图像引用匿名化，让它的含义在具体场景到来时才被赋予呢？</p>
<p>说到这里，有的读者会想到一种数据结构 —— <code>Map</code> 。是的，没有什么奇淫巧技，只是用了映射，就能解决这个代码复用问题中的最大障碍 —— 既然无法预知我们可能需要处理什么样的图像，可能需要处理多少份图像，并且这些未知数总是易变的，那么为什么不让具体场景的使用者来 <strong>动态添加</strong> 这些图像引用，并且为它们具名呢？图像部分被复用的代码，这里只声明了一样东西，就是从图像状态表述到图像引用的映射表。它解决了一个之前的写法不具备的达成复用的前提：<strong><em>图像存取的方式是统一的，有限的，因此是可固化的。</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Map&lt;String, Image&gt; stateTagToImageMap = <span class="keyword">new</span> HashMap&lt;&gt;;</span><br></pre></td></tr></tbody></table></figure>

<p>我们用一个字符串标签来表示图像的状态。对于图像管道的使用者来说，他只需要理解每个标签的含义，通过标签来存取图像并进行处理。在这些标签中，我们再提炼出几个具有通用含义的代表，比如。 Original 代表 “<strong>最初的</strong>” ， Processed 代表 “<strong>加工完成的</strong>” ，这正是前文提到的 <strong>占位符</strong> 。容易理解，你可以声明并且预置许多 <strong>占位符</strong> 在一份可复用的代码库中，可你不会声明同样数量的图像引用到这个代码库 —— 这样很奇怪。哪怕从程序实现的角度来说，没有分配实际空间的引用并不一定会占据更多内存。在后文中列举代码范例时我们将会经常地用到 Original 和 Processed 这样的标签。</p>
<p>不妨阅读以下这段代码，这是一种使用标签来操作其对应图像的写法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 显示两个处理步骤之后的图像 </span></span><br><span class="line">pipeline.from (tag_Original) <span class="comment">// 从原始的图像开始 </span></span><br><span class="line">        .copy_to (tag_Processed) <span class="comment">// 拷贝出一份图像，用于处理，命名标签 processed</span></span><br><span class="line">        .doProcess (tag_Processed, specificProcess_1)  <span class="comment">// 执行特定操作 1</span></span><br><span class="line">        .doProcess (tag_Processed, specificProcess_2); <span class="comment">// 执行特定操作 2</span></span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed)); <span class="comment">// 取得 processed 标签代表的图像并且展示 </span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="锋面的实现方案和意义"><a href="#锋面的实现方案和意义" class="headerlink" title="锋面的实现方案和意义"></a>锋面的实现方案和意义</h2><p>解决了节点的设计，我们再来看基于节点之上提炼出的 “锋面” 要怎么设计。容易理解， <strong>锋面</strong> 是最前面的那个节点，具有唯一性，对应具体的图像处理代码中就是 “当前正在被处理的那个图像”。当我们在设计图像管道对外提供的处理接口时约束处理动作一定只能发生在这个 “<strong>当前的</strong>” 图像上时，能够保证我们的 “图像流” 总是按照我们想要的方向流动，并且在这个过程中，“图像流” 是不会被篡改的。这是我们的图像编辑功能要实现撤销和重演功能的基本前提。</p>
<p>还是上面那段显示两个处理步骤之后的图像的代码，去掉处理接口的标签参数，因为我们约束了处理总是只能发生在 <strong>唯一的</strong> 、 <strong>当前的</strong> 图像上。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 显示一个处理步骤之后的图像 */</span></span><br><span class="line">pipeline.from (tag_Original)</span><br><span class="line">        .copy_to (tag_Processed)</span><br><span class="line">        .doProcess (specificProcess)</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed));</span><br></pre></td></tr></tbody></table></figure>

<p>如果要求能够回撤到第一个处理步骤之后的状态，再做第二个处理步骤，并且第二个处理步骤的参数是可以改变的。可以这么做：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 显示一个处理步骤之后的图像，但我们在过程中保留了第一个步骤的状态 */</span></span><br><span class="line">pipeline.from (tag_Original)</span><br><span class="line">        .copy_to (tag_specificProcess_1) <span class="comment">// 相比一步到位，这里多存储了第一个步骤的状态 </span></span><br><span class="line">        .doProcess (specificProcess_1)</span><br><span class="line">        .copy_to (tag_Processed)</span><br><span class="line">        .doProcess (specificProcess_2.setParams (params_t1))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调整第二个步骤的某些参数，重新显示图像 */</span></span><br><span class="line">pipeline.from (tag_specificProcess_1) <span class="comment">// 之前存储了第一个步骤的状态，直接从这个步骤开始 </span></span><br><span class="line">        .copy_to (tag_Processed)</span><br><span class="line">        .doProcess (specificProcess_2.setParams (params_t2))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed));</span><br></pre></td></tr></tbody></table></figure>

<h2 id="流动和连通性的实现方案"><a href="#流动和连通性的实现方案" class="headerlink" title="流动和连通性的实现方案"></a>流动和连通性的实现方案</h2><p>有了节点和锋面，流动和连通就有了作用的主体。对应到图像编辑功能， <strong>流动</strong> 其实就是图像从一个状态变成另外一个状态的过程。 <strong>连通</strong> 则更好理解，一个管道出来的图像可以被另外一个管道接纳，由此构成管道之间的连接。连接在一起的每一节 <strong>小管道</strong> 各司其职，灵活组合，再构成更长跨度的 <strong>大管道</strong> 或者 “<strong>管道网络</strong>” ，从而协同完成复杂的业务流程。</p>
<p><img src="images/construct-big-pipeline.jpg" alt="一条直线型连接小管道构成的大管道"><br><img src="images/diffluence_join_pipeline.jpg" alt="一个采用了分流策略的三个小管道构成的管道网络"></p>
<p>回归到代码，我们来看一组步骤稍多的图片处理工序如何体现出管道的流动性和连通性。刨去内部实现细节，整合或者忽略一些与管道设计思想关联不大的逻辑，以下代码在流程上已经比较接近实际生产环境了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** 主功能区，不妨将它的例程称为 Main</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 可以从这里进入各子功能处理图片再回到这里展示新的图片 </span></span><br><span class="line"><span class="comment"> * 3. 撤销到经过某个步骤处理之前的图像或者重做出之前做过但是被撤销掉的某个步骤的图像   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_Main.startFrom (image_file) -&gt; {</span><br><span class="line">    Routine_Main.pipeline.loadFrom (image_file, tag_Original) <span class="comment">// 从图片中加载初始的图像 </span></span><br><span class="line">}</span><br><span class="line">Routine_Main.showCurrent () -&gt; {</span><br><span class="line">    showImage (Routine_Main.pipeline.front (); <span class="comment">// 显示 “锋面”</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美型” 的功能区，对应的例程称为 FaceLift</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸轮廓，五官进行形状调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_FaceLift.startFrom (Routine_Main.pipeline.front ().copy ());</span><br><span class="line">Routine_FaceLift.process () {</span><br><span class="line">    Routine_FaceLift.pipeline</span><br><span class="line">         <span class="comment">// 这个过程用户无法干预，不会有 “重演”，因此我们可以直接在原稿上操作 </span></span><br><span class="line">        .from (tag_Original)</span><br><span class="line">        .doProcess (faceLift_step_1_process)</span><br><span class="line">        .doProcess (faceLift_step_2_process)</span><br><span class="line">        .doProcess (faceLift_step_3_process)</span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美型” 处理好的图像提交给主功能 </span></span><br><span class="line">Routine_Main.accept (Routine_FaceLift.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “滤镜” 的功能区，对应的例程称为 Filter</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 滤镜化处理图像 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_Filter.startFrom (Routine_Main.pipeline.front ().copy ());</span><br><span class="line">Routine_Filter.process () {</span><br><span class="line">    Routine_Filter.pipeline</span><br><span class="line">        <span class="comment">// 这个过程中用户决定要选用哪个具体的滤镜，因此每次都需要基于原稿复制一份再滤镜化 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"awful"</span>)))</span><br><span class="line">        ... <span class="comment">/// 皱眉，这个不好，换一个！</span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"notbad"</span>)))</span><br><span class="line">        ... <span class="comment">/// 托腮，这个还行，再换个试试～</span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"perfect"</span>)))</span><br><span class="line">        ... <span class="comment">/// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “滤镜” 处理好的图像提交给主功能 </span></span><br><span class="line">Routine_Main.accept (Routine_Filter.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美颜” 的功能区，对应的例程称为 SkinBeauty</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸皮肤进行色相调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像给 Main 功能 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_SkinBeauty.startFrom (Routine_Main.pipeline.front ().copy ());</span><br><span class="line">Routine_SkinBeauty.process () {</span><br><span class="line">    Routine_SkinBeauty.pipeline</span><br><span class="line">        <span class="comment">// 这个过程用户可以调节一个滑竿来控制色相参数，每次都基于原稿复制一份再调色相 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_weak))</span><br><span class="line">        ... <span class="comment">/// 托腮，效果好像不明显，加强一点 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_much)))</span><br><span class="line">        ... <span class="comment">/// 皱眉，好像有点过头了，往回调一点 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_just_right)</span><br><span class="line">        ... <span class="comment">/// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美颜” 处理好的图像提交给主功能 </span></span><br><span class="line">Routine_Main.accept (Routine_SkinBeauty.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纠结一下。。</span></span><br><span class="line"><span class="comment">/// 犹豫，要不还是不美颜了吧？</span></span><br><span class="line">Routine_Main.undo ();</span><br><span class="line"><span class="comment">/// 迟疑，滤镜也不要了？</span></span><br><span class="line">Routine_Main.undo ();</span><br><span class="line"><span class="comment">/// 思考中。。。</span></span><br><span class="line"><span class="comment">//... 不行，还是都加回来吧 </span></span><br><span class="line">Routine_Main.redo ().redo ();</span><br><span class="line"><span class="comment">// 端详 5 分钟。。。完美～～～</span></span><br><span class="line">save ();</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于管道的设计思路和实现方案介绍到此，读者可以回顾一下本文一开始所提到旧有设计的第二个问题：“<strong>图像管理</strong> 和 <strong>图像效果处理</strong> 被包在一起”。那么这个问题在管道方案中是不是已经解决了呢？</p>
<p>归纳一下。</p>
<blockquote>
<p>管道的基础是图像被 <strong>无差别的管理</strong> ，被管理的每一个图像由最初将其投入管道的创建者为其定义标签。最初的创建者和后来的协同者只需要对这个标签的含义达成共识，便可以进行协作。管道的思想是模拟 <strong>流体</strong> 的运行方式来实现图像处理过程，通过 <strong>节点</strong> 的设定来分解处理步骤，通过 <strong>锋面</strong> 的操控来聚焦每个单步的操作，通过 <strong>双向的连通性</strong> 来将分治的逻辑重新串联起来完成复杂的功能。</p>
</blockquote>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>关于花费时间的四宗罪</title>
    <url>/thinking/the-four-sins-of-spending-time/</url>
    <content><![CDATA[<blockquote>
<p>导致我们浪费时间的是我们的<strong>认知错误</strong>。</p>
</blockquote>
<p>你是否经历过这样的场景。邻居过来串门，喋喋不休，我们频频点头回应，哪怕当下已经心急如焚；同事开始闲聊琐碎，而我们沉浸其中，不曾意识到本该用来工作的时间正在一点一点溜走；从熟人那里收到微信，对方说：“我可以向你讨教点事情吗？”，我们爽快答应，因为抹不开面子拒绝别人？</p>
<p>斯多葛哲学家塞内卡（Seneca）曾经惊叹：哪怕最聪明的人，在保护自己的时间这件事上，都不免显得愚蠢。</p>
<blockquote>
<p>没有人会把自己的钱财送给路人，但我们中的许多人却送出了我们的生命！我们为财产和金钱所累，却罕有意识我们的时间正遭受的浪费。时间本应是我们每个人都最应吝惜的东西。</p>
</blockquote>
<p>两千多年后的今天，为什么我们还在允许时间这种宝贵的资源从我们的手中不停地溜走？</p>
<a id="more"></a>

<hr>
<h1 id="我们总以为我们有充足的时间"><a href="#我们总以为我们有充足的时间" class="headerlink" title="我们总以为我们有充足的时间"></a>我们总以为我们有充足的时间</h1><p>据说，人类现在的平均寿命已经到了 78 岁。听到这个数字你会有什么感觉？别着急作答，我们每个人用行动对这个数字做出的真实回应可能是：我好像拥有了无限的时间。是的，一辈子有这么长呢。于是乎，每天都在这里或者那里匀出二十分钟不算个事；去另一个城市开个会，去程三个小时，回程三个小时，然后再花一个小时休息安顿，然后一天就过去了，不是吗？</p>
<p>我们没有意识到是，死亡其实一直笼罩着我们所有人。要知道，寿命是一个平均值，保险公司允许你为自己买寿险，但没有任何人能为你的实际寿命做担保。更重要的是，时间其实和金钱一样，是复合的产物。当你浪费时间的时候，你浪费的不仅是眼前的这几分钟，还包括你把它们节省下来然后合理分配之后所带来的一切可能性。对，“可能性 “，这是另外一个话题，但我不需要展开讨论，你也不会没有感触。</p>
<hr>
<h1 id="我们为了做-“好人”-轻易让出时间"><a href="#我们为了做-“好人”-轻易让出时间" class="headerlink" title="我们为了做 “好人” 轻易让出时间"></a>我们为了做 “好人” 轻易让出时间</h1><p>在社交场合，似乎没有人喜欢对方说 “不”，而不愿意当 “坏人” 的我们，在内心想要拒绝的时候，选择了说 “好的”。时间浪费，只是这种委屈求全的行为所造成的一类后果，还有其他的负面影响，使得很多人其实能够意识到问题存在，并且在这种事情上自我纠结和挣扎。但是，想要摆脱这个困境，就像生孩子一样，别人是指望不上的，你只能靠自己。</p>
<p>如果我们懂得，对一件事说 “是”，通常意味着你要对另一件事说 “不”。我们就会意识到，当我们同意承担一些并不那么必要的义务时，有另外一些无辜的人也许要遭受痛苦。他们可能是我们的家人、朋友或者我们一直想要拿出时间来陪伴的人。</p>
<p>所以，当我忽略某个我不想交谈的人的电子邮件，拒绝多花一分种接听我不需要的电话销售，乃至对所有那些不符合我的意志的事情坚决说不的时候，我的心理障碍比以前小多了。</p>
<p>听起来有点卑鄙是不是？重要的是，你要想清楚什么对你来说是重要的。换一个角度，你花时间耐心接完一个电话销售在另一头给你介绍完产品，然后再拒绝并挂断。看似礼貌得体，其实你在浪费了自己时间的同时，也浪费了对方的时间。</p>
<p>在我们交付时间给别人时，可以经常提醒自己这么一个事实：每个人对于时间使用的粒度是不一样的。</p>
<hr>
<h1 id="我们对自己不够重视"><a href="#我们对自己不够重视" class="headerlink" title="我们对自己不够重视"></a>我们对自己不够重视</h1><p>我们缺少说 “不” 的信心，并且害怕伤害别人的感情。可能的原因是，我们觉得自己不配被放在我们的关注列表的前面。已逝的 Joan Rivers ，美国有史以来最有成就，最受尊敬和最有才华的喜剧演员，在七十多岁高龄时，被问到为什么她要继续工作？为什么她总是在路上？为什么她总是在寻找更多的演出？她拿着一本空日历，说出了她的恐惧：“如果我的书看起来是像这样的，那就意味着没有人想要我，我曾经尝试做的一切都没有用。没有人在乎，就等于我已经完全被遗忘了。”</p>
<p>不知道你听到这样的话是何反应。</p>
<p>我们每个人都不免有在人群中受欢迎的诉求。无论是作为销售，演讲者还是作家，我们之所以为我们的时间收费，原因之一是我们知道自己值这个价，但也要提醒自己，费用并不等于价值。关键是你要坚定信念，并且始终如一。</p>
<hr>
<h1 id="我们尚未发展出划清界限所需的力量"><a href="#我们尚未发展出划清界限所需的力量" class="headerlink" title="我们尚未发展出划清界限所需的力量"></a>我们尚未发展出划清界限所需的力量</h1><p>我花了很多时间思考自己想要什么样的生活。花在打电话或开会上的每一分钟，都本可以是我可以用在写作而实际没有用在写作上的时间。它们也是我没有花在陪伴家人这件事上的时间。我经常和我的助理说，保护我的日程表 —— 确保一天之内不要超过三件事。当我拿出日程表，看见它几乎是空白的时候，与 Joan Rivers 不同，我感觉很棒。  </p>
<p>我知道我想在哪里度过我的时光 —— 我不希望它们未经我的同意而被花掉。我知道这是值得的。</p>
<p>但是，帮助别人是另外一回事，你可以在坚持说不的原则下仍然帮助到别人。虽然无法回复收到的每一条信息，但我还是尝试回答人们有疑问的主题并撰写文章以解决这些问题。当我对请求说不的时候，我也会尽量想：“不行。但我愿意做<strong>___</strong>来代替。”<br>以这种方式慷慨地帮助人们，同时保持对自己时间的掌控。</p>
<p>聪明的慈善家会放弃自己的超额利润，但不会放弃让他们继续赚钱的原则。将其应用到时间管理中使我获益良多。我清楚自己不是反社会型人格，我只是严肃认真地对待自己。</p>
<p>内心平静是你取得你想要的人生以及所有使美好生活成为可能的关键。所以我避免打电话，我拒绝会议要求，我不喝杯咖啡，我拒绝播客邀请，并且忽略了收到的大多数电子邮件。那些都不是我想要度过自己宝贵生命的方式，因此我不会为它们而感到内疚，但我会尽量不把这些事情强加给别人。因为并不是我的时间就比其他任何人的时间都更有价值。</p>
<p>尊重时间，从现在开始做起。</p>
<p>编译自 <a href="https://forge.medium.com/why-dont-we-know-how-to-protect-our-time-a88859deea2e" target="_blank" rel="noopener">https://forge.medium.com/why-dont-we-know-how-to-protect-our-time-a88859deea2e</a> ，有删节和演绎，文章不代表译者观点。欢迎交流。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学教师协会 - K12 - 标准</title>
    <url>/uncategorized/csta-k12-standards/</url>
    <content><![CDATA[<p>About the CSTA K-12 Computer Science Standards<br>关于 CSTA K-12 计算机科学标准</p>
<p>Computer science and the technologies it enables rest at the heart of our economy and the way we live our lives. To be well-educate citizens in a computing-intensive world and to be prepared for careers in the 21st century, our students must have a clear understanding of the principles and practices of computer science. The CSTA K–12 Computer Science Standards delineate a core set of learning objectives designed to provide the foundation for a complete computer science curriculum and its implementation at the K–12 level. To this end, the CSTA Standards:</p>
<p>计算机科学及其支持的技术是我们经济的核心，也是我们生活的方式。为了对计算机密集型世界中的公民进行良好的教育并为 21 世纪的职业做好准备，我们的学生必须对计算机科学的原理和实践有清晰的了解。 CSTA K-12 计算机科学标准描述了一组核心学习目标，旨在为完整的计算机科学课程及其在 K-12 级别的实施提供基础。为此，CSTA 标准：</p>
<p>・Introduce the fundamental concepts of computer science to all students, beginning at the elementary school level.<br>・Present computer science at the secondary school level in a way that can fulfill a computer science, math, or science graduation credit.<br>・Encourage schools to offer additional secondary-level computer science courses that will allow interested students to study facets of computer science in more depth and prepare them for entry into the work force or college.<br>・Increase the availability of rigorous computer science for all students, especially those who are members of underrepresented groups.<br>The standards have been written by educators to be coherent and comprehensible to teachers, administrators, and policy makers.<br>Levels 1A, 1B, 2, and 3A are the computer science standards for ALL students. The Level 3B standards are intended for students who wish to pursue the study of computer science in high school beyond what is required for all students (specialty or elective courses).</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
  </entry>
  <entry>
    <title>聊一聊 UI 代码要怎么写 | 分治篇</title>
    <url>/programming/ui-programming-howto/</url>
    <content><![CDATA[<ul>
<li>本文的主要价值： 提供一份软件开发中分治 UI 逻辑的实践样本</li>
<li>关键词： 分治、 UOP</li>
</ul>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><blockquote>
<p><em>我们知道，分治策略是人们解决问题的一种基本策略。问题规模越大，内部包含的差异化的细节越多，越需要执行分治策略。</em></p>
</blockquote>
<p>所谓化整为零，化繁为简，逐个击破讲的都是分治。在计算机领域，我们要列举分治的例子，大的可以聊到七层网络模型（本质上分层也是一种分治），小的可以讲起二分算法。</p>
<p>本文基于 Android 客户端开发中经常涉及的交互逻辑编程展开，表达我对于 UI 分治在软件开发中如何实践的理解。</p>
<a id="more"></a>

<h1 id="从-MVC-说起"><a href="#从-MVC-说起" class="headerlink" title="从 MVC 说起"></a>从 MVC 说起</h1><p>经典的 <strong><a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC</a></strong> 设计模式想必各位程序猿们无人不晓。 MVC 最早存在于桌面程序中，后来由于其强大的复用性被广泛地发掘和应用于各端的开发中，还衍生出 MVP ， MVVM 等变体。如果把 MVC 的变体都算作 MVC ，可以说现如今任何一个成熟的 GUI 框架都内化了这种设计模式。放图：</p>
<p><img src="/images/MVC-vs-MVP-vs-MVVM.jpg" alt=""></p>
<p>然而我今天不是要来谈 MVC 设计模式的，因为网络上以各种姿势深入浅出 MVC 的好文章已经多的不能再多。之所以提及 MVC 模式只是想借此提醒读者， <strong>解耦</strong> 对于编程的重要性。</p>
<p>MVC 之所以看起来很简单却又如此广泛地被使用就在于它有效地解决了一个已知的，规模庞大的 <strong>耦合</strong> 问题：“你看到的”（不妨理解为 MVC 中的 View ) 和 “它代表的” (不妨理解为 MVC 中的 Model )，这两个东西永远不可能完全一致。</p>
<p>我们有时候需要用相同的表象去表示不同的真相，有时候则需要用不同的表象去表达同一个真相。而当我们尝试把两者捆绑在一起处理时，一旦映射关系发生变化，这个捆绑体便不再适用，需要重新构建。这样一来，原来的东西就都不能用了。所以我们需要一套机制来避免这种耦合，从而实现 Model 和 View 各自的复用。</p>
<blockquote>
<p><em>想要简单的理解这个问题，思考一下我们如何造字，为什么只需要造出常用的几千个汉字就能够表达一个人在生活中遇到的绝大部分事物？又为什么同一个字词在不同的场景下可以表达不同的含义？</em></p>
</blockquote>
<p>MVC 正是通过解耦 Model 和 View ，使得大量的 UI 可以被标准化，进而被重复利用。而这个问题之所以规模巨大，是因为只要一个计算机程序是给人类用的，就一定会涉及到人机交互，也就是我们常说的 UI 。</p>
<p>在解决了耦合问题并实现复用时， MVC 引入了 <strong>Controller</strong> ，我们的 UI 怎么写将围绕 Controller 展开。</p>
<hr>
<h1 id="UI-写在何处"><a href="#UI-写在何处" class="headerlink" title="UI 写在何处"></a>UI 写在何处</h1><p>在现今我们用到的主流应用框架中，你很难找到针对 GUI 编程部分只提供手写原生代码来实现界面的个例 — 它们无一例外地会引入基于某一种或者某几种标记语言的界面编程机制。其中最常见的是 xml 及其变体。</p>
<p>使用标记语言设计 UI 的最大好处在于它们可以被方便地转换为可视化的编辑界面，这样的话可以允许程序员以所见即所得的方式直观地进行界面设计，即 <strong>可视化编程</strong> 。提到可视化编程，桌面端的开发框架中大家最耳熟能详的想必包括微软的 .NET 。之所以特别提及 .NET ，是因为我认为微软在可视化编程技术和可视化集成开发环境方面的贡献至今仍是值得称道的。作为编程的初学者，我当年曾一度被 VisualStudio 的强大惊艳到。</p>
<p>在 GUI 编程方面摸爬滚打过几年，我先后使用过 MFC ， Windows Forms ， Qt 等框架开发桌面端的用户界面，目前从事的是 Android 客户端开发。从这些使用过的开发框架的用户界面部分的组件，我发现一个共同点： UI 都是一定程度上独立的。</p>
<p>首先，在设计阶段，通过使用单独的资源文件夹或者 .xml ， .qml ， .ui ，又或者是 C# 分部类，界面部分的生成逻辑是被隔离开的。然后，在使用阶段，界面部分的元素通过约定的方式查找或者引用，并且建立响应逻辑。这样的运行方式，使得 UI 和其他程序逻辑被天然地划分开，能够让程序员把 UI 的代码编写从整体的编程活动中独立出来，从而便于维护和协作。</p>
<h2 id="UI-编程的两个阶段"><a href="#UI-编程的两个阶段" class="headerlink" title="UI 编程的两个阶段"></a>UI 编程的两个阶段</h2><p>不妨把 UI 设计和 UI 使用的这两个阶段称为 <strong>UI 编程的两个阶段</strong> 。我在后文会介绍到 <strong>UOP</strong> 和从 UI 快速切入别人的代码结构进行修改的策略，都是基于 UI 实现所具备的这种独立性。从这里开始，相关话题我会以 Android 平台的客户端界面设计为例展开。</p>
<p>Android 的 UI 可以通过 xml 设计，运行时由系统加载和创建出界面，也可以通过代码直接创建。相对来说，前者的使用方式比较普遍，以下描述会基于采用前者方式的前提。在 UI 编程的第二个阶段， Android 通过 findViewById 的方式将 UI 元素从被隔离的区域 (xml) 中找出来，准确的说，是通过预先定义好的 id 将第二阶段所关心的 UI 元素从被隔离的区域 (xml) 中找出来，为它在控制器逻辑中建立一个引用，然后围绕这些 UI 元素编写交互逻辑。</p>
<p>到目前为止，我所说的是大家都已经知道的事实，而这一节要聊的关于 UI 写在何处 —— 跟我们已知的这些事实有什么关联呢？一些有过 Android 开发经验的同学想一想 <em>RoboGuice</em> 、 <em>ButterKnife</em> 以及官方的 <em>Android Data Binding</em> 为何会存在？也许会对这个问题有自己的答案。</p>
<h2 id="负担过重的-Controller"><a href="#负担过重的-Controller" class="headerlink" title="负担过重的 Controller"></a>负担过重的 Controller</h2><p>在我看来，在编程框架内置的 MVC 模型中，单一的 Controller 一直负荷了过重的工作，因为通常的情况是许多的 Model 和 View 都仅仅通过某个唯一的 Controller 建立关联，与此同时我们忽略了一个重要的事实：单一的 Controller 通常不仅要服务于 UI ，往往还需要承载多个不同角度不同层级的业务逻辑。</p>
<p>面对这个问题，我们能做些什么呢？有的读者可能已经想到了 MVVM 模式。首先，要肯定一下 MVVM 是一个可以考虑的选项。在我看来， ViewModel 本质上就是将 Controller 中与特定 UI 密切相关的逻辑集中在一起。不过呢，我会倾向于认为 MVVM 是 MVC 的一个变体， ViewModel 是我们在实现 Controller 时所采取的一种策略：这种策略叫做分治。那么为什么 MVVM 只是可以考虑的选项而不是根本的解决方案呢？我的解释是：因为 <strong>分治</strong> 这件事，太依赖于具体情况了。没有一种框架可以告诉我们应当如何拆分一整个复杂的控制器逻辑，如你所见，它们顶多帮你把 UI 隔离到另外的空间，让你的代码不至于一上来就看着一团乱麻。而我们在编程的时候，还可能会不断地把 UI 找出来，重新加入我们的控制器，并为它们书写冗长的交互代码。有的时候这些交互的复杂程度是已经具备一定约束规则的 ViewModel 所无法预见和适应的。</p>
<p>其实，无论 MVC 还是 MVVM，其实都是可行的方案，但是我们不能太拘泥于形式，不能规定 View 和 Model 必须以这样或者那样的方式建立关联。在具体的场景中，需要视逻辑的复杂度对控制器中的 UI 部分进行拆分。控制器中可以拆分的逻辑当然并不局限于 UI 部分，不过它与本文无关这里不特别说明。所有分治的 UI 控制器中的 UI 虽然是由原来的那个控制器统一创建的，但是在使用时却可以由各分治控制器自行把握。</p>
<p>这里提供一个参考思路：在实际的开发实践中，我做过的控制器拆分通常是以可复用的组件作为目标，根据模块分工，代码规模等情况综合考虑的。</p>
<hr>
<h1 id="UOP——-分治-UI-控制逻辑的利器"><a href="#UOP——-分治-UI-控制逻辑的利器" class="headerlink" title="UOP—— 分治 UI 控制逻辑的利器"></a>UOP—— 分治 UI 控制逻辑的利器</h1><p>接着第 2 节文末提出的思路，笔者在本文的最后一节要来重点分享一下在实践 UI 控制逻辑分治这件事时的一种十分有效的编程方式： <strong>UOP</strong>。</p>
<p>面向 UI 编程。你无法在 wikipedia 上找到这个词条。因为它是杜撰的。实际上，我将要说的 “面向 UI 编程” 应该是面向切面编程（<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="noopener">Aspect-oriented programming</a>）的一种，只不过切面聚焦在 User Interface 上。</p>
<p>在展开 <strong>UOP</strong> 之前，让我们先回到 Controller 这个概念，在我们熟知的框架内化的 MVC 模式中，原先的那个 Controller 角色必定是已经提供 UI 的访问途径了，比如 Android 框架的控制器 Activity ，它提供了 findViewById 。而分治出去的 Controller （同时也是我们自己创建的 Controller ）要如何取得 UI 呢？一些同学可能会想到，使用 setter。是的，我们完全可以这么实现。不过这里要提供另外一种思路 —— <strong>“UI 包装器”</strong> ，我给它取了一个代码名，叫 <code>UIWrapper</code> 。我们将通过这个 <strong>“UI 包装器”</strong> 来说明 UOP 是什么，以及我们为什么使用 UOP 。</p>
<p>一个 Android 上的 UI 包装器可以是如下的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIWrapper</span> </span>{</span><br><span class="line">        <span class="comment">/** 布局资源 id 到根视图的索引 */</span></span><br><span class="line">        <span class="keyword">protected</span> SparseArray&lt;View&gt; mLayoutIdToRootViewIndex = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">        <span class="comment">/** 视图 ID 到子视图的索引 */</span></span><br><span class="line">        <span class="keyword">protected</span> SparseArray&lt;View&gt; mIdToSubViewIndex = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UIWrapper</span><span class="params">()</span> </span>{}</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置 UI 元素 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> otherWrapper 给定的 UI 元素包装器 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">setUi</span><span class="params">(UIWrapper otherWrapper)</span> </span>{</span><br><span class="line">            mLayoutIdToRootViewIndex = otherWrapper.mLayoutIdToRootViewIndex.clone ();</span><br><span class="line">            mIdToSubViewIndex = otherWrapper.mIdToSubViewIndex.clone ();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 包装 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 指定的视图资源 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> view 指定的视图资源 ID 对应的视图 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">wrapUi</span><span class="params">(<span class="keyword">int</span> viewId, View view)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> wrapUi (viewId, view, <span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 包装 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 指定的视图资源 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> view 指定的视图资源 ID 对应的视图 </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> treatAsViewGroup 以 ViewGroup 方式处理包装的 View</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">wrapUi</span><span class="params">(<span class="keyword">int</span> viewId, View view, <span class="keyword">boolean</span> treatAsViewGroup)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (viewId &gt;= <span class="number">0</span> &amp;&amp; view != <span class="keyword">null</span>) {</span><br><span class="line">                mIdToSubViewIndex.put (viewId, view);</span><br><span class="line">                <span class="keyword">if</span> (treatAsViewGroup) {</span><br><span class="line">                    mLayoutIdToRootViewIndex.put (viewId, view);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据 view id 查找 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 目标视图的 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> view</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">findViewById</span><span class="params">(<span class="keyword">int</span> viewId)</span> </span>{</span><br><span class="line">            View view = mIdToSubViewIndex.get (viewId);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; mLayoutIdToRootViewIndex.size (); index++) {</span><br><span class="line">                    View layout = mLayoutIdToRootViewIndex.valueAt (index);</span><br><span class="line">                    <span class="keyword">if</span> (layout != <span class="keyword">null</span>) {</span><br><span class="line">                        view = layout.findViewById (viewId);</span><br><span class="line">                    }</span><br><span class="line">    </span><br><span class="line">                    <span class="keyword">if</span> (view != <span class="keyword">null</span>) {</span><br><span class="line">                        mIdToSubViewIndex.put (viewId, view);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">UIWrapper 这个类很简单，它的功能概括成一句话就是动态扩容地持有一组 View 的匿名引用，并且具备通过 viewId 来检索 View 的能力。（以动态扩容地持有匿名引用的方式来实现代码复用，是一个简单却极其有效的实用技巧，在我的另外一篇文章 __用 “管道” 设计拆分复杂处理流程__ 中也有提到，感兴趣的读者可以移步一阅。）</span><br><span class="line"></span><br><span class="line">UIWrapper 在具体场景中是以继承或者依赖的方式被使用的，如果我们的分治 UI 控制器本身没有基类，可以直接继承自 UIWrapper ；如果已经有了继承结构，可以引入 UIWrapper 作为成员，进而间接引入目标 UI ，比如 Fragment 就适用这种情况。题外话，说到 Fragment，读者会不会意识到它其实就是框架本身提供的一种分治策略的具体实现呢？</span><br><span class="line"></span><br><span class="line"> 对于以继承方式使用 UI 包装器的方式，我们不妨设计下面这样一个基类 AbsUIController ，也就是前文我们说的要分治的 UI 控制器。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分治的 UI 控制器基类 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsUIController</span> <span class="keyword">extends</span> <span class="title">UIWrapper</span> </span>{</span><br><span class="line">        <span class="comment">// 生产环境中这个抽象层级中除了构造方法外还有一些实际的基础功能，</span></span><br><span class="line">        <span class="comment">// 但是与本文重点无关，此处略过 </span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbsUIController</span><span class="params">(@NonNull Activity activity)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            wrapUi (<span class="number">0</span>, activity.getWindow ().getDecorView (), <span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbsUIController</span><span class="params">(@NonNull Activity activity, UIWrapper ui)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            setUi (ui);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>再基于基类的 UI 控制器，我举一个在生产环境中实现的 UI 控制器为例，它的功能是为所有由它管理的 UI 元素提供独占可见状态的显示和隐藏过程处理的可复用的工具类。通俗的说，就是处理几个 View 同一时间只显示其中一个的情况。以下是简化的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoDisplayController</span> <span class="keyword">extends</span> <span class="title">AbsUIController</span> </span>{</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占展示空间显示给定视图 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view 要显示的视图 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monoDisplay</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>{ ... }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏由当前包装器管理的全部视图 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayBeforeStart 开始隐藏前的延时 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整个隐藏过程完成的总耗时，以毫秒计 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hideAll</span><span class="params">(<span class="keyword">long</span> delayBeforeStart)</span> </span>{ ... }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>读者是否可以想到这样的一个简单的 UI 控制器可以用在哪里呢？不妨先看一下 MonoDisplayController 这个类的用例的代码片段:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 将可见性互斥的 UI 元素包在同一个 MonoDisplayController 里，包含可下载图标，下载进度等 </span></span><br><span class="line"><span class="comment">// 注意，生产环境中的 UI 元素数量可能很多，都要求互斥显示，这时复用代码更能体现优势 </span></span><br><span class="line">viewHolder.monoDisplaysOnDownloadStatus = <span class="keyword">new</span> MonoDisplayController (getActivity ());</span><br><span class="line">viewHolder.monoDisplaysOnDownloadStatus</span><br><span class="line">        .wrapUi (R.id.iv_download_available, viewHolder.ivDownloadAvailable)</span><br><span class="line">        .wrapUi (R.id.download_progress_view, viewHolder.downloadProgressView)</span><br><span class="line">        .wrapUi (...)</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="comment">// 根据下载状态互斥展示不同的 UI 元素 </span></span><br><span class="line"><span class="keyword">switch</span> (entity.getDownloadStatus ()) {</span><br><span class="line"><span class="comment">// 正在下载 </span></span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_DOWNLOADING:</span><br><span class="line">    viewHolder.monoDisplaysOnDownloadStatus.monoDisplay (viewHolder.progressView);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 下载暂停，删除，未下载 </span></span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_PAUSE:</span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_DELETED:</span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_UN_DOWNLOAD:</span><br><span class="line">    viewHolder.monoDisplaysOnDownloadStatus.monoDisplay (viewHolder.downloadAvailableView);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>限于篇幅没有奉上无关的代码。我相信如果读者有过用许多 if , else 分支来协调多个 View 的可见性这种编码经验的话，应该会认同这样一个控制器是能够有效减少代码量和避免错误的。</p>
<p>讲到这里， UOP 的实例已经在代码中完整给出。读者请重点留意一下 <code>UIWrapper#wrapUi (int viewId, View view)</code> 这个方法，它体现了 UOP 最核心的思维方式： UI 是第一度的逻辑出发点。<strong>首先搞清楚我们要跟哪些 UI 打交道，然后才是要在这些 UI 上做些什么事情。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">.wrapUi (R.id.iv_download_available, viewHolder.ivDownloadAvailable)</span><br><span class="line">.wrapUi (R.id.download_progress_view, viewHolder.downloadProgressView)</span><br></pre></td></tr></tbody></table></figure>

<p>解释完 UOP 是什么，最后再来解释一下为什么 UOP 是分治 UI 的利器。前面说过 UOP 其实是 AOP 中的一种，而我认为 AOP 其实是贯彻第一性原理的一种思维方式：聚焦任务在同一维度的事物构成的某一条线索上。UI 是程序代码中被最直观呈现的东西，以软件用户的角色观察，UI 可能就是他可以感知的全部，这是一条最自然的线索。而对于程序员来说，这个认知其实也是完全适用的。</p>
<p>如果上面的描述不好理解，我再举一个维护代码的例子，程序员朋友可能就会有共鸣了。</p>
<blockquote>
<p><em>假定有程序员甲开发了一款软件，他很熟悉这款软件的代码。还有程序员乙从未接触过这款软件的代码。有一，乙在甲不能提供帮助的情况下，（比方说甲请假了）接受了一个任务：他要在短时间内调整一处 UI 。对于乙来说，最快的做法是先去阅读代码吗？恐怕不是。然而，现实场景中，在对代码一无所知的情况下，要我们基于别人的代码增改功能，这并不少见。倘若时间有限，无法阅读太多的代码，那么抓住目标的特点，从代码中找到线索，利用线索切入，则是快速搞定任务的靠谱思路。这其实只是专注于任务本身的结果，而并非什么独特的解题技巧。对于 UI 来说，不论是框架内化的设计模式，还是它本身最直观的外在呈现，往往都天然地提供了一条独立于常规代码之外的 线索。</em></p>
</blockquote>
<p>使用 UOP ，本质上是在分治 UI 控制逻辑的同时，仍然保持对关注点的聚焦。虽然 UI 被分出来了，但事还是那些事，并没有因为设立了一个分管的去处，就多出了额外的东西。同时，又因为分管，被分出来的这些事，作为一个可单独运行的逻辑，自身变得更加纯粹了，更容易被复用。当然，它带来的最重要的好处是：维护这件事变得更容易了。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之十 | 可选型</title>
    <url>/programming/swiftswift-optionals/</url>
    <content><![CDATA[<h1 id="处理缺失的数据"><a href="#处理缺失的数据" class="headerlink" title="处理缺失的数据"></a>处理缺失的数据</h1><p>我们已经会使用 <code>Int</code> 这样的类型来存储像 5 这样的数值。不过，当你想要存储用户年龄这样的属性，并且你还不知道该用户的年龄时你该怎么做呢？</p>
<p>你可能会说，“我可以暂时存成 0”，但这样一来你就会混淆新生儿和你不知道年龄的用户。你应该用一个特殊的数字，比如 1000 或者 -1 来代表 “未知”，这两个数字都不可能是年龄，但你能记得住这些特殊数字的含义吗？</p>
<p>Swift 的解决方案称为 <em>optional</em> ，即可选型。你可以基于任意类型创建可选型。一个可选型整数可以有诸如 1 或者 1000 这样的数字，也可能没有任何值，即值可以缺失， Swift 里表示缺失是用 <code>nil</code> 。</p>
<p>为了把一个类型变成可选型，只需要在类型后面加一个问号。举个例子，我们可以这样把一个整数变成可选型：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p>这个可选型现在并不保有任何整数，但是如果之后我们知道了年龄值，我们可以给它重新赋值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">age = <span class="number">38</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="解包可选型"><a href="#解包可选型" class="headerlink" title="解包可选型"></a>解包可选型</h1><p>可选型字符串可能包含一个 “Hello” 或者 <code>nil</code> 。</p>
<p>考虑这样一个可选字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String?</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure>

<p>当我们调用 <code>name.count</code> 时会发生什么呢？一个真的字符串有 <code>count</code> 属性，它存储字符串的字符数量。但它是 <code>nil</code> 时，并没有 <code>count</code> 属性。</p>
<p>因此，试图直接使用 <code>name.count</code> 是不安全的， Swift 也不允许。取而代之的是，我们必须先检查可选型里面有些什么，这个过程被称为 <em>解包</em> 。</p>
<p>解包可选型的一种常见做法是采用 <code>if let</code> 语法，它是一种有条件的解包。如果可选型里有值，你就可以使用它，如果没有则条件失败。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrapped = name {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(unwrapped.count) letters"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Missing name."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果 <code>name</code> 持有一个字符串，这个字符串会被放进一个叫 <code>unwrapped</code> 的常规字符串，然后我们就可以读取它的 <code>count</code><br>属性。另一种情况，如果 <code>name</code> 是 nil， 那么 <code>else</code> 中的代码将被执行。</p>
<hr>
<h1 id="用-guard-解包可选型"><a href="#用-guard-解包可选型" class="headerlink" title="用 guard 解包可选型"></a>用 guard 解包可选型</h1><p><code>if let</code> 的一个替代方案是 <code>guard let</code> ，后者也可以用来解包可选型。 <code>guard let</code> 会为你解包，但是当它发现可选型里是 <code>nil</code> 时会期望你退出它所处的函数，循环或者条件。</p>
<p>因此， <code>if let</code> 和 <code>guard let</code> 的主要区别在于 <code>guard let</code> 之后可选型还可以继续使用。</p>
<p>让我们尝试一下 <code>greet ()</code> 函数。它将接收一个可选字符串作为唯一的参数，当它解包发现这个参数是 <code>nil</code> 时会打印消息并且退出函数。因为可选型 <code>unwrapped</code> 在 <code>guard let</code> 的语句块结束之后作用，我们可以在函数最后打印这个解包后的字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> name: String?)</span></span> {</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = name <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You didn't provide a name!"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(unwrapped)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过使用 <code>guard let</code> ，你可以在函数的前面解决可选型的解包问题，在这之后的代码就可以愉快地使用解包后的值而不必担心出错了。</p>
<hr>
<h1 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h1><p>可选型代表可能存在也可能不存在的数据，而某些时候你是 <em>确切</em> 知道一个可选型的值并不是 <code>nil</code> 。在这种情况下， Swift 允许你强制解包这个可选型：通过把一个可选型转换为非可选型的方式。</p>
<p>举个例子，下面你试图将一个字符串转换成 <code>Int</code> ，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"5"</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码中 <code>num</code> 其实是一个可选型 <code>Int</code> 。因为你有可能尝试转换一个不是数字的字符串导致转换失败。</p>
<p>尽管 Swift 不确定转换能否成功，你自己是知道你的结果是否可以安全地执行强制解包。这个强制解包是通过在 <code>Int (str)</code> 之后添加 <code>!</code> 来完成的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)!</span><br></pre></td></tr></tbody></table></figure>

<p>通过强制解包， Swift 将立刻解包 <code>num</code> ，把它变成一个常规的 <code>Int</code> 而不是 <code>Int?</code> 。但是假如你是错的，比方说 <code>str</code> 是某个不能转换成数字的字符串，那么你的代码将崩溃。</p>
<p>强制解包的操作符常常被戏称为崩溃操作符。因此，只有当你确信强制解包是安全的你才能这么做。</p>
<hr>
<h1 id="隐式解包可选型"><a href="#隐式解包可选型" class="headerlink" title="隐式解包可选型"></a>隐式解包可选型</h1><p>像常规可选型一样，隐式解包可选型可能包含一个值也可能包含 <code>nil</code> 。不过，跟常规可选型不一样的是，隐式解包可选型时不需要再解包，你可以把它们当做非可选型一样使用。</p>
<p>隐式解包可选型是通过类型名之后添加感叹号来声明的，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="type">Int!</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于它们表现起来就像已经被解包过的样子，你并不需要 <code>if let</code> 或者 <code>guard let</code> 这样的代码来测试它们。不过，当你试图使用它们而它们实际上没有值时，即它们的值是 <code>nil</code> 时，你的代码将崩溃。</p>
<p>隐式解包可选型存在的意义在于，有些情况某个变量一开始时是 <code>nil</code> ，但当你需要用到它之前它总会有值。如果你可以确信这一点，那么采用隐式解包可选型可以省去一直写 <code>if let</code> 的麻烦。</p>
<p>值得一提的是，如果条件允许采用常规可选型，安全起见最好总是采用常规可选型。</p>
<hr>
<h1 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h1><p>空合运算符解包一个可选型，如果可选型包含值则返回这个值，如果可选型不包含值，即可选型的值是 <code>nil</code> ，那么返回某个默认值。两种情况，返回值都不再是可选型：它要么是可选型里包含的有效值，要么是一个备选的默认值。</p>
<p>下面是一个接收整数作为唯一参数并且返回可选型字符串的函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">username</span><span class="params">(<span class="keyword">for</span> id: Int)</span></span> -&gt; <span class="type">String?</span> {</span><br><span class="line">  <span class="keyword">if</span> id == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Taylor Swift"</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们以 ID 15 来调用这个函数，我们将得到 <code>nil</code> 。通过空合运算符，我们可以提供一个叫 “Anonymous” 的默认值，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = username (<span class="keyword">for</span>: <span class="number">15</span>) ?? <span class="string">"Anonymous"</span></span><br></pre></td></tr></tbody></table></figure>

<p>它将检查 <code>username ()</code> 函数返回的值：如果是一个字符串，它将被解包并放入 <code>user</code> ，如果是 <code>nil</code> ，则使用 “Anonymous” 替代。</p>
<hr>
<h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h1><p>在使用可选型时， Swift 为我们提供了一种快捷方式：假如你试图访问形如 <code>a.b.c</code> 这样的代码并且 <code>b</code> 是可选型，你可以在 <code>b</code> 后面写一个问号来启用 <em>可选链</em> ： <code>a.b?.c</code> 。</p>
<p>当代码运行时， Swift 会检查 <code>b</code> 是否有值，如果它是 <code>nil</code> ，那么这行代码剩下的部分将被忽略。Swift 会立即返回 <code>nil</code> 。但是如果 <code>b</code> 有值，它将被解包，代码执行将继续。</p>
<p>下面是一个名字的数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>我们将使用数组的 <code>first</code> 属性，如果数组里第一个名字有值的话返回这个名字，如果数组为空则返回 <code>nil</code> 。在结果之上，我们调用 <code>uppercased ()</code> 把它变成一个全大写的字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> beatle = names.first?.uppercased ()</span><br></pre></td></tr></tbody></table></figure>

<p>上面的问号就是可选链。如果 <code>first</code> 返回 <code>nil</code> ，那么 Swift 就不会尝试将它转换成全大写，它会将 <code>beatle</code> 立即设置为 <code>nil</code> 。</p>
<hr>
<h1 id="可选型-try"><a href="#可选型-try" class="headerlink" title="可选型 try"></a>可选型 try</h1><p>让我们回忆一下可能抛出错误的函数那一节的知识，看下面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PasswordError</span>: <span class="title">Error</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> obvious</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword</span><span class="params">(<span class="number">_</span> password: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> {</span><br><span class="line">  <span class="keyword">if</span> password == <span class="string">"password"</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">PasswordError</span>.obvious</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  <span class="keyword">try</span> checkPassword (<span class="string">"password"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"That password is good!"</span>)</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"You can't use that password."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 <code>do</code> ， <code>try</code> 和 <code>catch</code> ，我们得以运行可能抛出错误的函数，并且优雅地处理错误。</p>
<p>上面的 <code>try</code> 写法其实有另外两种选择，这两种选项都能加深你对可选型和强制解包的理解。</p>
<p>第一个是 <code>try?</code> ，它将可能抛出错误的函数转换成返回可选型的函数。如果函数抛出错误，那你就会得到 <code>nil</code> 作为函数的执行结果，否则你会得到将返回值包装之后的可选型。</p>
<p>尝试使用 <code>try?</code> 来执行 <code>checkPassword ()</code> ，像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result = <span class="keyword">try</span>? checkPassword (<span class="string">"password"</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Result was \(result)"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"D'oh."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另外一种选择是 <code>try!</code> ，当你确信函数一定不会失败时你可以采用它。如果函数实际抛出了错误，你的代码将崩溃。</p>
<p>使用 <code>try!</code> 来重写前面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>! checkPassword (<span class="string">"sekrit"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"OK!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="失败构造器"><a href="#失败构造器" class="headerlink" title="失败构造器"></a>失败构造器</h1><p>当我们说到强制解包的时候，我用了下面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"5"</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)</span><br></pre></td></tr></tbody></table></figure>

<p>它将一个字符串转换成一个整数，但由于你可以传入任意字符串，你得到的实际上是一个可选型整数。</p>
<p>这里用到一种叫做 <em>失败构造器</em> 的东西：它是一种可能成功也可能失败的构造器。你在结构体或者类里面用 <code>init?()</code> 来实现失败构造器。如果某些东西出错，它将返回 <code>nil</code> 。因此这种构造器返回的是某种类型的可选型，你用之前需要解包。</p>
<p>举个例子，我们现在要求 <code>Person</code> 结构体必须通过一个 9 字符的 ID 字符串来构造。只要不是 9 个字符，都会返回 <code>nil</code> 。</p>
<p>Swift 代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>?(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">if</span> id.<span class="built_in">count</span> == <span class="number">9</span> {</span><br><span class="line">      <span class="keyword">self</span>.id = id</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Swift 知道每个变量的类型，但有的时候你知道的信息比 Swift 更多。举个例子，这里有三个类：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{ }</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>: <span class="title">Animal</span> </span>{ }</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Woof!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们创建几个 <code>Fish</code> 和几个 <code>Dog</code> ，然后把它们放进一个数组，像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = [<span class="type">Fish</span>(), <span class="type">Dog</span>(), <span class="type">Fish</span>(), <span class="type">Dog</span>()]</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 知道 <code>Fish</code> 和 <code>Dog</code> 都继承自 <code>Animal</code> 类，因此它通过类型推断将 <code>pets</code> 创建为一个 <code>Animal</code> 类型的数组。</p>
<p>如果我们想遍历 <code>pets</code> 数组，让所有的狗发出叫声，我们需要执行一次类型转换： Swift 将检查每个 pet 是否 <code>Dog</code> 对象，以便我们调用 <code>makeNoise ()</code> 方法。</p>
<p>这里用到了一个关键字 <code>as?</code> ，它将返回一个可选型：类型转换失败时返回 <code>nil</code> ，成功则返回转换后的类型。</p>
<p>Swift 代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pet <span class="keyword">in</span> pets {</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> dog = pet <span class="keyword">as</span>? <span class="type">Dog</span> {</span><br><span class="line">    dog.makeNoise ()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>可选型让我们可以用一种清晰无歧义的方式表示值缺失的情况。 </li>
<li>Swift 不允许不经解包就使用可选型，解包可以用 <code>if let</code> 或者 <code>guard let</code> 。 </li>
<li>你可以用感叹号强制解包可选型，不过如果解出来的是 <code>nil</code> ，你的代码将会崩溃。 </li>
<li>隐式解包可选型没有做常规可选型的安全性检查。 </li>
<li>你可以使用空合运算符解包一个可选型，以便可选型里没有值时提供一个默认值。 </li>
<li>可选链用于操作可选型，如果可选型的值是空的，后续代码将被忽略。 </li>
<li>你可以使用 <code>try?</code> 将一个可能抛出错误的函数转换成一个可选型的返回值，或者使用 <code>try!</code> 在抛出错误时崩溃。 </li>
<li>如果你需要在输入不合理时让构造过程失败，可以使用 <code>init?()</code> 来创建失败构造器。 </li>
<li>你可以使用类型转换将一个类型转换为另一个类型。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之九 | 协议</title>
    <url>/programming/swiftswift-protocol/</url>
    <content><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>协议是一种描述某个类型必须有某些属性和方法的方式。你告知 Swift 某个类型将使用某个协议，这个过程称为协议适配或者协议遵循。</p>
<p>举个例子，我们可以写一个函数接收 <code>id</code> 属性，但我们并不精确地关心用的是哪一种数据类型。让我们从 <code>Identifiable</code> 协议开始，这个协议要求所有遵循协议的类型必须有一个 <code>id</code> 字符串属性，并且这个字符串可读写。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> { <span class="keyword">get</span> <span class="keyword">set</span> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们无法创建协议的实例，因为协议只是一种描述，它本身并非一种类型。但是我们可以创建遵循它的结构体。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们还可以写一个 <code>displayID ()</code> 函数，它接收 <code>Identifiable</code> 对象：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displayID</span><span class="params">(thing: Identifiable)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"My ID is \(thing.id)"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h1><p>一个协议可以继承另一个协议，这个过程称为协议继承。跟类不一样的是，你可以同一时间继承多个协议。</p>
<p>接下来我们将定义三个协议： <code>Payable</code> 要求遵循它的类型实现 <code>calculateWages ()</code> 方法， <code>NeedsTraining</code> 要求遵循它的类型实现 <code>study ()</code> 方法，而 <code>HasVacation</code> 要求遵循它的类型实现 <code>takeVacation ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Payable</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">calculateWages</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NeedsTraining</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">study</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HasVacation</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">takeVacation</span><span class="params">(days: Int)</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们可以创建一个 <code>Employee</code> 协议，将上面的三个协议合并在一起。我们还不打算添加额外的东西，因此简单地写一对花括号就行：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Employee</span>: <span class="title">Payable</span>, <span class="title">NeedsTraining</span>, <span class="title">HasVacation</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们就可以创建遵循这个单一协议的类型，而不是分别遵循三个协议的类型。</p>
<hr>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>扩展使得你可以为已经存在的类型添加方法，实现它们设计时没有做的事情。</p>
<p>举个例子，我们可以为 <code>Int</code> 类型添加一个扩展方法 <code>squared ()</code> ，用来返回当前数的平方。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">squared</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> * <span class="keyword">self</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>尝试一下。创建一个整数，你会发现现在这个整数有了 <code>squared ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">8</span></span><br><span class="line">number.squared ()</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 不允许你通过扩展添加存储属性，但可以用扩展添加计算属性。举个例子，我们给整数添加一个 <code>isEven</code> 的计算属性，这个属性返回当前数值是否为偶数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> isEven: <span class="type">Bool</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h1><p>协议可以描述某个类型应当有某种方法，但并没有提供方法的代码。扩展实现有具体代码的方法，但一次只能作用于一个数据类型，你没办法同时给多个类型添加相同的代码。</p>
<p>协议扩展同时解决了这两个问题：它们就像常规扩展一样，差异只在于你并不是只扩展一个特定的类型，比如 <code>Int</code> ，你扩展是的一个协议，因而所有遵循这个协议的类型都会发生改变。</p>
<p>举个例子，下面有一个包含了一些名字的数组和一个同样包含了一些名字的集合：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pythons = [<span class="string">"Eric"</span>, <span class="string">"Graham"</span>, <span class="string">"John"</span>, <span class="string">"Michael"</span>, <span class="string">"Terry"</span>, <span class="string">"Terry"</span>]</span><br><span class="line"><span class="keyword">let</span> beatles = <span class="type">Set</span>([<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>])</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 的数组和集合都遵循一个叫 <code>Collection</code> 的协议，因此我们可以给 <code>Collection</code> 协议扩展一个叫 <code>summarize ()</code> 的方法，这个方法逐一打印 <code>Collection</code> 里的元素。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">summarize</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There are \(count) of us:"</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> <span class="keyword">self</span> {</span><br><span class="line">      <span class="built_in">print</span>(name)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Array</code> 和 <code>Set</code> 都将获得这个方法。让我们来尝试一下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">pythons.summarize ()</span><br><span class="line">beatles.summarize ()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h1><p>协议扩展可以为我们自己的协议方法提供默认实现。这使得类型遵循协议变得更加容易，并且允许我们 “面向协议编程”—— 这是一种利用协议和协议扩展来加工代码的方式。</p>
<p>首先，我们这里有一个叫 <code>Identifiable</code> 的协议，它要求所有遵循协议的类型都有一个叫 <code>id</code> 的属性和叫一个叫 <code>identify ()</code> 的方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> { <span class="keyword">get</span> <span class="keyword">set</span> }</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>虽然我们可以让每个遵循这个协议的类型书写它们自己的 <code>identify ()</code> 方法，但协议扩展允许我们可以提供一个默认实现：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"My ID is \(id)."</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在当我们再声明一个遵循 <code>Identifiable</code> 协议的类型时，它会自动获得 <code>identify ()</code> 方法的实现：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> paul = <span class="type">User</span>(id: <span class="string">"Paul"</span>)</span><br><span class="line">paul.identify ()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>协议描述了一个遵循它的类型应该拥有的属性和方法，但并不提供那些方法的实现。 </li>
<li>你可以基于协议创建协议，这一点跟类相似。 </li>
<li>扩展允许你为类型添加方法和计算属性。 </li>
<li>协议扩展是为协议添加方法和计算属性。 </li>
<li>面向协议编程是这样一种实践：它把程序架构按照一系列协议来设计，然后利用协议扩展来提供默认实现。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之八 | 类</title>
    <url>/programming/swiftswift-classes/</url>
    <content><![CDATA[<h1 id="创建你自己的类"><a href="#创建你自己的类" class="headerlink" title="创建你自己的类"></a>创建你自己的类</h1><p>Swift 的类也能让你创建带有属性和方法的新类型，这一点和结构体很相似，但是它们之间有五个显著的区别。下面让我一一为你说明。</p>
<p>类和结构体的第一个区别是类没有逐一成员构造器。这意味着只要你的类里有属性，你就必须自行创建构造器。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建类的实例跟创建结构体的实例方式一样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> poppy = <span class="type">Dog</span>(name: <span class="string">"Poppy"</span>, breed: <span class="string">"Poodle"</span>)</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><p>类和结构体的第二个区别是类可以继承已经存在的类。新的类继承了原始类所有的属性和方法。</p>
<p>这个过程被称为 <em>类继承</em> 或者 <em>子类化</em> ， 被继承的类称为 “父类” 或者 “超类”， 而新的类称为 “子类” 。</p>
<p>下面是一个 <code>Dog</code> 类：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在让我们基于 <code>Dog</code> 来创建一个新的类 <code>Poodle</code> 。默认情况下，它会继承 <code>Dog</code> 的所有属性以及构造器。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过，我们也可以为 <code>Poodle</code> 创建自己的构造器。我们知道这个类的 <code>breed</code> 属性总是 “Poodle”，因此我们可以创建一个只有 <code>name</code> 属性的构造器。并且，我们可以在 <code>Poodle</code> 的构造器里直接调用 <code>Dog</code> 的构造器，以便发生和 <code>Dog</code> 相同的构造过程。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, breed: <span class="string">"Poodle"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>出于安全性考虑， Swift 会要求你总是在子类里调用 <code>super.init ()</code> ，以防止类在构造时来自父类的一些重要工作被遗漏。</p>
<hr>
<h1 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h1><p>子类可以将父类的方法替换为自己的实现，这个过程被称为 <em>重写</em> 。 让我们给 <code>Dog</code> 类添加一个 <code>makeNoise ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Woof!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你创建一个 <code>Poodle</code> 类继承自 <code>Dog</code> ，它会继承 <code>makeNoise ()</code> 方法。 “Woof!”:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> poppy = <span class="type">Poodle</span>()</span><br><span class="line">poppy.makeNoise ()</span><br></pre></td></tr></tbody></table></figure>

<p>方法重写使得我们可以为 <code>Poodle</code> 类重新实现 <code>makeNoise ()</code> 。</p>
<p>Swift 要求我们在重写方法时用 <code>override func</code> 而不是 <code>func</code> ，这个限定防止你在自己不知情的情况下偶然重写方法。另外，试图重写一个父类中并不存在的方法，你会遭遇错误。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Yip!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这个修改， <code>poppy.makeNoise ()</code> 将打印出 “Yip!”，而不是 “Woof!”。</p>
<hr>
<h1 id="Final-类"><a href="#Final-类" class="headerlink" title="Final 类"></a>Final 类</h1><p>尽管类继承十分有用，并且苹果的平台在许多地方要求你大量使用它，有的时候你会希望阻止其他开发者基于你的类构建新的类。</p>
<p>Swift 给了我们 <code>final</code> 关键字用于实现这种意图：当你把一个类声明为 <code>final</code> 时，将没有类能够继承它。这意味着没有人能通过重写方法来改变这个类的行为。</p>
<p>只需要把 <code>final</code> 关键字放在类前面，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h1><p>类和结构体的第三个区别是它们被复制的方式。当你复制一个结构体时，原始对象和复制体是不一样的两个东西，改变其中一个并不会改变另外一个。当你复制一个 <em>类</em> 时，原始对象和复制体都指向相同的东西，所以改变其中一个也会改变另一个。</p>
<p>举个例子，有一个简单的 <code>Singer</code> 类，它有一个带有默认值的 <code>name</code> 属性：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当我们创建一个这个类的实例并且打印它的 <code>name</code> 时，我们会得到 “Taylor Swift” ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singer = <span class="type">Singer</span>()</span><br><span class="line"><span class="built_in">print</span>(singer.name)</span><br></pre></td></tr></tbody></table></figure>

<p>当我们基于第一个实例创建第二实例并且改变第二个实例的 <code>name</code> 时：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singerCopy = singer</span><br><span class="line">singerCopy.name = <span class="string">"Justin Bieber"</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于类的工作机制， <code>singer</code> 和 <code>singerCopy</code> 指向内存里的同一个对象。所以当我们打印 <code>singer</code> 的 <code>name</code> 时，我们也会得 “Justin Bieber”：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(singer.name)</span><br></pre></td></tr></tbody></table></figure>

<p>另一方面，假如 <code>Singer</code> 是一个结构体，那第二次我们还将得到 “Taylor Swift” ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h1><p>类和结构体的第四个区别是类有 <em>析构器</em> ，它是一个类的实例被销毁时执行的代码。</p>
<p>这里有一个 <code>Person</code> 类，它有一个 <code>name</code> 属性，一个简单的构造器，以及一个打印信息的 <code>printGreeting ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"John Doe"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name) is alive!"</span>)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">printGreeting</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, I'm \(name)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们将利用循环创建几个 <code>Person</code> 类的实例，每次循环流转的时候，一个新的 <code>Person</code> 都会被创建，之后被销毁：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> {</span><br><span class="line">  <span class="keyword">let</span> person = <span class="type">Person</span>()</span><br><span class="line">  person.printGreeting ()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>来到我们的析构器。每当 <code>Person</code> 实例被销毁时，它的析构器都会被执行。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(name) is no more!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h1><p>类和结构体的最后一个区别是它们处理常量的方式。如果你有一个常量结构体，它有一个变量属性，那么这个变量属性是无法修改的。</p>
<p>但是，如果它是一个常量类，也有一个变量属性，那么这个变量属性是可以被修改的。基于这个区别，类的方法在改变属性时，并不需要 <code>mutating</code> 关键字，而结构体则需要。</p>
<p>这个区别意味着你可以修改类中的任何变量属性，即便类的实例本身被声明为常量。以下代码完全合法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> taylor = <span class="type">Singer</span>()</span><br><span class="line">taylor.name = <span class="string">"Ed Sheeran"</span></span><br><span class="line"><span class="built_in">print</span>(taylor.name)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你不想属性被修改，那么你必须直接将属性声明为常量。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>类和结构体很相似，它们都允许你创建自己的属性和方法。 </li>
<li>一个类可以继承自另一个类，它会获得父类的所有属性和方法。谈到类层次结构的时候，我们经常说一个类基于另一个类，也就是一个类继承自另一个类。 </li>
<li>你可以用 <code>final</code> 关键字来标记一个类，这样可以阻止它被继承。 </li>
<li>方法重写使得一个子类可以用全新的实现来替代父类中的实现。 </li>
<li>当两个变量指向同一个实例时，它们指代的对象在内存中占用同一块区域，改变其中一个也会改变另一个。 </li>
<li>类可以有析构器，它们是类的实例被销毁时执行的代码。 </li>
<li>类不像结构体那样受常量的强制约束。如果类的一个属性被声明为变量，那么无论类的实例是否以变量的方式创建，这个属性都可以被修改。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之七 | 结构体</title>
    <url>/programming/swiftswift-structs/</url>
    <content><![CDATA[<h1 id="创建你自己的结构体"><a href="#创建你自己的结构体" class="headerlink" title="创建你自己的结构体"></a>创建你自己的结构体</h1><p>Swift 允许你用两种方式创建自己的类型。其中一种最常见的叫做结构体，即 <code>struct</code> 。Struct 可以拥有自己的变量、常量以及函数，而你可以在任意时候创建和使用它们。</p>
<p>让我们以一个简单的例子开始：创建一个 <code>Sport</code> 结构体，它有一个叫 <code>name</code> 的字符串变量。在结构体中，这种变量被称为 <em>属性</em> 。因此，这是一个拥有一个属性的结构体。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>类型定义完成，现在让我们来创建和使用它的实例：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tennis = <span class="type">Sport</span>(name: <span class="string">"Tennis"</span>)</span><br><span class="line"><span class="built_in">print</span>(tennis.name)</span><br></pre></td></tr></tbody></table></figure>

<p><code>name</code> 和 <code>tennis</code> 都是变量，因而我们可以像常规变量那样修改它们：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">tennis.name = <span class="string">"Lawn tennis"</span></span><br></pre></td></tr></tbody></table></figure>

<p>属性可以像常规变量那样拥有默认值，并且依赖 Swift 的类型推断。</p>
<a id="more"></a>

<hr>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>我们刚刚创建了 <code>Sport</code> 结构体：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它有一个叫 <em>name</em> 的属性，存储 <code>String</code> 类型。这种属性叫做 <em>存储</em> 属性，因为 Swift 还有另外一种属性，它叫 <em>计算</em> 属性。这是一种通过运行代码来获得值的属性。</p>
<p>让我们为 <code>Sport</code> 结构体再增加一个存储属性，然后是一个计算属性。代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> isOlympicSport: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> olympicStatus: <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">if</span> isOlympicSport {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"\(name) 是一项奥林匹克运动。"</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"\(name) 不是一项奥林匹克运动。"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如你所见， <code>olympicStatus</code> 看起来像一个常规的 <code>String</code> ，但它其实是依据其他的属性返回不同的值。</p>
<p>让我们来创建一个 <code>Sport</code> 实例：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chessBoxing = <span class="type">Sport</span>(name: <span class="string">"Chessboxing"</span>, isOlympicSport: <span class="literal">false</span>)</span><br><span class="line"><span class="built_in">print</span>(chessBoxing.olympicStatus)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h1><p>属性观察者允许我们可以在属性变化前后运行代码。让我们来写一个名叫 <code>Progress</code> 的结构体，这个结构体追踪一个任务以及它完成的百分比：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Progress</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> task: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> amount: <span class="type">Int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，创建这个结构体的实例，随着时间的推移调整它的进度：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> progress = <span class="type">Progress</span>(task: <span class="string">"加载数据"</span>, amount: <span class="number">0</span>)</span><br><span class="line">progress.amount = <span class="number">30</span></span><br><span class="line">progress.amount = <span class="number">80</span></span><br><span class="line">progress.amount = <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们期望 Swift 在每一次 <code>amount</code> 改变的时候都打印信息，这里可以用到一个叫 <code>didSet</code> 属性观察者。它可以用于每一次 <code>amount</code> 改变之后运行代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Progress</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> task: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> amount: <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">didSet</span> {</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"\(task) 已完成 \(amount)%。"</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你还可以用到叫 <code>willSet</code> 的属性观察者。它是在属性改变之前作用，相对来说更不常用。</p>
<hr>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Struct 的内部可以拥有函数，它们在必要时可以使用结构体的属性。这种函数被称为 <em>方法</em> ，关键字也是 <code>func</code> 。</p>
<p>现在我们通过一个叫 <code>City</code> 的结构体来演示。它有一个 <code>population</code> 属性，用于存储城市里的人口。此外，它还有一个 <code>collectTaxes ()</code> 方法，这个方法返回人口数乘以 1000。 由于方法是属于 <code>City</code> 的，它可以读取当前城市的 <code>population</code> 属性。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">City</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> population: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">collectTaxes</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> population * <span class="number">1000</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>基于结构体调用方法的代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xiamen = <span class="type">City</span>(population: <span class="number">4_110_000</span>)</span><br><span class="line">xiamen.collectTaxes ()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="可变方法"><a href="#可变方法" class="headerlink" title="可变方法"></a>可变方法</h1><p>如果一个结构体拥有一个变量属性，但是这个结构体的实例是以常量的方式创建的，那么在实例中，这个变量属性是不能修改的。这是因为结构体本身已经是常量了，所以它的所有属性也是常量。</p>
<p>这里面有一个问题， Swift 无从得知你将以常量还是变量的方式使用结构体。所以安全起见， Swift 的默认策略是：不允许你在方法里修改属性，除非你显式地要求这一点。</p>
<p>当你想要改变属性值时，需要在方法前使用 <code>mutating</code> 关键字，就像这样：</p>
 <figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAnonymous</span><span class="params">()</span></span> {</span><br><span class="line">    name = <span class="string">"Anonymous"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于这个方法改变了属性值，所以 Swift 只会允许这个方法在变量型的 <code>Person</code> 实例上调用。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>(name: <span class="string">"Ed"</span>)</span><br><span class="line">person.makeAnonymous ()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="String-的属性和方法"><a href="#String-的属性和方法" class="headerlink" title="String 的属性和方法"></a>String 的属性和方法</h1><p>目前为止我们已经大量地使用了字符串。你发现了吗？其实 <code>String</code> 类型是一个结构体类型。它有许多属性和方法，用于查询和维护字符串本身。</p>
<p>首先，我们创建一个测试字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"Do or do not, there is no try."</span></span><br></pre></td></tr></tbody></table></figure>

<p>你可以用 <code>count</code> 属性来读取这个字符串里的字符数量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.<span class="built_in">count</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>字符串有一个 <code>hasPrefix ()</code> 方法，可以用来检测字符串是否以特定字符开头：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.hasPrefix (<span class="string">"Do"</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>你还可以用 <code>uppercased ()</code> 方法把一个字符串转换成全大写的版本：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.uppercased ())</span><br></pre></td></tr></tbody></table></figure>

<p>你甚至可以让 Swift 将字符串中的字母重新排序成一个数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.sorted ())</span><br></pre></td></tr></tbody></table></figure>

<p>String 类型有大量的属性和方法。 你可以利用 Xcode 的代码补全，用 <code>string.</code> 调取这些选项看一看它们都有些什么能力。</p>
<hr>
<h1 id="数组的属性和方法"><a href="#数组的属性和方法" class="headerlink" title="数组的属性和方法"></a>数组的属性和方法</h1><p>数组同样也是结构体，这意味着它们也有可以用来查询和操作数组的属性和方法。</p>
<p>从一个简单的数组开始：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toys = [<span class="string">"Woody"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>你可以用 <code>count</code> 属性来读取数组的元素个数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(toys.<span class="built_in">count</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你需要增加一个元素，可以使用 <code>append ()</code> 方法，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">toys.append (<span class="string">"Buzz"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>你可以用 <code>firstIndex ()</code> 方法来定位元素在数组里的位置，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">toys.firstIndex (of: <span class="string">"Buzz"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码会返回 1 ，因为数组位置从 0 开始计数。</p>
<p>跟字符串一样，你可以让 Swift 以字母表顺序给数组的元素重新排序。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(toys.sorted ())</span><br></pre></td></tr></tbody></table></figure>

<p>最后，如果你想要移除数组里的一个元素，可以使用 <code>remove ()</code> 方法，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">toys.remove (at: <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>数组类型也有大量的属性和方法。 你可以利用 Xcode 的代码补全，用 <code>toys.</code> 调取这些选项看一看它们都有些什么能力。</p>
<hr>
<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p>构造器是一种可以用来支持不同方式创建结构体的特殊方法。所有的结构体都有一个默认的构造器，这个构造器被称为 <em>逐一成员构造器</em> ，它要求你为结构体的每一个属性都提供一个值。</p>
<p>让我们来声明一个 <code>User</code> 结构体，它有一个属性：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当我们创建这个结构体的实例时，我们需要提供一个 <code>username</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="type">User</span>(username: <span class="string">"Paul"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>当然，我们也可以创建自己的构造器用以替换默认的。举个例子，我们可能希望所有的新用户默认都叫 “Anonymous” ，并且会打印一条信息，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    username = <span class="string">"Anonymous"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"创建新用户！"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你并不需要在构造器前面写 <code>func</code> 关键字，但你必须确保构造器结束前所有的属性都被赋值。</p>
<p>现在让我们来用上这个没有参数的构造器，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="type">User</span>()</span><br><span class="line">user.username = <span class="string">"Paul"</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="引用当前实例"><a href="#引用当前实例" class="headerlink" title="引用当前实例"></a>引用当前实例</h1><p>方法的内部，有一个特殊的常量叫 <code>self</code> ，它指向当前正在使用的结构体实例。当你在构造器中遇到参数名和属性名相同的情况时，这个 <code>self</code> 会很有用。</p>
<p>举个例子，如果你声明一个 <code>Person</code> 的结构体，它有一个 <code>name</code> 属性，并且你尝试写一个接收名为 <code>name</code> 参数的构造器，那么 <code>self</code> 可以帮助你区分属性和参数。 <code>self.name</code> 指代属性，而 <code>name</code> 指代参数。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name) was born!"</span>)</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="懒加载属性"><a href="#懒加载属性" class="headerlink" title="懒加载属性"></a>懒加载属性</h1><p>作为一种性能优化手段， Swift 允许你在用到的时候才真正创建属性。举个例子，这里有一个叫 <code>FamilyTree</code> 的结构体，它做的工作很容易描述。但理论上为一个人创建族谱可能会是一个很耗时的过程：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FamilyTree</span> </span>{</span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"创建族谱！"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以在 <code>Person</code> 结构体内将 <code>FamilyTree</code> 作为一个属性来使用，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> familyTree = <span class="type">FamilyTree</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ed = <span class="type">Person</span>(name: <span class="string">"Ed"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>假如某些情况我们并不需要用到某个人的族谱信息呢？我们可以在 <code>familyTree</code> 属性前添加 <code>lazy</code> 关键字， Swift 将会在 <code>familyTree</code> 属性第一次被访问的时候才执行创建代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> familyTree = <span class="type">FamilyTree</span>()</span><br></pre></td></tr></tbody></table></figure>

<p>因此，如果你想要看到 “创建族谱！” 这条信息被打印，你至少需要访问 <code>familyTree</code> 属性一次：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">ed.familyTree</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h1><p>目前为止我们认识的所有属性和方法都是属于独立的结构体实例，这意味着假如我们有一个叫 <code>Student</code> 的结构体，我们可以创建几个 student 实例，每个实例都有各自的属性和方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ed = <span class="type">Student</span>(name: <span class="string">"Ed"</span>)</span><br><span class="line"><span class="keyword">let</span> taylor = <span class="type">Student</span>(name: <span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>你可以要求 Swift 在不同的结构体实例之间共享属性和方法，这些属性和方法被称为静态属性和静态方法，实现的方式是添加 <em>static</em> 声明。</p>
<p>现在，让我们给 <code>Student</code> 结构体添加一个静态属性，用以存放班级学生的总数。每当我们创建一个新的 student 实例时，我们将这个属性的数值加 1 ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> classSize = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="type">Student</span>.classSize += <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>classSize</code> 属性是属于结构体本身而非结构体的实例，因此我们需要用 <code>Student.classSize</code> 来访问它：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">Student</span>.classSize)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>访问控制使得我们可以限制哪些代码能够访问属性和方法。这个机制在你想要保护属性免于被直接读取的时候很有用，举个例子：</p>
<p>我们仍然创建一个 <code>Person</code> 结构体，它有一个 <code>id</code> 属性，用来存放社保 ID：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ed = <span class="type">Person</span>(id: <span class="string">"12345"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>一旦 person 实例被创建，我们希望它的 <code>id</code> 是私有的。私有的意思是你不能从结构体外部读取它，像 <code>ed.id</code> 这样的代码会变得不合法。</p>
<p>要做到这一点，你需要用到 <code>private</code> 关键字，像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这么写之后，只有 <code>Person</code> 内部的方法才能读取 <code>id</code> 属性。举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我的社保 ID 是 \(id)"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还有一个常见的选项是 <code>public</code> ，它使得所有的其他代码都能够访问到目标属性或者方法。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们一起来总结一下。</p>
<ol>
<li>你可以创建自己的结构体类型，它们有自己的属性和方法。 </li>
<li>你学习了存储属性，以及每一次通过临时计算得到值的计算属性。 </li>
<li>当你希望在方法中修改属性时，需要把方法标记成 <code>mutating</code> 。 </li>
<li>构造器是创建结构体时的特殊方法。默认情况下，你会得到一个逐一成员构造器。不过，如果你想要自行实现构造器的话，需要确保所有的属性都被赋值。 </li>
<li>你可以在方法中用 <code>self</code> 常量来引用当前正在使用的结构体实例。 </li>
<li><code>lazy</code> 关键字告诉 Swift 你希望属性在第一次访问时才被创建。 </li>
<li>可以利用 <code>static</code> 关键字在结构体的所有实例间共享属性和方法。 </li>
<li>访问控制使得我们可以限制哪些代码能够访问属性和方法。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之六 | 闭包</title>
    <url>/programming/swiftswift-closures/</url>
    <content><![CDATA[<h1 id="创建基本的闭包"><a href="#创建基本的闭包" class="headerlink" title="创建基本的闭包"></a>创建基本的闭包</h1><p>Swift 允许我们像字符串和整数一样使用函数。具体来说，你可以创建一个函数然后把它赋给一个变量，利用那个变量来调用函数。你甚至可以把函数作为参数传给另一个函数。</p>
<p>函数的这种用法被称为 <em>闭包</em> 。虽然工作机制差不多，写法上是有一些小差异的。</p>
<p>还是以打印信息为例：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我要去开车"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码实际上创建了一个匿名的函数，并将这个函数赋给了 <code>driving</code> 。之后你就可以把 <code>driving ()</code> 当作一个常规的函数来用，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">driving ()</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="在闭包中接收参数"><a href="#在闭包中接收参数" class="headerlink" title="在闭包中接收参数"></a>在闭包中接收参数</h1><p>当你创建闭包的时候，它们并没有名字，也没有提供书写参数的地方。但这并不意味着它们不能接收参数，只不过它们接收参数的方式稍有不同：这些参数是被写在花括号里面的。</p>
<p>为了让一个闭包接收参数，你需要在花括号之后把这些参数列出来，然后跟上一个 <code>in</code> 关键字。这样就告诉 Swift ，闭包的主体是从哪里开始的。</p>
<p>举个例子，我们来创建一个闭包，接收一个叫 <code>place</code> 的字符串作为唯一的参数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我要开车去 \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>函数和闭包的一个区别是运行闭包的时候你不会用到参数标签。因此，调用 <code>driving ()</code> 的时候，我们是这样写的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">driving (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="从闭包中返回值"><a href="#从闭包中返回值" class="headerlink" title="从闭包中返回值"></a>从闭包中返回值</h1><p>闭包也能返回值，写法和闭包的参数类似：写在闭包内部， <code>in</code> 关键字前面。</p>
<p>还是以 <code>driving ()</code> 闭包为例， 让它返回一个字符串。原来的函数是这样的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我要开车去  \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>改成返回字符串而不是直接打印那个字符串，需要 <code>in</code> 之前添加 <code>-&gt; String</code> ，然后像常规函数那样用到 <code>return</code> 关键字:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drivingWithReturn = { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们运行这个闭包并且打印出它的返回值：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = drivingWithReturn (<span class="string">"北京"</span>)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="闭包作为参数"><a href="#闭包作为参数" class="headerlink" title="闭包作为参数"></a>闭包作为参数</h1><p>既然闭包可以像字符串和整数一样使用，你就可以将它们传入函数。闭包作为参数的语法乍一看一看挺伤脑筋的，让我们慢慢来。</p>
<p>首先，还是基本的 <code>driving ()</code> 闭包。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们打算把这个闭包传入一个函数，以便函数内部可以运行这个闭包。我们需要把函数的参数类型指定为 <code>() -&gt; Void</code> 。它的意思是 “不接收参数，并且返回 <code>Void</code> ”。在 Swift 中， <code>Void</code> 是什么也没有的意思。</p>
<p>好了，让我们来写一个 <code>travel ()</code> 函数，接收不同类型的 traveling 动作， 并且在动作前后分别打印信息：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  action ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在可以用上 <code>driving</code> 闭包了，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel (action: driving)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="拖尾闭包语法"><a href="#拖尾闭包语法" class="headerlink" title="拖尾闭包语法"></a>拖尾闭包语法</h1><p>如果一个函数的最后一个参数是闭包， Swift 允许你采用一种被称为 <em>“拖尾闭包语法”</em> 的方式来调用这个闭包。你可以把闭包传入函数之后的花括号里，而不必像传入参数那样。</p>
<p>又用到我们的 <code>travel ()</code> 函数了。它接收一个 <code>action</code> 闭包。闭包在两个 <code>print ()</code> 调用之间执行:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  action ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于函数的最后一个参数是闭包，我们可以用拖尾闭包语法来调用 <code>travel ()</code> 函数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel () {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际上，由于函数没有别的参数了，我们还可以将圆括号完全移除：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>拖尾闭包语法在 Swift 中非常常见，所以你要适应它。</p>
<hr>
<h1 id="使用接收参数的闭包作为函数的参数"><a href="#使用接收参数的闭包作为函数的参数" class="headerlink" title="使用接收参数的闭包作为函数的参数"></a>使用接收参数的闭包作为函数的参数</h1><p>接下来要说到的闭包用法会有点复杂：当你把闭包作为函数参数时，闭包本身也接收参数。</p>
<p>前面我们用 <code>() -&gt; Void</code> 来表示 “不接收参数，并且什么也不返回”，但实际上你可以在 <code>()</code> 里填上你任何想要闭包接收的参数类型。</p>
<p>再次用到 <code>travel ()</code> 函数。函数只接收一个闭包作为参数，但这次闭包会接收一个字符串参数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  action (<span class="string">"北京"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，当我们采用拖尾闭包语法调用 <code>travel ()</code> 时，我们的闭包代码会要求接收一个字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备开车去 \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="使用有返回值的闭包作为函数的参数"><a href="#使用有返回值的闭包作为函数的参数" class="headerlink" title="使用有返回值的闭包作为函数的参数"></a>使用有返回值的闭包作为函数的参数</h1><p>我们之前用 <code>() -&gt; Void</code> 来表示 “不接收参数，并且什么也不返回”。你可以把 <code>Void</code> 替换成任意的类型从而让闭包可以返回值。</p>
<p>还是 <code>travel ()</code> 函数，这次闭包会返回一个字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  <span class="keyword">let</span> description = action (<span class="string">"北京"</span>)</span><br><span class="line">  <span class="built_in">print</span>(description)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>仍然用拖尾闭包语法来调用 <code>travel ()</code> ，闭包要求接收一个字符串并且返回一个字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="速记参数名"><a href="#速记参数名" class="headerlink" title="速记参数名"></a>速记参数名</h1><p>前面我们了构建 <code>travel ()</code> 函数。它接收一个闭包作为参数，这个闭包本身接收一个参数并且返回一个字符串，它在两个 <code>print ()</code> 调用之间运行。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  <span class="keyword">let</span> description = action (<span class="string">"北京"</span>)</span><br><span class="line">  <span class="built_in">print</span>(description)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以像这样调用 <code>travel ()</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过， Swift 知道提供给闭包的参数必须是一个字符串，所以调用的代码可以简写成这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { place -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Swfit 也知道闭包必须返回一个字符串，于是进一步简写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { place <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于这里的闭包只有一行代码，这行代码肯定是返回值的那行代码，因此 Swift 允许我们把 <code>return</code> 关键字也移除：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { place <span class="keyword">in</span></span><br><span class="line">  <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后， Swift 还提供一种速记语法，让你可以把代码变得更短。我们可以让 Swift 为闭包的参数自动提供一个名字，而不必自行写下 <code>place in</code> 。这些自动生成的名字以 $ 开头，然后跟着一个从 0 开始的整数，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="string">"我要开车去 \($0)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="有多个参数的闭包"><a href="#有多个参数的闭包" class="headerlink" title="有多个参数的闭包"></a>有多个参数的闭包</h1><p>让我们把闭包这个概念一次讲透吧。接下来举一个接收两个参数的闭包的例子。</p>
<p>将 <code>travel ()</code> 函数改造一下，不仅接收旅行目的地，也接收速度。闭包的类型会变成 <code>(String, Int) -&gt; String</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String, Int)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。)</span></span><br><span class="line"><span class="string">  let description = action ("</span> 北京 &lt; span class="string"&gt;", 60)</span><br><span class="line"><span class="string">  print (description)</span></span><br><span class="line"><span class="string">  print ("</span> 我到达目的地了。<span class="string">")</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>再一次用速记闭包参数名来调用函数。由于这次闭包有两个参数了，于是自动参数名分别是 <code>$0</code> 和 <code>$1</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="string">"我要开车去 \($0)，时速 \($1) 公里每小时。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有些人可能不喜欢用速记参数名，因为它们的语义不是很清晰。你可以根据自己的喜好来决定是否采用它们。不过了解一下这个语法还是必要的，这样读到别人的代码时就不会感到困惑。</p>
<hr>
<h1 id="从函数中返回闭包"><a href="#从函数中返回闭包" class="headerlink" title="从函数中返回闭包"></a>从函数中返回闭包</h1><p>就如同你可以把闭包传入函数那样，你也可以从函数中返回闭包。</p>
<p>返回闭包的语法看起来有点绕，因为用了两次 <code>-&gt;</code> ：第一次用于指定函数的返回值，第二次用于指定闭包的返回值。</p>
<p>又又又要把 <code>travel ()</code> 函数拉出来了。这次它不接收参数，但返回一个闭包。这个返回的闭包在用的时候必须传入一个字符串，但闭包本身没有返回值。</p>
<p>Swift 代码长这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"我要动身去 \($0)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来我们通过调用 <code>travel ()</code> 拿到闭包，然后作为函数来调用：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = travel ()</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>留意下面的代码，它是直接调用 <code>travel ()</code> 的返回值。这个写法虽然在语法上完全没问题，但是可读性较差，建议尽量不要这样写。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result2 = travel ()(<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h1><p>如果你想要使用闭包之外的对象， Swift 会为你 “捕捉” 它们，并把它们和闭包一同存储，以便外部作用域已经失效的情况下闭包内部还可以使用它们。</p>
<p>最后一次用到 <code>travel ()</code> 函数，它返回一个闭包，这个闭包接收字符串作为唯一的参数并且什么也不返回：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"我准备去 \($0)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用 <code>travel ()</code> 拿到闭包，然后自由使用：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = travel ()</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>闭包捕获变量可以发生在什么情况下呢？举个例子，当 <code>travel ()</code> 函数内创建了一个变量，这个变量需要在闭包里面用到，那么这个变量就会被闭包捕获。比如，我们想知道闭包被调用的次数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第 \(counter) 次，我将前往 \($0)"</span>)</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>尽管 <code>counter</code> 变量是在 <code>travel ()</code> 里被创建的，它被闭包捕获，因而会在闭包内部存续。</p>
<p>当我们多次调用 <code>result (" 北京 ")</code> ，计数器会持续增加：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">result (<span class="string">"北京"</span>)</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>你可以把闭包赋值给变量，之后再用变量名来调用闭包。 </li>
<li>闭包和常规函数一样可以接收参数和返回值。 </li>
<li>你可以将闭包作为参数传入函数，并且这些闭包也可以有自己的参数和返回值。 </li>
<li>如果函数的最后一个参数是闭包，你可以使用拖尾闭包语法。 </li>
<li>Swift 为拖尾闭包语法自动生成了 <code>$0</code> 和 <code>$1</code> 这样的速记闭包参数名，但不是所有人都习惯这种速记法。 </li>
<li>如果你在闭包中使用了外部变量，这些变量将被闭包 “捕捉” 以便后续引用。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之五 | 函数</title>
    <url>/programming/swiftswift-functions/</url>
    <content><![CDATA[<h1 id="书写函数"><a href="#书写函数" class="headerlink" title="书写函数"></a>书写函数</h1><p>函数让我们可以重用代码。这句话的具体含义是，我们写一次函数，在多个地方使用。书写重复的代码，通常来说不是一种好的实践，而函数帮助我们避免重复代码。</p>
<p>用一个简单的例子开始吧。假设我们要为 app 的用户提供帮助信息，这个动作在 app 里的多个地方都会用到。因此，把打印帮助信息这个逻辑写成一个函数就是个好主意。</p>
<p>Swift 的函数以 <code>func</code> 关键字开始，然后跟着函数名，然后是一对圆括号，最后是一对花括号。当函数被运行时，花括号里的代码会被执行。</p>
<p>一个 <code>printHelp ()</code> 函数长这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHelp</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">"""</span></span><br><span class="line"><span class="string">  欢迎来到我的 App!</span></span><br><span class="line"><span class="string">  在一个图片的目录下运行这个 App，</span></span><br><span class="line"><span class="string">  它会把所有的图片缩放成缩略图。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">  <span class="built_in">print</span>(message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们用 <code>printHelp ()</code> 来运行它。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">printHelp ()</span><br></pre></td></tr></tbody></table></figure>

<p>运行一个函数又被称为 * 调用 * 一个函数。</p>
<a id="more"></a>

<hr>
<h1 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h1><p>函数在你调用它们的时候可以被定制，这使得它们的能力更加强大。 Swift 允许你发送值给函数，这些值可以在函数内部使用，从而改变函数的行为。其实之前我们已经见过函数的这个特性：我们把整数和字符串传递给 <code>print ()</code> 函数，就像下面这样。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>这些被传入函数的值被称为 * 参数 * 。</p>
<p>为了使你的函数可以接收参数，你需要给参数起个名字，然后加一个冒号，最后再告诉 Swift 这个参数的数据类型。这些都是放在函数名之后的圆括号里面。</p>
<p>举个例子，我们可以写一个函数，打印任意数字的平方。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(number: Int)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(number * number)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码告知 Swift 我们期望接收一个 <code>Int</code> 类型，并且名字叫 <code>number</code> 。这个名字不仅用于函数内部指代参数，也用于运行函数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">square (number: <span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>函数不仅可以接收数据（通过参数），也可以返回数据。为了返回数据，在函数的参数列表之后写一个短横线加一个向右的尖括号，然后提供一个数据类型。这个语法告诉 Swift 函数将返回一个指定类型的数据。</p>
<p>在函数内，我们用 <code>return</code> 关键字来返回数据。这个时候函数会立即结束，并返回数据，函数内的其他代码都不再执行。</p>
<p>我们可以重写 <code>square ()</code> 函数，返回平方数而不是直接打印它：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">  <span class="keyword">return</span> number * number</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们可以通过运行这个函数，拿到返回值并且打印出来：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = square (number: <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你需要返回多个值，可以使用元组作为返回值的类型。</p>
<hr>
<h1 id="参数标签"><a href="#参数标签" class="headerlink" title="参数标签"></a>参数标签</h1><p>前面的 <code>square ()</code> 函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">  <span class="keyword">return</span> number * number</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>参数名是 <code>number</code> ，我们通过在函数里使用 <code>number</code> 来引用这个参数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = square (number: <span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 允许我们给参数起两个名字：一个供调用时使用，一个在函数内部使用。书写的时候把两个名字都写上，用空格分隔。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(to name: String)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(name)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的参数名是 <code>to name</code> ，在外部调用时用 <code>to</code> ，而内部指代时用 <code>name</code> 。这种方式让参数在函数内部有一个合理的名称，同时在调用时阅读起来也是自然的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">sayHello (to: <span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="省略参数标签"><a href="#省略参数标签" class="headerlink" title="省略参数标签"></a>省略参数标签</h1><p>你可能已经注意到我们在使用 <code>print ()</code> 函数时并没有传入任何参数标签。我们会写作 <code>print ("Hello")</code> ，而不是 <code>print (message:"Hello")</code> 。</p>
<p>通过使用下划线 <code>_</code> 作为外部参数标签，你可以在自己的函数里实现一样的效果，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> person: String)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(person)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样写的话，调用 <code>greet ()</code> 函数时，你就不必传入参数标签了：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">greet (<span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>为了使代码阅读起来更自然，通常我们是需要给参数起一个外部标签名的。举个例子，如果我说设置闹钟 5（ <code>setAlarm (5)</code> ）不写标签的话很难理解这代表什么意思：是要设置一个 5 点钟生效的闹钟呢？还是要激活第 5 个预先设好的闹钟？而像打印这件事，在打印后面直接跟上要打印的内容，本身就是一个清晰的表达，所以可以省略掉参数标签。</p>
<hr>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p><code>print ()</code> 函数打印文本到屏幕，并且不论你传什么内容给它，它都会在最后添加一个换行。所以多次调用 <code>print ()</code> 的话，那些文本是不会显示在同一行的。</p>
<p>但是你可以改变 <code>print ()</code> 函数的这个行为：你可以用其他符号，例如空格来取代换行。不过多数情况下，大家都想要换行，因此 <code>print ()</code> 有一个叫 <code>terminator</code> 的参数，它的默认值是换行符。</p>
<p>通过在参数后面加上一个 <code>=</code> 然后写上一个值，你可以为你自己的函数提供默认参数。 举个例子，我们写一个 <code>greet ()</code> 函数，默认友好问候：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> person: String, nicely: Bool = <span class="literal">true</span>)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> nicely == <span class="literal">true</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"你好， \(person)!"</span>)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"不是吧，又是 \(person) 你小子。"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在 <code>greet ()</code> 函数就有两种调用方式了：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">greet (<span class="string">"Taylor"</span>)</span><br><span class="line">greet (<span class="string">"Taylor"</span>, nicely: <span class="literal">false</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h1><p>有一些函数是 <em>可变</em> 的，可变是指函数可以接收任意多个同类型的参数。例如， <code>print ()</code> 函数实际上就是可变的：如果你传入多个参数，它们会被以空格相连打印在同一行。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Haters"</span>, <span class="string">"gonna"</span>, <span class="string">"hate"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>你可以通过在参数类型之后添加 <code>...</code> ，将一个参数声明成可变参数。因此，一个 <code>Int</code> 参数代表一个整数，而 <code>Int...</code> 则代表 0 个或者更多整数，理论上不限个数。</p>
<p>在函数内部， Swift 会将这些整数转成一个整数的数组，以方便你遍历它们。</p>
<p>让我们用 <code>square ()</code> 函数来尝试一下吧：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(numbers: Int...)</span></span> {</span><br><span class="line">  <span class="keyword">for</span> number <span class="keyword">in</span> numbers {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(number) 的平方等于 \(number * number)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们可以用逗号分隔一组数字，把它们全部传入 <code>square ()</code> 函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">square (numbers: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="书写会抛出错误的函数"><a href="#书写会抛出错误的函数" class="headerlink" title="书写会抛出错误的函数"></a>书写会抛出错误的函数</h1><p>有的时候函数会运行失败，因为不合理的输入或者函数内部的错误。 Swift 允许我们从函数中抛出错误。实现的方法是在返回值前写一个 <code>throws</code> ，然后在函数出错时使用 <code>throw</code> 关键字抛出错误。</p>
<p>首先我们需要定义一个 <code>enum</code> ，用于描述我们可能抛出的错误。这些错误必须基于 Swift 已经存在的 <code>Error</code> 类型。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PasswordError</span>: <span class="title">Error</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> obvious</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们来实现一个函数 <code>checkPassword ()</code> ，这个函数检测传入的密码是否合理，当密码过于简单时，我们抛出一个错误提醒用户。具体来说，当密码被设置成 “password” 时，执行 <code>throw PasswordError.obvious</code> 。</p>
<p>Swift 代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword</span><span class="params">(<span class="number">_</span> password: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> {</span><br><span class="line">  <span class="keyword">if</span> password == <span class="string">"password"</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">PasswordError</span>.obvious</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="运行可能会抛出错误的函数"><a href="#运行可能会抛出错误的函数" class="headerlink" title="运行可能会抛出错误的函数"></a>运行可能会抛出错误的函数</h1><p>Swift 并不期望你在程序运行时遭遇错误，因此它不会让你直接运行可能抛出错误的函数。</p>
<p>你需要用到三个关键字来运行会抛出错误的函数： <code>do</code> 开启一段可能会遭遇问题的代码， <code>try</code> 放在每一个可能抛出错误的函数前面，最后的 <code>catch</code> 让你可以优雅地处理错误。</p>
<p>如果 <code>do</code> 语句块里有任何错误抛出，代码执行会直接跳到 <code>catch</code> 语句块。让我们用一个可以触发 <code>checkPassword ()</code> 抛出错误的密码来调用这个函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  <span class="keyword">try</span> checkPassword (<span class="string">"password"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"这个密码很棒！"</span>)</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"你不能用这个密码。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当这段代码运行时，“你不能用这个密码。” 会被打印。但” 这个密码很棒！“则不会被打印。这个是由于错误的抛出导致那个打印无法被运行到。</p>
<hr>
<h1 id="inout-参数"><a href="#inout-参数" class="headerlink" title="inout 参数"></a>inout 参数</h1><p>所有传入 Swift 函数的参数默认都是 <em>常量</em> ，所以你无法更改它们。假如你就是想要在函数内改变这些参数呢？可以用 <code>inout</code> 修饰它们，所有在函数内对它们做出的改变都会影响到它们在函数外的原始值。</p>
<p>举个例子，如果你想要让一个数翻倍。比如，直接改变那个数，而不是返回一个新的数。你可以像下面这样写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doubleInPlace</span><span class="params">(number: <span class="keyword">inout</span> Int)</span></span> {</span><br><span class="line">  number *= <span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了使用这个可以修改参数的函数，首先要求传入的参数本身不能是常量，因为如果参数本来是常量，即使用 <code>inout</code> 修饰，也无法被修改。其次，在传入函数时，还要用一个 <code>&amp;</code> 符号，放在参数名前面。它是参数以 <code>inout</code> 方式使用的显式标识。</p>
<p>在代码中，是这么书写的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myNum = <span class="number">10</span> </span><br><span class="line">doubleInPlace (number: &amp;myNum)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>函数通过避免重复来帮助我们复用代码。 </li>
<li>函数可以接收参数，你需要告诉 Swift 每个参数的类型。 </li>
<li>函数可以返回值，同样需要指定返回值的类型。如果你想返回多个值，可以使用元组。 </li>
<li>你可以给参数取不同的外部名和内部名，并且可以完全省略外部名。 </li>
<li>参数可以有默认值，以便你用更少的代码指定常见的特定值。 </li>
<li>可变参数可以接收零到多个特定的参数， Swift 会把它们转成数组。 </li>
<li>函数可以抛出错误，但是调用这种函数的时候需要用 <code>try</code> 关键字并且用 <code>catch</code> 来处理错误。 </li>
<li>你可以用 <code>inout</code> 标记可以在函数内部改变的参数，不过通常来说最好还是返回一个新值。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之四 | 循环</title>
    <url>/programming/swiftswift-looping/</url>
    <content><![CDATA[<h1 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h1><p>Swift 有很多种书写循环的方式，它们底层的机制是相同的：重复执行某段代码直到某个条件不再满足。</p>
<p>最常见的循环是 <code>for</code> 循环：它在数组和范围上循环，每次拉出一个值然后把它赋予一个常量。</p>
<p>举个例子，这里是一个数字的范围：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">1</span>...<span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们可以用一个 <code>for</code> 循环打印里面的每一个值，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">count</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"数字是 \(number)"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>数组的操作方式也一样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> albums = [<span class="string">"Red"</span>, <span class="string">"1989"</span>, <span class="string">"Reputation"</span>]</span><br><span class="line"><span class="keyword">for</span> album <span class="keyword">in</span> albums {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(album) 在 Apple Music 上有售卖。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你不需要用到 <code>for</code> 循环提供给你的常量，你可以用下划线替代，这样 Swift 就会忽略这个你没有用到的值：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Zzz..."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h1><p>第二种书写循环的方式是使用 <code>while</code> ：给定一个检查的条件，循环运行代码直到条件不成立。</p>
<p>举个例子，我们可以使用 <code>while</code> 循环来模拟一个躲猫猫游戏：从 1 开始数数，数到的数会打印出来。数完 20 个数之后打印 “准备好了没？我来啦！”</p>
<p>Swift 代码长这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> number &lt;= <span class="number">20</span> {</span><br><span class="line">  <span class="built_in">print</span>(number)</span><br><span class="line">  number += <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"准备好了没？我来啦！"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Repeat-循环"><a href="#Repeat-循环" class="headerlink" title="Repeat 循环"></a>Repeat 循环</h1><p>第三种循环的写法不常用，它是 <code>repeat</code> 循环。除了把条件检查放在后面，它基本上跟 <code>while</code> 循环是一样的。</p>
<p>因此，我们可以用 <code>repeat</code> 循环重写我们的躲猫猫游戏：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span> {</span><br><span class="line">  <span class="built_in">print</span>(number)</span><br><span class="line">  number += <span class="number">1</span></span><br><span class="line">} <span class="keyword">while</span> number &lt;= <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"准备好了没？我来啦！"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>因为检查的条件是放在后面，所以 <code>repeat</code> 循环里的代码至少会被执行一次。而 <code>while</code> 循环则是在首次运行前就会检查条件。</p>
<p>举个例子， 下面代码里的 <code>print ()</code> 函数永远都不会被运行，因为 <code>false</code> 永远是 false ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">false</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"这是 false"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Xcode 会警告我们上面代码中的 <code>print ()</code> 代码永远都不会被执行。</p>
<p>而在下面这个代码里， <code>print ()</code> 函数则至少运行一次，因为 <code>repeat</code> 只有在条件检查没有通过时才会停止执行：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"这是 false"</span>)</span><br><span class="line">} <span class="keyword">while</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h1><p>你可以使用 <code>break</code> 关键字来终止循环。让我们以一个常规的 <code>while</code> 循环为例 —— 火箭发射倒计时：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countDown = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> countDown &gt;= <span class="number">0</span> {</span><br><span class="line">  <span class="built_in">print</span>(countDown)</span><br><span class="line">  countDown -= <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"发射！"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>想象一下，宇航员感觉这个倒计时过程很无聊，决定跳过后面的数，直接发射：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> countDown &gt;= <span class="number">0</span> {</span><br><span class="line">  <span class="built_in">print</span>(countDown)</span><br><span class="line">  <span class="keyword">if</span> countDown == <span class="number">4</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"好无聊啊，让我们直接发射吧！"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  countDown -= <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这次改动，只要 <code>countDown</code> 达到 4 ，那么宇航员的消息就会被打印，剩余的计数将会被忽略。</p>
<hr>
<h1 id="退出多重循环"><a href="#退出多重循环" class="headerlink" title="退出多重循环"></a>退出多重循环</h1><p>把循环放在另一个循环里，叫做 <em>嵌套</em> 循环。有的时候，你会有这种需求：同时跳出内部的循环和外部的循环。</p>
<p>举个例子， 我们可以用嵌套循环实现一个从 1 到 10 的乘法表：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">    <span class="keyword">let</span> product = i * j</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"\(i) * \(j) 等于 \(product)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果想退出循环，我们需要做两件事。首先，给外层循环加一个标签，像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">outerLoop: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">    <span class="keyword">let</span> product = i * j</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"\(i) * \(j) 等于 \(product)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，在内层循环里添加条件，在条件满足时用 <code>break outerLoop</code> 同时退出内外层循环：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">outerLoop: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">    <span class="keyword">let</span> product = i * j</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"\(i) * \(j) 等于 \(product)"</span>)</span><br><span class="line">    <span class="keyword">if</span> product == <span class="number">50</span> {</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"这是一个靶心。"</span>)</span><br><span class="line">      <span class="keyword">break</span> outerLoop</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果只使用 <code>break</code> ，就只能退出内层循环，外层循环会继续运行。</p>
<hr>
<h1 id="跳过循环项"><a href="#跳过循环项" class="headerlink" title="跳过循环项"></a>跳过循环项</h1><p>如你所见， <code>break</code> 关键字可以用于退出循环。 但是假如你想要跳过当前项然后继续执行下一次循环，你可以使用 <code>continue</code> 关键字。</p>
<p>让我们写一个从 1 到 10 的循环，然后利用 Swift 的取余操作符来跳过所有的奇数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h1><p>通常来说，我们用 <code>while</code> 循环来实现无限循环：它指的是那种不会自动停止的循环，或者说只有我们想要它停止时才停止的循环。你的智能手机里的 App 都用到了无限循环，因为它们一旦开始运行，就会持续运行，不断地接收输入事件，做出响应。</p>
<p>最简单的无限循环是用 <code>true</code> 作为条件。 <code>true</code> 使得循环可以无限重复地执行。 ** 警告：** 如果你采用 <code>while true</code> 来实现循环，确保你在循环内会有一个条件检查以退出这个无限循环。</p>
<p>举个例子， 我们用 <code>while true</code> 来模拟约翰・凯奇的《4’33”》这首歌。这首歌真的很奇葩，因为整个首歌的 4 分 33 秒都是沉默，没声。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">  counter += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> counter == <span class="number">273</span> {</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>循环可以重复执行某段代码，直到条件不再满足。 </li>
<li>最常见的循环是 <code>for</code> 循环，它内部会计数一个临时的常量来记录循环的次数。 </li>
<li>如果你用不上这个 <code>for</code> 循环给到你的常量，可以使用下划线来告知 Swift 忽略它。 </li>
<li>对于 <code>while</code> 循环，你需要显式地提供一个条件检查来决定循环是否执行。 </li>
<li>尽管和 <code>while</code> 循环很像， <code>repeat</code> 循环至少会执行一次循环体里的代码。 </li>
<li>你可以用 <code>break</code> 结束循环，但是在嵌套循环里， <code>break</code> 之后还要再加上标签才能跳出特定的外层循环。 </li>
<li>你可以用 <code>continue</code> 来跳过循环中特定的项。 </li>
<li>无限循环只有在你要求它停止时才会结束。如果你用了 <code>while true</code> 来实现无限循环，确保你有一个条件检查用于终止循环！ </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之三 | 操作符与条件</title>
    <url>/programming/swiftswift-operators-and-conditions/</url>
    <content><![CDATA[<h1 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h1><p>到目前为止，你已经了解了 Swift 的所有基本类型，现在让我们利用操作符把它们放在一起来使用。操作符指的是那些看起来像数学符号的玩意，比如 <code>+</code> 和 <code>-</code> 。 Swift 中有大量的操作符。</p>
<p>下面有一些测试用的变量（这里特指数学里的变量，不局限于 Swift 的 <code>var</code> ）：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstScore = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> secondScore = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>让我们用 <code>+</code> 和 <code>-</code> 把它们相加或者相减：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = firstScore + secondScore</span><br><span class="line"><span class="keyword">let</span> difference = firstScore - secondScore</span><br></pre></td></tr></tbody></table></figure>

<p>我们还可以用 <code>*</code> 和 <code>/</code> 来执行乘法和除法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> product = firstScore * secondScore</span><br><span class="line"><span class="keyword">let</span> divided = firstScore /secondScore</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 有一个用于计算除法的余数的特殊操作符： <code>%</code> 。它可以计算一个数 <code>A</code> 用若干个数 <code>B</code> 填充后，剩余的空间。</p>
<p>举个例子，如果我们把 <code>secondScore</code> 设置为 4 ，那么当我们做 <code>13 % secondScore</code> 这个操作时，我们会得到 1 ，因为 4 可以填充 13 三次，余数为 1 ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> remainder = <span class="number">13</span> % secondScore</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><p>Swift 支持 “操作符重载”，这是一种简明的说法，具体指的是操作符的行为可以根据它使用时的具体情境来决定。举个例子， <code>+</code> 可以用来相加整数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> doubleMeaning = <span class="number">42</span> + <span class="number">42</span></span><br></pre></td></tr></tbody></table></figure>

<p>同时， <code>+</code> 也可以用来连接字符串，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fakers = <span class="string">"Fakers gonna"</span></span><br><span class="line"><span class="keyword">let</span> action = fakers + <span class="string">"fake"</span></span><br></pre></td></tr></tbody></table></figure>

<p>你甚至还可以使用 <code>+</code> 来连接数组，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstHalf = [<span class="string">"John"</span>, <span class="string">"Paul"</span>]</span><br><span class="line"><span class="keyword">let</span> secondHalf = [<span class="string">"George"</span>, <span class="string">"Ringo"</span>]</span><br><span class="line"><span class="keyword">let</span> beatles = firstHalf + secondHalf</span><br></pre></td></tr></tbody></table></figure>

<p>记住， Swift 是一门类型安全的语言。这意味着它不允许你混用类型。举个例子，你不能把一个整数加到一个字符串上，因为这么做没有意义。</p>
<hr>
<h1 id="复合赋值操作符"><a href="#复合赋值操作符" class="headerlink" title="复合赋值操作符"></a>复合赋值操作符</h1><p>Swift 提供了一些把操作符和赋值组合起来的速记操作符，以便你可以用一次操作同时完成计算和赋值。它们看起来很像你已经认识的那些操作符，比如 <code>+</code> ，<code>-</code> ，<code>*</code> ，和 <code>/</code> ，不过需要在尾部再加上一个 <code>=</code> ，以表示把计算结果赋给操作数。</p>
<p>举个例子，如果有人考试考了 95 分，但是需要罚去 5 分，你可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">95</span></span><br><span class="line">score -= <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>类似地，你可以利用 += 来拼接字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quote = <span class="string">"The rain in Spain falls mainly on the"</span></span><br><span class="line">quote += <span class="string">"Spaniards"</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h1><p>Swift 提供了几个比较操作符，这些符号的工作方式跟你在数学中使用它们的方式很相似。</p>
<p>先来两个测试用的变量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstScore = <span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> secondScore = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>有两个可以用来检查相等的操作符。 <code>==</code> （发音 “等于”）检查两个值是否相等，而 <code>!=</code> （发音 “不等于”）则检查两个值是否不相等：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">firstScore == secondScore</span><br><span class="line">firstScore != secondScore</span><br></pre></td></tr></tbody></table></figure>

<p>还有四个用来检查两个值哪一个比较大，哪一个比较小或者相等的操作符。就跟数学里的符号一样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">firstScore &lt; secondScore</span><br><span class="line">firstScore &gt;= secondScore</span><br></pre></td></tr></tbody></table></figure>

<p>上面的这些操作符用在字符串上也是可以的，因为字符串都有一个自然的字母顺序。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"Taylor"</span> &lt;= <span class="string">"Swift"</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>你现在应该已经意识到你可以使用 <code>if</code> 语句来书写一些条件了。当你给到 Swift 一个条件时，如果条件成立， Swift 会运行你在 <code>if</code> 语句块里写的代码。</p>
<p>尝试一下。 你可以用上 Swift 最基础的函数，它叫做 <code>print ()</code> ：你提供一些文本给它，它将这些文本打印出来。</p>
<p>让我们用条件来检测二十一点扑克游戏的赢家：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstCard = <span class="number">11</span></span><br><span class="line"><span class="keyword">let</span> secondCard = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> firstCard + secondCard == <span class="number">21</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"21 点！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>花括号 <code>{</code> 和 <code>}</code> 之间的代码，在条件成立时会被执行。如果条件不成立时你想执行另外的代码，可以使用 <code>else</code> 语句：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> firstCard + secondCard == <span class="number">21</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"21 点！"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"普通点数。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你还可以使用 <code>else if</code> 来串联多个条件：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> firstCard + secondCard == <span class="number">2</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Aces，好手气！"</span>)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> firstCard + secondCard == <span class="number">21</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"21 点！"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"普通点数。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="组合条件"><a href="#组合条件" class="headerlink" title="组合条件"></a>组合条件</h1><p>Swift 提供两种操作符，以便我们把条件组合在一起，它们是 <code>&amp;&amp;</code>（发音 “与”）和 <code>||</code> （发音 “或”）。</p>
<p>举个例子，为了检查两个人的年龄是否都超过某个值，我们可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age1 = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> age2 = <span class="number">21</span></span><br><span class="line"><span class="keyword">if</span> age1 &gt; <span class="number">18</span> &amp;&amp; age2 &gt; <span class="number">18</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"两个人都超过 18 岁。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的 <code>print ()</code> 调用只有当两个年龄都大于 18 时才会被执行，而给到的两个年龄并不满足都大于 18 。实际上， Swift 并不会真的把两个条件都检查一遍，它不需要检查 <code>age2</code> 是否大于 18 ，因为当它发现 <code>age1</code> 大于 18 这个条件已经不成立时，就不会再继续检查后面的条件。</p>
<p>与 <code>&amp;&amp;</code> 不同的是，只要有任意一个条件通过测试， <code>||</code> 检查就会被认定为通过。 举个例子，下面的代码在任一年龄大于 18 时就会打印一条消息：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age1 &gt; <span class="number">18</span> || age2 &gt; <span class="number">18</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"有一个人超过 18 岁。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你可以在一个检查中使用多次 <code>&amp;&amp;</code> 和 <code>||</code> ，但是切记不要把条件写得太过复杂，因为那样很难阅读！</p>
<hr>
<h1 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h1><p>Swift 还提供一种不常用的操作符，叫做三元操作符。它的名字源自它可以一次协同三个操作数工作的特点。首先，它会先检查第一个数里指定的条件是否满足，如果满足则返回第二个数，否则返回第三个数。</p>
<p>三元操作符是把 <code>true</code> 和 <code>false</code> 两种情况一次性考虑进去的符号，它包含问号和冒号两个部分，因此阅读起来更麻烦一些。下面是一些例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstCard = <span class="number">11</span></span><br><span class="line"><span class="keyword">let</span> secondCard = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(firstCard == secondCard ? <span class="string">"牌是一样的"</span> : <span class="string">"牌不一样"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码检查两张牌是否一样，如果一样则打印 “牌是一样的”，否则打印 “牌不一样”。我们也可以换成常规的条件语句来达到一样的检测效果：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> firstCard == secondCard {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"牌是一样的"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"牌不一样"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h1><p>如果你需要用到多个 <code>if</code> 和 <code>else if</code> ，那你可以使用另一种结构：<code>switch case</code>，它会让你的代码看起来更清晰。采用 <code>switch</code> 语句，你只需要写一次条件，然后列出所有可能的结果，并针对所有的结果编写对应的处理代码。</p>
<p>让我们来尝试一下，下面是一个值为 <code>sunny</code> 字符串的名叫 <code>weather</code> 的常量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weather = <span class="string">"sunny"</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们可以使用 <code>switch</code> 语句块来打印下面四种消息中的一种：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> weather {</span><br><span class="line"><span class="keyword">case</span> <span class="string">"rain"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得带伞"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"snow"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得保暖"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sunny"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得戴墨镜"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"天气不错！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后一条 case 是 <code>default</code> ，它是不能省略的，因为 Swift 需要确保你覆盖了所有可能的 case ，即不能有遗漏的情况。所以只要天气不是 <code>rain</code> ， <code>snow</code> ，或者 <code>sunny</code> ， 默认的情况的 case 就会被运行。</p>
<p>Swift 只会运行某一个 case 里的代码。如果你希望继续执行下一个 case 的代码，你需要用到 <code>fallthrough</code> 关键字，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> weather {</span><br><span class="line"><span class="keyword">case</span> <span class="string">"rain"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得带伞"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"snow"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得保暖"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sunny"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得戴墨镜"</span>)</span><br><span class="line">  <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"天气不错！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h1><p>Swift 提供了两种方式给我们创建范围： 它们是 <code>..&lt;</code> 和 <code>...</code> 操作符。半开放范围操作符 <code>..&lt;</code> ，创建的范围不包含右边的值。而闭合范围操作符 <code>...</code> ，创建的范围包含右边的值。</p>
<p>范围 <code>1..&lt;5</code> 包含数字 1 ，2 ，3 和 4 ， 而范围 <code>1...5</code> 包含数字 1 ，2 ，3 ，4 和 5 。</p>
<p>对于 switch 语句块来说，范围非常有用。因为你可以把它们用于你的每条 case 。举个例子，假设我们根据某人的考试成绩打印不同的消息：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> score = <span class="number">85</span></span><br><span class="line"><span class="keyword">switch</span> score {</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>..&lt;<span class="number">50</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"你需要加把劲了。"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">50</span>..&lt;<span class="number">85</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"做的不错。"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"你真棒！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如前面提到的，这里必须有一个 <code>default case</code> 来确保所有的可能都被覆盖到。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ul>
<li>Swift 提供了用于算术和比较的操作符，它们的工作机制就像我们在数学中所熟知的那样。 </li>
<li>有一些算术操作符的复合变体，它们可以一次性完成算术和赋值两个操作，比如 <code>+=</code> ，<code>-=</code> ，等等。 </li>
<li>你可以使用 <code>if</code> ， <code>else</code> 和 <code>else if</code> 语句，基于条件判定的结果来运行不同的代码。 </li>
<li>Swift 提供一个三元操作符，把 <code>true</code> 和 <code>false</code> 两种条件检查和语句块组合在一起。尽管有的时候会看到大家在使用它们，我个人不建议你使用这个操作符。 </li>
<li>如果你基于同一个值做多种条件判定，那么你可以使用 switch 语句，这么做会使代码更清晰。 </li>
<li>我们可以用 <code>..&lt;</code> 或者 <code>...</code> 来创建范围，具体用哪一个取决于要不要包含后面那个值，即范围是否闭合。 </li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之二 | 复合类型</title>
    <url>/programming/swiftswift-complex-types/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是用于存储一组值的合集。举个例子，红、绿、蓝是三基色，你可以对它们进行调和从而产生新颜色。因此颜色就可以用一个包含了红、绿、蓝三个值的数组来存储。</p>
<p>代码上，我们这么书写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> red = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">let</span> green = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">let</span> blue = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">let</span> color = [red, green, blue]</span><br></pre></td></tr></tbody></table></figure>

<p>上面的最后一行代码创建了一个数组：它以方括号开始和结束，里面的元素通过逗号分隔。</p>
<p>你可以通过书写数组名加上内部包含一个数字的方括号来读取数组里的元素。注意：这个数字代表元素在数组里的位置，几乎在所有的计算机编程语言中，这个位置都是从 <code>0</code> 开始的。所以，如果你想读取蓝色，可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">color [<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>小心：如果你尝试读取一个不存在的值， Swift 将会崩溃。例如，试图读取 <code>color [5]</code> 就不是一个好主意。</p>
<p>另外还要注意的是，如果你想使用类型注解，数组是通过方括号加里面的类型来表示的： <code>[String]</code> ，<code>[Int]</code> ，<code>[Double]</code> 和 <code>[Bool]</code> 。</p>
<a id="more"></a>

<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合跟数组类似，也是存储一组值的合集。但它们有两个区别：集合中的元素是随机存放的，而数组中的元素是顺序存放的。集合中不允许有两个相同的元素，即任何一个元素只能出现一次。数组则没有这个限制。</p>
<p>你可以直接利用数组来创建一个集合，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="type">Set</span>([<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>])</span><br></pre></td></tr></tbody></table></figure>

<p>当你在 Playground 中查看 colors 中的元素时，你看到的元素的顺序可能跟你创建 colors 时填写的顺序不同。实际上，这个顺序并非真的是每次都随机生成，只不过很有可能跟你给的顺序不同。</p>
<p>Swift 内部自有算法来生成这个顺序，但不保证跟你创建集合时传入的顺序一致。所以，通过位置来读取数组中的元素那种方式，对于读取集合中的元素是不适用的。</p>
<p>如果你试图往集合中插入一个已经存在的元素，重复的这个元素会被忽略。举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors2 = <span class="type">Set</span>([<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"blue"</span>])</span><br></pre></td></tr></tbody></table></figure>

<p>最后的 <code>colors2</code> 只会包含 <code>red</code> ，<code>green</code> 和 <code>blue</code> 各一个。</p>
<hr>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组允许你通过一个值来存储几个值。 听起来跟数组很像，但元组有所不同：你不能往元组中添加或者删除元素 —— 元组的长度是固定的。你不能改变元组中元素的类型 —— 元组创建时内部的元素类型必须是一致的。</p>
<p>你可以通过位置或者名称来访问元组中的元素。但是 Swift 不允许你访问不存在的位置或者名称。</p>
<p>元组的创建方式是把一组值放进圆括号中，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = (first: <span class="string">"Taylor"</span>, last: <span class="string">"Swift"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>你可以通过从 0 之类的位置信息来访问元组的元素：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">name.<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>或者你也可以通过名称来访问元组的元素：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">name.first</span><br></pre></td></tr></tbody></table></figure>
<p>在元组创建之后，你可以改变其中元素的值，但是不能改变它们的类型。因此，如果你尝试把 name 改成 (first: “韩梅梅”，age: 25) ，将会遭遇错误。</p>
<hr>
<h1 id="数组-vs-集合-vs-元组"><a href="#数组-vs-集合-vs-元组" class="headerlink" title="数组 vs 集合 vs 元组"></a>数组 vs 集合 vs 元组</h1><p>数组，集合和元组第一眼看上去很相似，但它们的用途是有区别的。为了帮助你更好地选择，这里有一些规则供参考：</p>
<p>如果你需要存放的元素是关联在一起被使用的，它们的个数固定，顺序或者名称也相对固定，那么你应当使用元组。举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> address = (门牌号: <span class="number">666</span>, 街道: <span class="string">"朝阳区某街道"</span>, 城市: <span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你需要一个合集，其中的元素必须是唯一的，或者你可能需要快速地检验合集里有没有包含某个元素，那么你应当使用集合。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shoppingList = <span class="type">Set</span>([<span class="string">"苹果"</span>, <span class="string">"肉"</span>, <span class="string">"牛奶"</span>])</span><br></pre></td></tr></tbody></table></figure>

<p>如果你需要一个合集，其中的元素允许重复，或者合集中元素的顺序对你来说很重要，那么你应当使用数组。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pingpongScores = [<span class="string">"11-7"</span>, <span class="string">"8-11"</span>, <span class="string">"11-9"</span>, <span class="string">"8-11"</span>, <span class="string">"11-5"</span>, <span class="string">"13-11"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>三种类型中，数组是最常用的。</p>
<hr>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典也是用于存储一组值的合集。但跟数组用整数的位置来访问元素的方式不同的是，在字典里你可以用任何你想要的类型来充当访问标识。</p>
<p>当然，最常见的存储字典的访问标识是字符串。举个例子，我们可以创建一个基于运动员的名字来访问运动员的身高的字典：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> top3NBAHeights = [</span><br><span class="line">  <span class="string">"马努特 波尔"</span>: <span class="number">2.31</span>,</span><br><span class="line">  <span class="string">"姚明"</span>: <span class="number">2.28</span>,</span><br><span class="line">  <span class="string">"里克 施密茨"</span>: <span class="number">2.23</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>就像数组一样，字典也以方括号开始和结束，里面的元素通过逗号分隔。此外，为了把一个值（例如 2.28）存放到对应的标识（例如 “姚明”）下面，你还得用到一个冒号。</p>
<p>这些访问标识被称为 “键”，相对应的是 “值”。我们用键来读取值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">top3NBAHeights [<span class="string">"姚明"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>注意：如果你想使用类型注解，数组是通过方括号加里面的键值对类型来表示的，键值对又通过冒号分隔。举个例子， <code>[String: Double]</code> 或者 <code>[String: String]</code> 。</p>
<h2 id="字典默认值"><a href="#字典默认值" class="headerlink" title="字典默认值"></a>字典默认值</h2><p>如果你试图通过一个不存在于字典中的键读取字典中的值时， Swift 会返回给你一个 nil 。它代表没有东西。当然，这可能就是你想要 Swift 在找不到目标时返回给你的结果。不过，我们还有另外一种选择：当给定的键对应的值不存在时，我们可以指定一个默认的值返回给访问者。</p>
<p>为了演示这种操作，我们先创建一个包含了两个人最喜欢的冰淇淋的字典：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteIceCream = [</span><br><span class="line">  <span class="string">"小明"</span>: <span class="string">"巧克力"</span>,</span><br><span class="line">  <span class="string">"小红"</span>: <span class="string">"香草"</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以像这样读取小明最喜欢的冰淇淋：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">favoriteIceCream [<span class="string">"小明"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>但是当我们试图读取小华最喜欢的冰淇淋时，我们会得到一个 nil ，这代表 Swift 没有在字典里找到对应 “小华” 这个键的值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">favoriteIceCream [<span class="string">"小华"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>这种情况下，我们可以通过指定一个默认值，比如说 “未知”，来解决这个问题。这样做之后， 当 Swift 没有从字典中找到小华最喜欢的冰淇淋时，我们得到的不再是一个 nil ，而是一个 “未知” 字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">favoriteIceCream [<span class="string">"小华"</span>, <span class="keyword">default</span>: <span class="string">"未知"</span>]</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="创建空的合集"><a href="#创建空的合集" class="headerlink" title="创建空的合集"></a>创建空的合集</h1><p>数组，集合和字典都属于合集，因为它们都是把分散的值收集起来放在一处的结构。</p>
<p>如果你想要创建一个空的合集，只需要写上类型名，然后加上一组圆括号。举个例子，创建一个键和值的类型都是 <code>String</code> 的字典，我们可以这样书写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> teams = [<span class="type">String</span>: <span class="type">String</span>]()</span><br></pre></td></tr></tbody></table></figure>

<p>之后添加元素，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">teams [<span class="string">"小红"</span>] = <span class="string">"红色"</span></span><br></pre></td></tr></tbody></table></figure>

<p>类似的，你可以像这样创建一个 <code>Int</code> 类型的空数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> results = [<span class="type">Int</span>]()</span><br></pre></td></tr></tbody></table></figure>

<p>创建集合是一个例外，方式稍有不同：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> numbers = <span class="type">Set</span>&lt;<span class="type">Int</span>&gt;()</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为 Swift 只为字典和数组提供了特殊的语法，其他类型都必须使用尖括号来声明类型信息，就像集合那样。</p>
<p>当然，也可以不使用特殊语法，通过和集合类似的标准方式创建字典和数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> results = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举，通常简称 <code>enums</code> ，是一种定义一组高度关联的值的方式。它使得这组关联的值使用起来更方便。为什么这么说呢？</p>
<p>想象一下，如果你想要写一些代码表示正在做的某件事情的结果，成功或者失败，你选择了使用字符串来表示这个结果：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">"failure"</span></span><br></pre></td></tr></tbody></table></figure>
<p>不过，有人不小心写错了或者采用了不同的拼写，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result2 = <span class="string">"failed"</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="string">"fail"</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面几行表示失败的字符串都各不相同，所以它们代表不一样的东西，无法让你基于失败这一结果的代码被正确执行。</p>
<p>而有了枚举，我们可以定义一个叫做 <code>Result</code> 的类型，它既可以是 <code>success</code> ，也可以是 <code>failure</code> ，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> success</span><br><span class="line">  <span class="keyword">case</span> failure</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，当我们再想要表示结果时，只需要从两个值中选择一个：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result4 = <span class="type">Result</span>.failure</span><br></pre></td></tr></tbody></table></figure>

<p>这样做的好处是可以避免书写不一致字符串导致跟预期不匹配的情况发生。</p>
<h2 id="枚举关联值"><a href="#枚举关联值" class="headerlink" title="枚举关联值"></a>枚举关联值</h2><p>除了可以存储简单的值，枚举还可以存储附属于每个 <code>case</code> 的关联值。这个特性使得你可以为枚举附加额外的数据，从而让它们传达更多细微的信息。</p>
<p>举个例子，我们可以定义一个枚举，它存放了各种各样的活动类型：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Activity</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> bored</span><br><span class="line">  <span class="keyword">case</span> running</span><br><span class="line">  <span class="keyword">case</span> talking</span><br><span class="line">  <span class="keyword">case</span> singing</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的枚举类型存储的信息，可以让我们知道有人在讲话，但我们不知道讲话的内容，或者可以让我们知道有人在跑步，但我们不知道他们将跑去哪里。</p>
<p>通过枚举的关联值，我们添加额外的细节：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Activity</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> bored</span><br><span class="line">  <span class="keyword">case</span> running (destination: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> talking (topic: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> singing (volume: <span class="type">Int</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们有了更精确的信息。我们可以说某人正在谈论足球：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> talking = <span class="type">Activity</span>.talking (topic: <span class="string">"football"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="枚举原始值"><a href="#枚举原始值" class="headerlink" title="枚举原始值"></a>枚举原始值</h2><p>有的时候你可能想给枚举赋予一些原始值从而让它们可以表达某种含义。这么做可以让你动态地创建枚举，并且以不一样的方式来使用它们。</p>
<p>举个例子，你可以创建一个名叫 <code>Planet</code> 的枚举，然后让它的每条 case 存储一个整数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> mercury</span><br><span class="line">  <span class="keyword">case</span> venus</span><br><span class="line">  <span class="keyword">case</span> earth</span><br><span class="line">  <span class="keyword">case</span> mars</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 会为这些 case 自动分配一个数字，同样的，是从 0 开始。你可以利用这些数字创建枚举的 case 。举个例子， <code>earth</code> 会被分配到数字 2 ，于是你可以这么创建一个 <code>earth</code> 的 case ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> earth = <span class="type">Planet</span>(rawValue: <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你自行指定了一个或者几个 case 的原始值， Swift 可能会自动为剩下的 case 生成原始值，只要这些值是可以被 Swift 推断的。比如把地球算作第 2 颗行星来考虑可能不太自然（因为我们一般说它是九大行星中的第 3 颗)，于是你可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> mercury = <span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> venus</span><br><span class="line">  <span class="keyword">case</span> earth</span><br><span class="line">  <span class="keyword">case</span> mars</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样一来 Swift 就会给 <code>mercury</code> 分配数字 1 ，后面的数字基于前面的往上加， <code>earth</code> 就变成第 3 颗行星了。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ul>
<li>数组，集合，元组和字典让你可以通过单一对象存储一组值。它们实现这一点的方式各有不同，所以你需要根据具体场景来决定采用哪一种结构。</li>
<li>数组按顺序存储数据，你可以往里面添加或者删除元素，并通过位置来读取。</li>
<li>集合不按顺序存储数据，所以你不能通过位置来访问，但它提供了元素不重复的特性。</li>
<li>元组长度固定，你可以给里面的每个元素取名。这样就既可以通过位置，也可以通过名字来读取。</li>
<li>字典根据键来存储数据，因此读取元素时要用到键。</li>
<li>枚举是一种分组关联值的方法，帮你避免拼写错误。</li>
<li>你可以为枚举的每条 <code>case</code> 设置原始值，同时还可以为它们附加关联值来提供额外的信息。</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之一 | 简单类型</title>
    <url>/programming/swiftswift-simple-types/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>当你启动 Xcode 时，它会询问你想要做的事情，选择 “Get Started with a Playground” 。 Playground 是一个可以供你输入 Swift 代码并立即看到结果的沙盒环境。</p>
<p>默认的， Xcode 将提供一个 iOS 编程环境的空白 Playground, 点击 Next，然后再点击 Create ，将 Playground 保存到你的系统桌面。</p>
<p>在本文中，我将向你介绍 “变量”，它们是你用来存储程序数据的地方。之所以被称为 “变量”，是因为它们可变，即你可以自由地改变它们的值。</p>
<p>我们将从在 Playground 中的第一行代码开始了解 “变量”，它是一行创建了一个名称为 “str” ， 值为 “Hello, playground” 的字符串变量的代码。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello, playground"</span></span><br></pre></td></tr></tbody></table></figure>

<p>这行代码创建了一个名为 <code>str</code> 的新变量，并给它赋值为 “Hello, playground” 。在 Playground 右侧的输出区域你可以看到 “Hello, playground” – 这是 Xcode 在展示我们刚刚给 <code>str</code> 设置的值。</p>
<p>既然 str 是一个变量，我们就可以改变它:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">str = <span class="string">"Goodbye"</span></span><br></pre></td></tr></tbody></table></figure>

<p>第二次的时候，你不需要再写一次 <code>var</code> ，因为这个变量在前面已经被创建过了 – 我们只需要改变它。</p>
<a id="more"></a>

<hr>
<h1 id="字符串和整型"><a href="#字符串和整型" class="headerlink" title="字符串和整型"></a>字符串和整型</h1><p>Swift 是一门类型安全的编程语言，类型安全特指的含义包括：每一个变量都必须有一个特定的 “类型”。 Xcode 为我们创建的 str 变量拥有一个由字母组合 “Hello, playground” 组成的字符串，所以 Swift 为这个变量赋予了 <code>String</code> 类型。</p>
<p>换句话说，如果我们想存储一个人的年龄，那我们可能需要创建这样一个变量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">38</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个变量拥有一个整数， 所以 Swift 赋予它 <code>Int</code> 类型 –  <code>Int</code> 是 “integer” 的简写。如果你的数比较大，Swift 允许使用下划线作为千位分隔符。这些分隔符不会改变数字代表的绝对数值，它们只是让数字阅读起来更方便。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> population = <span class="number">8_000_000</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>String</code> 和 <code>Int</code> 是不同的类型，不能混用。因此，你可以把 <code>str</code> 的值改成 “Goodbye”，但你不能把它改成 <code>38</code> ，因为 <code>38</code> 是一个 <code>Int</code> 类型，不是一个 <code>String</code> 类型。</p>
<hr>
<h1 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h1><p>标准的 Swift 字符串使用双引号表示，但在双引号之间你不能换行。如果你想要表示多行的字符串，需要使用将双引号首尾的引号个数由一个改成三个，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"""</span></span><br><span class="line"><span class="string"> 这个字符串 </span></span><br><span class="line"><span class="string"> 跨越了 </span></span><br><span class="line"><span class="string"> 多行 </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure>

<p>Swift 对于书写这些引号有着特别的规定：开始的三个引号和结束的三个引号都必须独占一行，但它们占的那两行都不会算进最终的字符串里。假如你只是想利用多行字符串来使代码看起来更整洁，你可以通过在每行的行尾添加一个 \ 来确保换行不会进入最终的字符串，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str2 = <span class="string">"""</span></span><br><span class="line"><span class="string"> 这个字符串 \</span></span><br><span class="line"><span class="string"> 看起来跨越了多行， \</span></span><br><span class="line"><span class="string"> 实际上没有 </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="双精度浮点型和布尔型"><a href="#双精度浮点型和布尔型" class="headerlink" title="双精度浮点型和布尔型"></a>双精度浮点型和布尔型</h1><p>Swift 中还有两种基础的数据类型，它们是双精度浮点数类型和布尔类型，你将会经常用到它们。 <code>Double</code> 被用来代表 “双精度浮点数”，这是表示诸如 38.1 , 或者 3.141592654 这样的小数的一种高级的说法。每当你通过一个分数创建一个变量时， Swift 都会自动赋予这个变量 <code>Double</code> 类型。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pi = <span class="number">3.141</span></span><br></pre></td></tr></tbody></table></figure>

<p>双精度浮点数有别于整数，也不能混用。至于布尔类型则更简单一些：它们只有 <code>true</code> 和 <code>false</code> 两种值，所以当你用 <code>true</code> 或者 <code>false</code> 创建一个变量时， Swift 会自动赋予这个变量布尔类型。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> awesome = <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><p>你已经在前面学到了如何在代码中直接输入字符串的值，不过 Swift 还提供了一种被称为 “字符串插值” 的特性。这个特性允许你在字符串值里插入变量，从而动态地给一个 <code>String</code> 类型的变量赋值。在字符串内部，你可以放置任意类型，任意数量的变量。要放置这些变量，你需要以一个反斜杠开始，即 \，然后跟上用圆括号包起来的变量名。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">85</span> </span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"你的分数是 \(score)"</span></span><br></pre></td></tr></tbody></table></figure>

<p>你将会在 Playground 的输出区域里看到，上面的操作会把 <code>str</code> 变量的值设置为 “你的分数是 85”。</p>
<p>多尝试几次，通过字符串插值组合出任何你想要的字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> results = <span class="string">"测试结果如下： \(str)"</span></span><br></pre></td></tr></tbody></table></figure>

<p>在之后你还会学到，字符串插值不仅可以用来放置变量，还可以用来运行代码。</p>
<hr>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>前面提到变量之所以被称为变量是因为你可以随着时间的推移改变它们，这一点非常有用。不过，有些时候你只需要设置一次值然后就不再改变了，这种情况下我们使用常量。对应给变量用的 <code>var</code> 关键字，常量用 <code>let</code> 关键字表示。 <code>let</code> 关键字用来声明常量，常量的值只能被设置一次，并且无法被修改。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> taylor = <span class="string">"swift"</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果你尝试改变常量的值， Xcode 会拒绝运行你的代码。这是一种安全机制，以防止你失手改变一些本来不应该被改变的东西。在书写 Swift 代码的时候，除非你明确想要改变，你应当尽量使用 <code>let</code> 关键字。实际上，如果你用了 <code>var</code> 声明变量但之后都没有再对它进行改变， Xcode 将会发出警告。</p>
<hr>
<h1 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h1><p>Swift 基于变量和常量在创建时被赋予的值为它们分配了一个类型。因此，当你书写如下的代码时， Swift 知道这里面包含了一个字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"Hello, playground"</span></span><br></pre></td></tr></tbody></table></figure>

<p>它将把 <code>str</code> 当作一个 <code>String</code> 类型，因此之后你就不能再给它赋值一个整数值或者布尔值。这个过程被称为 ** 类型推断 **。 Swift 能够基于你创建一个东西的方式来推断它的类型。  如果你想显式地声明数据的类型而不是依赖 Swift 的类型推断，你可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> album: <span class="type">String</span> = <span class="string">"Reputation"</span> </span><br><span class="line"><span class="keyword">let</span> year: <span class="type">Int</span> = <span class="number">1989</span> </span><br><span class="line"><span class="keyword">let</span> height: <span class="type">Double</span> = <span class="number">1.78</span> </span><br><span class="line"><span class="keyword">let</span> <span class="keyword">is</span>: <span class="type">Bool</span> = <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>留心布尔类型的缩写名是 <code>Bool</code> ，同样地，整数类型也是采用缩写的 <code>Int</code> 。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ul>
<li>我们使用 <code>var</code> 来创建变量，使用 <code>let</code> 来创建常量。如无必要使用变量，应当尽可能地使用常量。 </li>
<li><code>String</code> 类型通常以双引号来开始和结束。如果你想要字符串能够跨越多行，则需要把引号替换为三个。 </li>
<li><code>Int</code> 类型存储整数，<code>Double</code> 存储小数，而 <code>Bool</code> 则存储 <code>true</code> 或者 <code>false</code>。 </li>
<li>字符串插值允许你通过在字符串内部放置其他的变量和常量的方式来创建新的字符串。 </li>
<li>Swift 通过类型推断来给变量或者常量分配类型，不过你也可以显式地提供类型。 </li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
