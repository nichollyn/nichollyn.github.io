<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Infinite Game</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://theinfinitegame.tech/"/>
  <updated>2020-01-14T08:42:01.369Z</updated>
  <id>https://theinfinitegame.tech/</id>
  
  <author>
    <name>猫克杯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>极速统计教程之十一 | 概率分布</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-random-variables-and-probability-distributions/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-random-variables-and-probability-distributions/</id>
    <published>2020-01-14T06:48:10.000Z</published>
    <updated>2020-01-14T08:42:01.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随机变量和概率分布"><a href="#随机变量和概率分布" class="headerlink" title="随机变量和概率分布"></a>随机变量和概率分布</h1><p>随机变量的随机性其实并不像它的名字传递的那样多。这一节教程中，我将通过随机变量的可能结果和它们对应的概率来描述 <strong>概率分布 (probability distribution)</strong> 。换句话说，随机分布使随机性具体化，并且提供了一条在计算中使用随机变量的道路。当我们观察个体或者对象的时候，我们可以关注每个个体的若干个属性，这些属性就叫做 <strong>变量</strong> 。</p><p>现在，想象你收集了一份数据，并且决定重复实验。你能够找到相同的试验个体来测量变量，或者能找到相近的个体。不管采用哪一种，你会发现你的变量的值每次都不一样。这就是所谓的变量。举个例子，你测量一个人的身高几次，每次的结果可能会有几毫米到 1 厘米的偏离，这取决于你测量的时间在一天中的时刻，你的测量设备的精度，等等。</p><p>通常我们预料变量的值具有随机的变异性。如果这种概率的随机性是中肯的，则这个变量被称为 <strong>随机变量 (random variable)</strong> 。随机变量可以有一组可能的值，每个值都和概率关联。因此，如果随机变量的样本足够大，不同值的相对频率就接近概率。为了让事情清晰，让我们用斜体的大写字母来表示随机变量，小写字母来表示它取到的值。</p><p>即 <strong>X_</strong> 为随机变量，$ x_1, x_2, x_3, … $ 为随机变量的值。</p><p>随机变量有两种，一种是 <strong>离散的 (discrete)</strong> ，一种是 <strong>连续的 (continuous)</strong> 。离散随机变量可以有一组可数数量的不同值，比如 0 / 1 / 2 / 3 。实际上，如果一个随机变量只能取得有限数量的不同值，那它必定是离散的。离散随机变量的例子很多，比如一个家庭里小孩的数量。连续随机变量则可以取得无限数量的可能值。它通常是测量。为了演示无限性，假设一个身高值测出来是 3.1 米，如果换更精确的测量仪器，也许能测到 3.14 米。更精确的仪器，也许还能测到 3.145 米。换言之，通过更精确的测量，或者放大操作，无限数量的结果是可能的。年龄，温度，速度，这些都可以是连续随机变量的例子。</p><p>随机变量的值可以很方便地通过随机分布来呈现。随机分布的呈现形式可以是表格，图或者数学方程，并且是通过随机变量的每个取值关联的概率列表来定义的。</p><p><img src="/images/pd_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>根据定义，每个随机变量都有一个概率分布，离散随机变量的概率分布叫 <strong>概率质量函数</strong> ，而连续随机变量的概率分布叫概率密度函数。至于为什么有这种区别，稍后解释。</p><p>对于离散随机变量来说，通过列出每种可能的结果，容易看出概率。假设变量 <strong><em>X</em></strong>  接收 1, 2, 3, 或者 4 。那么下面这张表就列出了每种结果的概率。分布还可以用概率直方图来描述，这跟频率表或者频率直方图的用法如出一撤。</p><p><img src="/images/pd_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>对于连续随机变量，可以采用图表。下图中的概率分布并没有在 y 轴上给出概率，而给出了 <strong>概率密度 (probability density)</strong> 。为了获得概率，你需要考虑曲线某个区间下方的区域而非曲线的高度。概率就是由这块区域的面积给出的。y 轴之所以要采用密度是因为你的随机变量单位可能会改变。比如，你表示的长度由米改成厘米，这个时候密度相应改变，而区域的面积不应该变化。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>随机变量是一个由随机现象产生多种可能结果的变量。当结果有限可数时，它是离散的；当结果数量无限时，它是连续的。</li><li>概率分布为随机变量可取得的每个值指定概率。离散随机变量的概率分布叫概率质量函数，而连续随机变量的概率分布叫概率密度函数，它的概率值时通过概率曲线指定区间下的面积来获得的。</li><li>概率密度函数可以以表格、图表或者方程的形式呈现。</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;随机变量和概率分布&quot;&gt;&lt;a href=&quot;#随机变量和概率分布&quot; class=&quot;headerlink&quot; title=&quot;随机变量和概率分布&quot;&gt;&lt;/a&gt;随机变量和概率分布&lt;/h1&gt;&lt;p&gt;随机变量的随机性其实并不像它的名字传递的那样多。这一节教程中，我将通过随机变量的可能
      
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之十 | 条件概率和独立性</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-conditional-probability-and-independence/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-conditional-probability-and-independence/</id>
    <published>2020-01-11T05:18:35.000Z</published>
    <updated>2020-01-11T12:41:24.218Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联合概率和边际概率"><a href="#联合概率和边际概率" class="headerlink" title="联合概率和边际概率"></a>联合概率和边际概率</h1><blockquote><p>对有趣现象的计数，在日常生活中常常转换成比例，最终变为概率。利用概率估算的力量，可以更好地理解这些现象之间的关系或做出预测。 <strong>联合概率 (joint probability)</strong> 和 <strong>边际概率 (marginal probability)</strong> 是两个在这种情况下会用到的重要概率类型。在这一节教程中，我将解释联合概率和边际概率的含义，并展示它们的属性。</p></blockquote><p>想象你在沙滩上观察你的海滩同伴。你会注意到三种不同类型的活动 —— 它们是互斥的。有的休息，他们都坐在或躺在沙滩上。有的玩，这些人到处乱跑，建造沙堡或站在水中。最后，有的在游泳。此外，你还可以按性别区分。所以你观察到的每个人都是一个案例.</p><p><img src="/images/conditional_p_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>在数据集中，性别和活动是变量。你最终得到以下结果的列联表。总共计了 113 人，其中有 79 人在休息，有 20 人在玩，并且他们中只有 14 人在游泳。女性和男性的数量，分别是 62 和 51 。</p><p><img src="/images/conditional_p_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>这些数字实际上是每行和每列变量位于此表边缘的总和，因此被称为边际值。请注意，这与口语上 “边缘的”，即并不重要的，并不是一回事。在表中边际值代表对于单个变量的说明，没有关于任何其他变量。例如说休息的人数不考虑性别。</p><p><img src="/images/conditional_p_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>现在，我们打开这个频率表通过将每个单元格数字除以总数 113 得到比例的表格。</p><p><img src="/images/conditional_p_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>在此表中，中心块包含六个位置，它们加起来等于一。同时，每列中的比例加总到底部的边缘行中的值，每行中的比例加总到右边的边缘列中的值。并且边缘行的值加起来等于边缘列的值加起来。</p><a id="more"></a><p>你的计数可以看作随机样本，测量在海滩的人的活动和性别分布，于是你会想到把比例看作概率。在中间区域，是活动与性别的交集。例如，给定的人是男性，正在游泳。这些值称为 <strong>联合概率 (conditional probability)</strong> 。 <strong>联合概率只是各种事件的交集概率的简称</strong> 。</p><p>我们的每个联合概率关联的事件都与表中任何其他联合概率关联的事件互斥，因为每个人在海滩上只被放置在六个互斥事件之一。同时，联合概率形成一系列完全穷尽的事件，因为案例中不会出现其他的可能活动和性别的组合。因此，联合概率总和为一。</p><p><img src="/images/conditional_p_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>在边缘的地方，你可能期望有 <strong>边际概率</strong> 。是的，这些概率仅考虑一个变量。例如，给定的人是男性，无论其活动如何，或者给定在玩，不论性别。边际概率来自联合概率的并集。例如休息的概率，玩耍的概率和游泳概率。因此，这里适用加法规则，即概率相加。</p><p><img src="/images/conditional_p_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>因此，如果你的原始计数不可得，但有联合概率，你始终可以计算出边际概率 —— 通过求和。相反，如果只给你边际概率，你将无法在每种情况下反推出联合概率。</p><p><img src="/images/conditional_p_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>当你在对源自一个随机样本或者试验中的现象计数时，可以把它们转换成概率。</li><li>如果观察多个随机变量，可以计算出这些变量的联合概率和边际概率。</li><li>联合概率是变量间某些结果交集的概率，而边际概率是每个变量所有结果概率的总和。</li><li>典型的例子里，如果变量有两个，列联表示组织数据的绝佳形式。联合概率放在中间，边际概率放在边缘。所有的联合概率加起来等于 1 ，它们在两个方向上分布加总得到一个边际概率。</li><li>你总是可以通过加总，基于联合概率算出边际概率；但仅有边际概率，不借助额外的假定是无法算出联合概率的。</li></ul><hr><h1 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h1><p>术语 <strong>条件 (condition)</strong> 意味着取决于别的东西。和日常语言中的概率上下文或多或少具有相同的含义。</p><p>其正式定义是：给定另外一件事已发生，这件事件发生的可能性。数学符号如下：</p><script type="math/tex; mode=display">P (A | B)</script><p>即给定 B 发生或以 B 为条件，事件 A 发生。垂直线是 “给定” 的速记，或者说 “有条件” 的速记。条件概率的计算公式是：</p><script type="math/tex; mode=display">P (A | B) = \frac {P (A \cap B)}{P (B)}</script><p>即事件 A 和事件 B 都发生的概率除以事件 B 发生的概率。也可以用下面的文氏图来说明：</p><p><img src="/images/conditional_p_8.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>该图强调 A 和 B 的交集概率只能小于或等于 B 的概率。</p><p>让我们应用方程到一个熟悉的例子。你考虑了沙滩上的人们进行的各种活动，也可以按性别区分人们。将结果转换一张有概率的表。现在，有了这些变量，活动和性别，如何举出一个条件概率的例子？具体来说，是你知道一个结果发生的概率，然后要计算这个结果发生后，其他结果再发生的概率。让我们举一个具体的例子。你将估算一个概率 —— 该人是男性，且则该人正在休息。</p><p>为了算得这个概率，应用前面说到的公式，联合概率除以是男性的概率。因此， 0.3 除以 0.45 。</p><p><img src="/images/conditional_p_9.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>现在我有一个问题要问你。你能计算给定活动的性别概率吗？方法一样：</p><p><img src="/images/conditional_p_10.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>因此，根据联合概率和边际概率，您可以计算出条件概率。虽然条件概率方程很简单，但它还有更多可以挖掘。再看一下方程式，如果两边都乘以事件 B 的边际概率，你就得到了一个计算联合概率的公式。</p><p>这其中隐含的意思是，如果交给你一项任务：找到事件 A 和事件 B 的联合概率，如果你不知道 A 和 B 之间是否独立，你需要同时拿到 B 的概率和给定 B 发生 A 的条件概率，或者拿到 A 的概率和给定 A 发生 B 的条件概率。</p><h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><ul><li>条件概率是指给定另一件事已发生时某件事的概率。</li><li>表明上看不是很特别，但条件概率是很多概率估算的核心。</li><li>数学上，给定 B 的 A 的条件概率等于 A 和 B 的联合概率除以概率 B 。</li><li>条件概率的定义，也适用于不论是否独立的事件的联合概率。给定 B 的 A 的条件概率可以看成是 B 发生后，样本空间缩小到 B 时 A 发生的概率。</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;联合概率和边际概率&quot;&gt;&lt;a href=&quot;#联合概率和边际概率&quot; class=&quot;headerlink&quot; title=&quot;联合概率和边际概率&quot;&gt;&lt;/a&gt;联合概率和边际概率&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;对有趣现象的计数，在日常生活中常常转换成比例，最终变为概率。利用概率估算的力量，可以更好地理解这些现象之间的关系或做出预测。 &lt;strong&gt;联合概率 (joint probability)&lt;/strong&gt; 和 &lt;strong&gt;边际概率 (marginal probability)&lt;/strong&gt; 是两个在这种情况下会用到的重要概率类型。在这一节教程中，我将解释联合概率和边际概率的含义，并展示它们的属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想象你在沙滩上观察你的海滩同伴。你会注意到三种不同类型的活动 —— 它们是互斥的。有的休息，他们都坐在或躺在沙滩上。有的玩，这些人到处乱跑，建造沙堡或站在水中。最后，有的在游泳。此外，你还可以按性别区分。所以你观察到的每个人都是一个案例.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/conditional_p_1.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在数据集中，性别和活动是变量。你最终得到以下结果的列联表。总共计了 113 人，其中有 79 人在休息，有 20 人在玩，并且他们中只有 14 人在游泳。女性和男性的数量，分别是 62 和 51 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/conditional_p_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这些数字实际上是每行和每列变量位于此表边缘的总和，因此被称为边际值。请注意，这与口语上 “边缘的”，即并不重要的，并不是一回事。在表中边际值代表对于单个变量的说明，没有关于任何其他变量。例如说休息的人数不考虑性别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/conditional_p_3.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在，我们打开这个频率表通过将每个单元格数字除以总数 113 得到比例的表格。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/conditional_p_4.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在此表中，中心块包含六个位置，它们加起来等于一。同时，每列中的比例加总到底部的边缘行中的值，每行中的比例加总到右边的边缘列中的值。并且边缘行的值加起来等于边缘列的值加起来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之九 | 概率和集合</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-probability-and-sets/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-probability-and-sets/</id>
    <published>2020-01-10T08:50:24.000Z</published>
    <updated>2020-01-11T04:25:25.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合基础-——-理论概念"><a href="#集合基础-——-理论概念" class="headerlink" title="集合基础 —— 理论概念"></a>集合基础 —— 理论概念</h1><p>在这篇教程中，我将介绍一些重要概念，它们是关于 <strong>集合 (set)</strong> ，即项的数据集。这对于理解概念以及得出概率的计算规则十分有用。同时，集合的特殊性还在于它不仅可用于概率演算，还用在逻辑学中。</p><p>让我们开始吧。如之前的教程中提到的，样本空间是随机现象所有结果的数据集。举个例子，抛一枚硬币两次，有四种可能的结果。事件是样本空间的子集。例如，最后一次抛硬币你得到正面朝上。</p><p><img src="/images/set_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>我们看到，一个样本空间可以两个或更多结果完全不同的事件。比如，抛硬币两次，0 次正面朝上，1 次正面朝上， 2 次正面朝上。它们被称为 <strong>互斥 (disjoint)</strong> 的事件。另外一个术语叫 <strong>互不相容 (mutually exclusive)</strong> 。</p><p>有一对特殊的互斥事件，某个事件和它的对立面 (即这个事件不发生的事件)。这种上下文中，对立的事件被称为 <strong>补集 (complement)</strong> 。比如，这里可以是没有正面朝上和其他三种情况互为补集。</p><p><img src="/images/set_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>你也可以有多个事件共同填满完整的样本空间。这些事件被称为 <strong>完全穷尽 (collectively exhaustive)</strong> 事件。如果它们彼此不重叠，就是 <strong>相互独立，完全穷尽 (disjoint collectively exhaustive)</strong> 。互斥事件相关联的概率之和小于或者等于 1 ，完全穷尽事件的概率之和等于 1 。</p><p><img src="/images/set_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>直觉上很容易理解这些概念，它们可以通过 <strong>文氏图 (Venn diagrams)</strong> 来表达。文氏图通过简单的几何形状来呈现集合或者集合的部分。</p><a id="more"></a><p>这些矩形描绘同一个样本空间，在空间中，有一个事件 A ，剩下的部分都是事件 A 的补集。同一个样本空间里，还有另外一个事件 B ，和 A 不重叠。因此它们两者是互斥的。</p><p>如果我们把这个文氏图应用于两次抛硬币的实验，你能把四个不同的结果放进图中并且描述事件吗？</p><p><img src="/images/set_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>可以是这样的，只有一次正面朝上是事件 A ，有两次正面朝上是事件 B 。 A 的补集会包含两次反面朝上和两次正面朝上。</p><p><img src="/images/set_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>还用文氏图，两次抛硬币的实验也可以是这样的：</p><p><img src="/images/set_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>两个事件， A 和 B ，相互之间有重叠。 A 是事件 “第二次结果是正面朝上”， B 是事件 “只有一次正面朝上”。结果 “反面，正面” 会同时落在两个事件之内。“反面，反面” 也属于样本空间的一部分，但不落在 A 和 B 任何一个事件内。两个事件重叠的部分被称为 <strong>交集 (intersection)</strong> 。</p><p>事件 A 和 事件 B 的交集可以速记为:</p><script type="math/tex; mode=display">A \cap B</script><hr><p>现在，让我们来找出两个事件交集的概率。如果两个事件是互斥的，事件很简单。交集的概率为 0 。如果两个事件并不互斥，即它们重叠，事情就稍微有点复杂。</p><p>假定我们正在处理的是独立事件。也就是说，例子中抛出第二个正面的事件的概率不受只抛出一个正面的事件的影响。对于独立事件 A 和 B ，它们的交集的概率是两者各自概率的乘积。</p><p>这里，事件 A 有两种情况，所以概率是 2 / 4 。事件 B 的情况相同，概率也是 2 / 4 。因此，最后的交集的概率等于两者概率乘积，也就是 1 / 4 。</p><p><img src="/images/set_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>样本空间中不共享任何结果的事件被称为 <strong>互斥事件</strong> 或者 <strong>互不相容</strong> 。</li><li>多个事件一起填满整个样本空间，则把它们称为 <strong>完全穷尽</strong> 事件。</li><li>如果样本空间里只有两个互斥事件构成完全穷尽，那么它们互为 <strong>补集</strong> 。</li><li>互斥事件的概率之和小于或者等于 1 。完全穷尽事件的概率之和等于 1 。</li><li>事件 A 和 B 的 <strong>交集</strong> 同时是两个事件的一个子集，这个子集包含了 A 的一部分，并且这部分也是 B 的一部分。独立事件 A 和 B 的交集是通过事件 A 的概率和事件 B 的概率乘积来计算的。对于互斥事件，按照定义，交集属性等于 0 。</li></ul><hr><h1 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h1><p>这一节中，我将介绍 <strong>并集 (Union)</strong> 的概念和并集的概率。并集在现实生活中会导致一个比其各个部分集合的总和具有更多新属性的实体吗？很遗憾，在概率理论中，这种魔力是不存在的。并集只是<br>需要特别注意 —— 不要将事情加倍计算。</p><p>还是贝壳的例子，你在海滩上随机捡三个贝壳。周围只有两种贝壳， Q 和 R 。两种类型的贝壳数量相等并且你可以认为有无数。在这种情况下，样本空间包括八个结果。整个实验的树形图如下。</p><p><img src="/images/union_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>获得任何组合的概率的八分之一。让我们设定，总共捡起一个 R 贝壳作为事件 A ，总共捡起两个 R 贝壳作为事件 B 。如果我们对事件 A 发生或事件 B 发生，或者 A 和 B 同时发生感兴趣。</p><p><img src="/images/union_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>以这种方式组合事件被称为 “并集”，速记为:</p><script type="math/tex; mode=display">A \cup B</script><p>要计算关于事件 A 和 B 的并集的概率，你必须求出两个事件的总和，然后减去 A 和 B 的交集。减去交集的原因是它被计数了两次。拿到一个 R 贝壳的概率 —— 事件 A ，是八分之三。<br>拿到两个 R 贝壳的概率同样也是八分之三，它们的总和是八分之六，即四分之三。</p><p>实际上，事件 A 和 B 不分享任何结果，即他们不相交的，则他们的交集概率为零。因此，并集的概率是四分之三。</p><p><img src="/images/union_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>现在，考虑两个不同的事件。 事件 C ，你选择的第一个贝壳将会是 R 贝壳。事件 D ，最后一个贝壳 是 R 贝壳。显然，这两个事件不是互斥的，因为它们有重叠。事件 C 和 D 的交集包括<br>第一个贝壳是 R 贝壳，同时第三个贝壳也是 R 贝壳的情况。</p><p><img src="/images/union_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>通过将 C 的概率加到 D 的概率，再减去 C 和 D 的交集来找到 C 和 D 的并集，是四分之三。</p><p><img src="/images/union_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>现在挑战升级 —— 事件 A ， B ， C 和 D 的并集是？如果你把方程式机械地应用过来，事情会有些乏味，因为会有不少加法和减法的计算。</p><script type="math/tex; mode=display">P (A \cup B \cup C \cup D) = P (A) + P (B) + P (C) + P (D) \\ - (P (A \cap B) + P (B \cap C) + P (C \cap D) + P (A \cap C) + P (A \cap D) + P (B \cap D) + P (A \cap B \cap C \cap D))</script><p><img src="/images/union_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>不过，由于总的样本空间中并没有特别多的基本事件，这里有一个更简单的方法。你可以列出八个<br>基本事件，然后检查它们出现在四个组合事件中的哪一个。最后，你会发现只有一个基本事件不发生在组合事件中。从四个组合事件来看，有七个基本事件的结果是四个组合事件中的某一个的部分。因此，并集的概率是这七个基本事件之和，即八分之七。</p><p><img src="/images/union_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>多个事件的并集是这样一个事件：它包含原始事件的所有结果，并且没有重复。</li><li>几个事件的并集概率是各个事件的概率之和减去事件之间的交集的概率。</li><li>对于两个事件，等式为 $ P (A \cup B) = P (A) + P (B) - P (A \cap B) $ 。如果事件 A 和 B 互斥，则交集的概率为零。并集方程简化为 $ P (A \cup B) = P (A) + P (B) $。</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集合基础-——-理论概念&quot;&gt;&lt;a href=&quot;#集合基础-——-理论概念&quot; class=&quot;headerlink&quot; title=&quot;集合基础 —— 理论概念&quot;&gt;&lt;/a&gt;集合基础 —— 理论概念&lt;/h1&gt;&lt;p&gt;在这篇教程中，我将介绍一些重要概念，它们是关于 &lt;strong&gt;集合 (set)&lt;/strong&gt; ，即项的数据集。这对于理解概念以及得出概率的计算规则十分有用。同时，集合的特殊性还在于它不仅可用于概率演算，还用在逻辑学中。&lt;/p&gt;
&lt;p&gt;让我们开始吧。如之前的教程中提到的，样本空间是随机现象所有结果的数据集。举个例子，抛一枚硬币两次，有四种可能的结果。事件是样本空间的子集。例如，最后一次抛硬币你得到正面朝上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/set_1.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们看到，一个样本空间可以两个或更多结果完全不同的事件。比如，抛硬币两次，0 次正面朝上，1 次正面朝上， 2 次正面朝上。它们被称为 &lt;strong&gt;互斥 (disjoint)&lt;/strong&gt; 的事件。另外一个术语叫 &lt;strong&gt;互不相容 (mutually exclusive)&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;有一对特殊的互斥事件，某个事件和它的对立面 (即这个事件不发生的事件)。这种上下文中，对立的事件被称为 &lt;strong&gt;补集 (complement)&lt;/strong&gt; 。比如，这里可以是没有正面朝上和其他三种情况互为补集。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/set_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;&lt;/p&gt;
&lt;p&gt;你也可以有多个事件共同填满完整的样本空间。这些事件被称为 &lt;strong&gt;完全穷尽 (collectively exhaustive)&lt;/strong&gt; 事件。如果它们彼此不重叠，就是 &lt;strong&gt;相互独立，完全穷尽 (disjoint collectively exhaustive)&lt;/strong&gt; 。互斥事件相关联的概率之和小于或者等于 1 ，完全穷尽事件的概率之和等于 1 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/set_3.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;&lt;/p&gt;
&lt;p&gt;直觉上很容易理解这些概念，它们可以通过 &lt;strong&gt;文氏图 (Venn diagrams)&lt;/strong&gt; 来表达。文氏图通过简单的几何形状来呈现集合或者集合的部分。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之八 | 样本空间、事件和树形图</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-sample-space-events-tree-diagrams/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-sample-space-events-tree-diagrams/</id>
    <published>2020-01-09T09:16:28.000Z</published>
    <updated>2020-01-10T03:58:24.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="样本空间-sample-space"><a href="#样本空间-sample-space" class="headerlink" title="样本空间 (sample space)"></a>样本空间 (sample space)</h1><p><em>海滩是一个多变的环境 —— 尤其当天气很好的时候，有许多人，需要可以做的事情和可以看的风景。这一节教程里，海滩是我们的背景。我将向你解释几个可以帮助我们找到概率的概念，以及一个可视化的辅助工具 —— <strong>树形图 (tree diagram)</strong> 。</em></p><p>这是一个温暖的下午，你可以来点下午茶。幸运的是，你所在的海滩上，有一个卖下午茶的摊位。不过，茶点几乎快卖完了，只剩下一种类型的冰淇淋和两瓶软饮料。</p><img src="/images/sample_space.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>有点不走运的是，有三个人排在你前面。不过还有个好消息是，摊主只卖给每个顾客一件东西。由于你实在很渴望喝到眼前这冰爽的饮料，你不禁开始寻思，“我喝到饮料的机会有多大呢？” </p><img src="/images/sample_space_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>注意，你并不清楚其他顾客会做出的决定，所以他们的购买对你来说全部都是随机事件。第一个顾客可能买饮料或者冰淇淋，在这件事发生之后，第二个顾客拥有同样的选项，然后轮到第三个顾客。如果前面的两位顾客都买了饮料，那她就只剩冰淇淋可以选，否则的话，她也还有两个选项。</p><p>通过下面这幅树形图，你排序了所有可能的随机试验结果。看起来有 7 种可能的组合。这里所有随机现象的里列表我们称为 <strong>样本空间 (sample space)</strong> 。</p><a id="more"></a><img src="/images/sample_space_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如果一个随机试验有离散的结果，比如我们的这个案例，一种描绘样本空间的便捷方式是通过树形图列出所有的可能性。就像上图中我们已经做的那样。在一个树形图中，有一些中间结果的划分，跟最终分支如出一撤。任何结果，包括结果的组合，被称为 <strong>事件 （event）</strong>，因此， <strong>一个事件其实就是一个样本空间的子集</strong> 。在这个特定的案例中，你关心的事件，不走运的那些 —— 没有饮料喝了，反之，还能买到饮料。 </p><p>任何一个随机事件都有与之关联的概率，并且小的事件可以组合成大的事件。量化这些事件的概率，可以通过实验。实验可以包含在一段足够长的时间内，观察冰淇淋和饮料的销售情况。但这里时间不够，当第一个顾客正在思考要买什么的时候，你就必须做出自己的决定了。于是你诉诸另外一种策略 —— 对样本空间里的结果做出有说服力的假设。</p><p>你假定每一种事件发生的机会相等 —— 每个顾客选冰淇淋和饮料的概率都是 0.5 。在这种方式中，你可以依赖通用的概率规则。概率处于 0 到 1 之间，所有可能的结果，例如，所有选项在树形图里以节点表示，它们最终的总和也等于 1 。借助它们，你可以很快得到答案。这个答案可能帮助你做出决定：是应该保持乐观，在队伍中等着轮到自己，还是应该开始考虑寻求别的方式购买饮料。</p><p>不过，要记得，经过所有事件都已经展开，你并不知道你对于概率的评估是否正确。虽然你收集了排在你前面的三个顾客的试验信息，但对于整个购买冰淇淋和饮料这种事情来说。你的信息极其有限，并没有办法推导出十分精确的概率估算。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>样本空间是所有随机现象的结果的集合，而事件是样本空间的子集，它对应某一个随机变量的结果或者一组可能的结果。</li><li>每个事件都有概率。为了找到这些概率，你可以用到树形图。在树形图中，你可以创建样本空间，并对各种事件显式地做出假设。为了量化树形图里每个事件的概率，你可以进行实验。</li><li>某些时候，你可以对样本空间里的结果做出有说服力的假设，然后基于推理估计出它们的概率。</li><li>在任何案例中，通用的概率规则都适用于树形图。任意事件的概率都处于 0 和 1 之间，而最终所有可能的结果的概率总和等于 1 。</li></ul><hr><h1 id="用树形图量化概率"><a href="#用树形图量化概率" class="headerlink" title="用树形图量化概率"></a>用树形图量化概率</h1><p>当你在思考随机现象并且把注意力放在事件之间的关系以及它们在树形图中的概率时，你已经开始计算概率和评估某件事发生的可能性。</p><p>下面我会解释实践中树形图中的概率是如何量化的。还是上面那个例子。下面这张图显示，你假定每个顾客都有 0.5 的概率选择冰淇林或者饮料。通用概率规则适用于树形图里的每一个节点。具体来说，如果你观察图中的第一个顾客，有两个分支，每个分支 0.5 的概率。到第二个顾客，有两对分支，每对占 0.5 的概率，一对里的两个分支又各占 0.5 的概率。</p><p>如果这个时候轮到你了，你需要沿着一条路径，从第一个顾客的某个购买结果算到第二个顾客的某个购买结果。在树形图中，通过计算这条路径上所有概率的乘积来找出最终组合的事件的概率。</p><p>两个顾客之后，你还有多大的机会买到饮料呢？至少得剩一瓶饮料吧，满足这个情况的事件分支有三条，像图示中那样，总的概率是 0.75 。</p><img src="/images/tree_diagram.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>还有没有更快的算法呢？—— 利用所有概率的总和等于 1 这个规则。所以 1 减去 两瓶饮料都卖出去的概率会给到我们相同的答案。</p><p>现在我们加大难度，考虑第三个顾客了。这里有一点特殊。她在四个分支中有三个拥有两个选项，但在两瓶饮料都卖完的这个分支上，只有一个选项 —— 买冰淇淋。同时在这里，规则也需要被满足，即所有概率的总和等于 1 ，所以这个单分支的概率就等于 1 。</p><img src="/images/tree_diagram_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>现在我们回到你买到饮料的机会上。我们需要算出四条分支的概率总和，即轮到你之前最多一瓶饮料被卖掉的概率总和。每条分支的概率等于 0.5 的三次方，即 0.125 ，加起来是 0.5。</p><img src="/images/tree_diagram_1_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><hr><p>上面我们演示了利用树形图找出概率的变量，但也有必要指出一些需要注意的事情。首先是树形图可以很从容地处理小问题，对于理解有很多结果的随机现象，它并不是很适合 —— 它会变得很庞大，无助于保持概览。</p><img src="/images/tree_diagram_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>其次，为了实际应用树形图来量化概率，需要每个节点的概率规格。这在有的时候是很容易的，比如你假定每个选项机会均等，并且独立于前面的选择。另一方面，它也可能很困难。</p><p>举个例子，假如第二个顾客的购买选择会受到第一个顾客的影响怎么办呢？</p><img src="/images/tree_diagram_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>在树形图中，你可以创建样本空间，并对各种事件显式做出假定，包括每个事件的概率，它们在序列之中的相互独立性。</li><li>你可以在树形图中计算组合事件的概率。为了计算沿着一系列分支的从起点到结果的概率，所有的概率需要相乘。而为了找到某个包含很多种结果的事件的概率，所有这些结果的概率则需要相加。</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;样本空间-sample-space&quot;&gt;&lt;a href=&quot;#样本空间-sample-space&quot; class=&quot;headerlink&quot; title=&quot;样本空间 (sample space)&quot;&gt;&lt;/a&gt;样本空间 (sample space)&lt;/h1&gt;&lt;p&gt;&lt;em&gt;海滩是一个多变的环境 —— 尤其当天气很好的时候，有许多人，需要可以做的事情和可以看的风景。这一节教程里，海滩是我们的背景。我将向你解释几个可以帮助我们找到概率的概念，以及一个可视化的辅助工具 —— &lt;strong&gt;树形图 (tree diagram)&lt;/strong&gt; 。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这是一个温暖的下午，你可以来点下午茶。幸运的是，你所在的海滩上，有一个卖下午茶的摊位。不过，茶点几乎快卖完了，只剩下一种类型的冰淇淋和两瓶软饮料。&lt;/p&gt;
&lt;img src=&quot;/images/sample_space.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;有点不走运的是，有三个人排在你前面。不过还有个好消息是，摊主只卖给每个顾客一件东西。由于你实在很渴望喝到眼前这冰爽的饮料，你不禁开始寻思，“我喝到饮料的机会有多大呢？” &lt;/p&gt;
&lt;img src=&quot;/images/sample_space_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;注意，你并不清楚其他顾客会做出的决定，所以他们的购买对你来说全部都是随机事件。第一个顾客可能买饮料或者冰淇淋，在这件事发生之后，第二个顾客拥有同样的选项，然后轮到第三个顾客。如果前面的两位顾客都买了饮料，那她就只剩冰淇淋可以选，否则的话，她也还有两个选项。&lt;/p&gt;
&lt;p&gt;通过下面这幅树形图，你排序了所有可能的随机试验结果。看起来有 7 种可能的组合。这里所有随机现象的里列表我们称为 &lt;strong&gt;样本空间 (sample space)&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之七 | 概率和随机性</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-probability-and-randomness/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-probability-and-randomness/</id>
    <published>2020-01-09T05:48:50.000Z</published>
    <updated>2020-01-09T09:21:26.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="随机性-（randomness）"><a href="#随机性-（randomness）" class="headerlink" title="随机性 （randomness）"></a>随机性 （randomness）</h1><p>识别和理解随机性，和推断它是一样重要的技能。它们不仅在统计分析中有用，对于每天发生在我们身边的日常事物，同样有意义。这篇教程中，我将向你解释为什么人们如此不擅长应对随机性。</p><p>想象你在海滩上看着海浪翻滚，然后你注意到一枚美丽的贝壳，它的个头和形状明显地异于周围其它贝壳。于是你想想看附近还有有没有这种贝壳。这是一项无法预见的行动计划 —— 贝壳可能是随机分布在这个巨大的海滩上的。因此，你找到另外一枚同类贝壳的时间是不确定的，甚至你都可能找不到一枚相似的。</p><p>你开始思考这件事，然后你意识到随机性几乎在日常生活中无处不在。所以，无怪乎我们有丰富的词汇来描述它，比如不确定性、机会、风险、可能性。还有，变异性和不确定性的程度能够非常精细地描述随机性。</p><p>看看下面这组词汇：罕有、少见、有时、普通、频繁、经常。有意思的是，某件事是否随机，不仅是现象自身的特性，也很大程度上取决于我们对它的认识。假如你之前就来过这片海滩，你可能已经发现过这种贝壳，从而改变这一次的搜索策略，以便增加找到更多这种贝壳的机会。你搜索的尺度也有关系，如果在很小的区域做一个短暂的搜索，可能不是很有把握找到新贝壳，但是搜索时间延长，搜索区域扩大，找到机会就会增大。</p><p>尽管有这么多的词汇，以及我们在日常经验中熟记随机性的能力，我们其实一点都不擅长量化地评估随机性。一方面，我们在真实的随机数据中寻找各种 “模式”。你一定听过一个词叫 “宿命”。另一方面，我们自身又无法制造随机熟记。有一个失败尝试的案例 —— 下图中左边的通过拼接得到的贝壳随机分布的地图，实际上是分布太规则的。而右边那幅是现实的随机分布模式，看起来有更多聚集在一起的 “簇”。</p><p><img src="/images/randomness.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><a id="more"></a><p>另外一个被我们用来解释随机性的例子叫 “赌徒谬误” —— 它的错误之处在于用一系列前面发生的随机现象预测未来的随机现象。人们没有意识到的是，如果你连续掷出了四次 6 ，感觉上不太可能再第五次掷出 6 。然后，这个投掷的结果为 6 的概率之前是 六分之一，之前是，现在还是。</p><p><img src="/images/randomness_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>我们之所以应对随机性孱弱，原因在于我们的大脑倾向于用记忆模式的方式衡量随机性。考量到这一点，为了量化随机性、理性思考随机性并且产出现实可行的随机模式，学习正确的方法十分重要。它们帮助我们避免错误，更准确和更有效地对我们周遭的世界做出预测。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>随机性并非一个现象的内在属性，它同时取决于我们对它的知识，观察方法以及我们关注它的尺度。尽管有大量表达随机性的词汇，人类天生不擅长量化评估它。我们困于宿命论，困于对某些纯随机模式的过度解读，这些操作同时也不利于构建随机性。</p><hr><h1 id="概率-probability"><a href="#概率-probability" class="headerlink" title="概率 (probability)"></a>概率 (probability)</h1><blockquote><p>坚持不懈，终有所成。</p></blockquote><p>尽管已经有很多关于这个概念的箴言和引证，我想再加一句 —— “毅力战胜一切”。这一节中，我将一步步引导你学会用概率来量化随机性。</p><p>人类的大脑也许并不是很适合回答随机性。但幸运的是，有一个基础的机制，它的运转极大地简化了我们的生活 —— 随机性会发生变化，从事物可变、案例稀少且无法预测，到事物恒定、案例庞大且可以预测。对于这个基础，我们甚至有一个数学上的证据，它就是 <strong>大数定律</strong> 。它有赖于独立性，也就是说，某个随机现象的结果，不受之前结果的影响。</p><p>让我举个例子，说明大数定律在现实生活中是长什么样子。还是想象你在海滩，决定搜寻贝壳。很快，你发现了海滩一共有四种类型的贝壳，随机分布，数量相等，就像下图这样：</p><p><img src="/images/possibility.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>现在，你需要数出一个 Q 贝壳的分数，可以通过选取操作来完成。比如，随机选 20 个贝壳，然后计算这 20 个样本里 Q 贝壳的数量。结果如下：</p><p><img src="/images/possibility_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>如你所见，20 个贝壳只有 2 个 Q 贝壳。 <strong>相对频率 (relative frequency)</strong> 是十分之一。基于你的推理，这个分数本来应该是在四分之一左右。 但是，你也知道，小样本的不规则性，是随机性的本质。所以呢？“保持冷静，继续前进。”</p><p><img src="/images/possibility_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>不着急下结论，继续选取更多的贝壳，观察比例如何变化，一直演化到四分之一 —— 这种比例被称为 <strong>“累积比例 (cumulative proportion)”</strong> 。</p><p><img src="/images/possibility_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>每一次你随机选取新的贝壳时，都被看作是一次可能带来 Q、R、S、T 四种贝壳之一的机会实现。用概率的术语来说，操作的结果，也就是你拿到的贝壳的类型，被称为 <strong>事件 (event)</strong> 。选取贝壳的这个行为被称为 <strong>独立试验 (independent trial)</strong> 。整个做这么多试验的事情被称为 <strong>实验 (experiment)</strong> 。在计算相对频率的时候，因为你用贝壳总数除每一种类型的贝壳，有两个属性将始终满足：每一个类型的概率将大于等于 0 或者小于等于 1 ；所有随机现象的结果的概率总和将等于 1 。</p><p><img src="/images/possibility_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>不过，现在让我们回到现实。生活并不是海滩，当然也不会有随机分布的贝壳。在日常生活中，纯粹的独立试验并不常见。通常，在随机事件之间存在 <strong>相互依赖 (interdependent)</strong> 。尽管如此，通过简化的假定，概率经常还是可以被很好地量化。此外，你需要拿到充足数量的样本，以便大数定律能发挥作用，确保你要估计的概率接近它的实际值。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>概率是一种量化随机性的方法，它可以用相对频率的均值来表示。根据这个定义，概率会始终大于等于 0 ，并 IE 小于等于 1 。所有可能事件的概率总和等于 1 。</li><li>正式的定义用到了实验、事件和独立试验的概念。某个事件的概率是通过它出现在整个实验中的相对频率来计算的。实验包含一系列独立试验。举个例子，掷骰子是一个事件，而每次掷出是一个独立试验。</li><li>让大数定律发挥作用的好方法是保持冷静，持续试验，直到 <strong>累积概率 (cumulative probability)</strong> 不怎么变化为止。</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;随机性-（randomness）&quot;&gt;&lt;a href=&quot;#随机性-（randomness）&quot; class=&quot;headerlink&quot; title=&quot;随机性 （randomness）&quot;&gt;&lt;/a&gt;随机性 （randomness）&lt;/h1&gt;&lt;p&gt;识别和理解随机性，和推断它是一样重要的技能。它们不仅在统计分析中有用，对于每天发生在我们身边的日常事物，同样有意义。这篇教程中，我将向你解释为什么人们如此不擅长应对随机性。&lt;/p&gt;
&lt;p&gt;想象你在海滩上看着海浪翻滚，然后你注意到一枚美丽的贝壳，它的个头和形状明显地异于周围其它贝壳。于是你想想看附近还有有没有这种贝壳。这是一项无法预见的行动计划 —— 贝壳可能是随机分布在这个巨大的海滩上的。因此，你找到另外一枚同类贝壳的时间是不确定的，甚至你都可能找不到一枚相似的。&lt;/p&gt;
&lt;p&gt;你开始思考这件事，然后你意识到随机性几乎在日常生活中无处不在。所以，无怪乎我们有丰富的词汇来描述它，比如不确定性、机会、风险、可能性。还有，变异性和不确定性的程度能够非常精细地描述随机性。&lt;/p&gt;
&lt;p&gt;看看下面这组词汇：罕有、少见、有时、普通、频繁、经常。有意思的是，某件事是否随机，不仅是现象自身的特性，也很大程度上取决于我们对它的认识。假如你之前就来过这片海滩，你可能已经发现过这种贝壳，从而改变这一次的搜索策略，以便增加找到更多这种贝壳的机会。你搜索的尺度也有关系，如果在很小的区域做一个短暂的搜索，可能不是很有把握找到新贝壳，但是搜索时间延长，搜索区域扩大，找到机会就会增大。&lt;/p&gt;
&lt;p&gt;尽管有这么多的词汇，以及我们在日常经验中熟记随机性的能力，我们其实一点都不擅长量化地评估随机性。一方面，我们在真实的随机数据中寻找各种 “模式”。你一定听过一个词叫 “宿命”。另一方面，我们自身又无法制造随机熟记。有一个失败尝试的案例 —— 下图中左边的通过拼接得到的贝壳随机分布的地图，实际上是分布太规则的。而右边那幅是现实的随机分布模式，看起来有更多聚集在一起的 “簇”。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/randomness.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之六 | 回归</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-regression/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-regression/</id>
    <published>2020-01-02T04:50:17.000Z</published>
    <updated>2020-01-09T03:25:15.197Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回归-——-找到-“那根线”！"><a href="#回归-——-找到-“那根线”！" class="headerlink" title="回归 —— 找到 “那根线”！"></a>回归 —— 找到 “那根线”！</h1><p>最近的一项研究表明，吃大量的巧克力可能是个好主意。</p><img src="/images/regression.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这个散点图展示了一个国家每个人年均消费的巧克力数量。可以看出，一年中人们吃的巧克力数量，跟这个国家每百万人口中的诺贝尔奖获得者人数，呈正相关性。</p><p>注意，这个散点图里的巧克力消耗量显示为自变量，而诺贝尔奖获得者人数显示为因变量。</p><p>散点图里分析的单位是国家。如你所见，相关性很高。实际上，这里的皮尔逊相关系数是 0.93 。这说明，多吃巧克力虽然可能令你发胖，但同时也让你变聪明。皮尔逊相关系数告诉我们，两个连续变量之间的线性相关性有多强，这种线性相关性被显示为一根直线。在我们的案例中，是这条线。</p><img src="/images/regression_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这就是我们所说的 <strong>回归线 (regression line)</strong> 。在本节教程中，我将告诉你如何找到回归线。重要的是要知道我们如何找到这条线，而不仅仅是因为回归线向你展示了两个变量之间的关系。 <em>找到回归线是许多统计分析的基础。</em></p><p>那么，我们如何找到回归线呢？想象你正在绘制散点图里每一条可能的直线。所以，你像下面这样画了许多可能的线。这是一组数量巨大的线。实际上，这几乎不可能做到。不过，暂时想象你有超能力 —— 你能做到这一点。</p><a id="more"></a><img src="/images/regression_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>接下来，你可以测量每条可能的线与每个案例之间的距离。在我们的例子，即线到每个国旗之间的距离。</p><p>让我给你举一个基于随机线的例子，比如，下面这个。测量日本和线的之间的垂直距离，西班牙和线之间的距离等等。直到你知道你的研究中每个案例的距离。</p><img src="/images/regression_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>每一个距离都被称为 <strong>残差 (residual)</strong>，你最终会得到正的残差，它们以线之上的案例到线之间的蓝色线段展示；以及负的残差，它们以线之下的案例到线之间的红色线段展示。</p><p>你为每一条可能的线测量残差。最终，我们选择一条能够 <em>使得残差的平方和最小的线</em> ，这便是我们要找的那根线。</p><img src="/images/regression_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>为什么是残差的平方和呢？因为正的残差和负的残差会相互抵消。</p><p>最佳拟合的线被称为 <strong>回归线</strong> ，分析的方法被称为 <strong>普通最小二乘回归 (ordinary least squares regression)</strong> ，这是指我们找到这条线的方式。</p><p>在实践中，几乎不可能绘制每一条可能的线和残差的和。幸运的是，数学家已经找到了寻找回归线的技巧。我不会解释这个把戏在这里是如何运作的，因为它相当复杂。目前为止，知道它基于残差的平方和就已经足够了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>你学到两件事：第一，你学会如何计算并寻找回归线；第二，你了解到，吃巧克力很可能有助于你通过这门课程。:D</p></blockquote><hr><h1 id="回归-——-描述-“那根线”"><a href="#回归-——-描述-“那根线”" class="headerlink" title="回归 —— 描述 “那根线”"></a>回归 —— 描述 “那根线”</h1><p>回归线是最好地描述两个变量之间线性关系的直线。但我们要如何描述这条线的样子呢？</p><p>这是一个非常重要的问题，因为通过用公式描述，我们可以很容易地把 <strong>回归的分析 (regression analysis)</strong> 传达给其他人，预测其他国家的诺贝尔奖获得者人数，以及确定不符合该模式的国家。基于此散点图中的回归线，我们可以预测：每年巧克力人均消费量为 6 公斤的国家，平均每 1000 万个人中有 11 位诺贝尔奖获得者。</p><img src="/images/regression_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>同样，基于同一条线，我们将预测一个每年人均巧克力消费量为 11 公斤的国家，平均每 1000 万人中 会有 25 个诺贝奖获得者。</p><img src="/images/regression_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>对大多数国家来说，这一预测并不完全正确。毕竟，大多数国家并不恰好在回归线上。然而，这是我们能做出的最好的预测 —— 根据我们掌握的信息。</p><img src="/images/regression_8.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>有一个简单的公式，我们可以用它来描述回归线。这就是那个公式。 </p><p>$$\hat y = a + bx$$</p><p>$\hat y$ 不是 y 的实际值，但它表示 y 的预测值。例如，当 x 等于 12 时， $\hat y$ 等于 28 。 请注意，在这种情况下， y 的实际值为 33 。但是， y 的预测值是回归线上的 y 的值。这意味着，正好在回归线上所有的值是 $\hat y$ 。</p><p>a 就是我们所说的 <strong>截距</strong> ，它是一个常数。当 x 等于 0 时，它是 y 的预测值。换句话说，当回归线上 y 的预测值与 y 轴的相交时， x 等于 0 。在我们的案例里，它是 -5.63 。请注意，这个值没有实质性的含义。不可能每 1000 万人中有 -5.63 名诺贝尔奖获得者。它只有一个目的：描述回归线的数学性质。</p><p>b 就是我们所说的 <strong>回归系数 (regression coefficient)</strong> 或 <strong>斜率 （regression slope）</strong> 。 它是当 x 增加一个单位时， $\hat y$ 的变化。在我们的例子中，我们看到当 x 增加一个单位，例如，从 4 到 5， y 的预测值增加 2.80 个单位。</p><p>因为是一条直线，回归线的斜率是处处相等的。所以，如果我们看看当 x 从 8 增加到 9 时会发生什么， $\hat y$ 也是增加 2.80 单位。我们案例中的回归系数为 2.80 。这可以推导出下面这个 <strong>回归方程 (regression equation)</strong>。 </p><p>$$ \hat y = 5.63 + 2.80x $$</p><p>请看这两条回归线。它们具有相同的回归系数或 b 值。 当 x 增加一个单位时，第一条线和第二条线的 y 值增长的量是一样的。但是，这些线具有不同的截距，或一个值。毕竟，它们在不同的位置上穿过 y 轴。</p><img src="/images/regression_9.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这两条回归线具有不同的回归系数。当 x 增加一个单位时，第一条线上的 $\hat y$ 比第二号线上的 $\hat y$ 增加地更多。然而，这两条线的截距是相同的，因为它们在同一个点穿过 y 轴。</p><img src="/images/regression_10.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我已经对你说过了，我们可以用回归线来预测 y 值 —— 基于给定的 x 值。我们还可以使用回归公式进行预测。让我们用一个回归公式。 $\hat y = -5.63 + 2.80x$ 。我们可以使用公式预测 y 值。如果 x = 3.5，该怎么办？我们得到 -5.63 + (2.80 * 3.5)。 这就得出了 4.17 。 所以这里的 $\hat y = 4.17$ 。 如果 x = 10.21，该怎么办？ 然后你得到 -5.63 + (2.80 x 10.21) 。 这使得 $\hat y$ 等于 22.96 。 当我们只看回归线时，我们得到了相同的值。对于 x 值等于 3.5 时，我们得到的预测 y 值约为 4 。 对于 x 值等于 10.21 时，我们得到的 $\hat y$ 值约为 23 。 你已经可以看到，使用公式有一个巨大的优势 —— 你可以做出更精确的预测。</p><p>通常情况下，计算机会为你找到回归线，所以你不需要自己计算。然而，当你知道你的变量的均值和标准差，以及相应的皮尔逊系数，你可以通过两个公式计算回归方程。</p><p>$$b = r\left (\frac {s_y}{s_x}\right)$$<br>$$a = \bar y - b (\bar x)$$</p><p>第一个公式通过将皮尔逊的回归系数乘以 y 的标准差，再除以 x 的标准差。这表明了回归系数事实上是皮尔逊系数的一个不标准化的版本。当 pearson 的 r 等于 0 时，回归系数等于 0 。当皮尔逊的 r 是一个正数，回归系数也是正数，当皮尔逊系数为负时，回归系数也是负的。</p><img src="/images/regression_11.jpg" width="68%" height="68%" style="margin: 10 auto;">这些是我们的研究的均值、标准差和皮尔逊系数。因此，为了找到回归系数，我们乘以 0.93 * (11.87/3.95)，结果是 2.79 。第二个公式用回归系数乘 x 的均值，之后从 y 的均值减去结果来计算截距。<p>所以 13.17-(2.79 * 6.71) 。 这样就可以得到 -5.55 了。回归方程为 -5.55 + 2.79 x 。</p><p>与这一个计算机算出的回归方程的不同是由舍入误差导致的。我用汇总均值、标准差和皮尔逊系数来计算，这导致了一个不太精确的回归方程。因此，在使用这些公式时，尽量减少舍入。恭喜你成功完成了这个教程的上半部分！现在，你可以进行回归分析并计算预测值了。了解回归的基础知识是至关重要的，因为能够了解之后的推理回归过程。</p><p>所以多看这篇教程几次。:D</p><blockquote><p>如果自变量 x 是你看这篇教程的次数，并且因变量 y 是你掌握的回归分析的知识，当你这样做时，回归分析的回归斜率将是一个正数。</p></blockquote><p>如果你不明白上面这句话意味着什么，立即重温这篇教程吧。</p><hr><h1 id="回归-——-“那根线有多适用？”"><a href="#回归-——-“那根线有多适用？”" class="headerlink" title="回归 —— “那根线有多适用？”"></a>回归 —— “那根线有多适用？”</h1><p>在这一节，我们来研究回归线对你的数据有多适用。</p><p>为什么需要关注回归线的适用程度呢？因为我们希望知道回归分析预测因变量的准确性有多高。回归线适用数据的程度是用一种称为 <strong>R 方 (r-squared)</strong> 的方法来表示的。</p><p>想象一下，你身处一个有 99 个其他学生的班级，你刚刚参加完一场统计学的考试。你的教授手上已经拿到随机选取的 20 个学生的考试成绩。教授想要分享这 20 个学生的考试成绩，但同时不想让大家知道这些学生是谁。因此，她匿名了这些分数的主人。</p><img src="/images/r_squared.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这是你看到的分数。因为是匿名的，你无从得知哪个学生拿到哪个分数。注意，最低分数是 0 ，最高分数是 10 。现在，想象你被要求预测你邻桌同学的分数。你怎么预测得到的分数会更靠谱呢？一个显而易见的答案是，用这 20 个分数的平均值，这个值时 6.8 。现在，继续想象教授还给了你这 20 个分数对应学生上一次统计学考试的分数，同样也是匿名的。结果如下：</p><img src="/images/r_squared_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>现在，你会如何预测你邻桌的分数呢？是的，你可以利用到回归分析了。下面是回归线和 <strong>回归方程 (regression equation)</strong> 的散点图。</p><img src="/images/r_squared_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>你会发现，那些在之前的考试中取得高分的同学趋向于在这一次考试中也拿到高分。实际上，你可以用这条回归线和对应的回归方程对分数做出预测。当你问到你的邻桌他之前的分数，你可以用回归线预测他这一次考试最有可能的分数。</p><img src="/images/r_squared_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>想象上一次分数是 8.1 ，代入回归方程，得到 2.80 加 (0.59 乘以 x)，等于 7.6 。因此，这一次的分数最有可能是 7.6 。这是什么意思呢？当你只有一个变量的信息时，你做出的预测的准确性要远远低于你拥有两个相关变量信息的情况。R 方就是一个告诉你用回归线预测因变量而不是平均值这种方式有多适用的程度。</p><p>再回到我们的散点图。我加了一根水平线，用以表示这次考试分数的平均值。</p><img src="/images/r_squared_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这根线之所以是水平的，是因为平均值是一个定值 6.8 ，它不会改变。可以看到，每个观察值和回归线的残差，相比于它们到平均值的残差，总体要小得多。</p><img src="/images/r_squared_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这表明，回归线的预测效果明显好于平均值。</p><p>在我们的案例中， R 方是 0.69 。这表示使用回归线预测错误的可能性比你使用平均值要小 69% 。 R 方也经常用另外一种说法来解释 —— 它是指你的因变量的方差，多大程度上可以由自变量的方差来解释。</p><p>一个变量的方差告诉你各个观察值相对于平均值的离散程度。因此，在我们的案例中，这一次考试分数的方差中的 69% ，可以被前一次考试的分数预测。用可视化的方式表达这种解释，可以用到两个圆。</p><img src="/images/r_squared_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>左边的圆表示自变量的方差，右边的圆表示因变量的方差。重叠的部分就是 R 方，或者说 <strong>可解释方差 (explained variance)</strong> 。当重叠部分很小时， R 方很小，重叠部分很大时， R 方很大。</p><img src="/images/r_squared_8.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>你需要了解一个很重要的事实 —— R 方和皮尔逊相关系数关联紧密。实际上，正如它的名字指示的， R 方就是皮尔逊相关系数的平方。因此，要计算 R 方，只要算出皮尔逊系数然后平方就行了。</p><p>这也说明 R 方总是一个正数。在我们的案例中，皮尔逊相关系数等于 0.83 。平方得到 R 方 0.69 。注意，如果两个变量的线性相关性是完美的，那么皮尔逊相关系数和 R 方都是 1 。如果完全线性无关，那皮尔逊相关系数和 R 方都是 0 。</p><p>但是，你需要记住： R 方的含义和皮尔逊相关系数很不同。皮尔逊相关系数告诉你两个变量之间是否存在正的或者负的相关性，以及这种相关性有多强。而 R 方并没有告诉你两个变量之间关联的方向。不过，它告诉你两件事，一是回归线预测相对于平均值预测优胜多少，二是因变量的方差有多少是可以被自变量的方差解释的。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;回归-——-找到-“那根线”！&quot;&gt;&lt;a href=&quot;#回归-——-找到-“那根线”！&quot; class=&quot;headerlink&quot; title=&quot;回归 —— 找到 “那根线”！&quot;&gt;&lt;/a&gt;回归 —— 找到 “那根线”！&lt;/h1&gt;&lt;p&gt;最近的一项研究表明，吃大量的巧克力可能是个好主意。&lt;/p&gt;
&lt;img src=&quot;/images/regression.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;这个散点图展示了一个国家每个人年均消费的巧克力数量。可以看出，一年中人们吃的巧克力数量，跟这个国家每百万人口中的诺贝尔奖获得者人数，呈正相关性。&lt;/p&gt;
&lt;p&gt;注意，这个散点图里的巧克力消耗量显示为自变量，而诺贝尔奖获得者人数显示为因变量。&lt;/p&gt;
&lt;p&gt;散点图里分析的单位是国家。如你所见，相关性很高。实际上，这里的皮尔逊相关系数是 0.93 。这说明，多吃巧克力虽然可能令你发胖，但同时也让你变聪明。皮尔逊相关系数告诉我们，两个连续变量之间的线性相关性有多强，这种线性相关性被显示为一根直线。在我们的案例中，是这条线。&lt;/p&gt;
&lt;img src=&quot;/images/regression_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;这就是我们所说的 &lt;strong&gt;回归线 (regression line)&lt;/strong&gt; 。在本节教程中，我将告诉你如何找到回归线。重要的是要知道我们如何找到这条线，而不仅仅是因为回归线向你展示了两个变量之间的关系。 &lt;em&gt;找到回归线是许多统计分析的基础。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;那么，我们如何找到回归线呢？想象你正在绘制散点图里每一条可能的直线。所以，你像下面这样画了许多可能的线。这是一组数量巨大的线。实际上，这几乎不可能做到。不过，暂时想象你有超能力 —— 你能做到这一点。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之五 | 相关性</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-correlation/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-correlation/</id>
    <published>2020-01-02T01:28:57.000Z</published>
    <updated>2020-01-08T08:59:51.811Z</updated>
    
    <content type="html"><![CDATA[<p>很多人喜欢吃巧克力，但多数人吃巧克力是比较谨慎的。因为吃了太多巧克力，很有可能会增加体重。在这一期的教程中，我将讨论如何使用表格和图表展示 <em>两个变量之间的关系</em> 。这有助于发现两个变量之间是否存在 <strong>相关性 (correlation)</strong> 。</p><h1 id="列联表-Contingency-Tables"><a href="#列联表-Contingency-Tables" class="headerlink" title="列联表 (Contingency Tables)"></a>列联表 (Contingency Tables)</h1><p>我们来进一步研究吃巧克力和体重之间的关系。</p><p>假设我在我们学校选择了 200 名女学生。她们身高都是一米七。这样，身高就是一个常数，不会影响体重或吃巧克力。让学生报告体重及每周巧克力消费情况。体重可以选择这样几个类别：小于 50 公斤； 50 至 69 公斤； 70 至 89 公斤和 90 公斤或以上。巧克力消费量可以选择这样几个类别：每周少于 50 克；每周 50 至 150 克；每周超过 150 克。</p><p>结果如下，这里看到的是 <strong>列联表</strong> 。 <strong>列联表</strong> 能够显示 <strong>两个定序或定类变量之间的关系</strong> 。 它类似于频率表，但主要区别在于 <strong>频率表始终只考虑一个变量，而列联表考虑两个变量</strong> 。</p><a id="more"></a><p>在我们的研究中，有两个变量：体重和巧克力消费量。</p><p><img src="/images/crosstab.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>该表显示我们有 33 个体重小于 50 公斤的样本 其中 27 人每周吃巧克力少于 50 克。还可以看到，每周有 90 人吃 50 至 150 克巧克力，其中 7 个体重 90 公斤及以上。</p><p>这种情况下，该表并不能提供两个变量之间的相关性信息，因为列和行包含不同数量的个案 —— 计算百分比可以提供更多洞察力。这种情况下，我们计算列的百分比，这意味着对于每个单元格，我们计算该单元格中的案例百分比，与相应列中的案例总数进行比较。</p><p>结果如示：</p><p><img src="/images/crosstab_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>我们也可以将这些百分比表示为比例: 45％ 则变为 0.45， 38％ 变为 0.38 。我们将这些比例称为 <strong>条件比例 (conditional proportions)</strong> —— 因为形成需要以另一个变量为前提条件。在这种情况下，该变量是巧克力消费量。</p><p><img src="/images/crosstab_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>我们也可以忽略巧克力消费的信息，并使用表格边缘的计数。这些都是 <strong>边际比例 (marginal proportions)</strong> 。例如， 33 除以 200 等于 0.17 。这个比例显示，研究中比例是 0.17 或 17％ 的受访者中，重量不到 50 公斤。</p><p><img src="/images/crosstab_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>这是什么意思呢？ 在每周吃巧克力超过 150 克的样本中， 56％ 的人体重达 90 公斤及以上；吃巧克力少于 50 克的样本中，只有 5％ 体重为 90 公斤或以上；另外，那些吃巧克力不到 50 克的人， 45％ 的人体重不到 50 公斤，而吃巧克力超过 150 克的人，只有 2％ 的体重不到 50 公斤。</p><p><img src="/images/crosstab_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>这些百分比表明：吃更多巧克力的人也更容易超重，而少吃巧克力的人也更可能体重较小。换句话说，<em>百分比表明巧克力消费量与体重之间存在相关性。</em></p><hr><h1 id="散点图-Scatterplot"><a href="#散点图-Scatterplot" class="headerlink" title="散点图 (Scatterplot)"></a>散点图 (Scatterplot)</h1><ul><li>列联表对定类和定序变量很有用，但不适用于定量变量。<em>对于定量变量，散点图更合适。</em> 假设没有提供类别，而是让 200 名女性给出确切的体重，例如 65 或 72 公斤。假设也要求他们告知每周吃巧克力的确切重量，例如每周可以是 64 克或 99 克。现在，有比之前更精确的信息展示定量变量，巧克力消费和体重之间关系的最佳方法是使用 <strong>散点图</strong> 。</li></ul><p>制作散点图，我们绘制两条线，称之为 <strong>轴</strong> 。我们将水平轴称为 <strong>X 轴</strong> 。这里展示的是 <strong>自变量 (independent variable)</strong> ，垂直轴称为 <strong>Y 轴</strong> ，我们用它来表示 <strong>因变量 (dependent variable)</strong> 。如果因变量和自变量之间没有区别，则 Y 轴和 X 轴上的位置是一个选择问题。在我们的例子中，自变量是巧克力消耗量，因变量是体重。</p><p>假如我们的研究表明，最少的巧克力消耗等于每周零克，最高的量是每周 700 克。我们在 x 轴上标注这些值；同样，体重的最小值为 40 公斤，最大值为 110 公斤。</p><p><img src="/images/scatterplot.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>接着我们在此图中显示每个人，为样本中的所有人做标注，这就绘制出了一幅散点图。散点图一目了然地显示巧克力消费量与体重之间存在相关性：吃的巧克力越多，体重就越高。</p><p><img src="/images/scatterplot_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><blockquote><p>大家学到了什么呢？不止于巧克力消耗量和体重的相关关系，我想大多数人已经意识到了：我们可以通过表格和图表显示 <strong>两个变量之间的关系</strong> ，<strong>当研究中的变量是定类或定序变量时，我们使用列联表；当它们是定量测量时，我们使用散点图</strong> 。</p></blockquote><hr><h1 id="皮尔逊积矩相关系数-Pearson’s-r"><a href="#皮尔逊积矩相关系数-Pearson’s-r" class="headerlink" title="皮尔逊积矩相关系数 (Pearson’s r)"></a>皮尔逊积矩相关系数 (Pearson’s r)</h1><p>散点图一目了然地表明两个变量之间存在很强的相关性，但 <strong>这种相关性有多强</strong> ？我们现在将要讨论最常用的相关性度量方法之一 —— <strong>皮尔逊积矩相关系数</strong> 。皮尔逊相关系数最重要的优点之一是：它用一个数字表示两个变量之间线性相关的 <strong>方向</strong> 和 <strong>强度</strong> 。</p><p>巧克力消费和体重之间的关系可以用这条直线来描述。因为所有案例都紧密围绕这条线，所以可以得出结论，这是一个相当强的相关性关系。</p><p><img src="/images/pearsonsr.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>另一个需要注意的点是，直线向上延伸，表明更多的巧克力消耗与更高的体重相关。因此，也可以说存在 <strong>正相关</strong> 关系。结论：这里存在一个强正向线性关系。</p><p>然而，变量也可以以不同的方式相关联。</p><p><img src="/images/correlation.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>在上图的第一幅图中，可以看到变量 x 和 y 之间存在相当强的正向线性关系，如同巧克力消费和体重的示例一样；而在第二幅图中，存在一个相当强的负向线性相关性 —— 直线向下表示当变量 x 上升时，变量 y 下降。第三幅图也可以看到正向线性关系，但是它比之前的强度要小得多 —— 因为每个案例都远离直线。第四幅图则是一个完全负向线性相关。之所以说完全的，是因为所有案例都完全落在线上。</p><p>但两个变量之间的相关性不必是线性的。在第五幅图中，可以看到变量 x 和 y 之间的关系。最能代表两个变量之间关系的线并不是直线。相反，是一个 U 形线，我们称之为曲线关系。</p><blockquote><p>散点图有助于我们总体评估相关性是强还是弱，但它并没有告诉我们这种关系强度到底是多少。皮尔逊相关系数恰巧可以展示确切数字 —— 更具体地说，皮尔逊相关系可以告诉我们 <strong>两个定量变量之间线性关系的方向和精确强度</strong> 。正皮尔逊相关系数表示相关性为正，而负系数表示相关性为负。</p></blockquote><p>系数的大小表示 <strong>观测结果围绕数据假想最佳拟合直线的紧密程度</strong> 。<em>皮尔逊相关系数是始终介于 -1 和 1 之间的数字：负 1 表示完全负相关；正 1 表示完全正相关； 0 表示完全没有相关性。</em></p><p>那如何计算皮尔逊相关系数呢？试想巧克力消费和体重的研究不是 200 个样本，而是四个样本。</p><p>下面是数据矩阵和散点图：</p><p><img src="/images/pearsonr_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>可以看到两个变量的每个值的组合在图形中变为一个圆点。要计算皮尔逊相关系数，我们需要这个公式：</p><script type="math/tex; mode=display">r = \frac {\sum {Z_xZ_y}}{n - 1}</script><p>这是什么意思呢？首先将所有原始分数改为 z 分数，换句话说，标准化所有数值 —— 原因是我们希望皮尔逊相关系数是介于 -1 和 1 之间的数字 。如果不进行标准化，相关性将会以原始数据呈现。</p><p>首先，我们计算两个变量的均值：变量 x 的值为 162.5 ，即巧克力消耗量；变量 y 的值为 71.25 ，即体重。然后计算两个变量的标准差， x 的结果为 110.9 ， y 的结果为 18.4。再然后计算每个案例的 z 分数，从每个值中减去均值，然后除以标准差。</p><p>为自变量的每个值，即巧克力消耗量，因变量的每个值，即体重，进行如此计算。下一步，计算 y 值 z 分数和 x 值 z 分数的乘积。 </p><p><img src="/images/pearsonr_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>计算公式的最后一部分，将所有这些 z 分数的乘积相加，将得数除以 n 减 1。所以在我们的例子中，皮尔逊相关系数是 2.78 除以 (4 - 1) ，等于 0.93 。这是什么意思呢 —— 这意味着巧克力消费与体重之间存在强烈的正向线性关系。</p><blockquote><p>一个重要注意事项：即使关系是非线性的，也可以随时计算皮尔逊相关系数。因此，<em>在计算皮尔逊相关系数之前，要先检查散点图看变量是否存在线性相关</em> ，这一点非常重要。如果不存在，就不要计算皮尔逊相关系数，因为它就不能提供太多变量关系信息。</p></blockquote><p>例如，下面这个散点图显示 x 和 y 之间存在强烈的 <strong>曲线关系</strong> 。如果计算皮尔逊相关系数，会得到一个非常低的值，负 0.15 。这并不能说相关性较弱，只能说线性相关性较弱。</p><p><img src="/images/pearsonr_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><blockquote><p>计算四个样本的皮尔逊相关系数是相当容易的。但是，可以想象，当样本是 200 个时，这几乎是不可能完成的任务。幸运的是，每个统计程序都可以快速计算皮尔逊相关系数。然而，重要的是要了解皮尔逊相关系数究竟意味着什么。了解公式的含义也很重要，它可以帮你更好地理解变量的相关性，也可能会帮你决定 “每周吃多少巧克力。” :)</p></blockquote><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很多人喜欢吃巧克力，但多数人吃巧克力是比较谨慎的。因为吃了太多巧克力，很有可能会增加体重。在这一期的教程中，我将讨论如何使用表格和图表展示 &lt;em&gt;两个变量之间的关系&lt;/em&gt; 。这有助于发现两个变量之间是否存在 &lt;strong&gt;相关性 (correlation)&lt;/strong&gt; 。&lt;/p&gt;
&lt;h1 id=&quot;列联表-Contingency-Tables&quot;&gt;&lt;a href=&quot;#列联表-Contingency-Tables&quot; class=&quot;headerlink&quot; title=&quot;列联表 (Contingency Tables)&quot;&gt;&lt;/a&gt;列联表 (Contingency Tables)&lt;/h1&gt;&lt;p&gt;我们来进一步研究吃巧克力和体重之间的关系。&lt;/p&gt;
&lt;p&gt;假设我在我们学校选择了 200 名女学生。她们身高都是一米七。这样，身高就是一个常数，不会影响体重或吃巧克力。让学生报告体重及每周巧克力消费情况。体重可以选择这样几个类别：小于 50 公斤； 50 至 69 公斤； 70 至 89 公斤和 90 公斤或以上。巧克力消费量可以选择这样几个类别：每周少于 50 克；每周 50 至 150 克；每周超过 150 克。&lt;/p&gt;
&lt;p&gt;结果如下，这里看到的是 &lt;strong&gt;列联表&lt;/strong&gt; 。 &lt;strong&gt;列联表&lt;/strong&gt; 能够显示 &lt;strong&gt;两个定序或定类变量之间的关系&lt;/strong&gt; 。 它类似于频率表，但主要区别在于 &lt;strong&gt;频率表始终只考虑一个变量，而列联表考虑两个变量&lt;/strong&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之四 | Z-score</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-z-scores/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-z-scores/</id>
    <published>2020-01-01T02:49:06.000Z</published>
    <updated>2020-01-06T01:47:54.489Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通俗解释 z-score ，即 z-score 是对某一原始分值进行转换，变成的一个标准分值，该标准分值可使得原来无法比较的数值变得可比。</p></blockquote><h1 id="Z-score"><a href="#Z-score" class="headerlink" title="Z-score"></a>Z-score</h1><p>本教程中我们还继续沿用前面教程中足球队的例子。</p><img src="/images/z-score.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>你在这里看到的是所谓的球员纹身占比，以纹身占身体的百分比表示。点图和标准差表明，第二队的分布比第一队的变化更大。</p><p>有时研究人员会问：一个特定的观测结果是常见还是特例。为了回答这个问题，研究人员会用 <strong>一个数与平均数的差再除以标准差</strong> 。这个数字就是我们所说的 z 分数。在这篇教程中，我将解释如何计算 z 分数，以及它们的用处。</p><p>我们先来看看第一队的分布情况。平均数是 15 ，标准差是 2.5 。为了计算 z 分数，我们使用这个公式：</p><p>$$ z = \frac {(x - \bar x)}{s} $$</p><p>这个公式不是很复杂，它告诉你如何计算感兴趣的数值。该数值与平均数之差，再除以标准差。</p><a id="more"></a><p>来看看纹身占比是 10.8％ 意味着什么。该值的 z 分数是 10.8 减去 15 再除以 2.5 等于负 1.68 。所以 z 分数是负 1.68 。你可以为所有数值进行如此计算。如果这样做，这些就是结果。</p><img src="/images/z-score_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>请注意，最终会得到负 z 分数和正 z 分数。负 z 分数表示低于平均数的值；正 z 分数表示高于平均数的值。因为平均数是分布的平衡点，所以负的和正的 z 分数相互抵消。换句话说，如果将所有 z 分数相加，结果为 0 。</p><p>好的，不过如何知道某个 z 分数是低还是高呢？</p><p>这取决于分布和前后关系。有一个黄金定律：如果变量的直方图是钟形的，那么 68％ 的观测值在 z 分数 -1 和 1 之间， 95％ 在 z 分数 -2 和 2 之间， 99％ 在 z 分数 -3 和 3 之间。这意味着对于这种类型的分布， z 分数大于 3 或小于 -3 ，可以被认定是特例。</p><img src="/images/z-score_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>但是，如果分布严重偏向右侧，如下图所示，较大的正 z 分数会更常见，因为分布的右侧有更多极值。</p><img src="/images/z-score_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>类似，如果分布严重偏向左侧 则较大的负 z 分数会更常见，因为分布的左侧存在更多极值。</p><img src="/images/z-score_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>无须考虑形状，适用于任何分布的规则。 <strong>75％ 的数据必须落在 z 分数正负 2 之内。</strong></p><img src="/images/z-score_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>且 <strong>89％ 的数据在 z 分数正负 3 之间。</strong> </p><img src="/images/z-score_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>因此， z 分数本身就在一定程度上，给出了关于观测极端程度的信息。如果要比较不同的分布， z 分数就更有用了。比如，来看一下 19.3 的体重是否常见：</p><img src="/images/z-score_8.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在第 1 组中，这并不常见。 z 分数为 19.3 减去 15 再除以 2.5 ，等于 1.72 。在第 2 组中， 19.3 的 z 分数等于 19.3 减去 15 除以 8 等于 0.54 。这表明在第 2 组中， 19.3 的体重更常见。在第 2 组中， z 分数是 0.54 ，在第 1 组中，是 1.72 。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果我们将原始分数重新编码为 z 分数，就是 <strong>将变量标准化</strong> 。 <strong>标准化</strong> 意味着我们用 z 分数 替换原始度量中测量的分数，其优点是我们可以一眼看出特定分数是相对常见还是特殊。</p><p>因此，一个球员纹身占比是五分之一是否异常，这取决于球队或你想比对的另一组数据。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通俗解释 z-score ，即 z-score 是对某一原始分值进行转换，变成的一个标准分值，该标准分值可使得原来无法比较的数值变得可比。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Z-score&quot;&gt;&lt;a href=&quot;#Z-score&quot; class=&quot;headerlink&quot; title=&quot;Z-score&quot;&gt;&lt;/a&gt;Z-score&lt;/h1&gt;&lt;p&gt;本教程中我们还继续沿用前面教程中足球队的例子。&lt;/p&gt;
&lt;img src=&quot;/images/z-score.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;你在这里看到的是所谓的球员纹身占比，以纹身占身体的百分比表示。点图和标准差表明，第二队的分布比第一队的变化更大。&lt;/p&gt;
&lt;p&gt;有时研究人员会问：一个特定的观测结果是常见还是特例。为了回答这个问题，研究人员会用 &lt;strong&gt;一个数与平均数的差再除以标准差&lt;/strong&gt; 。这个数字就是我们所说的 z 分数。在这篇教程中，我将解释如何计算 z 分数，以及它们的用处。&lt;/p&gt;
&lt;p&gt;我们先来看看第一队的分布情况。平均数是 15 ，标准差是 2.5 。为了计算 z 分数，我们使用这个公式：&lt;/p&gt;
&lt;p&gt;$$ z = \frac {(x - \bar x)}{s} $$&lt;/p&gt;
&lt;p&gt;这个公式不是很复杂，它告诉你如何计算感兴趣的数值。该数值与平均数之差，再除以标准差。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之三 | 测量集中趋势和离散程度</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-measures-of-central-tendency-and-dispersion/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-measures-of-central-tendency-and-dispersion/</id>
    <published>2019-12-31T07:28:52.000Z</published>
    <updated>2020-01-06T01:48:13.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="众数、中位数和平均数"><a href="#众数、中位数和平均数" class="headerlink" title="众数、中位数和平均数"></a>众数、中位数和平均数</h1><p>在前一篇教程中，我们学会通过图表概述分布。这同样适用于描述分布的中心位置，有三种主要方式，它们分别是：<strong>众数</strong> (mode) ，<strong>中位数</strong> (median) 和 <strong>平均数</strong> (mean) 。</p><p>这三个 m 通常被称为集中趋势的度量。</p><p>找到众数很容易，<strong>它是出现频次最高的值。</strong> 换句话说，就是最常见的结果。</p><p>如果测量定类或定序变量，<em>众数通常用作衡量集中趋势。</em></p><p>在下面这个饼图中，可以看到西班牙主要球赛中球员来自哪些大洲。</p><div id="echarts8458" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts8458'));        // 指定图表的配置项和数据        var option = {    title : {        text: ' 西班牙主要足球比赛中的球员国籍分布 ',        x:'center'    },    tooltip : {        trigger: 'item',        formatter: "{a} <br/>{b} : {c} ({d}%)"    },    legend: {        orient: 'vertical',        left: 'left',        data: [' 欧洲 ',' 北美 ',' 南美 ',' 非洲 ',' 亚洲 ']    },    series : [        {            name: ' 国籍 ',            type: 'pie',            radius : '55%',            center: ['50%', '60%'],            data:[                {value:280, name:' 欧洲 '},                {value:16, name:' 北美 '},                {value:56, name:' 南美 '},                {value:32, name:' 非洲 '},                {value:16, name:' 亚洲 '}            ],            itemStyle: {                emphasis: {                    shadowBlur: 10,                    shadowOffsetX: 0,                    shadowColor: 'rgba (0, 0, 0, 0.5)'                }            }        }    ]}        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>饼图使众数一目了然，是欧洲 70％ 的球员来自欧洲</p><p><strong><em>这里的众数是欧洲</em></strong> ，是最常出现的类别的名称，但众数不是 70％ 。这只是该特定类别的观测百分比。可能有多个众数。试想有一个足球运动员，拥有十分分裂的球迷，其中一些觉得他非常和善，而另一些则认为他非常蛮横。来给这个球员起个名，Franco Galton。</p><a id="more"></a><p>试想你选取西班牙 500 名受访者作为代表样本，询问他们对 Franco Galton 的看法，受访者可以在 0 到 10 的范围内表明他们认为他的和善程度。 0 表示非常蛮横， 10 表示非常和善。</p><img src="/images/two_mode.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>假设这是本研究得出的直方图形状，可以看到西班牙人分歧很大，有些人觉得 Galton 非常和善，有些人觉得他非常蛮横。正如所见，分布有 两个众数，即 3 和 8 这显然是双众数分布。</p><p>集中趋势的第二个衡量指标是中位数：<strong>观测值从最小到最大排序时，中位数就是观测值的中间值。</strong></p><p>试想你还问了七位受访者，对另一著名球员 Tomas Bayez 的看法。假设这是他的研究数据矩阵，这里的众数是 8 ，是频次最高的值。</p><img src="/images/median.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>要计算中位数，首先必须将所有数值从低到高排序，然后选择中间值。所以这里的中位数是 8 。如果案例是偶数而非奇数，那就稍微复杂点了。试想受访者是 8 人，他们对 Tomas Bayez 的看法。</p><img src="/images/median_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>数值是从低到高排列的。但是，在这种情况下，没有单个中间值。该如何解决这个问题呢？我们取两个中间数值的平均值 7 和 8 相加除以 2 等于 7.5 。因此，中位数是 7.5 。请注意，中位数将分布分为两个相等的部分。 50％ 的值低于中位数， 50％ 的值高于中位数。</p><p>集中趋势的第三个衡量指标，是最常用的一个，也可能是你已经非常熟悉的，就是平均数。</p><p><strong>平均数是所有观测值之和除以观测个数</strong>。</p><p>$$ \bar x = \frac {\sum {x}}{n} $$</p><p>上面是用于计算平均值的公式。它看起来比较复杂，公式的含义是： x 横线表示变量 x 的平均数，等于 x 的总和除以样本个数，由 n 表示。</p><p>举个例子，借用 Tomas Bayez 的研究。公式告诉我们首先求总和， 6 加 7 ，加 7 ，加 8 ，加 8 ，加 8 ，加 9 ，等于 53 ，现在再除以 n 。样本量是 7 ，因此 53 除以 7 等于 7.6 平均数是 7.6 。</p><img src="/images/mean.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>可以将平均数视为数据的平衡点。试想我们将重量平衡放置，那么平均数就是天平中心点。其中一侧的总重量恰好等于另一侧。</p><img src="/images/mean_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>现在大家已经熟悉了这三个 m 。可以通过各种方式轻松计算一组数字的中间值，但报告时，该使用哪种中心趋势呢？</p><p><strong>这部分取决于变量的测量级别。</strong> 如果是定类测量，则无法计算中位数或平均数，因为我们无法对定类变量进行数值运算，也不能对它们进行排序。<strong>当变量是定类变量时 唯一适合的集中趋势度量是众数。</strong></p><p>如果是定量变量该怎么办呢？</p><p>试想你在家乡足球俱乐部的一个食堂里，你想计算所有在场人士的平均收入和中位收入，包括你自己，其他 5 位客人和吧员。</p><img src="/images/mean_and_median.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这是数据矩阵，平均数约为 35,000 ，中位数恰好是 35,000 ， 它们彼此非常接近。使用哪一个来描述分布中心都无所谓。但现在，著名足球运动员 Franco Galton 走进食堂，比如他每年收入大约 7000 万 ，这时中位数略微增加到 36,000 ，然而，平均数却超过 800 万。</p><img src="/images/mean_and_median_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们说 Franco Galton 是这个分布的异常值。他的收入远高于其他所有人，他的收入对平均收入产生不成比例的影响。在这种情况下，计算中位数描述分布中心比平均数更合理。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>描述分布中心可以使用三种方法：众数，中位数和平均数。如果变量是定类的，则使用众数；如果是定量的，则使用中位数或平均数 —— 如果有异常值或分布高度偏离，使用中位数。如果不是，那就使用平均数。</p><hr><h1 id="全距、四分位距和箱线图"><a href="#全距、四分位距和箱线图" class="headerlink" title="全距、四分位距和箱线图"></a>全距、四分位距和箱线图</h1><p>你可能已经注意到了，纹身在足球运动员中越来越受欢迎。特别是所谓的纹身袖在球场上正在兴起。纹身袖，正如其名，是指满胳膊的纹身。</p><p>你对球员纹身占身体的比例感兴趣吗？</p><p>试想有两支球队，这里看到的是点图，表示两队中纹身占身体的百分比变量分布。水平线代表这个变量，原点代表每个团队中的 11 个人。</p><img src="/images/range.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>第一队队员纹身占比大约是 10％ 到 20％ 之间。在第二支球队中，球员的纹身占比差异很大，百分比范围是 0% 到大约 30％ 之间。因此，这个团队彼此差异很大。但是两队众数，中位数和平均数却相同。两队的众数都是 14.1 ，中位数和平均数都是 15 。<em>这表明为了充分描述分布，我们需要集中趋势度量之外的信息。</em> 这一节我将向大家展示我们还需要了解有关数据变化或离散的信息，讨论两种变异性测量，即：<strong>全距</strong> 和 <strong>四分位距</strong> ，还将讨论所谓的 <strong>箱线图</strong> —— 这是一个非常有用的图表，可以很好地呈现分布中的数值如何离散。</p><p>全距是最简单的变异性度量：它是 <strong>最高值和最低值之间的差值</strong> 。</p><img src="/images/range_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>再来看看我们的两支球队：第一队的球员中最大纹身占比是 19.3％ ， 占比最小的是 10.8％ ，范围是 19.3 减去 10.8 等于 8.5 ；第二队的球员中最大纹身占比是 27.7％ ，占比最小的是 0％ 。因此，范围是 27.7 减去 0 等于 27.7 。这清晰地显示第二队的变化范围比第一队的变化范围更大。全距是易于理解且易于计算的变异性度量。但是，在许多情况下，它并没有很好地呈现数据的变异性。 <em>原因是它只考虑了极值。。</em> 看看这两个分布，它们的范围相同，但一目了然第二个分布的变异性与第一个非常不同。</p><p>另一个更好的测量变异性的方法是 <strong>四分位距</strong> ，因为它省略了极值，它将分布分为四个相等的部分。因此，如果分布看起来是这样的。</p><img src="/images/range_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>可以这样切分，将得分最低的 25％ 划为一组，得分最高的 25％ 划为一组，中间的两个 25％ 再分两组。</p><p>这种划分分布方式称为四分位距，一共有三个 <strong>四分位</strong> ，以下称为 Q1 ， Q2 ， Q3 。</p><p>如你所见，第二个四分位 Q2 将分布分为两个相等的部分。毕竟， 50％ 的值低于该值， 50％ 高于该值。<br>因此 Q2 与中位数相同。 <strong>四分位距是第三和第一个四分位之间的距离</strong>。换句话说，四分位距是 Q3 减去 Q1 。下面让我通过纹身占比来展示计算过程。</p><img src="/images/range_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这是第二队的分布情况。首先，寻找中位数或者换句话说 Q2 。这很简单，中间数值是 15 ；可以通过查找中位数左侧数值的中间值找到 Q1 ，是 8.7 ；可以通过相同的策略在右侧找到 Q3 是 19.3 。现在，四分位距是 Q3 减去 Q1 即 19.3 减去 8.7 等于 10.6 。四分位距的主要优点是它不受异常值的影响，因为它没有考虑低于 Q1 或高于 Q3 的观测值。然而，在研究中寻找潜在的异常值可能仍然有用。 <strong>根据经验，如果观测值低于第一个四分位 1.5 个四分位距或高于第三个四分位 1.5 个四分位距则为异常值。</strong></p><p>在描述中心和变异性以及检测异常值时，有一种特定类型的图非常有用，该图称为 <strong>箱线图</strong> 。</p><p>Q1，Q2 和 Q3 在箱形图中一目了然，最小值不是异常值，最大值不是异常值。</p><img src="/images/range_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这是基于前一个示例的箱形图。<strong>箱体</strong> 本身代表分布中心的 50％ 。换句话说，从 Q1 到 Q3 。 <strong>箱高</strong> 代表四分位距，箱内的 <strong>水平线</strong> 是中位数，换句话说，即 Q2 。箱体上面和下面的线称为 <strong>箱须</strong> 。它们包含除异常值以外的其他值，异常值用点单独标记。这里没有点，所以这个箱形图没有任何异常值。</p><img src="/images/range_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如何确定箱须的长度呢？让我们回到之前示例中的数值，我们检测到了 Q2 ， Q1 和 Q3 以及四分位距。我们知道低于 Q1 1.5 倍四分位距的或高于 Q3 1.5 倍四分位距的值是异常值。这里的四分位距是 10.6 。所以 1.5 乘以 10.6 等于 15.9 ， Q1 为 8.7 ，因此所有低于 8.7 减去 15.9 等于 -7.2 的值都是异常值。这里不存在这样的值，所以下末端没有异常值，这里的最小值是 0 。 Q3 是 19.3 ，因此，高于 19.3 加上 15.9 等于 35.2 的值都是异常值。我们也没有这么高的数值，所以上末端也没有异常值。箱须的上末端等于最大值，即 27.7 。</p><p>我们来看一下第一队的箱形图，如果比较两个箱形图，我们立即就能看到两个分布的变异性差别很大。</p><img src="/images/range_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>请记住，分布的中心只能告诉你部分信息。为了了解的更完整，还要 <strong>评估分布的变异性</strong>。箱线图使用三个四分位数，异常值以及剔除异常值后的数据范围，以紧凑的方式显示分布的重要信息。</p><hr><h1 id="方差和标准差"><a href="#方差和标准差" class="headerlink" title="方差和标准差"></a>方差和标准差</h1><p>在足球运动员中，纹身越来越受欢迎。试想，你想知道球员纹身的身体占比。</p><img src="/images/tatto.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这里看到的点图表示纹身占比的分布，由两队球员纹身占身体的百分比表示。一目了然，在第一队中纹身占比的变化远小于第二队。这种变异性可以通过 <strong>全距离</strong> 或 <strong>四分位距</strong> 来测量。也可以用箱线图表示 在此可以看到相关的箱线图。在本节中，将讨论统计研究中经常使用的另外两种变异性度量，即 <strong>方差</strong> 和 <strong>标准差</strong> 。</p><p>与许多其他变异性度量相比，方差和标准差的巨大优势在于：<strong>它们考虑了所有变量的数值</strong> 。</p><p>让我们从方差开始。这是方差的公式：</p><p>$$ s^2 = \frac {\sum {(x - \bar x)^2}}{n - 1} $$</p><p>s 的平方代表方差。将每次的观测值 x 减去 x 的平均值 （x 拔），然后将所有这些值平方后相加，结果是我们所说的平方和，接下来将平方和除以样本的大小 n 减去 1 。我们现在将公式应用于纹身占比的示例，以了解它在实践中的工作原理。</p><img src="/images/variance.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>第一步是计算平均值，这些值的平均值等于 15 ； 第二步是从每个观测值中减去平均值。我们来取第一个值，0 从这个值中减去平均值 0 减去 15 是负 15 。我们对样本中所有的值都这样计算。算完后，我们发现有负数，也有正数。这并不奇怪，因为均值是这些数值的中间点或平衡点。事实上，均值的负差和正差相抵 ，结果的总和等于 0 。换句话说，这些值的总和等于 0 。</p><p>因此，我们不使用 <strong>原始差值</strong>，而是使用 <strong>差的平方</strong> 。</p><p>接下来，我们对所有这些计算值进行平方。</p><p>根据公式，接下来我们需要将所有这些值相加。现在得数是平方差的总和，换句话说，平方和。这个数等于 639.74 。然后将平方和除以 n 减 1 。在我们的例子中， n 是 11 ，所以 n 减去 1 等于 10 。 639.74 除以 10 等于 63.97 ，这就是方差。</p><p><strong>方差越大，变异性越大。这意味着方差越大，数值越离散。</strong></p><img src="/images/variance_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这里显示的第一队的方差约为 6.33 ，从点图和箱线图中已经可：第 2 队中纹身占比的较大差异，也由较大的方差表示。</p><p>方差的一个重要缺点是：方差的度量是经过平方的变量度量。毕竟，我们平方了正差和负差，以便它们不会相互抵消。</p><p>有一个非常简单的方案可以解决这个问题。我们只取方差的平方根 —— 我们称之为 <strong>标准差</strong> 。标准差可以被看作观测值与平均值的平均距离。<strong>标准差越大，数据的变异性越大。</strong></p><p>$$ s = \sqrt {\frac {\sum {(x - \bar x)^2}}{n - 1}} $$</p><p>因此在我们的例子中，第一队的标准差是 6.33 的平方根，等于 2.52 。第二队的标准差是 63.97 的平方根，等于 8.0 。标准差是最常使用的离散度量。然而，在许多统计方法中，方差也起着重要作用。在本节教程中，大家了解了它们密不可分，可以轻松从一个推演出另一个。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;众数、中位数和平均数&quot;&gt;&lt;a href=&quot;#众数、中位数和平均数&quot; class=&quot;headerlink&quot; title=&quot;众数、中位数和平均数&quot;&gt;&lt;/a&gt;众数、中位数和平均数&lt;/h1&gt;&lt;p&gt;在前一篇教程中，我们学会通过图表概述分布。这同样适用于描述分布的中心位置，有三种主要方式，它们分别是：&lt;strong&gt;众数&lt;/strong&gt; (mode) ，&lt;strong&gt;中位数&lt;/strong&gt; (median) 和 &lt;strong&gt;平均数&lt;/strong&gt; (mean) 。&lt;/p&gt;
&lt;p&gt;这三个 m 通常被称为集中趋势的度量。&lt;/p&gt;
&lt;p&gt;找到众数很容易，&lt;strong&gt;它是出现频次最高的值。&lt;/strong&gt; 换句话说，就是最常见的结果。&lt;/p&gt;
&lt;p&gt;如果测量定类或定序变量，&lt;em&gt;众数通常用作衡量集中趋势。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;在下面这个饼图中，可以看到西班牙主要球赛中球员来自哪些大洲。&lt;/p&gt;
&lt;div id=&quot;echarts8458&quot; style=&quot;width: 85%;height: 400px;margin: 0 auto&quot;&gt;&lt;/div&gt;
&lt;script src=&quot;https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById(&#39;echarts8458&#39;));
        // 指定图表的配置项和数据
        var option = {
    title : {
        text: &#39; 西班牙主要足球比赛中的球员国籍分布 &#39;,
        x:&#39;center&#39;
    },
    tooltip : {
        trigger: &#39;item&#39;,
        formatter: &quot;{a} &lt;br/&gt;{b} : {c} ({d}%)&quot;
    },
    legend: {
        orient: &#39;vertical&#39;,
        left: &#39;left&#39;,
        data: [&#39; 欧洲 &#39;,&#39; 北美 &#39;,&#39; 南美 &#39;,&#39; 非洲 &#39;,&#39; 亚洲 &#39;]
    },
    series : [
        {
            name: &#39; 国籍 &#39;,
            type: &#39;pie&#39;,
            radius : &#39;55%&#39;,
            center: [&#39;50%&#39;, &#39;60%&#39;],
            data:[
                {value:280, name:&#39; 欧洲 &#39;},
                {value:16, name:&#39; 北美 &#39;},
                {value:56, name:&#39; 南美 &#39;},
                {value:32, name:&#39; 非洲 &#39;},
                {value:16, name:&#39; 亚洲 &#39;}
            ],
            itemStyle: {
                emphasis: {
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: &#39;rgba (0, 0, 0, 0.5)&#39;
                }
            }
        }
    ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
&lt;/script&gt;

&lt;p&gt;饼图使众数一目了然，是欧洲 70％ 的球员来自欧洲&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;这里的众数是欧洲&lt;/em&gt;&lt;/strong&gt; ，是最常出现的类别的名称，但众数不是 70％ 。这只是该特定类别的观测百分比。可能有多个众数。试想有一个足球运动员，拥有十分分裂的球迷，其中一些觉得他非常和善，而另一些则认为他非常蛮横。来给这个球员起个名，Franco Galton。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之二 | 数据可视化</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-descriptive-statistics/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-descriptive-statistics/</id>
    <published>2019-12-31T01:34:47.000Z</published>
    <updated>2020-01-06T01:48:13.221Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>当我们向他人呈现数据时，通常需要将数据 “<strong>总结</strong>” 成各种图表的形式，例如频率表、饼图、条形图、散点图和直方图等。</p></blockquote><h1 id="统计案例、变量和测量级别"><a href="#统计案例、变量和测量级别" class="headerlink" title="统计案例、变量和测量级别"></a>统计案例、变量和测量级别</h1><blockquote><p>如果你对足球非常感兴趣，你想知道所有细节：比如某个球员有多少进球，某个球队赢了多少场比赛或者在某场足球比赛中有多少次点球。统计学知识，将帮助你成为足球或任何其他运动的真正专家。</p></blockquote><p>进球得分，赢得比赛，判罚点球，这些都可以被看作 <strong>变量</strong> 和 <strong>统计案例</strong> 。</p><blockquote><p><strong>变量</strong> 是事件或者人物的特征， <strong>统计案例</strong> 就是那个事或那个人。</p></blockquote><p>来讲得更具体一点。想象一下，你最喜欢的球队，你对足员的某些特征感兴趣：你想知道他 / 她的体重，头发颜色，年龄以及在最近的比赛中得分的总数。所有这些球员的特征都是变量，球员本身就是统计案例。</p><p>另一个例子，可能你对个别球员的特征不是那么感兴趣，而对他们所效力的球队特征感兴趣。例如，你可能想了解每个西班牙球队，以及它们所在的城市，他们队服的主色调是什么，以及球队去年有多少进球。这些特征也都是变量。但是，这里的统计案例不是个别球员，而是这些人所效力的球队。</p><p>在一项研究中，<em>案例可以是许多不同的事物。</em> 可以是个别球员和球队，也可以是公司，学校甚至是国家。</p><p><strong>案例的每个特征都可以成为变量</strong> —— 只要它符合一个基本的标准：即是变化的</p><p>这是什么意思呢？ 让我们回到示例。以球队为案例，并以团队所在的城市为变量。你关注每个西班牙球队，所以会有很多不同的城市：一支球队来自巴塞罗那，其他球队来自马德里，瓦伦西亚或塞维利亚。换句话说，城市是有变化的。</p><a id="more"></a><p>现在让我们关注另一个特征，不是城市，而是球队所在的国家。对于每一个球队而言，它们的国家都是西班牙 这些球队都是西班牙球队。这表示它们之间没有差异：没有一支球队会来自西班牙以外的其他国家。出于这个原因，这个特征不是变量，而是常量。</p><p>可以想象，我们可以有许多不同类型的变量代表非常不同的特征。因为这个原因，还有一些其他原因（我之后会讨论到）区分不同的 <strong>测量级别</strong> 至关重要，</p><p>最简单的测量是 <strong>定类测量</strong> 。<strong>定类变量由彼此不同的各种类别组成 变量之间没有顺序关系。</strong> 这意味着无法区别一个类别比另一个更好或更差，更多或更少。一个例子是球员的国籍，各种类别，例如西班牙，法国或墨西哥。彼此不同，但没有排名顺序；另一个例子是球员性别或球队所在城市。</p><p>第二级测量是 <strong>定序测量</strong>：<strong>变量的类别之间不仅存在差异，还存在顺序</strong> 。例如球赛的排名：可知谁是冠军，谁是第二，第三，等等。但是，通过查看排名，你不可能知道类别之间的差异大小 例如，你不知道第一名比第二名好多少。</p><p><em>定类和定序测量都可以称为分类变量。</em></p><p>下一级测量是 <strong>定距测量</strong>。在定距变量中：<strong>我们有不同的类别和顺序，类别之间也有相似的区间</strong>。 一个例子是球员的年龄。我们可以说，18 岁的球员与 16 岁的球员，年龄不同。另外，我们可以说这个球员年纪大些。就年龄而言，我们也可以说：18 岁球员和 16 岁球员之间的年龄差异，类似于 14 岁球员和 12 岁球员之间的年龄差异。</p><p>最高级的测量是 <strong>定比测量</strong> 。它类似于定序测量，但另外还有一个有意义的零点。例如球员的身高，以厘米为单位。它们在类别上存在差异，有一定的顺序，有相似的间隔，也有一个有意义的零点。身高为 0 厘米意味着没有高度。请注意，我们不能说年龄有一个有意义的零点：因为零岁并不意味着没有年龄，因此年龄是定距变量。</p><p>定距和定比变量就是我们所说的 <strong>定量变量</strong> ，因为类别由数值表示。</p><p>定量变量也可以分为 <strong>离散变量</strong> 和 <strong>连续变量</strong> 。如果某类别形成一组单独的数字，则变量是离散的。例如，球员的进球数：球员可以进一球或两球，但不能是 1.21 球。如果变量值形成区间，则变量是连续的。一个例子是玩家的高度：有人可能是 170 厘米或 171 厘米高，也可能是，比如说，170.2461 厘米高。我们没有一组单独的数字，而是一个无限的数值区域。</p><h2 id="区分测量级别的意义"><a href="#区分测量级别的意义" class="headerlink" title="区分测量级别的意义"></a>区分测量级别的意义</h2><p>为什么区分这些不同的测量等级如此重要。因为 <strong>我们用来分析数据的方法，取决于变量的测量水平</strong>。 </p><p>然而，在实践中， <em>区别有时会变得模糊。</em> 例如，对于许多统计分析，定距和定比测量之间的差异并不重要。此外，许多统计学家认为，如果定类测量有十分类甚至更多分类，就可以定量分析这些变量。</p><p>一个例子是调查问卷，问题是从 0 到 10 之间你如何评价某个球员。在形式上，这是一个定类变量，但在实践中，你可以讨巧将其视为定量变量。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从案例，变量和这些变量的衡量水平来考虑球员，球队和比赛，可以让你对足球有更结构化的理解。</p><hr><h1 id="数据矩阵"><a href="#数据矩阵" class="headerlink" title="数据矩阵"></a>数据矩阵</h1><p>我们已经知道实施一项研究，可以根据案例和变量来考虑。接下来，我将讨论如何排布和展示你的案例和变量。</p><p>想象一下，你对西班牙顶级球赛 “西班牙甲级联赛” 感兴趣。你感兴趣的案例是联赛的个体球员，你关注的变量是年龄，体重，进球数量，会籍和头发颜色。</p><p>排布所有这些信息的最佳方式是通过 <strong>数据矩阵</strong> 。数据矩阵是所有统计研究的核心要素：它是所有案例和变量的概述。 <strong>案例显示在行中</strong> ，它的范围从 1 号球员一直到 400 号球员。</p><table><thead><tr><th>球员</th><th>年龄</th><th>体重</th><th>进球数</th><th>会籍</th><th>头发颜色</th></tr></thead><tbody><tr><td>球员 1</td><td>18</td><td>72.6</td><td>0</td><td>Real Zaragoza</td><td>金发</td></tr><tr><td>球员 2</td><td>21</td><td>71.4</td><td>0</td><td>Real Betis</td><td>黑发</td></tr><tr><td>球员 3</td><td>26</td><td>74.8</td><td>8</td><td>Sevilla</td><td>黑发</td></tr><tr><td>球员 4</td><td>22</td><td>76.8</td><td>12</td><td>Barcelona</td><td>黑发</td></tr><tr><td>球员 5</td><td>22</td><td>74.1</td><td>17</td><td>Valencia</td><td>其他</td></tr><tr><td>球员 6</td><td>27</td><td>78.9</td><td>3</td><td>Real Sociedad</td><td>其他</td></tr><tr><td>球员 7</td><td>30</td><td>80.3</td><td>2</td><td>Real Madrid</td><td>金发</td></tr><tr><td>球员 8</td><td>24</td><td>73.3</td><td>1</td><td>Athletic Bilbao</td><td>褐发</td></tr><tr><td>球员 9</td><td>23</td><td>76.9</td><td>5</td><td>Valencia</td><td>褐发</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>球员 24</td><td>26</td><td>.</td><td>0</td><td>Malaga</td><td>黑发</td></tr><tr><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td><td>…</td></tr><tr><td>球员 400</td><td>26</td><td>77.2</td><td>0</td><td>Atheletic Madrid</td><td>其他</td></tr></tbody></table><p>这里没有显示名字，这意味着这里的名称是匿名的。 <strong>变量显示在列中</strong> 。我们有五个变量：年龄，体重 进球数，会籍和头发颜色。表格单元格中显示的值通常称为 <strong>观测值</strong> 。这里 80.3 表示 7 号球员的体重是 80.3 公斤，这里的八分表示三号球员已经进了八球。</p><p>我们看到的不是一个完整的数据矩阵，只是其中一部分。完整的矩阵无法单屏呈现，因为它有 400 行，因为我们有 400 名球员。省略号已经明确表示只取了矩阵的一部分。</p><p>来看看我们的数据矩阵是否包含异常值。嘿，其中的 24 号球员，我们看不到体重数值。目前，我们已经囊括了这些不完整的案例。但是，如果后续分析需要完整的数据矩阵，我们可能必须删除它们。</p><p>所有统计分析都需要数据矩阵。但是，你通常不会向其他人提供完整的数据矩阵。原因是数据矩阵通常很大。在我们的例子中，有 400 行，并且也没有清楚地概述数据矩阵中包含的统计信息。</p><p>当我们将数据矩阵中的信息呈现给其他人时，经常以表格和图形的形式进行数据摘要。想象一下，你想要概述西班牙足球比赛中关于球员头发颜色的信息。较好的方法是制作频率表。频率表显示案例中 <strong>变量数值的分布</strong> 。* 频率表就是变量的所有可能值的列表，连同每个值的观测次数。*</p><p>这是一个基于发色变量的示例，我们可以区分四个类别 金发，棕色，黑色和其他。</p><table><thead><tr><th>发色</th><th>频率</th><th>百分比</th><th>累积百分比</th></tr></thead><tbody><tr><td>金色</td><td>76</td><td>19</td><td>19</td></tr><tr><td>褐色</td><td>134</td><td>33.5</td><td>52.5</td></tr><tr><td>黑色</td><td>160</td><td>40</td><td>92.5</td></tr><tr><td>其他</td><td>30</td><td>7.5</td><td>100</td></tr><tr><td>总计</td><td>400</td><td>100</td><td></td></tr></tbody></table><p>可以看到 76 名球员是金发， 160 名球员是黑发。注意，这些值相加是 400，所以没遗漏任何头发颜色的数据。</p><p>我们还可以通过百分比表示相对频率。在第二列中，可以看到百分比。可以一眼看出 7.5％ 球员是其他发色， 19％ 的球员是金发。将 76 除以 400 再乘以 100 得到 19 。</p><p>有时，研究人员使用累积百分比。这也很容易计算，累积百分比就是每个类别的百分比之和。所以可以看到 19 加 33.5 等于 52.5 金发和棕色头发占比 52.5 。</p><p>在这个例子中，我们讨论了一个分类变量，头发颜色。如果处理定量变量怎么办？以体重为例，计算每个特定个体的体重百分比是没有意义的。因为那样我们最终会得到无数的类别 —— 频率表将显示：比如两个人的体重为 65.3 公斤，一个人体重 65.4 公斤，等等。这几乎没比原始数据矩阵提供额外的有用信息。</p><p>研究人员通常会建立新的 <strong>顺序分类</strong> 来解决这类问题。可以做成，例如，第一类包含那些小于 60 公斤的球员；第二类，体重在 60 到 69.9 公斤之间的；下一类，介于 70 和 79.9 之间的；接着介于 80 和 89.9 之间的；最后一类， 90 公斤及以上。像下面这样：</p><table><thead><tr><th>体重</th><th>频率</th><th>百分比</th></tr></thead><tbody><tr><td>&lt; 60</td><td>8</td><td>2</td></tr><tr><td>60-69.9</td><td>69</td><td>17.25</td></tr><tr><td>70-29.9</td><td>273</td><td>68.25</td></tr><tr><td>80-89.9</td><td>45</td><td>11.25</td></tr><tr><td>&gt;= 90</td><td>5</td><td>1.25</td></tr><tr><td>总计</td><td>400</td><td>100</td></tr></tbody></table><p>虽然这样你可能会丢失信息，但优点是可以获得更好的概述。我们说你已经 <strong>重新编码了变量</strong> 。体重变量本是定量变量，但现在变成了一个只有五个类别的定序变量。</p><p>将定量变量重新编码为定序变量非常容易。但是，反过来是不可能的：你无法将定序变量重新编码为定量变量。所以，你该了解 —— <strong>数据矩阵是所有统计分析的根源</strong> 。它是数据的概述。但是，如果你想将发现呈现给他人，可以使用 <strong>数据摘要</strong> 。一个非常好的总结方法是制作 <strong>频率表</strong> 。如有必要，你可以将定量变量重新编码为定序变量。</p><hr><h1 id="信息图和各种数据分布形状"><a href="#信息图和各种数据分布形状" class="headerlink" title="信息图和各种数据分布形状"></a>信息图和各种数据分布形状</h1><h2 id="定类变量"><a href="#定类变量" class="headerlink" title="定类变量"></a>定类变量</h2><p>如果想研究西班牙主要足球比赛中的球员来自哪里，下面这个频率表可能就是结果：</p><table><thead><tr><th>国籍</th><th>频率</th><th>百分比</th></tr></thead><tbody><tr><td>欧洲</td><td>280</td><td>70</td></tr><tr><td>北美</td><td>16</td><td>4</td></tr><tr><td>南美</td><td>56</td><td>14</td></tr><tr><td>非洲</td><td>32</td><td>8</td></tr><tr><td>亚洲</td><td>16</td><td>4</td></tr><tr><td>总计</td><td>400</td><td>100</td></tr></tbody></table><p>可以看到 280 名球员来自欧洲， 16 名来自北美， 56 名来自南美， 32 名来自非洲， 16 名来自亚洲。</p><p>我还添加了相对百分比，你可能希望通过图表展示百分比，有两种可能的方法。</p><div id="echarts2383" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts2383'));        // 指定图表的配置项和数据        var option = {    title : {        text: ' 西班牙主要足球比赛中的球员国籍分布 ',        x:'center'    },    tooltip : {        trigger: 'item',        formatter: "{a} <br/>{b} : {c} ({d}%)"    },    legend: {        orient: 'vertical',        left: 'left',        data: [' 欧洲 ',' 北美 ',' 南美 ',' 非洲 ',' 亚洲 ']    },    series : [        {            name: ' 国籍 ',            type: 'pie',            radius : '55%',            center: ['50%', '60%'],            data:[                {value:280, name:' 欧洲 '},                {value:16, name:' 北美 '},                {value:56, name:' 南美 '},                {value:32, name:' 非洲 '},                {value:16, name:' 亚洲 '}            ],            itemStyle: {                emphasis: {                    shadowBlur: 10,                    shadowOffsetX: 0,                    shadowColor: 'rgba (0, 0, 0, 0.5)'                }            }        }    ]}        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>这里是一个 <strong>饼图</strong> 。要概述的变量类别是通过饼图 <strong>切片</strong> 展示在饼图中，切片表示每个类别的百分比，一目了然 —— 几乎四分之三的足球运动员来自欧洲。</p><p>另一种概述数据的方法是 <strong>柱状图</strong> ，它可以非常清楚地展示数据在各个变量类别上的分布。</p><div id="echarts9271" style="width: 85%;height: 400px;margin: 0 auto"></div><script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script><script type="text/javascript">        // 基于准备好的dom，初始化echarts实例        var myChart = echarts.init(document.getElementById('echarts9271'));        // 指定图表的配置项和数据        var option = {    xAxis: {        type: 'category',        data: [' 欧洲 ', ' 北美 ', ' 南美 ', ' 非洲 ', ' 亚洲 ']    },    yAxis: {        type: 'value'    },    series: [{        label: {            normal: {                show: true,                position: 'insideTop'            }        },        data: [280, 16, 56, 32, 16],        type: 'bar'    }]}        // 使用刚指定的配置项和数据显示图表。        myChart.setOption(option);</script><p>柱形的高度代表每个类别观测值的百分比。</p><h2 id="饼图和柱状图的优劣"><a href="#饼图和柱状图的优劣" class="headerlink" title="饼图和柱状图的优劣"></a>饼图和柱状图的优劣</h2><p>两种图表都各有优，缺点。饼图的一个优点是，可以立即看出大约 75％ 的球员来自欧洲，不进行点计算就无法轻松地从柱状图中辨别出这些信息。但是，另一方面，从饼图中不容易检索每个类别的确切球员数量。例如，在柱状图中，可以轻松地看到有 50 多名球员来自南美洲。</p><p><strong>如果变量的类别数量增加，柱图优于饼图。</strong> 例如，想象一下，不是球员所在大洲，而是他们出生的某个具体国家。图呈现的效果将非常非常混乱。出于美学原因，你可能会在饼图中使用不同颜色，但所有这些信息使饼图不易于理解。在这种情况下，柱状图会更合理。柱状图也会包含大量信息。但它会比花里胡哨的饼图更容易理解。</p><h2 id="定量变量"><a href="#定量变量" class="headerlink" title="定量变量"></a>定量变量</h2><p>前面讲了定类变量，那么定量变量又要怎么处理呢？</p><p>一种可能性是 <strong>气泡图</strong> 。这个想法很简单，想象一下有 10 个球员身高信息，用厘米表示。</p><p>下面是数据矩阵。</p><table><thead><tr><th>球员</th><th>身高</th></tr></thead><tbody><tr><td>球员 1</td><td>176</td></tr><tr><td>球员 2</td><td>180</td></tr><tr><td>球员 3</td><td>165</td></tr><tr><td>球员 4</td><td>177</td></tr><tr><td>球员 5</td><td>167</td></tr><tr><td>球员 6</td><td>170</td></tr><tr><td>球员 7</td><td>175</td></tr><tr><td>球员 8</td><td>178</td></tr><tr><td>球员 9</td><td>174</td></tr><tr><td>球员 10</td><td>172</td></tr></tbody></table><p>首先，绘制一条水平线，并以规则的间隔标记可能的数值，如下所示。</p><img src="/images/singleAxis_bubble_scatter.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>接下来，对于每次观测在水平线上的数值之上标记一个点，像就这样：</p><img src="/images/singleAxis_bubble_scatter_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>可以想象，当只有若干观测结果时，气泡图很不错。但是，当样本巨大时，会变得混乱。 100 个球员的样本，看起来是这样的：</p><img src="/images/singleAxis_bubble_scatter_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如果有很多观测结果时，研究人员通常会使用另一种类型的图表：<strong>直方图</strong></p><p>这就是一例：</p><img src="/images/histogram.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>直方图在某种意义上类似于柱状图，它使用柱形来描绘变量可能数值的频率或相对频率。但是，有一个重要的区别： <strong>直方图中的柱点是相互接触的</strong>。</p><p>该接触表示区间比率变量的数值呈现连续标度。比如，我们对西班牙足球运动员的体重感兴趣，如果测量数值非常详细，比如 83.9 或 74.5 公斤，为每一个值绘制一个单独的柱形是没有意义的。相反，我们构建 <strong>区间</strong> 。</p><img src="/images/histogram_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p> 在此图中，有 10 个 区间，每个区间 5 公斤，第一个区间范围从 47.5 公斤到 52.5 公斤 显示 50 ，因为 50 是该区间的中间。对于创建的区间的数量，没有固定的规则。但是，重要的是区间数值必须相同，所以在此图中都是五公斤。可以一眼看出大多数球员的体重约为 75 公斤，还可以看到，重量小于 60 或大于 90 是非常罕见的。 </p> <img src="/images/histogram_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如图所见，此直方图具有特定形状，它是钟形的，有一个 <strong>峰值</strong> 且两侧近似对称。你会经常遇到钟形分布，但并非所有直方图都是钟形。</p><p>直方图也可以向左或向右 <strong>倾斜</strong> 。偏斜的直方图不是对称的，因为分布的一侧比另一侧延伸得更远。</p><img src="/images/histogram_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>有的直方图向左倾斜，而有的直方图向右倾斜。向右倾斜的直方图变量是西班牙比赛中球员的年收入。与球员的平均收入相比，收入很少的球员不会很多。但是，也会有一些球员比大多数球员赚的多得多。因此，右尾更长。</p><p>直方图也可能有两个峰值：设想两队六到八岁球员之间的足球比赛。比赛结束后，所有的孩子和父母都去食堂喝东西。</p><p>你感兴趣的问题是，食堂里的人年龄如何分布。在这种情况下，年龄变量的直方图有两个峰值。毕竟，食堂里的孩子是 6 到 8 岁的孩子和他们的父母，他们最有可能在 30 到 40 岁之间。</p><p>因此，可能在 7 岁左右达到峰值，在 35 岁左右再达到峰值。我们说这个变量是双峰而不是单峰。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇教程最重要的一个内容是：通过图表概述数据是一个好主意。<strong>如果处理定类或定序变量，你应该制作饼图或柱图。如果变量是定距或者定比变量，则应绘制直方图。</strong> 永远不要忘记查看变量的形状，它是钟形且对称的吗？它是单峰，还是双峰？分布是否倾斜？ <strong>评估分布的形状至关重要</strong>， 因为它可能影响你之后使用的统计方法。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;当我们向他人呈现数据时，通常需要将数据 “&lt;strong&gt;总结&lt;/strong&gt;” 成各种图表的形式，例如频率表、饼图、条形图、散点图和直方图等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;统计案例、变量和测量级别&quot;&gt;&lt;a href=&quot;#统计案例、变量和测量级别&quot; class=&quot;headerlink&quot; title=&quot;统计案例、变量和测量级别&quot;&gt;&lt;/a&gt;统计案例、变量和测量级别&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;如果你对足球非常感兴趣，你想知道所有细节：比如某个球员有多少进球，某个球队赢了多少场比赛或者在某场足球比赛中有多少次点球。统计学知识，将帮助你成为足球或任何其他运动的真正专家。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进球得分，赢得比赛，判罚点球，这些都可以被看作 &lt;strong&gt;变量&lt;/strong&gt; 和 &lt;strong&gt;统计案例&lt;/strong&gt; 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;变量&lt;/strong&gt; 是事件或者人物的特征， &lt;strong&gt;统计案例&lt;/strong&gt; 就是那个事或那个人。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来讲得更具体一点。想象一下，你最喜欢的球队，你对足员的某些特征感兴趣：你想知道他 / 她的体重，头发颜色，年龄以及在最近的比赛中得分的总数。所有这些球员的特征都是变量，球员本身就是统计案例。&lt;/p&gt;
&lt;p&gt;另一个例子，可能你对个别球员的特征不是那么感兴趣，而对他们所效力的球队特征感兴趣。例如，你可能想了解每个西班牙球队，以及它们所在的城市，他们队服的主色调是什么，以及球队去年有多少进球。这些特征也都是变量。但是，这里的统计案例不是个别球员，而是这些人所效力的球队。&lt;/p&gt;
&lt;p&gt;在一项研究中，&lt;em&gt;案例可以是许多不同的事物。&lt;/em&gt; 可以是个别球员和球队，也可以是公司，学校甚至是国家。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;案例的每个特征都可以成为变量&lt;/strong&gt; —— 只要它符合一个基本的标准：即是变化的&lt;/p&gt;
&lt;p&gt;这是什么意思呢？ 让我们回到示例。以球队为案例，并以团队所在的城市为变量。你关注每个西班牙球队，所以会有很多不同的城市：一支球队来自巴塞罗那，其他球队来自马德里，瓦伦西亚或塞维利亚。换句话说，城市是有变化的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之一 | 引言</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-basic-introduction/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-basic-introduction/</id>
    <published>2019-12-31T00:55:24.000Z</published>
    <updated>2020-01-06T01:48:08.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="学习统计学的意义"><a href="#学习统计学的意义" class="headerlink" title="学习统计学的意义"></a>学习统计学的意义</h1><p>乍一看，统计学可能很吓人，但实际上，统计学并不可怕。它可以关乎很有趣的事，比如足球、潜水、巧克力，很有趣的人，比如潮人、出租车司机和婴儿。</p><p>至少有三个原因，让统计学至关重要。</p><ul><li>首先，我们周围有很多统计学，包括新闻，还有科学工作。</li><li>其次，统计学知识将帮你开展自己的研究。你该如何分析你得到的信息？该采用哪种方法？</li><li>第三，也是最后一点，分析数据可以帮助我们了解有趣的世界。</li></ul><h1 id="统计学的两种类型"><a href="#统计学的两种类型" class="headerlink" title="统计学的两种类型"></a>统计学的两种类型</h1><p>我们将统计学分为两种类型： <strong>描述统计学</strong> 和 <strong>推断统计学</strong> 。当我们谈论 <strong>描述统计学</strong> 时，我们指的是概述信息的方法。我们可以通过图表来概述信息，比如饼图或条线图或者诸如平均值，百分比或相关系数等数字。<strong>推断统计学</strong> 是仅根据有限数据案例，推断有关整体的结论。</p><h1 id="教程导览"><a href="#教程导览" class="headerlink" title="教程导览"></a>教程导览</h1><p>教程会分为七个模块。前两个模块主题是描述统计学；接下来的三个模块，将介绍之后在推断统计学中用到的方法：我们会讨论 <strong>概率</strong> ，<strong>概率分布</strong> 和 <strong>抽样分布</strong> ；在最后的两个模块中，我们将介绍推断统计学方法， <strong>如何估计置信区间</strong> 以及 <strong>如何进行假设检验</strong> 。</p><h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>不需要额外的知识，学校里学的足够了。你需要的是对方法论和数据的兴趣，以及最重要的东西 —— <strong>激情</strong> ！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;学习统计学的意义&quot;&gt;&lt;a href=&quot;#学习统计学的意义&quot; class=&quot;headerlink&quot; title=&quot;学习统计学的意义&quot;&gt;&lt;/a&gt;学习统计学的意义&lt;/h1&gt;&lt;p&gt;乍一看，统计学可能很吓人，但实际上，统计学并不可怕。它可以关乎很有趣的事，比如足球、潜水、巧
      
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>用 “流水线” 设计拆解复杂处理流程</title>
    <link href="https://theinfinitegame.tech/programming/break-down-complexity-with-pipelines/"/>
    <id>https://theinfinitegame.tech/programming/break-down-complexity-with-pipelines/</id>
    <published>2019-12-28T12:59:40.000Z</published>
    <updated>2019-12-31T08:07:33.223Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文的主要价值： <strong>提供一种抽象复杂逻辑，达成功能复用的思路</strong></li><li>关键词： <strong>语义提炼</strong> 、 <strong>动态具名</strong></li><li>本文约 4000 字，建议阅读时间 30 分钟。 </li></ul><hr><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在软件开发时常常遇到一种场景：随着产品功能的扩展，出现了多个具备高度相似性的功能单元。这些功能单元可能有着相似的交互逻辑，提供同类的输入数据和输出数据。并且对于用户来说，它们共同处理同一个元素。举个例子，比如一款修图 app ，它包含了一组编辑功能，每个功能都作用于一张图片，处理之后的图片还可以作为其他功能的输入。作为编辑工具，在每个功能内部，还可能都需要支持撤销和重做这样的用户操作。容易想到，这些功能间存在着许多可以进行复用设计的代码。</p><p>本文基于我曾经从事的一款图像处理应用开发过程中的一次代码重构的实践所做的回顾发起，期望达到记录和分享的目的。</p><h1 id="重构的具体背景"><a href="#重构的具体背景" class="headerlink" title="重构的具体背景"></a>重构的具体背景</h1><p>请先看下面这幅图：</p><p><img src="/images/image_modules.jpg" alt="重构前的图像功能模块结构"></p><p>图中的元素很少，但细心的读者可能留意到了：图中的 “ <strong>内存图像管理 + 效果处理</strong> ” 是一个 “ <strong>黑盒子</strong> ”。那么这个黑盒子是一件好事还是坏事呢？</p><p>既然我们对这种设计做了重构，那么这里重点来探讨一下它的缺点。 黑盒子的优点部分，作为思考题留给读者。</p><p>在具体业务场景下，我发现旧有设计的两个问题：</p><ul><li>图像处理接口粒度太大，难以复用代码； </li><li>黑盒子把 <strong>图像管理</strong> 和 <strong>图像效果处理</strong> 这两件事包在了一起，使得外部难以灵活的接触和使用图像。 </li></ul><a id="more"></a><hr><h1 id="重构的设计思路-——-“流水线”-概念的提炼"><a href="#重构的设计思路-——-“流水线”-概念的提炼" class="headerlink" title="重构的设计思路 —— “流水线” 概念的提炼"></a>重构的设计思路 —— “流水线” 概念的提炼</h1><p>问题一在重构时也得到了解决，但与本文要表达的设计思想关联不大，就此略过。为了解决问题二，我引入了两个概念：“ <strong>流水线</strong> ” 和 “ <strong>例程</strong> ”。相信对于从事计算机领域工作的读者来说，这两个词不会陌生。</p><blockquote><p><strong>流水线</strong> pipeline， [计] 又称管道，管线。<br><strong>例程</strong> routine, [计] 程序；日常工作；例行公事</p></blockquote><p>在具体代码实现中， Pipeline 相当于内存中的图像状态机，提供了基本的管理图像的能力，例如加入图像，删除图像，复制图像，移动图像等。 Routine 相当于各个图像功能单元中通用的事务，比如每个图像功能单元都需要在其开始运作时从某处获得一份初始图像，并在其结束运作时输出一份 <strong>最终的</strong> 图像到另一处。我们约定， Routine 中的事务会基于 Pipeline 来完成。它的含义是：每个 Routine 都会包含一组基于一个或者多个 Pipeline 的典型操作，然后再加上每个 Pipeline 的差异化操作（即后文会提到的 <strong>差异化的图像处理步骤</strong> ），共同构成一个完整的具体场景下的图像功能单元。</p><p>下文中我们不妨把 “<strong>流水线</strong>” 的释义直接替换成 “<strong>管道</strong>” ，因为后面用到的一些比喻性的描述我觉得用 “管道” 一词衍生出来会比用 “流水线” 更自然一些。接着我们对 “管道” 这个意象再做进一步的挖掘，可以有下面一些对应关系（表格中左侧的概念只是我的比喻，读者可自行体会，这里不会全部详细解读）</p><table><thead><tr><th>比喻</th><th>原对象</th></tr></thead><tbody><tr><td>“管道”</td><td>图像状态机</td></tr><tr><td>“流体”</td><td>图像</td></tr><tr><td>“节点”</td><td>图像状态</td></tr><tr><td>“流动”</td><td>图像状态流转</td></tr><tr><td>“锋面”(流体的最前端)</td><td>当前正在处理的图像状态</td></tr><tr><td>“连通性”</td><td>状态机内的图像以及图像状态机之间都是可串联的</td></tr></tbody></table><p>“流体” 是一个名词，它对应的是图像，涉及到存储模型。根据 “流体” 的特性我们推断管道里的图像存储模型应该会被设计为平行结构。</p><p>请读者联想一下 &lt; <strong>化妆 / 整容 VS 软件上美化照片上的人脸</strong> ** &gt; 这种类比关系，再想一下两者在存储模型和工序这两个方面有什么异同？</p><p>回到正题，我配了五幅图来描述管道在具体实现中的五个特性：</p><ol><li><p>流体由一系列节点（即图像状态）组成。图像状态的含义构成了我们对某一个图像的本征性认知。通俗的说，图像状态能够帮助我们在特定场景下把不同的图像区分开来。举个例子，协同开发的两位开发者对于 “美颜” 和 “滤镜” 这两个步骤的认知达成了共识。于是我们就可以建立两个节点：“美颜”、“滤镜”，然后在开发过程中使用这两个节点来协作。注意到图像状态不是图像本身，图像状态的代码实现上我们可以使用一个极轻量的数据结构 —— 字符串。它体现的是 <strong>占位符思想</strong> ，而占位符的重要好处是它是 <em>可预见的（基于认知共识）、可预置的（它很轻量）、可固化的（可复用性代码的一个诉求）</em> 。 </p></li><li><p>管道通过衔接节点构成连通。在节点中有必要特别提出 “同位节点” 的描述。它指的是几个步骤在同一个图像上先后发生。在时间上有先后但在空间上始终操作同一份存储。后面会再用到这个描述。</p></li></ol><p><img src="/images/flow_connectivity.jpg" alt="流体和连通性"></p><ol start="3"><li><p>流动的流体会有一个 <strong>最前部</strong> ，好像水流的最前端，又称 “锋面” (Waterfront) ，对应着管道中的所有图像在同一时间里只会有一个图像处于可操作的状态，这个状态代表着 <strong>图像的变化趋势</strong> 。具体到代码中的实现可能会是一组带有同步关键字的方法加上一个唯一的当前状态的指针。开发者通过引导和操刀这个趋势，把图像引向最终要呈现出来的样子。在图示中，我们有意使用了绿色代表原始的、最初的，使用红色代表成熟的、完全体的。 Pipeline 专注于做一件事，就是把图像从一种状态转化为另外一种状态。这期间可能要经历很多个节点，而 Waterfront 的意义就在于它保证了 Pipeline 的操刀者可以明确地知道这一刻只有他自己在引导图像的流向而没有别人会干扰到这件事。</p></li><li><p>流动可以是双向的（相比生产车间的 “流水线”，释义替换为 “管道” 更自然的原因是后者可以实现双向流动，对应着图像可以实现反向编辑或者说撤销到一个处理步骤之前的状态）</p></li><li><p>流体如果分流则可以出现多个 “锋面”，对应着图像的并行处理。</p></li></ol><p><img src="/images/waterfront_and_flow.jpg" alt="锋面和流动"></p><hr><h1 id="管道的具体实现"><a href="#管道的具体实现" class="headerlink" title="管道的具体实现"></a>管道的具体实现</h1><p>如前文所述，“流体” 即图像，做简单的封装即可。我们主要需要实现的是 “<strong>节点</strong>” 和 “<strong>锋面</strong>”， “<strong>流动</strong>” 和 “<strong>连通</strong>”。</p><h2 id="节点的实现方案和意义"><a href="#节点的实现方案和意义" class="headerlink" title="节点的实现方案和意义"></a>节点的实现方案和意义</h2><p>我们先来看一种典型的图像处理过程中可能会采用的代码写法:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图像 xyz 的描述 </span></span><br><span class="line">Image xyz; </span><br><span class="line"><span class="comment">// 图像 ijk 的描述 </span></span><br><span class="line">Image ijk;</span><br><span class="line"><span class="comment">// 图像 abc 的描述 </span></span><br><span class="line">Image abc; </span><br><span class="line"> 其他图像及其描述...</span><br><span class="line"><span class="comment">// 图像的 getters：</span></span><br><span class="line">getXYZ ();</span><br><span class="line">getIJK ();</span><br><span class="line">getABC ();</span><br><span class="line"> 其他图像的 getter...</span><br></pre></td></tr></tbody></table></figure><p>不难发现，如上的代码无法复用，因为每一个图像的引用被赋予了非常具体的含义，同样的写法不会完全适用于另外一个图像处理场景，因为另外那个图像处理场景可能不会用到描述为 ijk 的图像，可能会用到描述是 uvw 的图像。因此采取这种写法会遇到的一个典型问题是：每新增一个图像处理场景，我们是不是需要新增若干个特定描述的图像声明？在代码层面，这无疑会造成冗余。</p><p>这里的图像引用，其实就是我们所说的图像管道里的某个 “节点”。要对 “节点” 实现代码复用要怎么做呢？通过分析上面的写法中代码不能复用的根源是图像引用的用途被具体定义（同时也是被具体约束），我想到，那么为什么不能把图像引用匿名化，让它的含义在具体场景到来时才被赋予呢？</p><p>说到这里，有的读者会想到一种数据结构 —— <code>Map</code> 。是的，没有什么奇淫巧技，只是用了映射，就能解决这个代码复用问题中的最大障碍 —— 既然无法预知我们可能需要处理什么样的图像，可能需要处理多少份图像，并且这些未知数总是易变的，那么为什么不让具体场景的使用者来 <strong>动态添加</strong> 这些图像引用，并且为它们具名呢？图像部分被复用的代码，这里只声明了一样东西，就是从图像状态表述到图像引用的映射表。它解决了一个之前的写法不具备的达成复用的前提：<strong><em>图像存取的方式是统一的，有限的，因此是可固化的。</em></strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Image&gt; stateTagToImageMap = <span class="keyword">new</span> HashMap&lt;&gt;;</span><br></pre></td></tr></tbody></table></figure><p>我们用一个字符串标签来表示图像的状态。对于图像管道的使用者来说，他只需要理解每个标签的含义，通过标签来存取图像并进行处理。在这些标签中，我们再提炼出几个具有通用含义的代表，比如。 Original 代表 “<strong>最初的</strong>” ， Processed 代表 “<strong>加工完成的</strong>” ，这正是前文提到的 <strong>占位符</strong> 。容易理解，你可以声明并且预置许多 <strong>占位符</strong> 在一份可复用的代码库中，可你不会声明同样数量的图像引用到这个代码库 —— 这样很奇怪。哪怕从程序实现的角度来说，没有分配实际空间的引用并不一定会占据更多内存。在后文中列举代码范例时我们将会经常地用到 Original 和 Processed 这样的标签。</p><p>不妨阅读以下这段代码，这是一种使用标签来操作其对应图像的写法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示两个处理步骤之后的图像 </span></span><br><span class="line">pipeline.from (tag_Original) <span class="comment">// 从原始的图像开始 </span></span><br><span class="line">        .copy_to (tag_Processed) <span class="comment">// 拷贝出一份图像，用于处理，命名标签 processed</span></span><br><span class="line">        .doProcess (tag_Processed, specificProcess_1)  <span class="comment">// 执行特定操作 1</span></span><br><span class="line">        .doProcess (tag_Processed, specificProcess_2); <span class="comment">// 执行特定操作 2</span></span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed)); <span class="comment">// 取得 processed 标签代表的图像并且展示 </span></span><br></pre></td></tr></tbody></table></figure><h2 id="锋面的实现方案和意义"><a href="#锋面的实现方案和意义" class="headerlink" title="锋面的实现方案和意义"></a>锋面的实现方案和意义</h2><p>解决了节点的设计，我们再来看基于节点之上提炼出的 “锋面” 要怎么设计。容易理解， <strong>锋面</strong> 是最前面的那个节点，具有唯一性，对应具体的图像处理代码中就是 “当前正在被处理的那个图像”。当我们在设计图像管道对外提供的处理接口时约束处理动作一定只能发生在这个 “<strong>当前的</strong>” 图像上时，能够保证我们的 “图像流” 总是按照我们想要的方向流动，并且在这个过程中，“图像流” 是不会被篡改的。这是我们的图像编辑功能要实现撤销和重演功能的基本前提。</p><p>还是上面那段显示两个处理步骤之后的图像的代码，去掉处理接口的标签参数，因为我们约束了处理总是只能发生在 <strong>唯一的</strong> 、 <strong>当前的</strong> 图像上。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 显示一个处理步骤之后的图像 */</span></span><br><span class="line">pipeline.from (tag_Original)</span><br><span class="line">        .copy_to (tag_Processed)</span><br><span class="line">        .doProcess (specificProcess)</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed));</span><br></pre></td></tr></tbody></table></figure><p>如果要求能够回撤到第一个处理步骤之后的状态，再做第二个处理步骤，并且第二个处理步骤的参数是可以改变的。可以这么做：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 显示一个处理步骤之后的图像，但我们在过程中保留了第一个步骤的状态 */</span></span><br><span class="line">pipeline.from (tag_Original)</span><br><span class="line">        .copy_to (tag_specificProcess_1) <span class="comment">// 相比一步到位，这里多存储了第一个步骤的状态 </span></span><br><span class="line">        .doProcess (specificProcess_1)</span><br><span class="line">        .copy_to (tag_Processed)</span><br><span class="line">        .doProcess (specificProcess_2.setParams (params_t1))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调整第二个步骤的某些参数，重新显示图像 */</span></span><br><span class="line">pipeline.from (tag_specificProcess_1) <span class="comment">// 之前存储了第一个步骤的状态，直接从这个步骤开始 </span></span><br><span class="line">        .copy_to (tag_Processed)</span><br><span class="line">        .doProcess (specificProcess_2.setParams (params_t2))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed));</span><br></pre></td></tr></tbody></table></figure><h2 id="流动和连通性的实现方案"><a href="#流动和连通性的实现方案" class="headerlink" title="流动和连通性的实现方案"></a>流动和连通性的实现方案</h2><p>有了节点和锋面，流动和连通就有了作用的主体。对应到图像编辑功能， <strong>流动</strong> 其实就是图像从一个状态变成另外一个状态的过程。 <strong>连通</strong> 则更好理解，一个管道出来的图像可以被另外一个管道接纳，由此构成管道之间的连接。连接在一起的每一节 <strong>小管道</strong> 各司其职，灵活组合，再构成更长跨度的 <strong>大管道</strong> 或者 “<strong>管道网络</strong>” ，从而协同完成复杂的业务流程。</p><p><img src="images/construct-big-pipeline.jpg" alt="一条直线型连接小管道构成的大管道"><br><img src="images/diffluence_join_pipeline.jpg" alt="一个采用了分流策略的三个小管道构成的管道网络"></p><p>回归到代码，我们来看一组步骤稍多的图片处理工序如何体现出管道的流动性和连通性。刨去内部实现细节，整合或者忽略一些与管道设计思想关联不大的逻辑，以下代码在流程上已经比较接近实际生产环境了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 主功能区，不妨将它的例程称为 Main</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 可以从这里进入各子功能处理图片再回到这里展示新的图片 </span></span><br><span class="line"><span class="comment"> * 3. 撤销到经过某个步骤处理之前的图像或者重做出之前做过但是被撤销掉的某个步骤的图像   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_Main.startFrom (image_file) -&gt; {</span><br><span class="line">    Routine_Main.pipeline.loadFrom (image_file, tag_Original) <span class="comment">// 从图片中加载初始的图像 </span></span><br><span class="line">}</span><br><span class="line">Routine_Main.showCurrent () -&gt; {</span><br><span class="line">    showImage (Routine_Main.pipeline.front (); <span class="comment">// 显示 “锋面”</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美型” 的功能区，对应的例程称为 FaceLift</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸轮廓，五官进行形状调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_FaceLift.startFrom (Routine_Main.pipeline.front ().copy ());</span><br><span class="line">Routine_FaceLift.process () {</span><br><span class="line">    Routine_FaceLift.pipeline</span><br><span class="line">         <span class="comment">// 这个过程用户无法干预，不会有 “重演”，因此我们可以直接在原稿上操作 </span></span><br><span class="line">        .from (tag_Original)</span><br><span class="line">        .doProcess (faceLift_step_1_process)</span><br><span class="line">        .doProcess (faceLift_step_2_process)</span><br><span class="line">        .doProcess (faceLift_step_3_process)</span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美型” 处理好的图像提交给主功能 </span></span><br><span class="line">Routine_Main.accept (Routine_FaceLift.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “滤镜” 的功能区，对应的例程称为 Filter</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 滤镜化处理图像 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_Filter.startFrom (Routine_Main.pipeline.front ().copy ());</span><br><span class="line">Routine_Filter.process () {</span><br><span class="line">    Routine_Filter.pipeline</span><br><span class="line">        <span class="comment">// 这个过程中用户决定要选用哪个具体的滤镜，因此每次都需要基于原稿复制一份再滤镜化 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"awful"</span>)))</span><br><span class="line">        ... <span class="comment">/// 皱眉，这个不好，换一个！</span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"notbad"</span>)))</span><br><span class="line">        ... <span class="comment">/// 托腮，这个还行，再换个试试～</span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"perfect"</span>)))</span><br><span class="line">        ... <span class="comment">/// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “滤镜” 处理好的图像提交给主功能 </span></span><br><span class="line">Routine_Main.accept (Routine_Filter.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美颜” 的功能区，对应的例程称为 SkinBeauty</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸皮肤进行色相调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像给 Main 功能 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_SkinBeauty.startFrom (Routine_Main.pipeline.front ().copy ());</span><br><span class="line">Routine_SkinBeauty.process () {</span><br><span class="line">    Routine_SkinBeauty.pipeline</span><br><span class="line">        <span class="comment">// 这个过程用户可以调节一个滑竿来控制色相参数，每次都基于原稿复制一份再调色相 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_weak))</span><br><span class="line">        ... <span class="comment">/// 托腮，效果好像不明显，加强一点 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_much)))</span><br><span class="line">        ... <span class="comment">/// 皱眉，好像有点过头了，往回调一点 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_just_right)</span><br><span class="line">        ... <span class="comment">/// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美颜” 处理好的图像提交给主功能 </span></span><br><span class="line">Routine_Main.accept (Routine_SkinBeauty.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纠结一下。。</span></span><br><span class="line"><span class="comment">/// 犹豫，要不还是不美颜了吧？</span></span><br><span class="line">Routine_Main.undo ();</span><br><span class="line"><span class="comment">/// 迟疑，滤镜也不要了？</span></span><br><span class="line">Routine_Main.undo ();</span><br><span class="line"><span class="comment">/// 思考中。。。</span></span><br><span class="line"><span class="comment">//... 不行，还是都加回来吧 </span></span><br><span class="line">Routine_Main.redo ().redo ();</span><br><span class="line"><span class="comment">// 端详 5 分钟。。。完美～～～</span></span><br><span class="line">save ();</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于管道的设计思路和实现方案介绍到此，读者可以回顾一下本文一开始所提到旧有设计的第二个问题：“<strong>图像管理</strong> 和 <strong>图像效果处理</strong> 被包在一起”。那么这个问题在管道方案中是不是已经解决了呢？</p><p>归纳一下。</p><blockquote><p>管道的基础是图像被 <strong>无差别的管理</strong> ，被管理的每一个图像由最初将其投入管道的创建者为其定义标签。最初的创建者和后来的协同者只需要对这个标签的含义达成共识，便可以进行协作。管道的思想是模拟 <strong>流体</strong> 的运行方式来实现图像处理过程，通过 <strong>节点</strong> 的设定来分解处理步骤，通过 <strong>锋面</strong> 的操控来聚焦每个单步的操作，通过 <strong>双向的连通性</strong> 来将分治的逻辑重新串联起来完成复杂的功能。</p></blockquote><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文的主要价值： &lt;strong&gt;提供一种抽象复杂逻辑，达成功能复用的思路&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;关键词： &lt;strong&gt;语义提炼&lt;/strong&gt; 、 &lt;strong&gt;动态具名&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;本文约 4000 字，建议阅读时间 30 分钟。 &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;p&gt;在软件开发时常常遇到一种场景：随着产品功能的扩展，出现了多个具备高度相似性的功能单元。这些功能单元可能有着相似的交互逻辑，提供同类的输入数据和输出数据。并且对于用户来说，它们共同处理同一个元素。举个例子，比如一款修图 app ，它包含了一组编辑功能，每个功能都作用于一张图片，处理之后的图片还可以作为其他功能的输入。作为编辑工具，在每个功能内部，还可能都需要支持撤销和重做这样的用户操作。容易想到，这些功能间存在着许多可以进行复用设计的代码。&lt;/p&gt;
&lt;p&gt;本文基于我曾经从事的一款图像处理应用开发过程中的一次代码重构的实践所做的回顾发起，期望达到记录和分享的目的。&lt;/p&gt;
&lt;h1 id=&quot;重构的具体背景&quot;&gt;&lt;a href=&quot;#重构的具体背景&quot; class=&quot;headerlink&quot; title=&quot;重构的具体背景&quot;&gt;&lt;/a&gt;重构的具体背景&lt;/h1&gt;&lt;p&gt;请先看下面这幅图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/image_modules.jpg&quot; alt=&quot;重构前的图像功能模块结构&quot;&gt;&lt;/p&gt;
&lt;p&gt;图中的元素很少，但细心的读者可能留意到了：图中的 “ &lt;strong&gt;内存图像管理 + 效果处理&lt;/strong&gt; ” 是一个 “ &lt;strong&gt;黑盒子&lt;/strong&gt; ”。那么这个黑盒子是一件好事还是坏事呢？&lt;/p&gt;
&lt;p&gt;既然我们对这种设计做了重构，那么这里重点来探讨一下它的缺点。 黑盒子的优点部分，作为思考题留给读者。&lt;/p&gt;
&lt;p&gt;在具体业务场景下，我发现旧有设计的两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;图像处理接口粒度太大，难以复用代码； &lt;/li&gt;
&lt;li&gt;黑盒子把 &lt;strong&gt;图像管理&lt;/strong&gt; 和 &lt;strong&gt;图像效果处理&lt;/strong&gt; 这两件事包在了一起，使得外部难以灵活的接触和使用图像。 &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="programming" scheme="https://theinfinitegame.tech/categories/programming/"/>
    
    
      <category term="编程" scheme="https://theinfinitegame.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://theinfinitegame.tech/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>关于花费时间的四宗罪</title>
    <link href="https://theinfinitegame.tech/thinking/the-four-sins-of-spending-time/"/>
    <id>https://theinfinitegame.tech/thinking/the-four-sins-of-spending-time/</id>
    <published>2019-12-28T12:42:32.000Z</published>
    <updated>2020-01-06T01:46:17.519Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>导致我们浪费时间的是我们的<strong>认知错误</strong>。</p></blockquote><p>你是否经历过这样的场景。邻居过来串门，喋喋不休，我们频频点头回应，哪怕当下已经心急如焚；同事开始闲聊琐碎，而我们沉浸其中，不曾意识到本该用来工作的时间正在一点一点溜走；从熟人那里收到微信，对方说：“我可以向你讨教点事情吗？”，我们爽快答应，因为抹不开面子拒绝别人？</p><p>斯多葛哲学家塞内卡（Seneca）曾经惊叹：哪怕最聪明的人，在保护自己的时间这件事上，都不免显得愚蠢。</p><blockquote><p>没有人会把自己的钱财送给路人，但我们中的许多人却送出了我们的生命！我们为财产和金钱所累，却罕有意识我们的时间正遭受的浪费。时间本应是我们每个人都最应吝惜的东西。</p></blockquote><p>两千多年后的今天，为什么我们还在允许时间这种宝贵的资源从我们的手中不停地溜走？</p><a id="more"></a><hr><h1 id="我们总以为我们有充足的时间"><a href="#我们总以为我们有充足的时间" class="headerlink" title="我们总以为我们有充足的时间"></a>我们总以为我们有充足的时间</h1><p>据说，人类现在的平均寿命已经到了 78 岁。听到这个数字你会有什么感觉？别着急作答，我们每个人用行动对这个数字做出的真实回应可能是：我好像拥有了无限的时间。是的，一辈子有这么长呢。于是乎，每天都在这里或者那里匀出二十分钟不算个事；去另一个城市开个会，去程三个小时，回程三个小时，然后再花一个小时休息安顿，然后一天就过去了，不是吗？</p><p>我们没有意识到是，死亡其实一直笼罩着我们所有人。要知道，寿命是一个平均值，保险公司允许你为自己买寿险，但没有任何人能为你的实际寿命做担保。更重要的是，时间其实和金钱一样，是复合的产物。当你浪费时间的时候，你浪费的不仅是眼前的这几分钟，还包括你把它们节省下来然后合理分配之后所带来的一切可能性。对，“可能性 “，这是另外一个话题，但我不需要展开讨论，你也不会没有感触。</p><hr><h1 id="我们为了做-“好人”-轻易让出时间"><a href="#我们为了做-“好人”-轻易让出时间" class="headerlink" title="我们为了做 “好人” 轻易让出时间"></a>我们为了做 “好人” 轻易让出时间</h1><p>在社交场合，似乎没有人喜欢对方说 “不”，而不愿意当 “坏人” 的我们，在内心想要拒绝的时候，选择了说 “好的”。时间浪费，只是这种委屈求全的行为所造成的一类后果，还有其他的负面影响，使得很多人其实能够意识到问题存在，并且在这种事情上自我纠结和挣扎。但是，想要摆脱这个困境，就像生孩子一样，别人是指望不上的，你只能靠自己。</p><p>如果我们懂得，对一件事说 “是”，通常意味着你要对另一件事说 “不”。我们就会意识到，当我们同意承担一些并不那么必要的义务时，有另外一些无辜的人也许要遭受痛苦。他们可能是我们的家人、朋友或者我们一直想要拿出时间来陪伴的人。</p><p>所以，当我忽略某个我不想交谈的人的电子邮件，拒绝多花一分种接听我不需要的电话销售，乃至对所有那些不符合我的意志的事情坚决说不的时候，我的心理障碍比以前小多了。</p><p>听起来有点卑鄙是不是？重要的是，你要想清楚什么对你来说是重要的。换一个角度，你花时间耐心接完一个电话销售在另一头给你介绍完产品，然后再拒绝并挂断。看似礼貌得体，其实你在浪费了自己时间的同时，也浪费了对方的时间。</p><p>在我们交付时间给别人时，可以经常提醒自己这么一个事实：每个人对于时间使用的粒度是不一样的。</p><hr><h1 id="我们对自己不够重视"><a href="#我们对自己不够重视" class="headerlink" title="我们对自己不够重视"></a>我们对自己不够重视</h1><p>我们缺少说 “不” 的信心，并且害怕伤害别人的感情。可能的原因是，我们觉得自己不配被放在我们的关注列表的前面。已逝的 Joan Rivers ，美国有史以来最有成就，最受尊敬和最有才华的喜剧演员，在七十多岁高龄时，被问到为什么她要继续工作？为什么她总是在路上？为什么她总是在寻找更多的演出？她拿着一本空日历，说出了她的恐惧：“如果我的书看起来是像这样的，那就意味着没有人想要我，我曾经尝试做的一切都没有用。没有人在乎，就等于我已经完全被遗忘了。”</p><p>不知道你听到这样的话是何反应。</p><p>我们每个人都不免有在人群中受欢迎的诉求。无论是作为销售，演讲者还是作家，我们之所以为我们的时间收费，原因之一是我们知道自己值这个价，但也要提醒自己，费用并不等于价值。关键是你要坚定信念，并且始终如一。</p><hr><h1 id="我们尚未发展出划清界限所需的力量"><a href="#我们尚未发展出划清界限所需的力量" class="headerlink" title="我们尚未发展出划清界限所需的力量"></a>我们尚未发展出划清界限所需的力量</h1><p>我花了很多时间思考自己想要什么样的生活。花在打电话或开会上的每一分钟，都本可以是我可以用在写作而实际没有用在写作上的时间。它们也是我没有花在陪伴家人这件事上的时间。我经常和我的助理说，保护我的日程表 —— 确保一天之内不要超过三件事。当我拿出日程表，看见它几乎是空白的时候，与 Joan Rivers 不同，我感觉很棒。  </p><p>我知道我想在哪里度过我的时光 —— 我不希望它们未经我的同意而被花掉。我知道这是值得的。</p><p>但是，帮助别人是另外一回事，你可以在坚持说不的原则下仍然帮助到别人。虽然无法回复收到的每一条信息，但我还是尝试回答人们有疑问的主题并撰写文章以解决这些问题。当我对请求说不的时候，我也会尽量想：“不行。但我愿意做<strong>___</strong>来代替。”<br>以这种方式慷慨地帮助人们，同时保持对自己时间的掌控。</p><p>聪明的慈善家会放弃自己的超额利润，但不会放弃让他们继续赚钱的原则。将其应用到时间管理中使我获益良多。我清楚自己不是反社会型人格，我只是严肃认真地对待自己。</p><p>内心平静是你取得你想要的人生以及所有使美好生活成为可能的关键。所以我避免打电话，我拒绝会议要求，我不喝杯咖啡，我拒绝播客邀请，并且忽略了收到的大多数电子邮件。那些都不是我想要度过自己宝贵生命的方式，因此我不会为它们而感到内疚，但我会尽量不把这些事情强加给别人。因为并不是我的时间就比其他任何人的时间都更有价值。</p><p>尊重时间，从现在开始做起。</p><p>编译自 <a href="https://forge.medium.com/why-dont-we-know-how-to-protect-our-time-a88859deea2e" target="_blank" rel="noopener">https://forge.medium.com/why-dont-we-know-how-to-protect-our-time-a88859deea2e</a> ，有删节和演绎，文章不代表译者观点。欢迎交流。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;导致我们浪费时间的是我们的&lt;strong&gt;认知错误&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;你是否经历过这样的场景。邻居过来串门，喋喋不休，我们频频点头回应，哪怕当下已经心急如焚；同事开始闲聊琐碎，而我们沉浸其中，不曾意识到本该用来工作的时间正在一点一点溜走；从熟人那里收到微信，对方说：“我可以向你讨教点事情吗？”，我们爽快答应，因为抹不开面子拒绝别人？&lt;/p&gt;
&lt;p&gt;斯多葛哲学家塞内卡（Seneca）曾经惊叹：哪怕最聪明的人，在保护自己的时间这件事上，都不免显得愚蠢。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;没有人会把自己的钱财送给路人，但我们中的许多人却送出了我们的生命！我们为财产和金钱所累，却罕有意识我们的时间正遭受的浪费。时间本应是我们每个人都最应吝惜的东西。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;两千多年后的今天，为什么我们还在允许时间这种宝贵的资源从我们的手中不停地溜走？&lt;/p&gt;
    
    </summary>
    
    
      <category term="thinking" scheme="https://theinfinitegame.tech/categories/thinking/"/>
    
    
      <category term="思考" scheme="https://theinfinitegame.tech/tags/%E6%80%9D%E8%80%83/"/>
    
      <category term="翻译" scheme="https://theinfinitegame.tech/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学教师协会 - K12 - 标准</title>
    <link href="https://theinfinitegame.tech/uncategorized/csta-k12-standards/"/>
    <id>https://theinfinitegame.tech/uncategorized/csta-k12-standards/</id>
    <published>2019-12-28T08:01:41.000Z</published>
    <updated>2019-12-28T14:14:01.651Z</updated>
    
    <content type="html"><![CDATA[<p>About the CSTA K-12 Computer Science Standards<br>关于 CSTA K-12 计算机科学标准</p><p>Computer science and the technologies it enables rest at the heart of our economy and the way we live our lives. To be well-educate citizens in a computing-intensive world and to be prepared for careers in the 21st century, our students must have a clear understanding of the principles and practices of computer science. The CSTA K–12 Computer Science Standards delineate a core set of learning objectives designed to provide the foundation for a complete computer science curriculum and its implementation at the K–12 level. To this end, the CSTA Standards:</p><p>计算机科学及其支持的技术是我们经济的核心，也是我们生活的方式。为了对计算机密集型世界中的公民进行良好的教育并为 21 世纪的职业做好准备，我们的学生必须对计算机科学的原理和实践有清晰的了解。 CSTA K-12 计算机科学标准描述了一组核心学习目标，旨在为完整的计算机科学课程及其在 K-12 级别的实施提供基础。为此，CSTA 标准：</p><p>・Introduce the fundamental concepts of computer science to all students, beginning at the elementary school level.<br>・Present computer science at the secondary school level in a way that can fulfill a computer science, math, or science graduation credit.<br>・Encourage schools to offer additional secondary-level computer science courses that will allow interested students to study facets of computer science in more depth and prepare them for entry into the work force or college.<br>・Increase the availability of rigorous computer science for all students, especially those who are members of underrepresented groups.<br>The standards have been written by educators to be coherent and comprehensible to teachers, administrators, and policy makers.<br>Levels 1A, 1B, 2, and 3A are the computer science standards for ALL students. The Level 3B standards are intended for students who wish to pursue the study of computer science in high school beyond what is required for all students (specialty or elective courses).</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;About the CSTA K-12 Computer Science Standards&lt;br&gt;关于 CSTA K-12 计算机科学标准&lt;/p&gt;
&lt;p&gt;Computer science and the technologies it enables rest at th
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>聊一聊 UI 代码要怎么写 | 分治篇</title>
    <link href="https://theinfinitegame.tech/programming/ui-programming-howto/"/>
    <id>https://theinfinitegame.tech/programming/ui-programming-howto/</id>
    <published>2019-12-27T02:52:07.000Z</published>
    <updated>2020-01-01T05:18:55.852Z</updated>
    
    <content type="html"><![CDATA[<ul><li>本文的主要价值： 提供一份软件开发中分治 UI 逻辑的实践样本</li><li>关键词： 分治、 UOP</li></ul><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><blockquote><p><em>我们知道，分治策略是人们解决问题的一种基本策略。问题规模越大，内部包含的差异化的细节越多，越需要执行分治策略。</em></p></blockquote><p>所谓化整为零，化繁为简，逐个击破讲的都是分治。在计算机领域，我们要列举分治的例子，大的可以聊到七层网络模型（本质上分层也是一种分治），小的可以讲起二分算法。</p><p>本文基于 Android 客户端开发中经常涉及的交互逻辑编程展开，表达我对于 UI 分治在软件开发中如何实践的理解。</p><a id="more"></a><h1 id="从-MVC-说起"><a href="#从-MVC-说起" class="headerlink" title="从 MVC 说起"></a>从 MVC 说起</h1><p>经典的 <strong><a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC</a></strong> 设计模式想必各位程序猿们无人不晓。 MVC 最早存在于桌面程序中，后来由于其强大的复用性被广泛地发掘和应用于各端的开发中，还衍生出 MVP ， MVVM 等变体。如果把 MVC 的变体都算作 MVC ，可以说现如今任何一个成熟的 GUI 框架都内化了这种设计模式。放图：</p><p><img src="/images/MVC-vs-MVP-vs-MVVM.jpg" alt=""></p><p>然而我今天不是要来谈 MVC 设计模式的，因为网络上以各种姿势深入浅出 MVC 的好文章已经多的不能再多。之所以提及 MVC 模式只是想借此提醒读者， <strong>解耦</strong> 对于编程的重要性。</p><p>MVC 之所以看起来很简单却又如此广泛地被使用就在于它有效地解决了一个已知的，规模庞大的 <strong>耦合</strong> 问题：“你看到的”（不妨理解为 MVC 中的 View ) 和 “它代表的” (不妨理解为 MVC 中的 Model )，这两个东西永远不可能完全一致。</p><p>我们有时候需要用相同的表象去表示不同的真相，有时候则需要用不同的表象去表达同一个真相。而当我们尝试把两者捆绑在一起处理时，一旦映射关系发生变化，这个捆绑体便不再适用，需要重新构建。这样一来，原来的东西就都不能用了。所以我们需要一套机制来避免这种耦合，从而实现 Model 和 View 各自的复用。</p><blockquote><p><em>想要简单的理解这个问题，思考一下我们如何造字，为什么只需要造出常用的几千个汉字就能够表达一个人在生活中遇到的绝大部分事物？又为什么同一个字词在不同的场景下可以表达不同的含义？</em></p></blockquote><p>MVC 正是通过解耦 Model 和 View ，使得大量的 UI 可以被标准化，进而被重复利用。而这个问题之所以规模巨大，是因为只要一个计算机程序是给人类用的，就一定会涉及到人机交互，也就是我们常说的 UI 。</p><p>在解决了耦合问题并实现复用时， MVC 引入了 <strong>Controller</strong> ，我们的 UI 怎么写将围绕 Controller 展开。</p><hr><h1 id="UI-写在何处"><a href="#UI-写在何处" class="headerlink" title="UI 写在何处"></a>UI 写在何处</h1><p>在现今我们用到的主流应用框架中，你很难找到针对 GUI 编程部分只提供手写原生代码来实现界面的个例 — 它们无一例外地会引入基于某一种或者某几种标记语言的界面编程机制。其中最常见的是 xml 及其变体。</p><p>使用标记语言设计 UI 的最大好处在于它们可以被方便地转换为可视化的编辑界面，这样的话可以允许程序员以所见即所得的方式直观地进行界面设计，即 <strong>可视化编程</strong> 。提到可视化编程，桌面端的开发框架中大家最耳熟能详的想必包括微软的 .NET 。之所以特别提及 .NET ，是因为我认为微软在可视化编程技术和可视化集成开发环境方面的贡献至今仍是值得称道的。作为编程的初学者，我当年曾一度被 VisualStudio 的强大惊艳到。</p><p>在 GUI 编程方面摸爬滚打过几年，我先后使用过 MFC ， Windows Forms ， Qt 等框架开发桌面端的用户界面，目前从事的是 Android 客户端开发。从这些使用过的开发框架的用户界面部分的组件，我发现一个共同点： UI 都是一定程度上独立的。</p><p>首先，在设计阶段，通过使用单独的资源文件夹或者 .xml ， .qml ， .ui ，又或者是 C# 分部类，界面部分的生成逻辑是被隔离开的。然后，在使用阶段，界面部分的元素通过约定的方式查找或者引用，并且建立响应逻辑。这样的运行方式，使得 UI 和其他程序逻辑被天然地划分开，能够让程序员把 UI 的代码编写从整体的编程活动中独立出来，从而便于维护和协作。</p><h2 id="UI-编程的两个阶段"><a href="#UI-编程的两个阶段" class="headerlink" title="UI 编程的两个阶段"></a>UI 编程的两个阶段</h2><p>不妨把 UI 设计和 UI 使用的这两个阶段称为 <strong>UI 编程的两个阶段</strong> 。我在后文会介绍到 <strong>UOP</strong> 和从 UI 快速切入别人的代码结构进行修改的策略，都是基于 UI 实现所具备的这种独立性。从这里开始，相关话题我会以 Android 平台的客户端界面设计为例展开。</p><p>Android 的 UI 可以通过 xml 设计，运行时由系统加载和创建出界面，也可以通过代码直接创建。相对来说，前者的使用方式比较普遍，以下描述会基于采用前者方式的前提。在 UI 编程的第二个阶段， Android 通过 findViewById 的方式将 UI 元素从被隔离的区域 (xml) 中找出来，准确的说，是通过预先定义好的 id 将第二阶段所关心的 UI 元素从被隔离的区域 (xml) 中找出来，为它在控制器逻辑中建立一个引用，然后围绕这些 UI 元素编写交互逻辑。</p><p>到目前为止，我所说的是大家都已经知道的事实，而这一节要聊的关于 UI 写在何处 —— 跟我们已知的这些事实有什么关联呢？一些有过 Android 开发经验的同学想一想 <em>RoboGuice</em> 、 <em>ButterKnife</em> 以及官方的 <em>Android Data Binding</em> 为何会存在？也许会对这个问题有自己的答案。</p><h2 id="负担过重的-Controller"><a href="#负担过重的-Controller" class="headerlink" title="负担过重的 Controller"></a>负担过重的 Controller</h2><p>在我看来，在编程框架内置的 MVC 模型中，单一的 Controller 一直负荷了过重的工作，因为通常的情况是许多的 Model 和 View 都仅仅通过某个唯一的 Controller 建立关联，与此同时我们忽略了一个重要的事实：单一的 Controller 通常不仅要服务于 UI ，往往还需要承载多个不同角度不同层级的业务逻辑。</p><p>面对这个问题，我们能做些什么呢？有的读者可能已经想到了 MVVM 模式。首先，要肯定一下 MVVM 是一个可以考虑的选项。在我看来， ViewModel 本质上就是将 Controller 中与特定 UI 密切相关的逻辑集中在一起。不过呢，我会倾向于认为 MVVM 是 MVC 的一个变体， ViewModel 是我们在实现 Controller 时所采取的一种策略：这种策略叫做分治。那么为什么 MVVM 只是可以考虑的选项而不是根本的解决方案呢？我的解释是：因为 <strong>分治</strong> 这件事，太依赖于具体情况了。没有一种框架可以告诉我们应当如何拆分一整个复杂的控制器逻辑，如你所见，它们顶多帮你把 UI 隔离到另外的空间，让你的代码不至于一上来就看着一团乱麻。而我们在编程的时候，还可能会不断地把 UI 找出来，重新加入我们的控制器，并为它们书写冗长的交互代码。有的时候这些交互的复杂程度是已经具备一定约束规则的 ViewModel 所无法预见和适应的。</p><p>其实，无论 MVC 还是 MVVM，其实都是可行的方案，但是我们不能太拘泥于形式，不能规定 View 和 Model 必须以这样或者那样的方式建立关联。在具体的场景中，需要视逻辑的复杂度对控制器中的 UI 部分进行拆分。控制器中可以拆分的逻辑当然并不局限于 UI 部分，不过它与本文无关这里不特别说明。所有分治的 UI 控制器中的 UI 虽然是由原来的那个控制器统一创建的，但是在使用时却可以由各分治控制器自行把握。</p><p>这里提供一个参考思路：在实际的开发实践中，我做过的控制器拆分通常是以可复用的组件作为目标，根据模块分工，代码规模等情况综合考虑的。</p><hr><h1 id="UOP——-分治-UI-控制逻辑的利器"><a href="#UOP——-分治-UI-控制逻辑的利器" class="headerlink" title="UOP—— 分治 UI 控制逻辑的利器"></a>UOP—— 分治 UI 控制逻辑的利器</h1><p>接着第 2 节文末提出的思路，笔者在本文的最后一节要来重点分享一下在实践 UI 控制逻辑分治这件事时的一种十分有效的编程方式： <strong>UOP</strong>。</p><p>面向 UI 编程。你无法在 wikipedia 上找到这个词条。因为它是杜撰的。实际上，我将要说的 “面向 UI 编程” 应该是面向切面编程（<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="noopener">Aspect-oriented programming</a>）的一种，只不过切面聚焦在 User Interface 上。</p><p>在展开 <strong>UOP</strong> 之前，让我们先回到 Controller 这个概念，在我们熟知的框架内化的 MVC 模式中，原先的那个 Controller 角色必定是已经提供 UI 的访问途径了，比如 Android 框架的控制器 Activity ，它提供了 findViewById 。而分治出去的 Controller （同时也是我们自己创建的 Controller ）要如何取得 UI 呢？一些同学可能会想到，使用 setter。是的，我们完全可以这么实现。不过这里要提供另外一种思路 —— <strong>“UI 包装器”</strong> ，我给它取了一个代码名，叫 <code>UIWrapper</code> 。我们将通过这个 <strong>“UI 包装器”</strong> 来说明 UOP 是什么，以及我们为什么使用 UOP 。</p><p>一个 Android 上的 UI 包装器可以是如下的实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIWrapper</span> </span>{</span><br><span class="line">        <span class="comment">/** 布局资源 id 到根视图的索引 */</span></span><br><span class="line">        <span class="keyword">protected</span> SparseArray&lt;View&gt; mLayoutIdToRootViewIndex = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">        <span class="comment">/** 视图 ID 到子视图的索引 */</span></span><br><span class="line">        <span class="keyword">protected</span> SparseArray&lt;View&gt; mIdToSubViewIndex = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UIWrapper</span><span class="params">()</span> </span>{}</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置 UI 元素 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> otherWrapper 给定的 UI 元素包装器 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">setUi</span><span class="params">(UIWrapper otherWrapper)</span> </span>{</span><br><span class="line">            mLayoutIdToRootViewIndex = otherWrapper.mLayoutIdToRootViewIndex.clone ();</span><br><span class="line">            mIdToSubViewIndex = otherWrapper.mIdToSubViewIndex.clone ();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 包装 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 指定的视图资源 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> view 指定的视图资源 ID 对应的视图 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">wrapUi</span><span class="params">(<span class="keyword">int</span> viewId, View view)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> wrapUi (viewId, view, <span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 包装 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 指定的视图资源 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> view 指定的视图资源 ID 对应的视图 </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> treatAsViewGroup 以 ViewGroup 方式处理包装的 View</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">wrapUi</span><span class="params">(<span class="keyword">int</span> viewId, View view, <span class="keyword">boolean</span> treatAsViewGroup)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (viewId &gt;= <span class="number">0</span> &amp;&amp; view != <span class="keyword">null</span>) {</span><br><span class="line">                mIdToSubViewIndex.put (viewId, view);</span><br><span class="line">                <span class="keyword">if</span> (treatAsViewGroup) {</span><br><span class="line">                    mLayoutIdToRootViewIndex.put (viewId, view);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据 view id 查找 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 目标视图的 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> view</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">findViewById</span><span class="params">(<span class="keyword">int</span> viewId)</span> </span>{</span><br><span class="line">            View view = mIdToSubViewIndex.get (viewId);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; mLayoutIdToRootViewIndex.size (); index++) {</span><br><span class="line">                    View layout = mLayoutIdToRootViewIndex.valueAt (index);</span><br><span class="line">                    <span class="keyword">if</span> (layout != <span class="keyword">null</span>) {</span><br><span class="line">                        view = layout.findViewById (viewId);</span><br><span class="line">                    }</span><br><span class="line">    </span><br><span class="line">                    <span class="keyword">if</span> (view != <span class="keyword">null</span>) {</span><br><span class="line">                        mIdToSubViewIndex.put (viewId, view);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">UIWrapper 这个类很简单，它的功能概括成一句话就是动态扩容地持有一组 View 的匿名引用，并且具备通过 viewId 来检索 View 的能力。（以动态扩容地持有匿名引用的方式来实现代码复用，是一个简单却极其有效的实用技巧，在我的另外一篇文章 __用 “管道” 设计拆分复杂处理流程__ 中也有提到，感兴趣的读者可以移步一阅。）</span><br><span class="line"></span><br><span class="line">UIWrapper 在具体场景中是以继承或者依赖的方式被使用的，如果我们的分治 UI 控制器本身没有基类，可以直接继承自 UIWrapper ；如果已经有了继承结构，可以引入 UIWrapper 作为成员，进而间接引入目标 UI ，比如 Fragment 就适用这种情况。题外话，说到 Fragment，读者会不会意识到它其实就是框架本身提供的一种分治策略的具体实现呢？</span><br><span class="line"></span><br><span class="line"> 对于以继承方式使用 UI 包装器的方式，我们不妨设计下面这样一个基类 AbsUIController ，也就是前文我们说的要分治的 UI 控制器。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分治的 UI 控制器基类 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsUIController</span> <span class="keyword">extends</span> <span class="title">UIWrapper</span> </span>{</span><br><span class="line">        <span class="comment">// 生产环境中这个抽象层级中除了构造方法外还有一些实际的基础功能，</span></span><br><span class="line">        <span class="comment">// 但是与本文重点无关，此处略过 </span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbsUIController</span><span class="params">(@NonNull Activity activity)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            wrapUi (<span class="number">0</span>, activity.getWindow ().getDecorView (), <span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbsUIController</span><span class="params">(@NonNull Activity activity, UIWrapper ui)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            setUi (ui);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>再基于基类的 UI 控制器，我举一个在生产环境中实现的 UI 控制器为例，它的功能是为所有由它管理的 UI 元素提供独占可见状态的显示和隐藏过程处理的可复用的工具类。通俗的说，就是处理几个 View 同一时间只显示其中一个的情况。以下是简化的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoDisplayController</span> <span class="keyword">extends</span> <span class="title">AbsUIController</span> </span>{</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占展示空间显示给定视图 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view 要显示的视图 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monoDisplay</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>{ ... }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏由当前包装器管理的全部视图 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayBeforeStart 开始隐藏前的延时 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整个隐藏过程完成的总耗时，以毫秒计 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hideAll</span><span class="params">(<span class="keyword">long</span> delayBeforeStart)</span> </span>{ ... }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>读者是否可以想到这样的一个简单的 UI 控制器可以用在哪里呢？不妨先看一下 MonoDisplayController 这个类的用例的代码片段:</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将可见性互斥的 UI 元素包在同一个 MonoDisplayController 里，包含可下载图标，下载进度等 </span></span><br><span class="line"><span class="comment">// 注意，生产环境中的 UI 元素数量可能很多，都要求互斥显示，这时复用代码更能体现优势 </span></span><br><span class="line">viewHolder.monoDisplaysOnDownloadStatus = <span class="keyword">new</span> MonoDisplayController (getActivity ());</span><br><span class="line">viewHolder.monoDisplaysOnDownloadStatus</span><br><span class="line">        .wrapUi (R.id.iv_download_available, viewHolder.ivDownloadAvailable)</span><br><span class="line">        .wrapUi (R.id.download_progress_view, viewHolder.downloadProgressView)</span><br><span class="line">        .wrapUi (...)</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="comment">// 根据下载状态互斥展示不同的 UI 元素 </span></span><br><span class="line"><span class="keyword">switch</span> (entity.getDownloadStatus ()) {</span><br><span class="line"><span class="comment">// 正在下载 </span></span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_DOWNLOADING:</span><br><span class="line">    viewHolder.monoDisplaysOnDownloadStatus.monoDisplay (viewHolder.progressView);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 下载暂停，删除，未下载 </span></span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_PAUSE:</span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_DELETED:</span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_UN_DOWNLOAD:</span><br><span class="line">    viewHolder.monoDisplaysOnDownloadStatus.monoDisplay (viewHolder.downloadAvailableView);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>限于篇幅没有奉上无关的代码。我相信如果读者有过用许多 if , else 分支来协调多个 View 的可见性这种编码经验的话，应该会认同这样一个控制器是能够有效减少代码量和避免错误的。</p><p>讲到这里， UOP 的实例已经在代码中完整给出。读者请重点留意一下 <code>UIWrapper#wrapUi (int viewId, View view)</code> 这个方法，它体现了 UOP 最核心的思维方式： UI 是第一度的逻辑出发点。<strong>首先搞清楚我们要跟哪些 UI 打交道，然后才是要在这些 UI 上做些什么事情。</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.wrapUi (R.id.iv_download_available, viewHolder.ivDownloadAvailable)</span><br><span class="line">.wrapUi (R.id.download_progress_view, viewHolder.downloadProgressView)</span><br></pre></td></tr></tbody></table></figure><p>解释完 UOP 是什么，最后再来解释一下为什么 UOP 是分治 UI 的利器。前面说过 UOP 其实是 AOP 中的一种，而我认为 AOP 其实是贯彻第一性原理的一种思维方式：聚焦任务在同一维度的事物构成的某一条线索上。UI 是程序代码中被最直观呈现的东西，以软件用户的角色观察，UI 可能就是他可以感知的全部，这是一条最自然的线索。而对于程序员来说，这个认知其实也是完全适用的。</p><p>如果上面的描述不好理解，我再举一个维护代码的例子，程序员朋友可能就会有共鸣了。</p><blockquote><p><em>假定有程序员甲开发了一款软件，他很熟悉这款软件的代码。还有程序员乙从未接触过这款软件的代码。有一，乙在甲不能提供帮助的情况下，（比方说甲请假了）接受了一个任务：他要在短时间内调整一处 UI 。对于乙来说，最快的做法是先去阅读代码吗？恐怕不是。然而，现实场景中，在对代码一无所知的情况下，要我们基于别人的代码增改功能，这并不少见。倘若时间有限，无法阅读太多的代码，那么抓住目标的特点，从代码中找到线索，利用线索切入，则是快速搞定任务的靠谱思路。这其实只是专注于任务本身的结果，而并非什么独特的解题技巧。对于 UI 来说，不论是框架内化的设计模式，还是它本身最直观的外在呈现，往往都天然地提供了一条独立于常规代码之外的 线索。</em></p></blockquote><p>使用 UOP ，本质上是在分治 UI 控制逻辑的同时，仍然保持对关注点的聚焦。虽然 UI 被分出来了，但事还是那些事，并没有因为设立了一个分管的去处，就多出了额外的东西。同时，又因为分管，被分出来的这些事，作为一个可单独运行的逻辑，自身变得更加纯粹了，更容易被复用。当然，它带来的最重要的好处是：维护这件事变得更容易了。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;本文的主要价值： 提供一份软件开发中分治 UI 逻辑的实践样本&lt;/li&gt;
&lt;li&gt;关键词： 分治、 UOP&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;我们知道，分治策略是人们解决问题的一种基本策略。问题规模越大，内部包含的差异化的细节越多，越需要执行分治策略。&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所谓化整为零，化繁为简，逐个击破讲的都是分治。在计算机领域，我们要列举分治的例子，大的可以聊到七层网络模型（本质上分层也是一种分治），小的可以讲起二分算法。&lt;/p&gt;
&lt;p&gt;本文基于 Android 客户端开发中经常涉及的交互逻辑编程展开，表达我对于 UI 分治在软件开发中如何实践的理解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="programming" scheme="https://theinfinitegame.tech/categories/programming/"/>
    
    
      <category term="编程" scheme="https://theinfinitegame.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="UI" scheme="https://theinfinitegame.tech/tags/UI/"/>
    
  </entry>
  
  <entry>
    <title>极速 Swift 教程之十 | 可选型</title>
    <link href="https://theinfinitegame.tech/programming/swiftswift-optionals/"/>
    <id>https://theinfinitegame.tech/programming/swiftswift-optionals/</id>
    <published>2019-12-25T09:27:30.000Z</published>
    <updated>2019-12-28T06:29:12.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="处理缺失的数据"><a href="#处理缺失的数据" class="headerlink" title="处理缺失的数据"></a>处理缺失的数据</h1><p>我们已经会使用 <code>Int</code> 这样的类型来存储像 5 这样的数值。不过，当你想要存储用户年龄这样的属性，并且你还不知道该用户的年龄时你该怎么做呢？</p><p>你可能会说，“我可以暂时存成 0”，但这样一来你就会混淆新生儿和你不知道年龄的用户。你应该用一个特殊的数字，比如 1000 或者 -1 来代表 “未知”，这两个数字都不可能是年龄，但你能记得住这些特殊数字的含义吗？</p><p>Swift 的解决方案称为 <em>optional</em> ，即可选型。你可以基于任意类型创建可选型。一个可选型整数可以有诸如 1 或者 1000 这样的数字，也可能没有任何值，即值可以缺失， Swift 里表示缺失是用 <code>nil</code> 。</p><p>为了把一个类型变成可选型，只需要在类型后面加一个问号。举个例子，我们可以这样把一个整数变成可选型：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure><a id="more"></a><p>这个可选型现在并不保有任何整数，但是如果之后我们知道了年龄值，我们可以给它重新赋值。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">38</span></span><br></pre></td></tr></tbody></table></figure><hr><h1 id="解包可选型"><a href="#解包可选型" class="headerlink" title="解包可选型"></a>解包可选型</h1><p>可选型字符串可能包含一个 “Hello” 或者 <code>nil</code> 。</p><p>考虑这样一个可选字符串：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String?</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure><p>当我们调用 <code>name.count</code> 时会发生什么呢？一个真的字符串有 <code>count</code> 属性，它存储字符串的字符数量。但它是 <code>nil</code> 时，并没有 <code>count</code> 属性。</p><p>因此，试图直接使用 <code>name.count</code> 是不安全的， Swift 也不允许。取而代之的是，我们必须先检查可选型里面有些什么，这个过程被称为 <em>解包</em> 。</p><p>解包可选型的一种常见做法是采用 <code>if let</code> 语法，它是一种有条件的解包。如果可选型里有值，你就可以使用它，如果没有则条件失败。</p><p>举个例子：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrapped = name {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(unwrapped.count) letters"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Missing name."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果 <code>name</code> 持有一个字符串，这个字符串会被放进一个叫 <code>unwrapped</code> 的常规字符串，然后我们就可以读取它的 <code>count</code><br>属性。另一种情况，如果 <code>name</code> 是 nil， 那么 <code>else</code> 中的代码将被执行。</p><hr><h1 id="用-guard-解包可选型"><a href="#用-guard-解包可选型" class="headerlink" title="用 guard 解包可选型"></a>用 guard 解包可选型</h1><p><code>if let</code> 的一个替代方案是 <code>guard let</code> ，后者也可以用来解包可选型。 <code>guard let</code> 会为你解包，但是当它发现可选型里是 <code>nil</code> 时会期望你退出它所处的函数，循环或者条件。</p><p>因此， <code>if let</code> 和 <code>guard let</code> 的主要区别在于 <code>guard let</code> 之后可选型还可以继续使用。</p><p>让我们尝试一下 <code>greet ()</code> 函数。它将接收一个可选字符串作为唯一的参数，当它解包发现这个参数是 <code>nil</code> 时会打印消息并且退出函数。因为可选型 <code>unwrapped</code> 在 <code>guard let</code> 的语句块结束之后作用，我们可以在函数最后打印这个解包后的字符串。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> name: String?)</span></span> {</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = name <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You didn't provide a name!"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(unwrapped)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过使用 <code>guard let</code> ，你可以在函数的前面解决可选型的解包问题，在这之后的代码就可以愉快地使用解包后的值而不必担心出错了。</p><hr><h1 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h1><p>可选型代表可能存在也可能不存在的数据，而某些时候你是 <em>确切</em> 知道一个可选型的值并不是 <code>nil</code> 。在这种情况下， Swift 允许你强制解包这个可选型：通过把一个可选型转换为非可选型的方式。</p><p>举个例子，下面你试图将一个字符串转换成 <code>Int</code> ，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"5"</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)</span><br></pre></td></tr></tbody></table></figure><p>上面的代码中 <code>num</code> 其实是一个可选型 <code>Int</code> 。因为你有可能尝试转换一个不是数字的字符串导致转换失败。</p><p>尽管 Swift 不确定转换能否成功，你自己是知道你的结果是否可以安全地执行强制解包。这个强制解包是通过在 <code>Int (str)</code> 之后添加 <code>!</code> 来完成的。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)!</span><br></pre></td></tr></tbody></table></figure><p>通过强制解包， Swift 将立刻解包 <code>num</code> ，把它变成一个常规的 <code>Int</code> 而不是 <code>Int?</code> 。但是假如你是错的，比方说 <code>str</code> 是某个不能转换成数字的字符串，那么你的代码将崩溃。</p><p>强制解包的操作符常常被戏称为崩溃操作符。因此，只有当你确信强制解包是安全的你才能这么做。</p><hr><h1 id="隐式解包可选型"><a href="#隐式解包可选型" class="headerlink" title="隐式解包可选型"></a>隐式解包可选型</h1><p>像常规可选型一样，隐式解包可选型可能包含一个值也可能包含 <code>nil</code> 。不过，跟常规可选型不一样的是，隐式解包可选型时不需要再解包，你可以把它们当做非可选型一样使用。</p><p>隐式解包可选型是通过类型名之后添加感叹号来声明的，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="type">Int!</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure><p>由于它们表现起来就像已经被解包过的样子，你并不需要 <code>if let</code> 或者 <code>guard let</code> 这样的代码来测试它们。不过，当你试图使用它们而它们实际上没有值时，即它们的值是 <code>nil</code> 时，你的代码将崩溃。</p><p>隐式解包可选型存在的意义在于，有些情况某个变量一开始时是 <code>nil</code> ，但当你需要用到它之前它总会有值。如果你可以确信这一点，那么采用隐式解包可选型可以省去一直写 <code>if let</code> 的麻烦。</p><p>值得一提的是，如果条件允许采用常规可选型，安全起见最好总是采用常规可选型。</p><hr><h1 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h1><p>空合运算符解包一个可选型，如果可选型包含值则返回这个值，如果可选型不包含值，即可选型的值是 <code>nil</code> ，那么返回某个默认值。两种情况，返回值都不再是可选型：它要么是可选型里包含的有效值，要么是一个备选的默认值。</p><p>下面是一个接收整数作为唯一参数并且返回可选型字符串的函数：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">username</span><span class="params">(<span class="keyword">for</span> id: Int)</span></span> -&gt; <span class="type">String?</span> {</span><br><span class="line">  <span class="keyword">if</span> id == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Taylor Swift"</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们以 ID 15 来调用这个函数，我们将得到 <code>nil</code> 。通过空合运算符，我们可以提供一个叫 “Anonymous” 的默认值，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user = username (<span class="keyword">for</span>: <span class="number">15</span>) ?? <span class="string">"Anonymous"</span></span><br></pre></td></tr></tbody></table></figure><p>它将检查 <code>username ()</code> 函数返回的值：如果是一个字符串，它将被解包并放入 <code>user</code> ，如果是 <code>nil</code> ，则使用 “Anonymous” 替代。</p><hr><h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h1><p>在使用可选型时， Swift 为我们提供了一种快捷方式：假如你试图访问形如 <code>a.b.c</code> 这样的代码并且 <code>b</code> 是可选型，你可以在 <code>b</code> 后面写一个问号来启用 <em>可选链</em> ： <code>a.b?.c</code> 。</p><p>当代码运行时， Swift 会检查 <code>b</code> 是否有值，如果它是 <code>nil</code> ，那么这行代码剩下的部分将被忽略。Swift 会立即返回 <code>nil</code> 。但是如果 <code>b</code> 有值，它将被解包，代码执行将继续。</p><p>下面是一个名字的数组：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>]</span><br></pre></td></tr></tbody></table></figure><p>我们将使用数组的 <code>first</code> 属性，如果数组里第一个名字有值的话返回这个名字，如果数组为空则返回 <code>nil</code> 。在结果之上，我们调用 <code>uppercased ()</code> 把它变成一个全大写的字符串：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> beatle = names.first?.uppercased ()</span><br></pre></td></tr></tbody></table></figure><p>上面的问号就是可选链。如果 <code>first</code> 返回 <code>nil</code> ，那么 Swift 就不会尝试将它转换成全大写，它会将 <code>beatle</code> 立即设置为 <code>nil</code> 。</p><hr><h1 id="可选型-try"><a href="#可选型-try" class="headerlink" title="可选型 try"></a>可选型 try</h1><p>让我们回忆一下可能抛出错误的函数那一节的知识，看下面的代码：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PasswordError</span>: <span class="title">Error</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> obvious</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword</span><span class="params">(<span class="number">_</span> password: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> {</span><br><span class="line">  <span class="keyword">if</span> password == <span class="string">"password"</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">PasswordError</span>.obvious</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  <span class="keyword">try</span> checkPassword (<span class="string">"password"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"That password is good!"</span>)</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"You can't use that password."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过 <code>do</code> ， <code>try</code> 和 <code>catch</code> ，我们得以运行可能抛出错误的函数，并且优雅地处理错误。</p><p>上面的 <code>try</code> 写法其实有另外两种选择，这两种选项都能加深你对可选型和强制解包的理解。</p><p>第一个是 <code>try?</code> ，它将可能抛出错误的函数转换成返回可选型的函数。如果函数抛出错误，那你就会得到 <code>nil</code> 作为函数的执行结果，否则你会得到将返回值包装之后的可选型。</p><p>尝试使用 <code>try?</code> 来执行 <code>checkPassword ()</code> ，像下面这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result = <span class="keyword">try</span>? checkPassword (<span class="string">"password"</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Result was \(result)"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"D'oh."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外一种选择是 <code>try!</code> ，当你确信函数一定不会失败时你可以采用它。如果函数实际抛出了错误，你的代码将崩溃。</p><p>使用 <code>try!</code> 来重写前面的代码：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>! checkPassword (<span class="string">"sekrit"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"OK!"</span>)</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="失败构造器"><a href="#失败构造器" class="headerlink" title="失败构造器"></a>失败构造器</h1><p>当我们说到强制解包的时候，我用了下面的代码：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"5"</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)</span><br></pre></td></tr></tbody></table></figure><p>它将一个字符串转换成一个整数，但由于你可以传入任意字符串，你得到的实际上是一个可选型整数。</p><p>这里用到一种叫做 <em>失败构造器</em> 的东西：它是一种可能成功也可能失败的构造器。你在结构体或者类里面用 <code>init?()</code> 来实现失败构造器。如果某些东西出错，它将返回 <code>nil</code> 。因此这种构造器返回的是某种类型的可选型，你用之前需要解包。</p><p>举个例子，我们现在要求 <code>Person</code> 结构体必须通过一个 9 字符的 ID 字符串来构造。只要不是 9 个字符，都会返回 <code>nil</code> 。</p><p>Swift 代码如下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>?(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">if</span> id.<span class="built_in">count</span> == <span class="number">9</span> {</span><br><span class="line">      <span class="keyword">self</span>.id = id</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Swift 知道每个变量的类型，但有的时候你知道的信息比 Swift 更多。举个例子，这里有三个类：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{ }</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>: <span class="title">Animal</span> </span>{ }</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Woof!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们创建几个 <code>Fish</code> 和几个 <code>Dog</code> ，然后把它们放进一个数组，像下面这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = [<span class="type">Fish</span>(), <span class="type">Dog</span>(), <span class="type">Fish</span>(), <span class="type">Dog</span>()]</span><br></pre></td></tr></tbody></table></figure><p>Swift 知道 <code>Fish</code> 和 <code>Dog</code> 都继承自 <code>Animal</code> 类，因此它通过类型推断将 <code>pets</code> 创建为一个 <code>Animal</code> 类型的数组。</p><p>如果我们想遍历 <code>pets</code> 数组，让所有的狗发出叫声，我们需要执行一次类型转换： Swift 将检查每个 pet 是否 <code>Dog</code> 对象，以便我们调用 <code>makeNoise ()</code> 方法。</p><p>这里用到了一个关键字 <code>as?</code> ，它将返回一个可选型：类型转换失败时返回 <code>nil</code> ，成功则返回转换后的类型。</p><p>Swift 代码如下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> pet <span class="keyword">in</span> pets {</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> dog = pet <span class="keyword">as</span>? <span class="type">Dog</span> {</span><br><span class="line">    dog.makeNoise ()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p><ol><li>可选型让我们可以用一种清晰无歧义的方式表示值缺失的情况。 </li><li>Swift 不允许不经解包就使用可选型，解包可以用 <code>if let</code> 或者 <code>guard let</code> 。 </li><li>你可以用感叹号强制解包可选型，不过如果解出来的是 <code>nil</code> ，你的代码将会崩溃。 </li><li>隐式解包可选型没有做常规可选型的安全性检查。 </li><li>你可以使用空合运算符解包一个可选型，以便可选型里没有值时提供一个默认值。 </li><li>可选链用于操作可选型，如果可选型的值是空的，后续代码将被忽略。 </li><li>你可以使用 <code>try?</code> 将一个可能抛出错误的函数转换成一个可选型的返回值，或者使用 <code>try!</code> 在抛出错误时崩溃。 </li><li>如果你需要在输入不合理时让构造过程失败，可以使用 <code>init?()</code> 来创建失败构造器。 </li><li>你可以使用类型转换将一个类型转换为另一个类型。 </li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;处理缺失的数据&quot;&gt;&lt;a href=&quot;#处理缺失的数据&quot; class=&quot;headerlink&quot; title=&quot;处理缺失的数据&quot;&gt;&lt;/a&gt;处理缺失的数据&lt;/h1&gt;&lt;p&gt;我们已经会使用 &lt;code&gt;Int&lt;/code&gt; 这样的类型来存储像 5 这样的数值。不过，当你想要存储用户年龄这样的属性，并且你还不知道该用户的年龄时你该怎么做呢？&lt;/p&gt;
&lt;p&gt;你可能会说，“我可以暂时存成 0”，但这样一来你就会混淆新生儿和你不知道年龄的用户。你应该用一个特殊的数字，比如 1000 或者 -1 来代表 “未知”，这两个数字都不可能是年龄，但你能记得住这些特殊数字的含义吗？&lt;/p&gt;
&lt;p&gt;Swift 的解决方案称为 &lt;em&gt;optional&lt;/em&gt; ，即可选型。你可以基于任意类型创建可选型。一个可选型整数可以有诸如 1 或者 1000 这样的数字，也可能没有任何值，即值可以缺失， Swift 里表示缺失是用 &lt;code&gt;nil&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;为了把一个类型变成可选型，只需要在类型后面加一个问号。举个例子，我们可以这样把一个整数变成可选型：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; age: &lt;span class=&quot;type&quot;&gt;Int?&lt;/span&gt; = &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="programming" scheme="https://theinfinitegame.tech/categories/programming/"/>
    
    
      <category term="swift" scheme="https://theinfinitegame.tech/tags/swift/"/>
    
      <category term="编程" scheme="https://theinfinitegame.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>极速 Swift 教程之九 | 协议</title>
    <link href="https://theinfinitegame.tech/programming/swiftswift-protocol/"/>
    <id>https://theinfinitegame.tech/programming/swiftswift-protocol/</id>
    <published>2019-12-25T09:17:33.000Z</published>
    <updated>2019-12-28T06:29:14.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>协议是一种描述某个类型必须有某些属性和方法的方式。你告知 Swift 某个类型将使用某个协议，这个过程称为协议适配或者协议遵循。</p><p>举个例子，我们可以写一个函数接收 <code>id</code> 属性，但我们并不精确地关心用的是哪一种数据类型。让我们从 <code>Identifiable</code> 协议开始，这个协议要求所有遵循协议的类型必须有一个 <code>id</code> 字符串属性，并且这个字符串可读写。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> { <span class="keyword">get</span> <span class="keyword">set</span> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们无法创建协议的实例，因为协议只是一种描述，它本身并非一种类型。但是我们可以创建遵循它的结构体。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后，我们还可以写一个 <code>displayID ()</code> 函数，它接收 <code>Identifiable</code> 对象：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displayID</span><span class="params">(thing: Identifiable)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"My ID is \(thing.id)"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><hr><h1 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h1><p>一个协议可以继承另一个协议，这个过程称为协议继承。跟类不一样的是，你可以同一时间继承多个协议。</p><p>接下来我们将定义三个协议： <code>Payable</code> 要求遵循它的类型实现 <code>calculateWages ()</code> 方法， <code>NeedsTraining</code> 要求遵循它的类型实现 <code>study ()</code> 方法，而 <code>HasVacation</code> 要求遵循它的类型实现 <code>takeVacation ()</code> 方法：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Payable</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">calculateWages</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NeedsTraining</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">study</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HasVacation</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">takeVacation</span><span class="params">(days: Int)</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们可以创建一个 <code>Employee</code> 协议，将上面的三个协议合并在一起。我们还不打算添加额外的东西，因此简单地写一对花括号就行：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Employee</span>: <span class="title">Payable</span>, <span class="title">NeedsTraining</span>, <span class="title">HasVacation</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure><p>现在我们就可以创建遵循这个单一协议的类型，而不是分别遵循三个协议的类型。</p><hr><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>扩展使得你可以为已经存在的类型添加方法，实现它们设计时没有做的事情。</p><p>举个例子，我们可以为 <code>Int</code> 类型添加一个扩展方法 <code>squared ()</code> ，用来返回当前数的平方。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">squared</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> * <span class="keyword">self</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>尝试一下。创建一个整数，你会发现现在这个整数有了 <code>squared ()</code> 方法：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">8</span></span><br><span class="line">number.squared ()</span><br></pre></td></tr></tbody></table></figure><p>Swift 不允许你通过扩展添加存储属性，但可以用扩展添加计算属性。举个例子，我们给整数添加一个 <code>isEven</code> 的计算属性，这个属性返回当前数值是否为偶数：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> isEven: <span class="type">Bool</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h1><p>协议可以描述某个类型应当有某种方法，但并没有提供方法的代码。扩展实现有具体代码的方法，但一次只能作用于一个数据类型，你没办法同时给多个类型添加相同的代码。</p><p>协议扩展同时解决了这两个问题：它们就像常规扩展一样，差异只在于你并不是只扩展一个特定的类型，比如 <code>Int</code> ，你扩展是的一个协议，因而所有遵循这个协议的类型都会发生改变。</p><p>举个例子，下面有一个包含了一些名字的数组和一个同样包含了一些名字的集合：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pythons = [<span class="string">"Eric"</span>, <span class="string">"Graham"</span>, <span class="string">"John"</span>, <span class="string">"Michael"</span>, <span class="string">"Terry"</span>, <span class="string">"Terry"</span>]</span><br><span class="line"><span class="keyword">let</span> beatles = <span class="type">Set</span>([<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>])</span><br></pre></td></tr></tbody></table></figure><p>Swift 的数组和集合都遵循一个叫 <code>Collection</code> 的协议，因此我们可以给 <code>Collection</code> 协议扩展一个叫 <code>summarize ()</code> 的方法，这个方法逐一打印 <code>Collection</code> 里的元素。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">summarize</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There are \(count) of us:"</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> <span class="keyword">self</span> {</span><br><span class="line">      <span class="built_in">print</span>(name)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Array</code> 和 <code>Set</code> 都将获得这个方法。让我们来尝试一下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pythons.summarize ()</span><br><span class="line">beatles.summarize ()</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h1><p>协议扩展可以为我们自己的协议方法提供默认实现。这使得类型遵循协议变得更加容易，并且允许我们 “面向协议编程”—— 这是一种利用协议和协议扩展来加工代码的方式。</p><p>首先，我们这里有一个叫 <code>Identifiable</code> 的协议，它要求所有遵循协议的类型都有一个叫 <code>id</code> 的属性和叫一个叫 <code>identify ()</code> 的方法：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> { <span class="keyword">get</span> <span class="keyword">set</span> }</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然我们可以让每个遵循这个协议的类型书写它们自己的 <code>identify ()</code> 方法，但协议扩展允许我们可以提供一个默认实现：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"My ID is \(id)."</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在当我们再声明一个遵循 <code>Identifiable</code> 协议的类型时，它会自动获得 <code>identify ()</code> 方法的实现：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> paul = <span class="type">User</span>(id: <span class="string">"Paul"</span>)</span><br><span class="line">paul.identify ()</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p><ol><li>协议描述了一个遵循它的类型应该拥有的属性和方法，但并不提供那些方法的实现。 </li><li>你可以基于协议创建协议，这一点跟类相似。 </li><li>扩展允许你为类型添加方法和计算属性。 </li><li>协议扩展是为协议添加方法和计算属性。 </li><li>面向协议编程是这样一种实践：它把程序架构按照一系列协议来设计，然后利用协议扩展来提供默认实现。 </li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;协议&quot;&gt;&lt;a href=&quot;#协议&quot; class=&quot;headerlink&quot; title=&quot;协议&quot;&gt;&lt;/a&gt;协议&lt;/h1&gt;&lt;p&gt;协议是一种描述某个类型必须有某些属性和方法的方式。你告知 Swift 某个类型将使用某个协议，这个过程称为协议适配或者协议遵循。&lt;/p&gt;
&lt;p&gt;举个例子，我们可以写一个函数接收 &lt;code&gt;id&lt;/code&gt; 属性，但我们并不精确地关心用的是哪一种数据类型。让我们从 &lt;code&gt;Identifiable&lt;/code&gt; 协议开始，这个协议要求所有遵循协议的类型必须有一个 &lt;code&gt;id&lt;/code&gt; 字符串属性，并且这个字符串可读写。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protocol&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Identifiable&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; id: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt; { &lt;span class=&quot;keyword&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;set&lt;/span&gt; }&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;我们无法创建协议的实例，因为协议只是一种描述，它本身并非一种类型。但是我们可以创建遵循它的结构体。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;User&lt;/span&gt;: &lt;span class=&quot;title&quot;&gt;Identifiable&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; id: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;最后，我们还可以写一个 &lt;code&gt;displayID ()&lt;/code&gt; 函数，它接收 &lt;code&gt;Identifiable&lt;/code&gt; 对象：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;displayID&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(thing: Identifiable)&lt;/span&gt;&lt;/span&gt; {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;My ID is \(thing.id)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="programming" scheme="https://theinfinitegame.tech/categories/programming/"/>
    
    
      <category term="swift" scheme="https://theinfinitegame.tech/tags/swift/"/>
    
      <category term="编程" scheme="https://theinfinitegame.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>极速 Swift 教程之八 | 类</title>
    <link href="https://theinfinitegame.tech/programming/swiftswift-classes/"/>
    <id>https://theinfinitegame.tech/programming/swiftswift-classes/</id>
    <published>2019-12-25T02:10:59.000Z</published>
    <updated>2019-12-28T06:28:56.065Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建你自己的类"><a href="#创建你自己的类" class="headerlink" title="创建你自己的类"></a>创建你自己的类</h1><p>Swift 的类也能让你创建带有属性和方法的新类型，这一点和结构体很相似，但是它们之间有五个显著的区别。下面让我一一为你说明。</p><p>类和结构体的第一个区别是类没有逐一成员构造器。这意味着只要你的类里有属性，你就必须自行创建构造器。</p><p>举个例子：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>创建类的实例跟创建结构体的实例方式一样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> poppy = <span class="type">Dog</span>(name: <span class="string">"Poppy"</span>, breed: <span class="string">"Poodle"</span>)</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><hr><h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><p>类和结构体的第二个区别是类可以继承已经存在的类。新的类继承了原始类所有的属性和方法。</p><p>这个过程被称为 <em>类继承</em> 或者 <em>子类化</em> ， 被继承的类称为 “父类” 或者 “超类”， 而新的类称为 “子类” 。</p><p>下面是一个 <code>Dog</code> 类：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在让我们基于 <code>Dog</code> 来创建一个新的类 <code>Poodle</code> 。默认情况下，它会继承 <code>Dog</code> 的所有属性以及构造器。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不过，我们也可以为 <code>Poodle</code> 创建自己的构造器。我们知道这个类的 <code>breed</code> 属性总是 “Poodle”，因此我们可以创建一个只有 <code>name</code> 属性的构造器。并且，我们可以在 <code>Poodle</code> 的构造器里直接调用 <code>Dog</code> 的构造器，以便发生和 <code>Dog</code> 相同的构造过程。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, breed: <span class="string">"Poodle"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>出于安全性考虑， Swift 会要求你总是在子类里调用 <code>super.init ()</code> ，以防止类在构造时来自父类的一些重要工作被遗漏。</p><hr><h1 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h1><p>子类可以将父类的方法替换为自己的实现，这个过程被称为 <em>重写</em> 。 让我们给 <code>Dog</code> 类添加一个 <code>makeNoise ()</code> 方法：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Woof!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果你创建一个 <code>Poodle</code> 类继承自 <code>Dog</code> ，它会继承 <code>makeNoise ()</code> 方法。 “Woof!”:</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> poppy = <span class="type">Poodle</span>()</span><br><span class="line">poppy.makeNoise ()</span><br></pre></td></tr></tbody></table></figure><p>方法重写使得我们可以为 <code>Poodle</code> 类重新实现 <code>makeNoise ()</code> 。</p><p>Swift 要求我们在重写方法时用 <code>override func</code> 而不是 <code>func</code> ，这个限定防止你在自己不知情的情况下偶然重写方法。另外，试图重写一个父类中并不存在的方法，你会遭遇错误。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Yip!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>通过这个修改， <code>poppy.makeNoise ()</code> 将打印出 “Yip!”，而不是 “Woof!”。</p><hr><h1 id="Final-类"><a href="#Final-类" class="headerlink" title="Final 类"></a>Final 类</h1><p>尽管类继承十分有用，并且苹果的平台在许多地方要求你大量使用它，有的时候你会希望阻止其他开发者基于你的类构建新的类。</p><p>Swift 给了我们 <code>final</code> 关键字用于实现这种意图：当你把一个类声明为 <code>final</code> 时，将没有类能够继承它。这意味着没有人能通过重写方法来改变这个类的行为。</p><p>只需要把 <code>final</code> 关键字放在类前面，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h1><p>类和结构体的第三个区别是它们被复制的方式。当你复制一个结构体时，原始对象和复制体是不一样的两个东西，改变其中一个并不会改变另外一个。当你复制一个 <em>类</em> 时，原始对象和复制体都指向相同的东西，所以改变其中一个也会改变另一个。</p><p>举个例子，有一个简单的 <code>Singer</code> 类，它有一个带有默认值的 <code>name</code> 属性：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我们创建一个这个类的实例并且打印它的 <code>name</code> 时，我们会得到 “Taylor Swift” ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singer = <span class="type">Singer</span>()</span><br><span class="line"><span class="built_in">print</span>(singer.name)</span><br></pre></td></tr></tbody></table></figure><p>当我们基于第一个实例创建第二实例并且改变第二个实例的 <code>name</code> 时：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singerCopy = singer</span><br><span class="line">singerCopy.name = <span class="string">"Justin Bieber"</span></span><br></pre></td></tr></tbody></table></figure><p>由于类的工作机制， <code>singer</code> 和 <code>singerCopy</code> 指向内存里的同一个对象。所以当我们打印 <code>singer</code> 的 <code>name</code> 时，我们也会得 “Justin Bieber”：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(singer.name)</span><br></pre></td></tr></tbody></table></figure><p>另一方面，假如 <code>Singer</code> 是一个结构体，那第二次我们还将得到 “Taylor Swift” ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h1><p>类和结构体的第四个区别是类有 <em>析构器</em> ，它是一个类的实例被销毁时执行的代码。</p><p>这里有一个 <code>Person</code> 类，它有一个 <code>name</code> 属性，一个简单的构造器，以及一个打印信息的 <code>printGreeting ()</code> 方法：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"John Doe"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name) is alive!"</span>)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">printGreeting</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, I'm \(name)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们将利用循环创建几个 <code>Person</code> 类的实例，每次循环流转的时候，一个新的 <code>Person</code> 都会被创建，之后被销毁：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> {</span><br><span class="line">  <span class="keyword">let</span> person = <span class="type">Person</span>()</span><br><span class="line">  person.printGreeting ()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>来到我们的析构器。每当 <code>Person</code> 实例被销毁时，它的析构器都会被执行。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">deinit</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(name) is no more!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h1><p>类和结构体的最后一个区别是它们处理常量的方式。如果你有一个常量结构体，它有一个变量属性，那么这个变量属性是无法修改的。</p><p>但是，如果它是一个常量类，也有一个变量属性，那么这个变量属性是可以被修改的。基于这个区别，类的方法在改变属性时，并不需要 <code>mutating</code> 关键字，而结构体则需要。</p><p>这个区别意味着你可以修改类中的任何变量属性，即便类的实例本身被声明为常量。以下代码完全合法：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> taylor = <span class="type">Singer</span>()</span><br><span class="line">taylor.name = <span class="string">"Ed Sheeran"</span></span><br><span class="line"><span class="built_in">print</span>(taylor.name)</span><br></pre></td></tr></tbody></table></figure><p>如果你不想属性被修改，那么你必须直接将属性声明为常量。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p><ol><li>类和结构体很相似，它们都允许你创建自己的属性和方法。 </li><li>一个类可以继承自另一个类，它会获得父类的所有属性和方法。谈到类层次结构的时候，我们经常说一个类基于另一个类，也就是一个类继承自另一个类。 </li><li>你可以用 <code>final</code> 关键字来标记一个类，这样可以阻止它被继承。 </li><li>方法重写使得一个子类可以用全新的实现来替代父类中的实现。 </li><li>当两个变量指向同一个实例时，它们指代的对象在内存中占用同一块区域，改变其中一个也会改变另一个。 </li><li>类可以有析构器，它们是类的实例被销毁时执行的代码。 </li><li>类不像结构体那样受常量的强制约束。如果类的一个属性被声明为变量，那么无论类的实例是否以变量的方式创建，这个属性都可以被修改。 </li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;创建你自己的类&quot;&gt;&lt;a href=&quot;#创建你自己的类&quot; class=&quot;headerlink&quot; title=&quot;创建你自己的类&quot;&gt;&lt;/a&gt;创建你自己的类&lt;/h1&gt;&lt;p&gt;Swift 的类也能让你创建带有属性和方法的新类型，这一点和结构体很相似，但是它们之间有五个显著的区别。下面让我一一为你说明。&lt;/p&gt;
&lt;p&gt;类和结构体的第一个区别是类没有逐一成员构造器。这意味着只要你的类里有属性，你就必须自行创建构造器。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Dog&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; breed: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt;(name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, breed: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;) {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.name = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;self&lt;/span&gt;.breed = breed&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  }&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;创建类的实例跟创建结构体的实例方式一样：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; poppy = &lt;span class=&quot;type&quot;&gt;Dog&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Poppy&quot;&lt;/span&gt;, breed: &lt;span class=&quot;string&quot;&gt;&quot;Poodle&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="programming" scheme="https://theinfinitegame.tech/categories/programming/"/>
    
    
      <category term="swift" scheme="https://theinfinitegame.tech/tags/swift/"/>
    
      <category term="编程" scheme="https://theinfinitegame.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>极速 Swift 教程之七 | 结构体</title>
    <link href="https://theinfinitegame.tech/programming/swiftswift-structs/"/>
    <id>https://theinfinitegame.tech/programming/swiftswift-structs/</id>
    <published>2019-12-24T13:21:46.000Z</published>
    <updated>2019-12-28T06:29:19.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建你自己的结构体"><a href="#创建你自己的结构体" class="headerlink" title="创建你自己的结构体"></a>创建你自己的结构体</h1><p>Swift 允许你用两种方式创建自己的类型。其中一种最常见的叫做结构体，即 <code>struct</code> 。Struct 可以拥有自己的变量、常量以及函数，而你可以在任意时候创建和使用它们。</p><p>让我们以一个简单的例子开始：创建一个 <code>Sport</code> 结构体，它有一个叫 <code>name</code> 的字符串变量。在结构体中，这种变量被称为 <em>属性</em> 。因此，这是一个拥有一个属性的结构体。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>类型定义完成，现在让我们来创建和使用它的实例：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tennis = <span class="type">Sport</span>(name: <span class="string">"Tennis"</span>)</span><br><span class="line"><span class="built_in">print</span>(tennis.name)</span><br></pre></td></tr></tbody></table></figure><p><code>name</code> 和 <code>tennis</code> 都是变量，因而我们可以像常规变量那样修改它们：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tennis.name = <span class="string">"Lawn tennis"</span></span><br></pre></td></tr></tbody></table></figure><p>属性可以像常规变量那样拥有默认值，并且依赖 Swift 的类型推断。</p><a id="more"></a><hr><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>我们刚刚创建了 <code>Sport</code> 结构体：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>它有一个叫 <em>name</em> 的属性，存储 <code>String</code> 类型。这种属性叫做 <em>存储</em> 属性，因为 Swift 还有另外一种属性，它叫 <em>计算</em> 属性。这是一种通过运行代码来获得值的属性。</p><p>让我们为 <code>Sport</code> 结构体再增加一个存储属性，然后是一个计算属性。代码如下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> isOlympicSport: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> olympicStatus: <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">if</span> isOlympicSport {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"\(name) 是一项奥林匹克运动。"</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"\(name) 不是一项奥林匹克运动。"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如你所见， <code>olympicStatus</code> 看起来像一个常规的 <code>String</code> ，但它其实是依据其他的属性返回不同的值。</p><p>让我们来创建一个 <code>Sport</code> 实例：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> chessBoxing = <span class="type">Sport</span>(name: <span class="string">"Chessboxing"</span>, isOlympicSport: <span class="literal">false</span>)</span><br><span class="line"><span class="built_in">print</span>(chessBoxing.olympicStatus)</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h1><p>属性观察者允许我们可以在属性变化前后运行代码。让我们来写一个名叫 <code>Progress</code> 的结构体，这个结构体追踪一个任务以及它完成的百分比：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Progress</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> task: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> amount: <span class="type">Int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在，创建这个结构体的实例，随着时间的推移调整它的进度：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> progress = <span class="type">Progress</span>(task: <span class="string">"加载数据"</span>, amount: <span class="number">0</span>)</span><br><span class="line">progress.amount = <span class="number">30</span></span><br><span class="line">progress.amount = <span class="number">80</span></span><br><span class="line">progress.amount = <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure><p>我们期望 Swift 在每一次 <code>amount</code> 改变的时候都打印信息，这里可以用到一个叫 <code>didSet</code> 属性观察者。它可以用于每一次 <code>amount</code> 改变之后运行代码：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Progress</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> task: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> amount: <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">didSet</span> {</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"\(task) 已完成 \(amount)%。"</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你还可以用到叫 <code>willSet</code> 的属性观察者。它是在属性改变之前作用，相对来说更不常用。</p><hr><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Struct 的内部可以拥有函数，它们在必要时可以使用结构体的属性。这种函数被称为 <em>方法</em> ，关键字也是 <code>func</code> 。</p><p>现在我们通过一个叫 <code>City</code> 的结构体来演示。它有一个 <code>population</code> 属性，用于存储城市里的人口。此外，它还有一个 <code>collectTaxes ()</code> 方法，这个方法返回人口数乘以 1000。 由于方法是属于 <code>City</code> 的，它可以读取当前城市的 <code>population</code> 属性。</p><p>代码如下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">City</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> population: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">collectTaxes</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> population * <span class="number">1000</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>基于结构体调用方法的代码如下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> xiamen = <span class="type">City</span>(population: <span class="number">4_110_000</span>)</span><br><span class="line">xiamen.collectTaxes ()</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="可变方法"><a href="#可变方法" class="headerlink" title="可变方法"></a>可变方法</h1><p>如果一个结构体拥有一个变量属性，但是这个结构体的实例是以常量的方式创建的，那么在实例中，这个变量属性是不能修改的。这是因为结构体本身已经是常量了，所以它的所有属性也是常量。</p><p>这里面有一个问题， Swift 无从得知你将以常量还是变量的方式使用结构体。所以安全起见， Swift 的默认策略是：不允许你在方法里修改属性，除非你显式地要求这一点。</p><p>当你想要改变属性值时，需要在方法前使用 <code>mutating</code> 关键字，就像这样：</p> <figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAnonymous</span><span class="params">()</span></span> {</span><br><span class="line">    name = <span class="string">"Anonymous"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于这个方法改变了属性值，所以 Swift 只会允许这个方法在变量型的 <code>Person</code> 实例上调用。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>(name: <span class="string">"Ed"</span>)</span><br><span class="line">person.makeAnonymous ()</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="String-的属性和方法"><a href="#String-的属性和方法" class="headerlink" title="String 的属性和方法"></a>String 的属性和方法</h1><p>目前为止我们已经大量地使用了字符串。你发现了吗？其实 <code>String</code> 类型是一个结构体类型。它有许多属性和方法，用于查询和维护字符串本身。</p><p>首先，我们创建一个测试字符串：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"Do or do not, there is no try."</span></span><br></pre></td></tr></tbody></table></figure><p>你可以用 <code>count</code> 属性来读取这个字符串里的字符数量：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.<span class="built_in">count</span>)</span><br></pre></td></tr></tbody></table></figure><p>字符串有一个 <code>hasPrefix ()</code> 方法，可以用来检测字符串是否以特定字符开头：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.hasPrefix (<span class="string">"Do"</span>))</span><br></pre></td></tr></tbody></table></figure><p>你还可以用 <code>uppercased ()</code> 方法把一个字符串转换成全大写的版本：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.uppercased ())</span><br></pre></td></tr></tbody></table></figure><p>你甚至可以让 Swift 将字符串中的字母重新排序成一个数组：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.sorted ())</span><br></pre></td></tr></tbody></table></figure><p>String 类型有大量的属性和方法。 你可以利用 Xcode 的代码补全，用 <code>string.</code> 调取这些选项看一看它们都有些什么能力。</p><hr><h1 id="数组的属性和方法"><a href="#数组的属性和方法" class="headerlink" title="数组的属性和方法"></a>数组的属性和方法</h1><p>数组同样也是结构体，这意味着它们也有可以用来查询和操作数组的属性和方法。</p><p>从一个简单的数组开始：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toys = [<span class="string">"Woody"</span>]</span><br></pre></td></tr></tbody></table></figure><p>你可以用 <code>count</code> 属性来读取数组的元素个数：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(toys.<span class="built_in">count</span>)</span><br></pre></td></tr></tbody></table></figure><p>如果你需要增加一个元素，可以使用 <code>append ()</code> 方法，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toys.append (<span class="string">"Buzz"</span>)</span><br></pre></td></tr></tbody></table></figure><p>你可以用 <code>firstIndex ()</code> 方法来定位元素在数组里的位置，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toys.firstIndex (of: <span class="string">"Buzz"</span>)</span><br></pre></td></tr></tbody></table></figure><p>上面的代码会返回 1 ，因为数组位置从 0 开始计数。</p><p>跟字符串一样，你可以让 Swift 以字母表顺序给数组的元素重新排序。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(toys.sorted ())</span><br></pre></td></tr></tbody></table></figure><p>最后，如果你想要移除数组里的一个元素，可以使用 <code>remove ()</code> 方法，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">toys.remove (at: <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure><p>数组类型也有大量的属性和方法。 你可以利用 Xcode 的代码补全，用 <code>toys.</code> 调取这些选项看一看它们都有些什么能力。</p><hr><h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p>构造器是一种可以用来支持不同方式创建结构体的特殊方法。所有的结构体都有一个默认的构造器，这个构造器被称为 <em>逐一成员构造器</em> ，它要求你为结构体的每一个属性都提供一个值。</p><p>让我们来声明一个 <code>User</code> 结构体，它有一个属性：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当我们创建这个结构体的实例时，我们需要提供一个 <code>username</code> ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="type">User</span>(username: <span class="string">"Paul"</span>)</span><br></pre></td></tr></tbody></table></figure><p>当然，我们也可以创建自己的构造器用以替换默认的。举个例子，我们可能希望所有的新用户默认都叫 “Anonymous” ，并且会打印一条信息，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    username = <span class="string">"Anonymous"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"创建新用户！"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你并不需要在构造器前面写 <code>func</code> 关键字，但你必须确保构造器结束前所有的属性都被赋值。</p><p>现在让我们来用上这个没有参数的构造器，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="type">User</span>()</span><br><span class="line">user.username = <span class="string">"Paul"</span></span><br></pre></td></tr></tbody></table></figure><hr><h1 id="引用当前实例"><a href="#引用当前实例" class="headerlink" title="引用当前实例"></a>引用当前实例</h1><p>方法的内部，有一个特殊的常量叫 <code>self</code> ，它指向当前正在使用的结构体实例。当你在构造器中遇到参数名和属性名相同的情况时，这个 <code>self</code> 会很有用。</p><p>举个例子，如果你声明一个 <code>Person</code> 的结构体，它有一个 <code>name</code> 属性，并且你尝试写一个接收名为 <code>name</code> 参数的构造器，那么 <code>self</code> 可以帮助你区分属性和参数。 <code>self.name</code> 指代属性，而 <code>name</code> 指代参数。</p><p>代码如下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name) was born!"</span>)</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="懒加载属性"><a href="#懒加载属性" class="headerlink" title="懒加载属性"></a>懒加载属性</h1><p>作为一种性能优化手段， Swift 允许你在用到的时候才真正创建属性。举个例子，这里有一个叫 <code>FamilyTree</code> 的结构体，它做的工作很容易描述。但理论上为一个人创建族谱可能会是一个很耗时的过程：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FamilyTree</span> </span>{</span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"创建族谱！"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以在 <code>Person</code> 结构体内将 <code>FamilyTree</code> 作为一个属性来使用，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> familyTree = <span class="type">FamilyTree</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ed = <span class="type">Person</span>(name: <span class="string">"Ed"</span>)</span><br></pre></td></tr></tbody></table></figure><p>假如某些情况我们并不需要用到某个人的族谱信息呢？我们可以在 <code>familyTree</code> 属性前添加 <code>lazy</code> 关键字， Swift 将会在 <code>familyTree</code> 属性第一次被访问的时候才执行创建代码：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> familyTree = <span class="type">FamilyTree</span>()</span><br></pre></td></tr></tbody></table></figure><p>因此，如果你想要看到 “创建族谱！” 这条信息被打印，你至少需要访问 <code>familyTree</code> 属性一次：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ed.familyTree</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h1><p>目前为止我们认识的所有属性和方法都是属于独立的结构体实例，这意味着假如我们有一个叫 <code>Student</code> 的结构体，我们可以创建几个 student 实例，每个实例都有各自的属性和方法：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ed = <span class="type">Student</span>(name: <span class="string">"Ed"</span>)</span><br><span class="line"><span class="keyword">let</span> taylor = <span class="type">Student</span>(name: <span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure><p>你可以要求 Swift 在不同的结构体实例之间共享属性和方法，这些属性和方法被称为静态属性和静态方法，实现的方式是添加 <em>static</em> 声明。</p><p>现在，让我们给 <code>Student</code> 结构体添加一个静态属性，用以存放班级学生的总数。每当我们创建一个新的 student 实例时，我们将这个属性的数值加 1 ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> classSize = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="type">Student</span>.classSize += <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>classSize</code> 属性是属于结构体本身而非结构体的实例，因此我们需要用 <code>Student.classSize</code> 来访问它：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">Student</span>.classSize)</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>访问控制使得我们可以限制哪些代码能够访问属性和方法。这个机制在你想要保护属性免于被直接读取的时候很有用，举个例子：</p><p>我们仍然创建一个 <code>Person</code> 结构体，它有一个 <code>id</code> 属性，用来存放社保 ID：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ed = <span class="type">Person</span>(id: <span class="string">"12345"</span>)</span><br></pre></td></tr></tbody></table></figure><p>一旦 person 实例被创建，我们希望它的 <code>id</code> 是私有的。私有的意思是你不能从结构体外部读取它，像 <code>ed.id</code> 这样的代码会变得不合法。</p><p>要做到这一点，你需要用到 <code>private</code> 关键字，像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这么写之后，只有 <code>Person</code> 内部的方法才能读取 <code>id</code> 属性。举个例子：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我的社保 ID 是 \(id)"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>还有一个常见的选项是 <code>public</code> ，它使得所有的其他代码都能够访问到目标属性或者方法。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们一起来总结一下。</p><ol><li>你可以创建自己的结构体类型，它们有自己的属性和方法。 </li><li>你学习了存储属性，以及每一次通过临时计算得到值的计算属性。 </li><li>当你希望在方法中修改属性时，需要把方法标记成 <code>mutating</code> 。 </li><li>构造器是创建结构体时的特殊方法。默认情况下，你会得到一个逐一成员构造器。不过，如果你想要自行实现构造器的话，需要确保所有的属性都被赋值。 </li><li>你可以在方法中用 <code>self</code> 常量来引用当前正在使用的结构体实例。 </li><li><code>lazy</code> 关键字告诉 Swift 你希望属性在第一次访问时才被创建。 </li><li>可以利用 <code>static</code> 关键字在结构体的所有实例间共享属性和方法。 </li><li>访问控制使得我们可以限制哪些代码能够访问属性和方法。 </li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;创建你自己的结构体&quot;&gt;&lt;a href=&quot;#创建你自己的结构体&quot; class=&quot;headerlink&quot; title=&quot;创建你自己的结构体&quot;&gt;&lt;/a&gt;创建你自己的结构体&lt;/h1&gt;&lt;p&gt;Swift 允许你用两种方式创建自己的类型。其中一种最常见的叫做结构体，即 &lt;code&gt;struct&lt;/code&gt; 。Struct 可以拥有自己的变量、常量以及函数，而你可以在任意时候创建和使用它们。&lt;/p&gt;
&lt;p&gt;让我们以一个简单的例子开始：创建一个 &lt;code&gt;Sport&lt;/code&gt; 结构体，它有一个叫 &lt;code&gt;name&lt;/code&gt; 的字符串变量。在结构体中，这种变量被称为 &lt;em&gt;属性&lt;/em&gt; 。因此，这是一个拥有一个属性的结构体。&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Sport&lt;/span&gt; &lt;/span&gt;{&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; name: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;类型定义完成，现在让我们来创建和使用它的实例：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; tennis = &lt;span class=&quot;type&quot;&gt;Sport&lt;/span&gt;(name: &lt;span class=&quot;string&quot;&gt;&quot;Tennis&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(tennis.name)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;code&gt;name&lt;/code&gt; 和 &lt;code&gt;tennis&lt;/code&gt; 都是变量，因而我们可以像常规变量那样修改它们：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tennis.name = &lt;span class=&quot;string&quot;&gt;&quot;Lawn tennis&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;属性可以像常规变量那样拥有默认值，并且依赖 Swift 的类型推断。&lt;/p&gt;
    
    </summary>
    
    
      <category term="programming" scheme="https://theinfinitegame.tech/categories/programming/"/>
    
    
      <category term="swift" scheme="https://theinfinitegame.tech/tags/swift/"/>
    
      <category term="编程" scheme="https://theinfinitegame.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>极速 Swift 教程之六 | 闭包</title>
    <link href="https://theinfinitegame.tech/programming/swiftswift-closures/"/>
    <id>https://theinfinitegame.tech/programming/swiftswift-closures/</id>
    <published>2019-12-24T13:05:51.000Z</published>
    <updated>2019-12-28T06:28:58.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建基本的闭包"><a href="#创建基本的闭包" class="headerlink" title="创建基本的闭包"></a>创建基本的闭包</h1><p>Swift 允许我们像字符串和整数一样使用函数。具体来说，你可以创建一个函数然后把它赋给一个变量，利用那个变量来调用函数。你甚至可以把函数作为参数传给另一个函数。</p><p>函数的这种用法被称为 <em>闭包</em> 。虽然工作机制差不多，写法上是有一些小差异的。</p><p>还是以打印信息为例：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我要去开车"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码实际上创建了一个匿名的函数，并将这个函数赋给了 <code>driving</code> 。之后你就可以把 <code>driving ()</code> 当作一个常规的函数来用，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driving ()</span><br></pre></td></tr></tbody></table></figure><a id="more"></a><hr><h1 id="在闭包中接收参数"><a href="#在闭包中接收参数" class="headerlink" title="在闭包中接收参数"></a>在闭包中接收参数</h1><p>当你创建闭包的时候，它们并没有名字，也没有提供书写参数的地方。但这并不意味着它们不能接收参数，只不过它们接收参数的方式稍有不同：这些参数是被写在花括号里面的。</p><p>为了让一个闭包接收参数，你需要在花括号之后把这些参数列出来，然后跟上一个 <code>in</code> 关键字。这样就告诉 Swift ，闭包的主体是从哪里开始的。</p><p>举个例子，我们来创建一个闭包，接收一个叫 <code>place</code> 的字符串作为唯一的参数，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我要开车去 \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>函数和闭包的一个区别是运行闭包的时候你不会用到参数标签。因此，调用 <code>driving ()</code> 的时候，我们是这样写的：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driving (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="从闭包中返回值"><a href="#从闭包中返回值" class="headerlink" title="从闭包中返回值"></a>从闭包中返回值</h1><p>闭包也能返回值，写法和闭包的参数类似：写在闭包内部， <code>in</code> 关键字前面。</p><p>还是以 <code>driving ()</code> 闭包为例， 让它返回一个字符串。原来的函数是这样的：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我要开车去  \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>改成返回字符串而不是直接打印那个字符串，需要 <code>in</code> 之前添加 <code>-&gt; String</code> ，然后像常规函数那样用到 <code>return</code> 关键字:</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> drivingWithReturn = { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在我们运行这个闭包并且打印出它的返回值：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message = drivingWithReturn (<span class="string">"北京"</span>)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="闭包作为参数"><a href="#闭包作为参数" class="headerlink" title="闭包作为参数"></a>闭包作为参数</h1><p>既然闭包可以像字符串和整数一样使用，你就可以将它们传入函数。闭包作为参数的语法乍一看一看挺伤脑筋的，让我们慢慢来。</p><p>首先，还是基本的 <code>driving ()</code> 闭包。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们打算把这个闭包传入一个函数，以便函数内部可以运行这个闭包。我们需要把函数的参数类型指定为 <code>() -&gt; Void</code> 。它的意思是 “不接收参数，并且返回 <code>Void</code> ”。在 Swift 中， <code>Void</code> 是什么也没有的意思。</p><p>好了，让我们来写一个 <code>travel ()</code> 函数，接收不同类型的 traveling 动作， 并且在动作前后分别打印信息：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  action ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在可以用上 <code>driving</code> 闭包了，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travel (action: driving)</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="拖尾闭包语法"><a href="#拖尾闭包语法" class="headerlink" title="拖尾闭包语法"></a>拖尾闭包语法</h1><p>如果一个函数的最后一个参数是闭包， Swift 允许你采用一种被称为 <em>“拖尾闭包语法”</em> 的方式来调用这个闭包。你可以把闭包传入函数之后的花括号里，而不必像传入参数那样。</p><p>又用到我们的 <code>travel ()</code> 函数了。它接收一个 <code>action</code> 闭包。闭包在两个 <code>print ()</code> 调用之间执行:</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  action ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于函数的最后一个参数是闭包，我们可以用拖尾闭包语法来调用 <code>travel ()</code> 函数，就像这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel () {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际上，由于函数没有别的参数了，我们还可以将圆括号完全移除：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>拖尾闭包语法在 Swift 中非常常见，所以你要适应它。</p><hr><h1 id="使用接收参数的闭包作为函数的参数"><a href="#使用接收参数的闭包作为函数的参数" class="headerlink" title="使用接收参数的闭包作为函数的参数"></a>使用接收参数的闭包作为函数的参数</h1><p>接下来要说到的闭包用法会有点复杂：当你把闭包作为函数参数时，闭包本身也接收参数。</p><p>前面我们用 <code>() -&gt; Void</code> 来表示 “不接收参数，并且什么也不返回”，但实际上你可以在 <code>()</code> 里填上你任何想要闭包接收的参数类型。</p><p>再次用到 <code>travel ()</code> 函数。函数只接收一个闭包作为参数，但这次闭包会接收一个字符串参数：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  action (<span class="string">"北京"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在，当我们采用拖尾闭包语法调用 <code>travel ()</code> 时，我们的闭包代码会要求接收一个字符串：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备开车去 \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="使用有返回值的闭包作为函数的参数"><a href="#使用有返回值的闭包作为函数的参数" class="headerlink" title="使用有返回值的闭包作为函数的参数"></a>使用有返回值的闭包作为函数的参数</h1><p>我们之前用 <code>() -&gt; Void</code> 来表示 “不接收参数，并且什么也不返回”。你可以把 <code>Void</code> 替换成任意的类型从而让闭包可以返回值。</p><p>还是 <code>travel ()</code> 函数，这次闭包会返回一个字符串。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  <span class="keyword">let</span> description = action (<span class="string">"北京"</span>)</span><br><span class="line">  <span class="built_in">print</span>(description)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>仍然用拖尾闭包语法来调用 <code>travel ()</code> ，闭包要求接收一个字符串并且返回一个字符串：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="速记参数名"><a href="#速记参数名" class="headerlink" title="速记参数名"></a>速记参数名</h1><p>前面我们了构建 <code>travel ()</code> 函数。它接收一个闭包作为参数，这个闭包本身接收一个参数并且返回一个字符串，它在两个 <code>print ()</code> 调用之间运行。</p><p>代码如下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  <span class="keyword">let</span> description = action (<span class="string">"北京"</span>)</span><br><span class="line">  <span class="built_in">print</span>(description)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以像这样调用 <code>travel ()</code> ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不过， Swift 知道提供给闭包的参数必须是一个字符串，所以调用的代码可以简写成这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel { place -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Swfit 也知道闭包必须返回一个字符串，于是进一步简写：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel { place <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>由于这里的闭包只有一行代码，这行代码肯定是返回值的那行代码，因此 Swift 允许我们把 <code>return</code> 关键字也移除：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel { place <span class="keyword">in</span></span><br><span class="line">  <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后， Swift 还提供一种速记语法，让你可以把代码变得更短。我们可以让 Swift 为闭包的参数自动提供一个名字，而不必自行写下 <code>place in</code> 。这些自动生成的名字以 $ 开头，然后跟着一个从 0 开始的整数，就像下面这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="string">"我要开车去 \($0)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="有多个参数的闭包"><a href="#有多个参数的闭包" class="headerlink" title="有多个参数的闭包"></a>有多个参数的闭包</h1><p>让我们把闭包这个概念一次讲透吧。接下来举一个接收两个参数的闭包的例子。</p><p>将 <code>travel ()</code> 函数改造一下，不仅接收旅行目的地，也接收速度。闭包的类型会变成 <code>(String, Int) -&gt; String</code> ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String, Int)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。)</span></span><br><span class="line"><span class="string">  let description = action ("</span> 北京 &lt; span class="string"&gt;", 60)</span><br><span class="line"><span class="string">  print (description)</span></span><br><span class="line"><span class="string">  print ("</span> 我到达目的地了。<span class="string">")</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure><p>再一次用速记闭包参数名来调用函数。由于这次闭包有两个参数了，于是自动参数名分别是 <code>$0</code> 和 <code>$1</code> ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="string">"我要开车去 \($0)，时速 \($1) 公里每小时。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>有些人可能不喜欢用速记参数名，因为它们的语义不是很清晰。你可以根据自己的喜好来决定是否采用它们。不过了解一下这个语法还是必要的，这样读到别人的代码时就不会感到困惑。</p><hr><h1 id="从函数中返回闭包"><a href="#从函数中返回闭包" class="headerlink" title="从函数中返回闭包"></a>从函数中返回闭包</h1><p>就如同你可以把闭包传入函数那样，你也可以从函数中返回闭包。</p><p>返回闭包的语法看起来有点绕，因为用了两次 <code>-&gt;</code> ：第一次用于指定函数的返回值，第二次用于指定闭包的返回值。</p><p>又又又要把 <code>travel ()</code> 函数拉出来了。这次它不接收参数，但返回一个闭包。这个返回的闭包在用的时候必须传入一个字符串，但闭包本身没有返回值。</p><p>Swift 代码长这样：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"我要动身去 \($0)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来我们通过调用 <code>travel ()</code> 拿到闭包，然后作为函数来调用：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = travel ()</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure><p>留意下面的代码，它是直接调用 <code>travel ()</code> 的返回值。这个写法虽然在语法上完全没问题，但是可读性较差，建议尽量不要这样写。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result2 = travel ()(<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h1><p>如果你想要使用闭包之外的对象， Swift 会为你 “捕捉” 它们，并把它们和闭包一同存储，以便外部作用域已经失效的情况下闭包内部还可以使用它们。</p><p>最后一次用到 <code>travel ()</code> 函数，它返回一个闭包，这个闭包接收字符串作为唯一的参数并且什么也不返回：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"我准备去 \($0)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>调用 <code>travel ()</code> 拿到闭包，然后自由使用：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = travel ()</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure><p>闭包捕获变量可以发生在什么情况下呢？举个例子，当 <code>travel ()</code> 函数内创建了一个变量，这个变量需要在闭包里面用到，那么这个变量就会被闭包捕获。比如，我们想知道闭包被调用的次数：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第 \(counter) 次，我将前往 \($0)"</span>)</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>尽管 <code>counter</code> 变量是在 <code>travel ()</code> 里被创建的，它被闭包捕获，因而会在闭包内部存续。</p><p>当我们多次调用 <code>result (" 北京 ")</code> ，计数器会持续增加：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result (<span class="string">"北京"</span>)</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p><ol><li>你可以把闭包赋值给变量，之后再用变量名来调用闭包。 </li><li>闭包和常规函数一样可以接收参数和返回值。 </li><li>你可以将闭包作为参数传入函数，并且这些闭包也可以有自己的参数和返回值。 </li><li>如果函数的最后一个参数是闭包，你可以使用拖尾闭包语法。 </li><li>Swift 为拖尾闭包语法自动生成了 <code>$0</code> 和 <code>$1</code> 这样的速记闭包参数名，但不是所有人都习惯这种速记法。 </li><li>如果你在闭包中使用了外部变量，这些变量将被闭包 “捕捉” 以便后续引用。 </li></ol><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;创建基本的闭包&quot;&gt;&lt;a href=&quot;#创建基本的闭包&quot; class=&quot;headerlink&quot; title=&quot;创建基本的闭包&quot;&gt;&lt;/a&gt;创建基本的闭包&lt;/h1&gt;&lt;p&gt;Swift 允许我们像字符串和整数一样使用函数。具体来说，你可以创建一个函数然后把它赋给一个变量，利用那个变量来调用函数。你甚至可以把函数作为参数传给另一个函数。&lt;/p&gt;
&lt;p&gt;函数的这种用法被称为 &lt;em&gt;闭包&lt;/em&gt; 。虽然工作机制差不多，写法上是有一些小差异的。&lt;/p&gt;
&lt;p&gt;还是以打印信息为例：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; driving = {&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;print&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;我要去开车&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;}&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;上面的代码实际上创建了一个匿名的函数，并将这个函数赋给了 &lt;code&gt;driving&lt;/code&gt; 。之后你就可以把 &lt;code&gt;driving ()&lt;/code&gt; 当作一个常规的函数来用，就像这样：&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;driving ()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="programming" scheme="https://theinfinitegame.tech/categories/programming/"/>
    
    
      <category term="swift" scheme="https://theinfinitegame.tech/tags/swift/"/>
    
      <category term="编程" scheme="https://theinfinitegame.tech/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
