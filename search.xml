<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>聊一聊 UI 代码要怎么写 | 分治篇</title>
    <url>/programming/ui-programming-howto/</url>
    <content><![CDATA[<ul>
<li>本文的主要价值： 提供一份软件开发中分治 UI 逻辑的实践样本</li>
<li>关键词： 分治、 UOP</li>
</ul>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><blockquote>
<p><em>我们知道，分治策略是人们解决问题的一种基本策略。问题规模越大，内部包含的差异化的细节越多，越需要执行分治策略。</em></p>
</blockquote>
<p>所谓化整为零，化繁为简，逐个击破讲的都是分治。在计算机领域，我们要列举分治的例子，大的可以聊到七层网络模型（本质上分层也是一种分治），小的可以讲起二分算法。</p>
<p>本文基于 Android 客户端开发中经常涉及的交互逻辑编程展开，表达我对于 UI 分治在软件开发中如何实践的理解。</p>
<a id="more"></a>

<h1 id="从-MVC-说起"><a href="#从-MVC-说起" class="headerlink" title="从 MVC 说起"></a>从 MVC 说起</h1><p>经典的 <strong><a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC</a></strong> 设计模式想必各位程序猿们无人不晓。 MVC 最早存在于桌面程序中，后来由于其强大的复用性被广泛地发掘和应用于各端的开发中，还衍生出 MVP ， MVVM 等变体。如果把 MVC 的变体都算作 MVC ，可以说现如今任何一个成熟的 GUI 框架都内化了这种设计模式。放图：</p>
<p><img src="./images/MVC-vs-MVP-vs-MVVM.png" alt=""></p>
<p>然而我今天不是要来谈 MVC 设计模式的，因为网络上以各种姿势深入浅出 MVC 的好文章已经多的不能再多。之所以提及 MVC 模式只是想借此提醒读者， <strong>解耦</strong> 对于编程的重要性。</p>
<p>MVC 之所以看起来很简单却又如此广泛地被使用就在于它有效地解决了一个已知的，规模庞大的 <strong>耦合</strong> 问题：“你看到的”（不妨理解为 MVC 中的 View ) 和 “它代表的” (不妨理解为 MVC 中的 Model )，这两个东西永远不可能完全一致。</p>
<p>我们有时候需要用相同的表象去表示不同的真相，有时候则需要用不同的表象去表达同一个真相。而当我们尝试把两者捆绑在一起处理时，一旦映射关系发生变化，这个捆绑体便不再适用，需要重新构建。这样一来，原来的东西就都不能用了。所以我们需要一套机制来避免这种耦合，从而实现 Model 和 View 各自的复用。</p>
<blockquote>
<p><em>想要简单的理解这个问题，思考一下我们如何造字，为什么只需要造出常用的几千个汉字就能够表达一个人在生活中遇到的绝大部分事物？又为什么同一个字词在不同的场景下可以表达不同的含义？</em></p>
</blockquote>
<p>MVC 正是通过解耦 Model 和 View ，使得大量的 UI 可以被标准化，进而被重复利用。而这个问题之所以规模巨大，是因为只要一个计算机程序是给人类用的，就一定会涉及到人机交互，也就是我们常说的 UI 。</p>
<p>在解决了耦合问题并实现复用时， MVC 引入了 <strong>Controller</strong> ，我们的 UI 怎么写将围绕 Controller 展开。</p>
<hr>
<h1 id="UI-写在何处"><a href="#UI-写在何处" class="headerlink" title="UI 写在何处"></a>UI 写在何处</h1><p>在现今我们用到的主流应用框架中，你很难找到针对 GUI 编程部分只提供手写原生代码来实现界面的个例 — 它们无一例外地会引入基于某一种或者某几种标记语言的界面编程机制。其中最常见的是 xml 及其变体。</p>
<p>使用标记语言设计 UI 的最大好处在于它们可以被方便地转换为可视化的编辑界面，这样的话可以允许程序员以所见即所得的方式直观地进行界面设计，即 <strong>可视化编程</strong> 。提到可视化编程，桌面端的开发框架中大家最耳熟能详的想必包括微软的 .NET 。之所以特别提及 .NET ，是因为我认为微软在可视化编程技术和可视化集成开发环境方面的贡献至今仍是值得称道的。作为编程的初学者，我当年曾一度被 VisualStudio 的强大惊艳到。</p>
<p>在 GUI 编程方面摸爬滚打过几年，我先后使用过 MFC ， Windows Forms ， Qt 等框架开发桌面端的用户界面，目前从事的是 Android 客户端开发。从这些使用过的开发框架的用户界面部分的组件，我发现一个共同点： UI 都是一定程度上独立的。</p>
<p>首先，在设计阶段，通过使用单独的资源文件夹或者 .xml ， .qml ， .ui ，又或者是 C# 分部类，界面部分的生成逻辑是被隔离开的。然后，在使用阶段，界面部分的元素通过约定的方式查找或者引用，并且建立响应逻辑。这样的运行方式，使得 UI 和其他程序逻辑被天然地划分开，能够让程序员把 UI 的代码编写从整体的编程活动中独立出来，从而便于维护和协作。</p>
<h2 id="UI-编程的两个阶段"><a href="#UI-编程的两个阶段" class="headerlink" title="UI 编程的两个阶段"></a>UI 编程的两个阶段</h2><p>不妨把 UI 设计和 UI 使用的这两个阶段称为 <strong>UI 编程的两个阶段</strong> 。我在后文会介绍到 <strong>UOP</strong> 和从 UI 快速切入别人的代码结构进行修改的策略，都是基于 UI 实现所具备的这种独立性。从这里开始，相关话题我会以 Android 平台的客户端界面设计为例展开。</p>
<p>Android 的 UI 可以通过 xml 设计，运行时由系统加载和创建出界面，也可以通过代码直接创建。相对来说，前者的使用方式比较普遍，以下描述会基于采用前者方式的前提。在 UI 编程的第二个阶段， Android 通过 findViewById 的方式将 UI 元素从被隔离的区域 (xml) 中找出来，准确的说，是通过预先定义好的 id 将第二阶段所关心的 UI 元素从被隔离的区域 (xml) 中找出来，为它在控制器逻辑中建立一个引用，然后围绕这些 UI 元素编写交互逻辑。</p>
<p>到目前为止，我所说的是大家都已经知道的事实，而这一节要聊的关于 UI 写在何处 —— 跟我们已知的这些事实有什么关联呢？一些有过 Android 开发经验的同学想一想 <em>RoboGuice</em> 、 <em>ButterKnife</em> 以及官方的 <em>Android Data Binding</em> 为何会存在？也许会对这个问题有自己的答案。</p>
<h2 id="负担过重的-Controller"><a href="#负担过重的-Controller" class="headerlink" title="负担过重的 Controller"></a>负担过重的 Controller</h2><p>在我看来，在编程框架内置的 MVC 模型中，单一的 Controller 一直负荷了过重的工作，因为通常的情况是许多的 Model 和 View 都仅仅通过某个唯一的 Controller 建立关联，与此同时我们忽略了一个重要的事实：单一的 Controller 通常不仅要服务于 UI ，往往还需要承载多个不同角度不同层级的业务逻辑。</p>
<p>面对这个问题，我们能做些什么呢？有的读者可能已经想到了 MVVM 模式。首先，要肯定一下 MVVM 是一个可以考虑的选项。在我看来， ViewModel 本质上就是将 Controller 中与特定 UI 密切相关的逻辑集中在一起。不过呢，我会倾向于认为 MVVM 是 MVC 的一个变体， ViewModel 是我们在实现 Controller 时所采取的一种策略：这种策略叫做分治。那么为什么 MVVM 只是可以考虑的选项而不是根本的解决方案呢？我的解释是：因为 <strong>分治</strong> 这件事，太依赖于具体情况了。没有一种框架可以告诉我们应当如何拆分一整个复杂的控制器逻辑，如你所见，它们顶多帮你把 UI 隔离到另外的空间，让你的代码不至于一上来就看着一团乱麻。而我们在编程的时候，还可能会不断地把 UI 找出来，重新加入我们的控制器，并为它们书写冗长的交互代码。有的时候这些交互的复杂程度是已经具备一定约束规则的 ViewModel 所无法预见和适应的。</p>
<p>其实，无论 MVC 还是 MVVM，其实都是可行的方案，但是我们不能太拘泥于形式，不能规定 View 和 Model 必须以这样或者那样的方式建立关联。在具体的场景中，需要视逻辑的复杂度对控制器中的 UI 部分进行拆分。控制器中可以拆分的逻辑当然并不局限于 UI 部分，不过它与本文无关这里不特别说明。所有分治的 UI 控制器中的 UI 虽然是由原来的那个控制器统一创建的，但是在使用时却可以由各分治控制器自行把握。</p>
<p>这里提供一个参考思路：在实际的开发实践中，我做过的控制器拆分通常是以可复用的组件作为目标，根据模块分工，代码规模等情况综合考虑的。</p>
<hr>
<h1 id="UOP——-分治-UI-控制逻辑的利器"><a href="#UOP——-分治-UI-控制逻辑的利器" class="headerlink" title="UOP—— 分治 UI 控制逻辑的利器"></a>UOP—— 分治 UI 控制逻辑的利器</h1><p>接着第 2 节文末提出的思路，笔者在本文的最后一节要来重点分享一下在实践 UI 控制逻辑分治这件事时的一种十分有效的编程方式： <strong>UOP</strong>。</p>
<p>面向 UI 编程。你无法在 wikipedia 上找到这个词条。因为它是杜撰的。实际上，我将要说的 “面向 UI 编程” 应该是面向切面编程（<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming" target="_blank" rel="noopener">Aspect-oriented programming</a>）的一种，只不过切面聚焦在 User Interface 上。</p>
<p>在展开 <strong>UOP</strong> 之前，让我们先回到 Controller 这个概念，在我们熟知的框架内化的 MVC 模式中，原先的那个 Controller 角色必定是已经提供 UI 的访问途径了，比如 Android 框架的控制器 Activity ，它提供了 findViewById 。而分治出去的 Controller （同时也是我们自己创建的 Controller ）要如何取得 UI 呢？一些同学可能会想到，使用 setter。是的，我们完全可以这么实现。不过这里要提供另外一种思路 —— <strong>“UI 包装器”</strong> ，我给它取了一个代码名，叫 <code>UIWrapper</code> 。我们将通过这个 <strong>“UI 包装器”</strong> 来说明 UOP 是什么，以及我们为什么使用 UOP 。</p>
<p>一个 Android 上的 UI 包装器可以是如下的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIWrapper</span> </span>{</span><br><span class="line">        <span class="comment">/** 布局资源 id 到根视图的索引 */</span></span><br><span class="line">        <span class="keyword">protected</span> SparseArray&lt;View&gt; mLayoutIdToRootViewIndex = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">        <span class="comment">/** 视图 ID 到子视图的索引 */</span></span><br><span class="line">        <span class="keyword">protected</span> SparseArray&lt;View&gt; mIdToSubViewIndex = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UIWrapper</span><span class="params">()</span> </span>{}</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置 UI 元素 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> otherWrapper 给定的 UI 元素包装器 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">setUi</span><span class="params">(UIWrapper otherWrapper)</span> </span>{</span><br><span class="line">            mLayoutIdToRootViewIndex = otherWrapper.mLayoutIdToRootViewIndex.clone ();</span><br><span class="line">            mIdToSubViewIndex = otherWrapper.mIdToSubViewIndex.clone ();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 包装 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 指定的视图资源 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> view 指定的视图资源 ID 对应的视图 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">wrapUi</span><span class="params">(<span class="keyword">int</span> viewId, View view)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> wrapUi (viewId, view, <span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 包装 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 指定的视图资源 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> view 指定的视图资源 ID 对应的视图 </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> treatAsViewGroup 以 ViewGroup 方式处理包装的 View</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">wrapUi</span><span class="params">(<span class="keyword">int</span> viewId, View view, <span class="keyword">boolean</span> treatAsViewGroup)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (viewId &gt;= <span class="number">0</span> &amp;&amp; view != <span class="keyword">null</span>) {</span><br><span class="line">                mIdToSubViewIndex.put (viewId, view);</span><br><span class="line">                <span class="keyword">if</span> (treatAsViewGroup) {</span><br><span class="line">                    mLayoutIdToRootViewIndex.put (viewId, view);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据 view id 查找 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 目标视图的 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> view</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">findViewById</span><span class="params">(<span class="keyword">int</span> viewId)</span> </span>{</span><br><span class="line">            View view = mIdToSubViewIndex.get (viewId);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; mLayoutIdToRootViewIndex.size (); index++) {</span><br><span class="line">                    View layout = mLayoutIdToRootViewIndex.valueAt (index);</span><br><span class="line">                    <span class="keyword">if</span> (layout != <span class="keyword">null</span>) {</span><br><span class="line">                        view = layout.findViewById (viewId);</span><br><span class="line">                    }</span><br><span class="line">    </span><br><span class="line">                    <span class="keyword">if</span> (view != <span class="keyword">null</span>) {</span><br><span class="line">                        mIdToSubViewIndex.put (viewId, view);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">UIWrapper 这个类很简单，它的功能概括成一句话就是动态扩容地持有一组 View 的匿名引用，并且具备通过 viewId 来检索 View 的能力。（以动态扩容地持有匿名引用的方式来实现代码复用，是一个简单却极其有效的实用技巧，在我的另外一篇文章 __用 “管道” 设计拆分复杂处理流程__ 中也有提到，感兴趣的读者可以移步一阅。）</span><br><span class="line"></span><br><span class="line">UIWrapper 在具体场景中是以继承或者依赖的方式被使用的，如果我们的分治 UI 控制器本身没有基类，可以直接继承自 UIWrapper ；如果已经有了继承结构，可以引入 UIWrapper 作为成员，进而间接引入目标 UI ，比如 Fragment 就适用这种情况。题外话，说到 Fragment，读者会不会意识到它其实就是框架本身提供的一种分治策略的具体实现呢？</span><br><span class="line"></span><br><span class="line"> 对于以继承方式使用 UI 包装器的方式，我们不妨设计下面这样一个基类 AbsUIController ，也就是前文我们说的要分治的 UI 控制器。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分治的 UI 控制器基类 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsUIController</span> <span class="keyword">extends</span> <span class="title">UIWrapper</span> </span>{</span><br><span class="line">        <span class="comment">// 生产环境中这个抽象层级中除了构造方法外还有一些实际的基础功能，</span></span><br><span class="line">        <span class="comment">// 但是与本文重点无关，此处略过 </span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbsUIController</span><span class="params">(@NonNull Activity activity)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            wrapUi (<span class="number">0</span>, activity.getWindow ().getDecorView (), <span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbsUIController</span><span class="params">(@NonNull Activity activity, UIWrapper ui)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            setUi (ui);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>再基于基类的 UI 控制器，我举一个在生产环境中实现的 UI 控制器为例，它的功能是为所有由它管理的 UI 元素提供独占可见状态的显示和隐藏过程处理的可复用的工具类。通俗的说，就是处理几个 View 同一时间只显示其中一个的情况。以下是简化的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoDisplayController</span> <span class="keyword">extends</span> <span class="title">AbsUIController</span> </span>{</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占展示空间显示给定视图 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view 要显示的视图 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monoDisplay</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>{ ... }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏由当前包装器管理的全部视图 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayBeforeStart 开始隐藏前的延时 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整个隐藏过程完成的总耗时，以毫秒计 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hideAll</span><span class="params">(<span class="keyword">long</span> delayBeforeStart)</span> </span>{ ... }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>读者是否可以想到这样的一个简单的 UI 控制器可以用在哪里呢？不妨先看一下 MonoDisplayController 这个类的用例的代码片段:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 将可见性互斥的 UI 元素包在同一个 MonoDisplayController 里，包含可下载图标，下载进度等 </span></span><br><span class="line"><span class="comment">// 注意，生产环境中的 UI 元素数量可能很多，都要求互斥显示，这时复用代码更能体现优势 </span></span><br><span class="line">viewHolder.monoDisplaysOnDownloadStatus = <span class="keyword">new</span> MonoDisplayController (getActivity ());</span><br><span class="line">viewHolder.monoDisplaysOnDownloadStatus</span><br><span class="line">        .wrapUi (R.id.iv_download_available, viewHolder.ivDownloadAvailable)</span><br><span class="line">        .wrapUi (R.id.download_progress_view, viewHolder.downloadProgressView)</span><br><span class="line">        .wrapUi (...)</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="comment">// 根据下载状态互斥展示不同的 UI 元素 </span></span><br><span class="line"><span class="keyword">switch</span> (entity.getDownloadStatus ()) {</span><br><span class="line"><span class="comment">// 正在下载 </span></span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_DOWNLOADING:</span><br><span class="line">    viewHolder.monoDisplaysOnDownloadStatus.monoDisplay (viewHolder.progressView);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 下载暂停，删除，未下载 </span></span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_PAUSE:</span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_DELETED:</span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_UN_DOWNLOAD:</span><br><span class="line">    viewHolder.monoDisplaysOnDownloadStatus.monoDisplay (viewHolder.downloadAvailableView);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>限于篇幅没有奉上无关的代码。我相信如果读者有过用许多 if , else 分支来协调多个 View 的可见性这种编码经验的话，应该会认同这样一个控制器是能够有效减少代码量和避免错误的。</p>
<p>讲到这里， UOP 的实例已经在代码中完整给出。读者请重点留意一下 <code>UIWrapper#wrapUi (int viewId, View view)</code> 这个方法，它体现了 UOP 最核心的思维方式： UI 是第一度的逻辑出发点。<strong>首先搞清楚我们要跟哪些 UI 打交道，然后才是要在这些 UI 上做些什么事情。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">.wrapUi (R.id.iv_download_available, viewHolder.ivDownloadAvailable)</span><br><span class="line">.wrapUi (R.id.download_progress_view, viewHolder.downloadProgressView)</span><br></pre></td></tr></tbody></table></figure>

<p>解释完 UOP 是什么，最后再来解释一下为什么 UOP 是分治 UI 的利器。前面说过 UOP 其实是 AOP 中的一种，而我认为 AOP 其实是贯彻第一性原理的一种思维方式：聚焦任务在同一维度的事物构成的某一条线索上。UI 是程序代码中被最直观呈现的东西，以软件用户的角色观察，UI 可能就是他可以感知的全部，这是一条最自然的线索。而对于程序员来说，这个认知其实也是完全适用的。</p>
<p>如果上面的描述不好理解，我再举一个维护代码的例子，程序员朋友可能就会有共鸣了。</p>
<blockquote>
<p><em>假定有程序员甲开发了一款软件，他很熟悉这款软件的代码。还有程序员乙从未接触过这款软件的代码。有一，乙在甲不能提供帮助的情况下，（比方说甲请假了）接受了一个任务：他要在短时间内调整一处 UI 。对于乙来说，最快的做法是先去阅读代码吗？恐怕不是。然而，现实场景中，在对代码一无所知的情况下，要我们基于别人的代码增改功能，这并不少见。倘若时间有限，无法阅读太多的代码，那么抓住目标的特点，从代码中找到线索，利用线索切入，则是快速搞定任务的靠谱思路。这其实只是专注于任务本身的结果，而并非什么独特的解题技巧。对于 UI 来说，不论是框架内化的设计模式，还是它本身最直观的外在呈现，往往都天然地提供了一条独立于常规代码之外的 线索。</em></p>
</blockquote>
<p>使用 UOP ，本质上是在分治 UI 控制逻辑的同时，仍然保持对关注点的聚焦。虽然 UI 被分出来了，但事还是那些事，并没有因为设立了一个分管的去处，就多出了额外的东西。同时，又因为分管，被分出来的这些事，作为一个可单独运行的逻辑，自身变得更加纯粹了，更容易被复用。当然，它带来的最重要的好处是：维护这件事变得更容易了。</p>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>编程，UI</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之十 | 可选型</title>
    <url>/programming/swiftswift-optionals/</url>
    <content><![CDATA[<h1 id="处理缺失的数据"><a href="#处理缺失的数据" class="headerlink" title="处理缺失的数据"></a>处理缺失的数据</h1><p>我们已经会使用 <code>Int</code> 这样的类型来存储像 5 这样的数值。不过，当你想要存储用户年龄这样的属性，并且你还不知道该用户的年龄时你该怎么做呢？</p>
<p>你可能会说，“我可以暂时存成 0”，但这样一来你就会混淆新生儿和你不知道年龄的用户。你应该用一个特殊的数字，比如 1000 或者 -1 来代表 “未知”，这两个数字都不可能是年龄，但你能记得住这些特殊数字的含义吗？</p>
<p>Swift 的解决方案称为 <em>optional</em> ，即可选型。你可以基于任意类型创建可选型。一个可选型整数可以有诸如 1 或者 1000 这样的数字，也可能没有任何值，即值可以缺失， Swift 里表示缺失是用 <code>nil</code> 。</p>
<p>为了把一个类型变成可选型，只需要在类型后面加一个问号。举个例子，我们可以这样把一个整数变成可选型：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<p>这个可选型现在并不保有任何整数，但是如果之后我们知道了年龄值，我们可以给它重新赋值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">age = <span class="number">38</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="解包可选型"><a href="#解包可选型" class="headerlink" title="解包可选型"></a>解包可选型</h1><p>可选型字符串可能包含一个 “Hello” 或者 <code>nil</code> 。</p>
<p>考虑这样一个可选字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String?</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure>

<p>当我们调用 <code>name.count</code> 时会发生什么呢？一个真的字符串有 <code>count</code> 属性，它存储字符串的字符数量。但它是 <code>nil</code> 时，并没有 <code>count</code> 属性。</p>
<p>因此，试图直接使用 <code>name.count</code> 是不安全的， Swift 也不允许。取而代之的是，我们必须先检查可选型里面有些什么，这个过程被称为 <em>解包</em> 。</p>
<p>解包可选型的一种常见做法是采用 <code>if let</code> 语法，它是一种有条件的解包。如果可选型里有值，你就可以使用它，如果没有则条件失败。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrapped = name {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(unwrapped.count) letters"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Missing name."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果 <code>name</code> 持有一个字符串，这个字符串会被放进一个叫 <code>unwrapped</code> 的常规字符串，然后我们就可以读取它的 <code>count</code><br>属性。另一种情况，如果 <code>name</code> 是 nil， 那么 <code>else</code> 中的代码将被执行。</p>
<hr>
<h1 id="用-guard-解包可选型"><a href="#用-guard-解包可选型" class="headerlink" title="用 guard 解包可选型"></a>用 guard 解包可选型</h1><p><code>if let</code> 的一个替代方案是 <code>guard let</code> ，后者也可以用来解包可选型。 <code>guard let</code> 会为你解包，但是当它发现可选型里是 <code>nil</code> 时会期望你退出它所处的函数，循环或者条件。</p>
<p>因此， <code>if let</code> 和 <code>guard let</code> 的主要区别在于 <code>guard let</code> 之后可选型还可以继续使用。</p>
<p>让我们尝试一下 <code>greet ()</code> 函数。它将接收一个可选字符串作为唯一的参数，当它解包发现这个参数是 <code>nil</code> 时会打印消息并且退出函数。因为可选型 <code>unwrapped</code> 在 <code>guard let</code> 的语句块结束之后作用，我们可以在函数最后打印这个解包后的字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> name: String?)</span></span> {</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = name <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You didn't provide a name!"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(unwrapped)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过使用 <code>guard let</code> ，你可以在函数的前面解决可选型的解包问题，在这之后的代码就可以愉快地使用解包后的值而不必担心出错了。</p>
<hr>
<h1 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h1><p>可选型代表可能存在也可能不存在的数据，而某些时候你是 <em>确切</em> 知道一个可选型的值并不是 <code>nil</code> 。在这种情况下， Swift 允许你强制解包这个可选型：通过把一个可选型转换为非可选型的方式。</p>
<p>举个例子，下面你试图将一个字符串转换成 <code>Int</code> ，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"5"</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码中 <code>num</code> 其实是一个可选型 <code>Int</code> 。因为你有可能尝试转换一个不是数字的字符串导致转换失败。</p>
<p>尽管 Swift 不确定转换能否成功，你自己是知道你的结果是否可以安全地执行强制解包。这个强制解包是通过在 <code>Int (str)</code> 之后添加 <code>!</code> 来完成的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)!</span><br></pre></td></tr></tbody></table></figure>

<p>通过强制解包， Swift 将立刻解包 <code>num</code> ，把它变成一个常规的 <code>Int</code> 而不是 <code>Int?</code> 。但是假如你是错的，比方说 <code>str</code> 是某个不能转换成数字的字符串，那么你的代码将崩溃。</p>
<p>强制解包的操作符常常被戏称为崩溃操作符。因此，只有当你确信强制解包是安全的你才能这么做。</p>
<hr>
<h1 id="隐式解包可选型"><a href="#隐式解包可选型" class="headerlink" title="隐式解包可选型"></a>隐式解包可选型</h1><p>像常规可选型一样，隐式解包可选型可能包含一个值也可能包含 <code>nil</code> 。不过，跟常规可选型不一样的是，隐式解包可选型时不需要再解包，你可以把它们当做非可选型一样使用。</p>
<p>隐式解包可选型是通过类型名之后添加感叹号来声明的，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="type">Int!</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于它们表现起来就像已经被解包过的样子，你并不需要 <code>if let</code> 或者 <code>guard let</code> 这样的代码来测试它们。不过，当你试图使用它们而它们实际上没有值时，即它们的值是 <code>nil</code> 时，你的代码将崩溃。</p>
<p>隐式解包可选型存在的意义在于，有些情况某个变量一开始时是 <code>nil</code> ，但当你需要用到它之前它总会有值。如果你可以确信这一点，那么采用隐式解包可选型可以省去一直写 <code>if let</code> 的麻烦。</p>
<p>值得一提的是，如果条件允许采用常规可选型，安全起见最好总是采用常规可选型。</p>
<hr>
<h1 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h1><p>空合运算符解包一个可选型，如果可选型包含值则返回这个值，如果可选型不包含值，即可选型的值是 <code>nil</code> ，那么返回某个默认值。两种情况，返回值都不再是可选型：它要么是可选型里包含的有效值，要么是一个备选的默认值。</p>
<p>下面是一个接收整数作为唯一参数并且返回可选型字符串的函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">username</span><span class="params">(<span class="keyword">for</span> id: Int)</span></span> -&gt; <span class="type">String?</span> {</span><br><span class="line">  <span class="keyword">if</span> id == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Taylor Swift"</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们以 ID 15 来调用这个函数，我们将得到 <code>nil</code> 。通过空合运算符，我们可以提供一个叫 “Anonymous” 的默认值，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = username (<span class="keyword">for</span>: <span class="number">15</span>) ?? <span class="string">"Anonymous"</span></span><br></pre></td></tr></tbody></table></figure>

<p>它将检查 <code>username ()</code> 函数返回的值：如果是一个字符串，它将被解包并放入 <code>user</code> ，如果是 <code>nil</code> ，则使用 “Anonymous” 替代。</p>
<hr>
<h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h1><p>在使用可选型时， Swift 为我们提供了一种快捷方式：假如你试图访问形如 <code>a.b.c</code> 这样的代码并且 <code>b</code> 是可选型，你可以在 <code>b</code> 后面写一个问号来启用 <em>可选链</em> ： <code>a.b?.c</code> 。</p>
<p>当代码运行时， Swift 会检查 <code>b</code> 是否有值，如果它是 <code>nil</code> ，那么这行代码剩下的部分将被忽略。Swift 会立即返回 <code>nil</code> 。但是如果 <code>b</code> 有值，它将被解包，代码执行将继续。</p>
<p>下面是一个名字的数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>我们将使用数组的 <code>first</code> 属性，如果数组里第一个名字有值的话返回这个名字，如果数组为空则返回 <code>nil</code> 。在结果之上，我们调用 <code>uppercased ()</code> 把它变成一个全大写的字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> beatle = names.first?.uppercased ()</span><br></pre></td></tr></tbody></table></figure>

<p>上面的问号就是可选链。如果 <code>first</code> 返回 <code>nil</code> ，那么 Swift 就不会尝试将它转换成全大写，它会将 <code>beatle</code> 立即设置为 <code>nil</code> 。</p>
<hr>
<h1 id="可选型-try"><a href="#可选型-try" class="headerlink" title="可选型 try"></a>可选型 try</h1><p>让我们回忆一下可能抛出错误的函数那一节的知识，看下面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PasswordError</span>: <span class="title">Error</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> obvious</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword</span><span class="params">(<span class="number">_</span> password: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> {</span><br><span class="line">  <span class="keyword">if</span> password == <span class="string">"password"</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">PasswordError</span>.obvious</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  <span class="keyword">try</span> checkPassword (<span class="string">"password"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"That password is good!"</span>)</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"You can't use that password."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过 <code>do</code> ， <code>try</code> 和 <code>catch</code> ，我们得以运行可能抛出错误的函数，并且优雅地处理错误。</p>
<p>上面的 <code>try</code> 写法其实有另外两种选择，这两种选项都能加深你对可选型和强制解包的理解。</p>
<p>第一个是 <code>try?</code> ，它将可能抛出错误的函数转换成返回可选型的函数。如果函数抛出错误，那你就会得到 <code>nil</code> 作为函数的执行结果，否则你会得到将返回值包装之后的可选型。</p>
<p>尝试使用 <code>try?</code> 来执行 <code>checkPassword ()</code> ，像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result = <span class="keyword">try</span>? checkPassword (<span class="string">"password"</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Result was \(result)"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"D'oh."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>另外一种选择是 <code>try!</code> ，当你确信函数一定不会失败时你可以采用它。如果函数实际抛出了错误，你的代码将崩溃。</p>
<p>使用 <code>try!</code> 来重写前面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>! checkPassword (<span class="string">"sekrit"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"OK!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="失败构造器"><a href="#失败构造器" class="headerlink" title="失败构造器"></a>失败构造器</h1><p>当我们说到强制解包的时候，我用了下面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"5"</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)</span><br></pre></td></tr></tbody></table></figure>

<p>它将一个字符串转换成一个整数，但由于你可以传入任意字符串，你得到的实际上是一个可选型整数。</p>
<p>这里用到一种叫做 <em>失败构造器</em> 的东西：它是一种可能成功也可能失败的构造器。你在结构体或者类里面用 <code>init?()</code> 来实现失败构造器。如果某些东西出错，它将返回 <code>nil</code> 。因此这种构造器返回的是某种类型的可选型，你用之前需要解包。</p>
<p>举个例子，我们现在要求 <code>Person</code> 结构体必须通过一个 9 字符的 ID 字符串来构造。只要不是 9 个字符，都会返回 <code>nil</code> 。</p>
<p>Swift 代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>?(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">if</span> id.<span class="built_in">count</span> == <span class="number">9</span> {</span><br><span class="line">      <span class="keyword">self</span>.id = id</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Swift 知道每个变量的类型，但有的时候你知道的信息比 Swift 更多。举个例子，这里有三个类：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{ }</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>: <span class="title">Animal</span> </span>{ }</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Woof!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们创建几个 <code>Fish</code> 和几个 <code>Dog</code> ，然后把它们放进一个数组，像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = [<span class="type">Fish</span>(), <span class="type">Dog</span>(), <span class="type">Fish</span>(), <span class="type">Dog</span>()]</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 知道 <code>Fish</code> 和 <code>Dog</code> 都继承自 <code>Animal</code> 类，因此它通过类型推断将 <code>pets</code> 创建为一个 <code>Animal</code> 类型的数组。</p>
<p>如果我们想遍历 <code>pets</code> 数组，让所有的狗发出叫声，我们需要执行一次类型转换： Swift 将检查每个 pet 是否 <code>Dog</code> 对象，以便我们调用 <code>makeNoise ()</code> 方法。</p>
<p>这里用到了一个关键字 <code>as?</code> ，它将返回一个可选型：类型转换失败时返回 <code>nil</code> ，成功则返回转换后的类型。</p>
<p>Swift 代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pet <span class="keyword">in</span> pets {</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> dog = pet <span class="keyword">as</span>? <span class="type">Dog</span> {</span><br><span class="line">    dog.makeNoise ()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>可选型让我们可以用一种清晰无歧义的方式表示值缺失的情况。 </li>
<li>Swift 不允许不经解包就使用可选型，解包可以用 <code>if let</code> 或者 <code>guard let</code> 。 </li>
<li>你可以用感叹号强制解包可选型，不过如果解出来的是 <code>nil</code> ，你的代码将会崩溃。 </li>
<li>隐式解包可选型没有做常规可选型的安全性检查。 </li>
<li>你可以使用空合运算符解包一个可选型，以便可选型里没有值时提供一个默认值。 </li>
<li>可选链用于操作可选型，如果可选型的值是空的，后续代码将被忽略。 </li>
<li>你可以使用 <code>try?</code> 将一个可能抛出错误的函数转换成一个可选型的返回值，或者使用 <code>try!</code> 在抛出错误时崩溃。 </li>
<li>如果你需要在输入不合理时让构造过程失败，可以使用 <code>init?()</code> 来创建失败构造器。 </li>
<li>你可以使用类型转换将一个类型转换为另一个类型。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之九 | 协议</title>
    <url>/programming/swiftswift-protocol/</url>
    <content><![CDATA[<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>协议是一种描述某个类型必须有某些属性和方法的方式。你告知 Swift 某个类型将使用某个协议，这个过程称为协议适配或者协议遵循。</p>
<p>举个例子，我们可以写一个函数接收 <code>id</code> 属性，但我们并不精确地关心用的是哪一种数据类型。让我们从 <code>Identifiable</code> 协议开始，这个协议要求所有遵循协议的类型必须有一个 <code>id</code> 字符串属性，并且这个字符串可读写。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> { <span class="keyword">get</span> <span class="keyword">set</span> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们无法创建协议的实例，因为协议只是一种描述，它本身并非一种类型。但是我们可以创建遵循它的结构体。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后，我们还可以写一个 <code>displayID ()</code> 函数，它接收 <code>Identifiable</code> 对象：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displayID</span><span class="params">(thing: Identifiable)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"My ID is \(thing.id)"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h1><p>一个协议可以继承另一个协议，这个过程称为协议继承。跟类不一样的是，你可以同一时间继承多个协议。</p>
<p>接下来我们将定义三个协议： <code>Payable</code> 要求遵循它的类型实现 <code>calculateWages ()</code> 方法， <code>NeedsTraining</code> 要求遵循它的类型实现 <code>study ()</code> 方法，而 <code>HasVacation</code> 要求遵循它的类型实现 <code>takeVacation ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Payable</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">calculateWages</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NeedsTraining</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">study</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HasVacation</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">takeVacation</span><span class="params">(days: Int)</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们可以创建一个 <code>Employee</code> 协议，将上面的三个协议合并在一起。我们还不打算添加额外的东西，因此简单地写一对花括号就行：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Employee</span>: <span class="title">Payable</span>, <span class="title">NeedsTraining</span>, <span class="title">HasVacation</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们就可以创建遵循这个单一协议的类型，而不是分别遵循三个协议的类型。</p>
<hr>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>扩展使得你可以为已经存在的类型添加方法，实现它们设计时没有做的事情。</p>
<p>举个例子，我们可以为 <code>Int</code> 类型添加一个扩展方法 <code>squared ()</code> ，用来返回当前数的平方。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">squared</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> * <span class="keyword">self</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>尝试一下。创建一个整数，你会发现现在这个整数有了 <code>squared ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">8</span></span><br><span class="line">number.squared ()</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 不允许你通过扩展添加存储属性，但可以用扩展添加计算属性。举个例子，我们给整数添加一个 <code>isEven</code> 的计算属性，这个属性返回当前数值是否为偶数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> isEven: <span class="type">Bool</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h1><p>协议可以描述某个类型应当有某种方法，但并没有提供方法的代码。扩展实现有具体代码的方法，但一次只能作用于一个数据类型，你没办法同时给多个类型添加相同的代码。</p>
<p>协议扩展同时解决了这两个问题：它们就像常规扩展一样，差异只在于你并不是只扩展一个特定的类型，比如 <code>Int</code> ，你扩展是的一个协议，因而所有遵循这个协议的类型都会发生改变。</p>
<p>举个例子，下面有一个包含了一些名字的数组和一个同样包含了一些名字的集合：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pythons = [<span class="string">"Eric"</span>, <span class="string">"Graham"</span>, <span class="string">"John"</span>, <span class="string">"Michael"</span>, <span class="string">"Terry"</span>, <span class="string">"Terry"</span>]</span><br><span class="line"><span class="keyword">let</span> beatles = <span class="type">Set</span>([<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>])</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 的数组和集合都遵循一个叫 <code>Collection</code> 的协议，因此我们可以给 <code>Collection</code> 协议扩展一个叫 <code>summarize ()</code> 的方法，这个方法逐一打印 <code>Collection</code> 里的元素。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">summarize</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There are \(count) of us:"</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> <span class="keyword">self</span> {</span><br><span class="line">      <span class="built_in">print</span>(name)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>Array</code> 和 <code>Set</code> 都将获得这个方法。让我们来尝试一下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">pythons.summarize ()</span><br><span class="line">beatles.summarize ()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h1><p>协议扩展可以为我们自己的协议方法提供默认实现。这使得类型遵循协议变得更加容易，并且允许我们 “面向协议编程”—— 这是一种利用协议和协议扩展来加工代码的方式。</p>
<p>首先，我们这里有一个叫 <code>Identifiable</code> 的协议，它要求所有遵循协议的类型都有一个叫 <code>id</code> 的属性和叫一个叫 <code>identify ()</code> 的方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> { <span class="keyword">get</span> <span class="keyword">set</span> }</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>虽然我们可以让每个遵循这个协议的类型书写它们自己的 <code>identify ()</code> 方法，但协议扩展允许我们可以提供一个默认实现：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"My ID is \(id)."</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在当我们再声明一个遵循 <code>Identifiable</code> 协议的类型时，它会自动获得 <code>identify ()</code> 方法的实现：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> paul = <span class="type">User</span>(id: <span class="string">"Paul"</span>)</span><br><span class="line">paul.identify ()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>协议描述了一个遵循它的类型应该拥有的属性和方法，但并不提供那些方法的实现。 </li>
<li>你可以基于协议创建协议，这一点跟类相似。 </li>
<li>扩展允许你为类型添加方法和计算属性。 </li>
<li>协议扩展是为协议添加方法和计算属性。 </li>
<li>面向协议编程是这样一种实践：它把程序架构按照一系列协议来设计，然后利用协议扩展来提供默认实现。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之八 | 类</title>
    <url>/programming/swiftswift-classes/</url>
    <content><![CDATA[<h1 id="创建你自己的类"><a href="#创建你自己的类" class="headerlink" title="创建你自己的类"></a>创建你自己的类</h1><p>Swift 的类也能让你创建带有属性和方法的新类型，这一点和结构体很相似，但是它们之间有五个显著的区别。下面让我一一为你说明。</p>
<p>类和结构体的第一个区别是类没有逐一成员构造器。这意味着只要你的类里有属性，你就必须自行创建构造器。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>创建类的实例跟创建结构体的实例方式一样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> poppy = <span class="type">Dog</span>(name: <span class="string">"Poppy"</span>, breed: <span class="string">"Poodle"</span>)</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><p>类和结构体的第二个区别是类可以继承已经存在的类。新的类继承了原始类所有的属性和方法。</p>
<p>这个过程被称为 <em>类继承</em> 或者 <em>子类化</em> ， 被继承的类称为 “父类” 或者 “超类”， 而新的类称为 “子类” 。</p>
<p>下面是一个 <code>Dog</code> 类：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在让我们基于 <code>Dog</code> 来创建一个新的类 <code>Poodle</code> 。默认情况下，它会继承 <code>Dog</code> 的所有属性以及构造器。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过，我们也可以为 <code>Poodle</code> 创建自己的构造器。我们知道这个类的 <code>breed</code> 属性总是 “Poodle”，因此我们可以创建一个只有 <code>name</code> 属性的构造器。并且，我们可以在 <code>Poodle</code> 的构造器里直接调用 <code>Dog</code> 的构造器，以便发生和 <code>Dog</code> 相同的构造过程。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, breed: <span class="string">"Poodle"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>出于安全性考虑， Swift 会要求你总是在子类里调用 <code>super.init ()</code> ，以防止类在构造时来自父类的一些重要工作被遗漏。</p>
<hr>
<h1 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h1><p>子类可以将父类的方法替换为自己的实现，这个过程被称为 <em>重写</em> 。 让我们给 <code>Dog</code> 类添加一个 <code>makeNoise ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Woof!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你创建一个 <code>Poodle</code> 类继承自 <code>Dog</code> ，它会继承 <code>makeNoise ()</code> 方法。 “Woof!”:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> poppy = <span class="type">Poodle</span>()</span><br><span class="line">poppy.makeNoise ()</span><br></pre></td></tr></tbody></table></figure>

<p>方法重写使得我们可以为 <code>Poodle</code> 类重新实现 <code>makeNoise ()</code> 。</p>
<p>Swift 要求我们在重写方法时用 <code>override func</code> 而不是 <code>func</code> ，这个限定防止你在自己不知情的情况下偶然重写方法。另外，试图重写一个父类中并不存在的方法，你会遭遇错误。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Yip!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这个修改， <code>poppy.makeNoise ()</code> 将打印出 “Yip!”，而不是 “Woof!”。</p>
<hr>
<h1 id="Final-类"><a href="#Final-类" class="headerlink" title="Final 类"></a>Final 类</h1><p>尽管类继承十分有用，并且苹果的平台在许多地方要求你大量使用它，有的时候你会希望阻止其他开发者基于你的类构建新的类。</p>
<p>Swift 给了我们 <code>final</code> 关键字用于实现这种意图：当你把一个类声明为 <code>final</code> 时，将没有类能够继承它。这意味着没有人能通过重写方法来改变这个类的行为。</p>
<p>只需要把 <code>final</code> 关键字放在类前面，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h1><p>类和结构体的第三个区别是它们被复制的方式。当你复制一个结构体时，原始对象和复制体是不一样的两个东西，改变其中一个并不会改变另外一个。当你复制一个 <em>类</em> 时，原始对象和复制体都指向相同的东西，所以改变其中一个也会改变另一个。</p>
<p>举个例子，有一个简单的 <code>Singer</code> 类，它有一个带有默认值的 <code>name</code> 属性：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当我们创建一个这个类的实例并且打印它的 <code>name</code> 时，我们会得到 “Taylor Swift” ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singer = <span class="type">Singer</span>()</span><br><span class="line"><span class="built_in">print</span>(singer.name)</span><br></pre></td></tr></tbody></table></figure>

<p>当我们基于第一个实例创建第二实例并且改变第二个实例的 <code>name</code> 时：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singerCopy = singer</span><br><span class="line">singerCopy.name = <span class="string">"Justin Bieber"</span></span><br></pre></td></tr></tbody></table></figure>

<p>由于类的工作机制， <code>singer</code> 和 <code>singerCopy</code> 指向内存里的同一个对象。所以当我们打印 <code>singer</code> 的 <code>name</code> 时，我们也会得 “Justin Bieber”：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(singer.name)</span><br></pre></td></tr></tbody></table></figure>

<p>另一方面，假如 <code>Singer</code> 是一个结构体，那第二次我们还将得到 “Taylor Swift” ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h1><p>类和结构体的第四个区别是类有 <em>析构器</em> ，它是一个类的实例被销毁时执行的代码。</p>
<p>这里有一个 <code>Person</code> 类，它有一个 <code>name</code> 属性，一个简单的构造器，以及一个打印信息的 <code>printGreeting ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"John Doe"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name) is alive!"</span>)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">printGreeting</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, I'm \(name)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们将利用循环创建几个 <code>Person</code> 类的实例，每次循环流转的时候，一个新的 <code>Person</code> 都会被创建，之后被销毁：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> {</span><br><span class="line">  <span class="keyword">let</span> person = <span class="type">Person</span>()</span><br><span class="line">  person.printGreeting ()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>来到我们的析构器。每当 <code>Person</code> 实例被销毁时，它的析构器都会被执行。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(name) is no more!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h1><p>类和结构体的最后一个区别是它们处理常量的方式。如果你有一个常量结构体，它有一个变量属性，那么这个变量属性是无法修改的。</p>
<p>但是，如果它是一个常量类，也有一个变量属性，那么这个变量属性是可以被修改的。基于这个区别，类的方法在改变属性时，并不需要 <code>mutating</code> 关键字，而结构体则需要。</p>
<p>这个区别意味着你可以修改类中的任何变量属性，即便类的实例本身被声明为常量。以下代码完全合法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> taylor = <span class="type">Singer</span>()</span><br><span class="line">taylor.name = <span class="string">"Ed Sheeran"</span></span><br><span class="line"><span class="built_in">print</span>(taylor.name)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你不想属性被修改，那么你必须直接将属性声明为常量。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>类和结构体很相似，它们都允许你创建自己的属性和方法。 </li>
<li>一个类可以继承自另一个类，它会获得父类的所有属性和方法。谈到类层次结构的时候，我们经常说一个类基于另一个类，也就是一个类继承自另一个类。 </li>
<li>你可以用 <code>final</code> 关键字来标记一个类，这样可以阻止它被继承。 </li>
<li>方法重写使得一个子类可以用全新的实现来替代父类中的实现。 </li>
<li>当两个变量指向同一个实例时，它们指代的对象在内存中占用同一块区域，改变其中一个也会改变另一个。 </li>
<li>类可以有析构器，它们是类的实例被销毁时执行的代码。 </li>
<li>类不像结构体那样受常量的强制约束。如果类的一个属性被声明为变量，那么无论类的实例是否以变量的方式创建，这个属性都可以被修改。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之七 | 结构体</title>
    <url>/programming/swiftswift-structs/</url>
    <content><![CDATA[<h1 id="创建你自己的结构体"><a href="#创建你自己的结构体" class="headerlink" title="创建你自己的结构体"></a>创建你自己的结构体</h1><p>Swift 允许你用两种方式创建自己的类型。其中一种最常见的叫做结构体，即 <code>struct</code> 。Struct 可以拥有自己的变量、常量以及函数，而你可以在任意时候创建和使用它们。</p>
<p>让我们以一个简单的例子开始：创建一个 <code>Sport</code> 结构体，它有一个叫 <code>name</code> 的字符串变量。在结构体中，这种变量被称为 <em>属性</em> 。因此，这是一个拥有一个属性的结构体。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>类型定义完成，现在让我们来创建和使用它的实例：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tennis = <span class="type">Sport</span>(name: <span class="string">"Tennis"</span>)</span><br><span class="line"><span class="built_in">print</span>(tennis.name)</span><br></pre></td></tr></tbody></table></figure>

<p><code>name</code> 和 <code>tennis</code> 都是变量，因而我们可以像常规变量那样修改它们：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">tennis.name = <span class="string">"Lawn tennis"</span></span><br></pre></td></tr></tbody></table></figure>

<p>属性可以像常规变量那样拥有默认值，并且依赖 Swift 的类型推断。</p>
<a id="more"></a>

<hr>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>我们刚刚创建了 <code>Sport</code> 结构体：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>它有一个叫 <em>name</em> 的属性，存储 <code>String</code> 类型。这种属性叫做 <em>存储</em> 属性，因为 Swift 还有另外一种属性，它叫 <em>计算</em> 属性。这是一种通过运行代码来获得值的属性。</p>
<p>让我们为 <code>Sport</code> 结构体再增加一个存储属性，然后是一个计算属性。代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> isOlympicSport: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> olympicStatus: <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">if</span> isOlympicSport {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"\(name) 是一项奥林匹克运动。"</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"\(name) 不是一项奥林匹克运动。"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如你所见， <code>olympicStatus</code> 看起来像一个常规的 <code>String</code> ，但它其实是依据其他的属性返回不同的值。</p>
<p>让我们来创建一个 <code>Sport</code> 实例：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chessBoxing = <span class="type">Sport</span>(name: <span class="string">"Chessboxing"</span>, isOlympicSport: <span class="literal">false</span>)</span><br><span class="line"><span class="built_in">print</span>(chessBoxing.olympicStatus)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h1><p>属性观察者允许我们可以在属性变化前后运行代码。让我们来写一个名叫 <code>Progress</code> 的结构体，这个结构体追踪一个任务以及它完成的百分比：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Progress</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> task: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> amount: <span class="type">Int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，创建这个结构体的实例，随着时间的推移调整它的进度：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> progress = <span class="type">Progress</span>(task: <span class="string">"加载数据"</span>, amount: <span class="number">0</span>)</span><br><span class="line">progress.amount = <span class="number">30</span></span><br><span class="line">progress.amount = <span class="number">80</span></span><br><span class="line">progress.amount = <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们期望 Swift 在每一次 <code>amount</code> 改变的时候都打印信息，这里可以用到一个叫 <code>didSet</code> 属性观察者。它可以用于每一次 <code>amount</code> 改变之后运行代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Progress</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> task: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> amount: <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">didSet</span> {</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"\(task) 已完成 \(amount)%。"</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你还可以用到叫 <code>willSet</code> 的属性观察者。它是在属性改变之前作用，相对来说更不常用。</p>
<hr>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Struct 的内部可以拥有函数，它们在必要时可以使用结构体的属性。这种函数被称为 <em>方法</em> ，关键字也是 <code>func</code> 。</p>
<p>现在我们通过一个叫 <code>City</code> 的结构体来演示。它有一个 <code>population</code> 属性，用于存储城市里的人口。此外，它还有一个 <code>collectTaxes ()</code> 方法，这个方法返回人口数乘以 1000。 由于方法是属于 <code>City</code> 的，它可以读取当前城市的 <code>population</code> 属性。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">City</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> population: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">collectTaxes</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> population * <span class="number">1000</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>基于结构体调用方法的代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xiamen = <span class="type">City</span>(population: <span class="number">4_110_000</span>)</span><br><span class="line">xiamen.collectTaxes ()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="可变方法"><a href="#可变方法" class="headerlink" title="可变方法"></a>可变方法</h1><p>如果一个结构体拥有一个变量属性，但是这个结构体的实例是以常量的方式创建的，那么在实例中，这个变量属性是不能修改的。这是因为结构体本身已经是常量了，所以它的所有属性也是常量。</p>
<p>这里面有一个问题， Swift 无从得知你将以常量还是变量的方式使用结构体。所以安全起见， Swift 的默认策略是：不允许你在方法里修改属性，除非你显式地要求这一点。</p>
<p>当你想要改变属性值时，需要在方法前使用 <code>mutating</code> 关键字，就像这样：</p>
 <figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAnonymous</span><span class="params">()</span></span> {</span><br><span class="line">    name = <span class="string">"Anonymous"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于这个方法改变了属性值，所以 Swift 只会允许这个方法在变量型的 <code>Person</code> 实例上调用。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>(name: <span class="string">"Ed"</span>)</span><br><span class="line">person.makeAnonymous ()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="String-的属性和方法"><a href="#String-的属性和方法" class="headerlink" title="String 的属性和方法"></a>String 的属性和方法</h1><p>目前为止我们已经大量地使用了字符串。你发现了吗？其实 <code>String</code> 类型是一个结构体类型。它有许多属性和方法，用于查询和维护字符串本身。</p>
<p>首先，我们创建一个测试字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"Do or do not, there is no try."</span></span><br></pre></td></tr></tbody></table></figure>

<p>你可以用 <code>count</code> 属性来读取这个字符串里的字符数量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.<span class="built_in">count</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>字符串有一个 <code>hasPrefix ()</code> 方法，可以用来检测字符串是否以特定字符开头：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.hasPrefix (<span class="string">"Do"</span>))</span><br></pre></td></tr></tbody></table></figure>

<p>你还可以用 <code>uppercased ()</code> 方法把一个字符串转换成全大写的版本：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.uppercased ())</span><br></pre></td></tr></tbody></table></figure>

<p>你甚至可以让 Swift 将字符串中的字母重新排序成一个数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.sorted ())</span><br></pre></td></tr></tbody></table></figure>

<p>String 类型有大量的属性和方法。 你可以利用 Xcode 的代码补全，用 <code>string.</code> 调取这些选项看一看它们都有些什么能力。</p>
<hr>
<h1 id="数组的属性和方法"><a href="#数组的属性和方法" class="headerlink" title="数组的属性和方法"></a>数组的属性和方法</h1><p>数组同样也是结构体，这意味着它们也有可以用来查询和操作数组的属性和方法。</p>
<p>从一个简单的数组开始：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toys = [<span class="string">"Woody"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>你可以用 <code>count</code> 属性来读取数组的元素个数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(toys.<span class="built_in">count</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你需要增加一个元素，可以使用 <code>append ()</code> 方法，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">toys.append (<span class="string">"Buzz"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>你可以用 <code>firstIndex ()</code> 方法来定位元素在数组里的位置，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">toys.firstIndex (of: <span class="string">"Buzz"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码会返回 1 ，因为数组位置从 0 开始计数。</p>
<p>跟字符串一样，你可以让 Swift 以字母表顺序给数组的元素重新排序。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(toys.sorted ())</span><br></pre></td></tr></tbody></table></figure>

<p>最后，如果你想要移除数组里的一个元素，可以使用 <code>remove ()</code> 方法，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">toys.remove (at: <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>数组类型也有大量的属性和方法。 你可以利用 Xcode 的代码补全，用 <code>toys.</code> 调取这些选项看一看它们都有些什么能力。</p>
<hr>
<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p>构造器是一种可以用来支持不同方式创建结构体的特殊方法。所有的结构体都有一个默认的构造器，这个构造器被称为 <em>逐一成员构造器</em> ，它要求你为结构体的每一个属性都提供一个值。</p>
<p>让我们来声明一个 <code>User</code> 结构体，它有一个属性：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当我们创建这个结构体的实例时，我们需要提供一个 <code>username</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="type">User</span>(username: <span class="string">"Paul"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>当然，我们也可以创建自己的构造器用以替换默认的。举个例子，我们可能希望所有的新用户默认都叫 “Anonymous” ，并且会打印一条信息，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    username = <span class="string">"Anonymous"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"创建新用户！"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你并不需要在构造器前面写 <code>func</code> 关键字，但你必须确保构造器结束前所有的属性都被赋值。</p>
<p>现在让我们来用上这个没有参数的构造器，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="type">User</span>()</span><br><span class="line">user.username = <span class="string">"Paul"</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="引用当前实例"><a href="#引用当前实例" class="headerlink" title="引用当前实例"></a>引用当前实例</h1><p>方法的内部，有一个特殊的常量叫 <code>self</code> ，它指向当前正在使用的结构体实例。当你在构造器中遇到参数名和属性名相同的情况时，这个 <code>self</code> 会很有用。</p>
<p>举个例子，如果你声明一个 <code>Person</code> 的结构体，它有一个 <code>name</code> 属性，并且你尝试写一个接收名为 <code>name</code> 参数的构造器，那么 <code>self</code> 可以帮助你区分属性和参数。 <code>self.name</code> 指代属性，而 <code>name</code> 指代参数。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name) was born!"</span>)</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="懒加载属性"><a href="#懒加载属性" class="headerlink" title="懒加载属性"></a>懒加载属性</h1><p>作为一种性能优化手段， Swift 允许你在用到的时候才真正创建属性。举个例子，这里有一个叫 <code>FamilyTree</code> 的结构体，它做的工作很容易描述。但理论上为一个人创建族谱可能会是一个很耗时的过程：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FamilyTree</span> </span>{</span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"创建族谱！"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以在 <code>Person</code> 结构体内将 <code>FamilyTree</code> 作为一个属性来使用，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> familyTree = <span class="type">FamilyTree</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ed = <span class="type">Person</span>(name: <span class="string">"Ed"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>假如某些情况我们并不需要用到某个人的族谱信息呢？我们可以在 <code>familyTree</code> 属性前添加 <code>lazy</code> 关键字， Swift 将会在 <code>familyTree</code> 属性第一次被访问的时候才执行创建代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> familyTree = <span class="type">FamilyTree</span>()</span><br></pre></td></tr></tbody></table></figure>

<p>因此，如果你想要看到 “创建族谱！” 这条信息被打印，你至少需要访问 <code>familyTree</code> 属性一次：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">ed.familyTree</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h1><p>目前为止我们认识的所有属性和方法都是属于独立的结构体实例，这意味着假如我们有一个叫 <code>Student</code> 的结构体，我们可以创建几个 student 实例，每个实例都有各自的属性和方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ed = <span class="type">Student</span>(name: <span class="string">"Ed"</span>)</span><br><span class="line"><span class="keyword">let</span> taylor = <span class="type">Student</span>(name: <span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>你可以要求 Swift 在不同的结构体实例之间共享属性和方法，这些属性和方法被称为静态属性和静态方法，实现的方式是添加 <em>static</em> 声明。</p>
<p>现在，让我们给 <code>Student</code> 结构体添加一个静态属性，用以存放班级学生的总数。每当我们创建一个新的 student 实例时，我们将这个属性的数值加 1 ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> classSize = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="type">Student</span>.classSize += <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>classSize</code> 属性是属于结构体本身而非结构体的实例，因此我们需要用 <code>Student.classSize</code> 来访问它：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">Student</span>.classSize)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>访问控制使得我们可以限制哪些代码能够访问属性和方法。这个机制在你想要保护属性免于被直接读取的时候很有用，举个例子：</p>
<p>我们仍然创建一个 <code>Person</code> 结构体，它有一个 <code>id</code> 属性，用来存放社保 ID：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ed = <span class="type">Person</span>(id: <span class="string">"12345"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>一旦 person 实例被创建，我们希望它的 <code>id</code> 是私有的。私有的意思是你不能从结构体外部读取它，像 <code>ed.id</code> 这样的代码会变得不合法。</p>
<p>要做到这一点，你需要用到 <code>private</code> 关键字，像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这么写之后，只有 <code>Person</code> 内部的方法才能读取 <code>id</code> 属性。举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"我的社保 ID 是 \(id)"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>还有一个常见的选项是 <code>public</code> ，它使得所有的其他代码都能够访问到目标属性或者方法。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们一起来总结一下。</p>
<ol>
<li>你可以创建自己的结构体类型，它们有自己的属性和方法。 </li>
<li>你学习了存储属性，以及每一次通过临时计算得到值的计算属性。 </li>
<li>当你希望在方法中修改属性时，需要把方法标记成 <code>mutating</code> 。 </li>
<li>构造器是创建结构体时的特殊方法。默认情况下，你会得到一个逐一成员构造器。不过，如果你想要自行实现构造器的话，需要确保所有的属性都被赋值。 </li>
<li>你可以在方法中用 <code>self</code> 常量来引用当前正在使用的结构体实例。 </li>
<li><code>lazy</code> 关键字告诉 Swift 你希望属性在第一次访问时才被创建。 </li>
<li>可以利用 <code>static</code> 关键字在结构体的所有实例间共享属性和方法。 </li>
<li>访问控制使得我们可以限制哪些代码能够访问属性和方法。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之六 | 闭包</title>
    <url>/programming/swiftswift-closures/</url>
    <content><![CDATA[<h1 id="创建基本的闭包"><a href="#创建基本的闭包" class="headerlink" title="创建基本的闭包"></a>创建基本的闭包</h1><p>Swift 允许我们像字符串和整数一样使用函数。具体来说，你可以创建一个函数然后把它赋给一个变量，利用那个变量来调用函数。你甚至可以把函数作为参数传给另一个函数。</p>
<p>函数的这种用法被称为 <em>闭包</em> 。虽然工作机制差不多，写法上是有一些小差异的。</p>
<p>还是以打印信息为例：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我要去开车"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码实际上创建了一个匿名的函数，并将这个函数赋给了 <code>driving</code> 。之后你就可以把 <code>driving ()</code> 当作一个常规的函数来用，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">driving ()</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="在闭包中接收参数"><a href="#在闭包中接收参数" class="headerlink" title="在闭包中接收参数"></a>在闭包中接收参数</h1><p>当你创建闭包的时候，它们并没有名字，也没有提供书写参数的地方。但这并不意味着它们不能接收参数，只不过它们接收参数的方式稍有不同：这些参数是被写在花括号里面的。</p>
<p>为了让一个闭包接收参数，你需要在花括号之后把这些参数列出来，然后跟上一个 <code>in</code> 关键字。这样就告诉 Swift ，闭包的主体是从哪里开始的。</p>
<p>举个例子，我们来创建一个闭包，接收一个叫 <code>place</code> 的字符串作为唯一的参数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我要开车去 \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>函数和闭包的一个区别是运行闭包的时候你不会用到参数标签。因此，调用 <code>driving ()</code> 的时候，我们是这样写的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">driving (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="从闭包中返回值"><a href="#从闭包中返回值" class="headerlink" title="从闭包中返回值"></a>从闭包中返回值</h1><p>闭包也能返回值，写法和闭包的参数类似：写在闭包内部， <code>in</code> 关键字前面。</p>
<p>还是以 <code>driving ()</code> 闭包为例， 让它返回一个字符串。原来的函数是这样的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我要开车去  \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>改成返回字符串而不是直接打印那个字符串，需要 <code>in</code> 之前添加 <code>-&gt; String</code> ，然后像常规函数那样用到 <code>return</code> 关键字:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drivingWithReturn = { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们运行这个闭包并且打印出它的返回值：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = drivingWithReturn (<span class="string">"北京"</span>)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="闭包作为参数"><a href="#闭包作为参数" class="headerlink" title="闭包作为参数"></a>闭包作为参数</h1><p>既然闭包可以像字符串和整数一样使用，你就可以将它们传入函数。闭包作为参数的语法乍一看一看挺伤脑筋的，让我们慢慢来。</p>
<p>首先，还是基本的 <code>driving ()</code> 闭包。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们打算把这个闭包传入一个函数，以便函数内部可以运行这个闭包。我们需要把函数的参数类型指定为 <code>() -&gt; Void</code> 。它的意思是 “不接收参数，并且返回 <code>Void</code> ”。在 Swift 中， <code>Void</code> 是什么也没有的意思。</p>
<p>好了，让我们来写一个 <code>travel ()</code> 函数，接收不同类型的 traveling 动作， 并且在动作前后分别打印信息：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  action ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在可以用上 <code>driving</code> 闭包了，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel (action: driving)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="拖尾闭包语法"><a href="#拖尾闭包语法" class="headerlink" title="拖尾闭包语法"></a>拖尾闭包语法</h1><p>如果一个函数的最后一个参数是闭包， Swift 允许你采用一种被称为 <em>“拖尾闭包语法”</em> 的方式来调用这个闭包。你可以把闭包传入函数之后的花括号里，而不必像传入参数那样。</p>
<p>又用到我们的 <code>travel ()</code> 函数了。它接收一个 <code>action</code> 闭包。闭包在两个 <code>print ()</code> 调用之间执行:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  action ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于函数的最后一个参数是闭包，我们可以用拖尾闭包语法来调用 <code>travel ()</code> 函数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel () {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实际上，由于函数没有别的参数了，我们还可以将圆括号完全移除：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>拖尾闭包语法在 Swift 中非常常见，所以你要适应它。</p>
<hr>
<h1 id="使用接收参数的闭包作为函数的参数"><a href="#使用接收参数的闭包作为函数的参数" class="headerlink" title="使用接收参数的闭包作为函数的参数"></a>使用接收参数的闭包作为函数的参数</h1><p>接下来要说到的闭包用法会有点复杂：当你把闭包作为函数参数时，闭包本身也接收参数。</p>
<p>前面我们用 <code>() -&gt; Void</code> 来表示 “不接收参数，并且什么也不返回”，但实际上你可以在 <code>()</code> 里填上你任何想要闭包接收的参数类型。</p>
<p>再次用到 <code>travel ()</code> 函数。函数只接收一个闭包作为参数，但这次闭包会接收一个字符串参数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  action (<span class="string">"北京"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，当我们采用拖尾闭包语法调用 <code>travel ()</code> 时，我们的闭包代码会要求接收一个字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备开车去 \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="使用有返回值的闭包作为函数的参数"><a href="#使用有返回值的闭包作为函数的参数" class="headerlink" title="使用有返回值的闭包作为函数的参数"></a>使用有返回值的闭包作为函数的参数</h1><p>我们之前用 <code>() -&gt; Void</code> 来表示 “不接收参数，并且什么也不返回”。你可以把 <code>Void</code> 替换成任意的类型从而让闭包可以返回值。</p>
<p>还是 <code>travel ()</code> 函数，这次闭包会返回一个字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  <span class="keyword">let</span> description = action (<span class="string">"北京"</span>)</span><br><span class="line">  <span class="built_in">print</span>(description)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>仍然用拖尾闭包语法来调用 <code>travel ()</code> ，闭包要求接收一个字符串并且返回一个字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="速记参数名"><a href="#速记参数名" class="headerlink" title="速记参数名"></a>速记参数名</h1><p>前面我们了构建 <code>travel ()</code> 函数。它接收一个闭包作为参数，这个闭包本身接收一个参数并且返回一个字符串，它在两个 <code>print ()</code> 调用之间运行。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。"</span>)</span><br><span class="line">  <span class="keyword">let</span> description = action (<span class="string">"北京"</span>)</span><br><span class="line">  <span class="built_in">print</span>(description)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以像这样调用 <code>travel ()</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过， Swift 知道提供给闭包的参数必须是一个字符串，所以调用的代码可以简写成这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { place -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Swfit 也知道闭包必须返回一个字符串，于是进一步简写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { place <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>由于这里的闭包只有一行代码，这行代码肯定是返回值的那行代码，因此 Swift 允许我们把 <code>return</code> 关键字也移除：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { place <span class="keyword">in</span></span><br><span class="line">  <span class="string">"我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后， Swift 还提供一种速记语法，让你可以把代码变得更短。我们可以让 Swift 为闭包的参数自动提供一个名字，而不必自行写下 <code>place in</code> 。这些自动生成的名字以 $ 开头，然后跟着一个从 0 开始的整数，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="string">"我要开车去 \($0)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="有多个参数的闭包"><a href="#有多个参数的闭包" class="headerlink" title="有多个参数的闭包"></a>有多个参数的闭包</h1><p>让我们把闭包这个概念一次讲透吧。接下来举一个接收两个参数的闭包的例子。</p>
<p>将 <code>travel ()</code> 函数改造一下，不仅接收旅行目的地，也接收速度。闭包的类型会变成 <code>(String, Int) -&gt; String</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String, Int)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"我准备出发了。)</span></span><br><span class="line"><span class="string">  let description = action ("</span> 北京 &lt; span class="string"&gt;", 60)</span><br><span class="line"><span class="string">  print (description)</span></span><br><span class="line"><span class="string">  print ("</span> 我到达目的地了。<span class="string">")</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>再一次用速记闭包参数名来调用函数。由于这次闭包有两个参数了，于是自动参数名分别是 <code>$0</code> 和 <code>$1</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="string">"我要开车去 \($0)，时速 \($1) 公里每小时。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有些人可能不喜欢用速记参数名，因为它们的语义不是很清晰。你可以根据自己的喜好来决定是否采用它们。不过了解一下这个语法还是必要的，这样读到别人的代码时就不会感到困惑。</p>
<hr>
<h1 id="从函数中返回闭包"><a href="#从函数中返回闭包" class="headerlink" title="从函数中返回闭包"></a>从函数中返回闭包</h1><p>就如同你可以把闭包传入函数那样，你也可以从函数中返回闭包。</p>
<p>返回闭包的语法看起来有点绕，因为用了两次 <code>-&gt;</code> ：第一次用于指定函数的返回值，第二次用于指定闭包的返回值。</p>
<p>又又又要把 <code>travel ()</code> 函数拉出来了。这次它不接收参数，但返回一个闭包。这个返回的闭包在用的时候必须传入一个字符串，但闭包本身没有返回值。</p>
<p>Swift 代码长这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"我要动身去 \($0)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>接下来我们通过调用 <code>travel ()</code> 拿到闭包，然后作为函数来调用：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = travel ()</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>留意下面的代码，它是直接调用 <code>travel ()</code> 的返回值。这个写法虽然在语法上完全没问题，但是可读性较差，建议尽量不要这样写。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result2 = travel ()(<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h1><p>如果你想要使用闭包之外的对象， Swift 会为你 “捕捉” 它们，并把它们和闭包一同存储，以便外部作用域已经失效的情况下闭包内部还可以使用它们。</p>
<p>最后一次用到 <code>travel ()</code> 函数，它返回一个闭包，这个闭包接收字符串作为唯一的参数并且什么也不返回：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"我准备去 \($0)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>调用 <code>travel ()</code> 拿到闭包，然后自由使用：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = travel ()</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>闭包捕获变量可以发生在什么情况下呢？举个例子，当 <code>travel ()</code> 函数内创建了一个变量，这个变量需要在闭包里面用到，那么这个变量就会被闭包捕获。比如，我们想知道闭包被调用的次数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"第 \(counter) 次，我将前往 \($0)"</span>)</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>尽管 <code>counter</code> 变量是在 <code>travel ()</code> 里被创建的，它被闭包捕获，因而会在闭包内部存续。</p>
<p>当我们多次调用 <code>result (" 北京 ")</code> ，计数器会持续增加：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">result (<span class="string">"北京"</span>)</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br><span class="line">result (<span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>你可以把闭包赋值给变量，之后再用变量名来调用闭包。 </li>
<li>闭包和常规函数一样可以接收参数和返回值。 </li>
<li>你可以将闭包作为参数传入函数，并且这些闭包也可以有自己的参数和返回值。 </li>
<li>如果函数的最后一个参数是闭包，你可以使用拖尾闭包语法。 </li>
<li>Swift 为拖尾闭包语法自动生成了 <code>$0</code> 和 <code>$1</code> 这样的速记闭包参数名，但不是所有人都习惯这种速记法。 </li>
<li>如果你在闭包中使用了外部变量，这些变量将被闭包 “捕捉” 以便后续引用。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之五 | 函数</title>
    <url>/programming/swiftswift-functions/</url>
    <content><![CDATA[<h1 id="书写函数"><a href="#书写函数" class="headerlink" title="书写函数"></a>书写函数</h1><p>函数让我们可以重用代码。这句话的具体含义是，我们写一次函数，在多个地方使用。书写重复的代码，通常来说不是一种好的实践，而函数帮助我们避免重复代码。</p>
<p>用一个简单的例子开始吧。假设我们要为 app 的用户提供帮助信息，这个动作在 app 里的多个地方都会用到。因此，把打印帮助信息这个逻辑写成一个函数就是个好主意。</p>
<p>Swift 的函数以 <code>func</code> 关键字开始，然后跟着函数名，然后是一对圆括号，最后是一对花括号。当函数被运行时，花括号里的代码会被执行。</p>
<p>一个 <code>printHelp ()</code> 函数长这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHelp</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">"""</span></span><br><span class="line"><span class="string">  欢迎来到我的 App!</span></span><br><span class="line"><span class="string">  在一个图片的目录下运行这个 App，</span></span><br><span class="line"><span class="string">  它会把所有的图片缩放成缩略图。</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">  <span class="built_in">print</span>(message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后我们用 <code>printHelp ()</code> 来运行它。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">printHelp ()</span><br></pre></td></tr></tbody></table></figure>

<p>运行一个函数又被称为 * 调用 * 一个函数。</p>
<a id="more"></a>

<hr>
<h1 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h1><p>函数在你调用它们的时候可以被定制，这使得它们的能力更加强大。 Swift 允许你发送值给函数，这些值可以在函数内部使用，从而改变函数的行为。其实之前我们已经见过函数的这个特性：我们把整数和字符串传递给 <code>print ()</code> 函数，就像下面这样。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>这些被传入函数的值被称为 * 参数 * 。</p>
<p>为了使你的函数可以接收参数，你需要给参数起个名字，然后加一个冒号，最后再告诉 Swift 这个参数的数据类型。这些都是放在函数名之后的圆括号里面。</p>
<p>举个例子，我们可以写一个函数，打印任意数字的平方。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(number: Int)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(number * number)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码告知 Swift 我们期望接收一个 <code>Int</code> 类型，并且名字叫 <code>number</code> 。这个名字不仅用于函数内部指代参数，也用于运行函数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">square (number: <span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>函数不仅可以接收数据（通过参数），也可以返回数据。为了返回数据，在函数的参数列表之后写一个短横线加一个向右的尖括号，然后提供一个数据类型。这个语法告诉 Swift 函数将返回一个指定类型的数据。</p>
<p>在函数内，我们用 <code>return</code> 关键字来返回数据。这个时候函数会立即结束，并返回数据，函数内的其他代码都不再执行。</p>
<p>我们可以重写 <code>square ()</code> 函数，返回平方数而不是直接打印它：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">  <span class="keyword">return</span> number * number</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们可以通过运行这个函数，拿到返回值并且打印出来：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = square (number: <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你需要返回多个值，可以使用元组作为返回值的类型。</p>
<hr>
<h1 id="参数标签"><a href="#参数标签" class="headerlink" title="参数标签"></a>参数标签</h1><p>前面的 <code>square ()</code> 函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">  <span class="keyword">return</span> number * number</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>参数名是 <code>number</code> ，我们通过在函数里使用 <code>number</code> 来引用这个参数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = square (number: <span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 允许我们给参数起两个名字：一个供调用时使用，一个在函数内部使用。书写的时候把两个名字都写上，用空格分隔。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(to name: String)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(name)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里的参数名是 <code>to name</code> ，在外部调用时用 <code>to</code> ，而内部指代时用 <code>name</code> 。这种方式让参数在函数内部有一个合理的名称，同时在调用时阅读起来也是自然的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">sayHello (to: <span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="省略参数标签"><a href="#省略参数标签" class="headerlink" title="省略参数标签"></a>省略参数标签</h1><p>你可能已经注意到我们在使用 <code>print ()</code> 函数时并没有传入任何参数标签。我们会写作 <code>print ("Hello")</code> ，而不是 <code>print (message:"Hello")</code> 。</p>
<p>通过使用下划线 <code>_</code> 作为外部参数标签，你可以在自己的函数里实现一样的效果，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> person: String)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(person)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这样写的话，调用 <code>greet ()</code> 函数时，你就不必传入参数标签了：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">greet (<span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>为了使代码阅读起来更自然，通常我们是需要给参数起一个外部标签名的。举个例子，如果我说设置闹钟 5（ <code>setAlarm (5)</code> ）不写标签的话很难理解这代表什么意思：是要设置一个 5 点钟生效的闹钟呢？还是要激活第 5 个预先设好的闹钟？而像打印这件事，在打印后面直接跟上要打印的内容，本身就是一个清晰的表达，所以可以省略掉参数标签。</p>
<hr>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p><code>print ()</code> 函数打印文本到屏幕，并且不论你传什么内容给它，它都会在最后添加一个换行。所以多次调用 <code>print ()</code> 的话，那些文本是不会显示在同一行的。</p>
<p>但是你可以改变 <code>print ()</code> 函数的这个行为：你可以用其他符号，例如空格来取代换行。不过多数情况下，大家都想要换行，因此 <code>print ()</code> 有一个叫 <code>terminator</code> 的参数，它的默认值是换行符。</p>
<p>通过在参数后面加上一个 <code>=</code> 然后写上一个值，你可以为你自己的函数提供默认参数。 举个例子，我们写一个 <code>greet ()</code> 函数，默认友好问候：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="number">_</span> person: String, nicely: Bool = <span class="literal">true</span>)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> nicely == <span class="literal">true</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"你好， \(person)!"</span>)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"不是吧，又是 \(person) 你小子。"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在 <code>greet ()</code> 函数就有两种调用方式了：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">greet (<span class="string">"Taylor"</span>)</span><br><span class="line">greet (<span class="string">"Taylor"</span>, nicely: <span class="literal">false</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h1><p>有一些函数是 <em>可变</em> 的，可变是指函数可以接收任意多个同类型的参数。例如， <code>print ()</code> 函数实际上就是可变的：如果你传入多个参数，它们会被以空格相连打印在同一行。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Haters"</span>, <span class="string">"gonna"</span>, <span class="string">"hate"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>你可以通过在参数类型之后添加 <code>...</code> ，将一个参数声明成可变参数。因此，一个 <code>Int</code> 参数代表一个整数，而 <code>Int...</code> 则代表 0 个或者更多整数，理论上不限个数。</p>
<p>在函数内部， Swift 会将这些整数转成一个整数的数组，以方便你遍历它们。</p>
<p>让我们用 <code>square ()</code> 函数来尝试一下吧：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(numbers: Int...)</span></span> {</span><br><span class="line">  <span class="keyword">for</span> number <span class="keyword">in</span> numbers {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(number) 的平方等于 \(number * number)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们可以用逗号分隔一组数字，把它们全部传入 <code>square ()</code> 函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">square (numbers: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="书写会抛出错误的函数"><a href="#书写会抛出错误的函数" class="headerlink" title="书写会抛出错误的函数"></a>书写会抛出错误的函数</h1><p>有的时候函数会运行失败，因为不合理的输入或者函数内部的错误。 Swift 允许我们从函数中抛出错误。实现的方法是在返回值前写一个 <code>throws</code> ，然后在函数出错时使用 <code>throw</code> 关键字抛出错误。</p>
<p>首先我们需要定义一个 <code>enum</code> ，用于描述我们可能抛出的错误。这些错误必须基于 Swift 已经存在的 <code>Error</code> 类型。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PasswordError</span>: <span class="title">Error</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> obvious</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在我们来实现一个函数 <code>checkPassword ()</code> ，这个函数检测传入的密码是否合理，当密码过于简单时，我们抛出一个错误提醒用户。具体来说，当密码被设置成 “password” 时，执行 <code>throw PasswordError.obvious</code> 。</p>
<p>Swift 代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword</span><span class="params">(<span class="number">_</span> password: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> {</span><br><span class="line">  <span class="keyword">if</span> password == <span class="string">"password"</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">PasswordError</span>.obvious</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="运行可能会抛出错误的函数"><a href="#运行可能会抛出错误的函数" class="headerlink" title="运行可能会抛出错误的函数"></a>运行可能会抛出错误的函数</h1><p>Swift 并不期望你在程序运行时遭遇错误，因此它不会让你直接运行可能抛出错误的函数。</p>
<p>你需要用到三个关键字来运行会抛出错误的函数： <code>do</code> 开启一段可能会遭遇问题的代码， <code>try</code> 放在每一个可能抛出错误的函数前面，最后的 <code>catch</code> 让你可以优雅地处理错误。</p>
<p>如果 <code>do</code> 语句块里有任何错误抛出，代码执行会直接跳到 <code>catch</code> 语句块。让我们用一个可以触发 <code>checkPassword ()</code> 抛出错误的密码来调用这个函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  <span class="keyword">try</span> checkPassword (<span class="string">"password"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"这个密码很棒！"</span>)</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"你不能用这个密码。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>当这段代码运行时，“你不能用这个密码。” 会被打印。但” 这个密码很棒！“则不会被打印。这个是由于错误的抛出导致那个打印无法被运行到。</p>
<hr>
<h1 id="inout-参数"><a href="#inout-参数" class="headerlink" title="inout 参数"></a>inout 参数</h1><p>所有传入 Swift 函数的参数默认都是 <em>常量</em> ，所以你无法更改它们。假如你就是想要在函数内改变这些参数呢？可以用 <code>inout</code> 修饰它们，所有在函数内对它们做出的改变都会影响到它们在函数外的原始值。</p>
<p>举个例子，如果你想要让一个数翻倍。比如，直接改变那个数，而不是返回一个新的数。你可以像下面这样写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doubleInPlace</span><span class="params">(number: <span class="keyword">inout</span> Int)</span></span> {</span><br><span class="line">  number *= <span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>为了使用这个可以修改参数的函数，首先要求传入的参数本身不能是常量，因为如果参数本来是常量，即使用 <code>inout</code> 修饰，也无法被修改。其次，在传入函数时，还要用一个 <code>&amp;</code> 符号，放在参数名前面。它是参数以 <code>inout</code> 方式使用的显式标识。</p>
<p>在代码中，是这么书写的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myNum = <span class="number">10</span> </span><br><span class="line">doubleInPlace (number: &amp;myNum)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>函数通过避免重复来帮助我们复用代码。 </li>
<li>函数可以接收参数，你需要告诉 Swift 每个参数的类型。 </li>
<li>函数可以返回值，同样需要指定返回值的类型。如果你想返回多个值，可以使用元组。 </li>
<li>你可以给参数取不同的外部名和内部名，并且可以完全省略外部名。 </li>
<li>参数可以有默认值，以便你用更少的代码指定常见的特定值。 </li>
<li>可变参数可以接收零到多个特定的参数， Swift 会把它们转成数组。 </li>
<li>函数可以抛出错误，但是调用这种函数的时候需要用 <code>try</code> 关键字并且用 <code>catch</code> 来处理错误。 </li>
<li>你可以用 <code>inout</code> 标记可以在函数内部改变的参数，不过通常来说最好还是返回一个新值。 </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之四 | 循环</title>
    <url>/programming/swiftswift-looping/</url>
    <content><![CDATA[<h1 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h1><p>Swift 有很多种书写循环的方式，它们底层的机制是相同的：重复执行某段代码直到某个条件不再满足。</p>
<p>最常见的循环是 <code>for</code> 循环：它在数组和范围上循环，每次拉出一个值然后把它赋予一个常量。</p>
<p>举个例子，这里是一个数字的范围：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">1</span>...<span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们可以用一个 <code>for</code> 循环打印里面的每一个值，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">count</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"数字是 \(number)"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>数组的操作方式也一样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> albums = [<span class="string">"Red"</span>, <span class="string">"1989"</span>, <span class="string">"Reputation"</span>]</span><br><span class="line"><span class="keyword">for</span> album <span class="keyword">in</span> albums {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(album) 在 Apple Music 上有售卖。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果你不需要用到 <code>for</code> 循环提供给你的常量，你可以用下划线替代，这样 Swift 就会忽略这个你没有用到的值：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Zzz..."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h1><p>第二种书写循环的方式是使用 <code>while</code> ：给定一个检查的条件，循环运行代码直到条件不成立。</p>
<p>举个例子，我们可以使用 <code>while</code> 循环来模拟一个躲猫猫游戏：从 1 开始数数，数到的数会打印出来。数完 20 个数之后打印 “准备好了没？我来啦！”</p>
<p>Swift 代码长这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> number &lt;= <span class="number">20</span> {</span><br><span class="line">  <span class="built_in">print</span>(number)</span><br><span class="line">  number += <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"准备好了没？我来啦！"</span>)</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="Repeat-循环"><a href="#Repeat-循环" class="headerlink" title="Repeat 循环"></a>Repeat 循环</h1><p>第三种循环的写法不常用，它是 <code>repeat</code> 循环。除了把条件检查放在后面，它基本上跟 <code>while</code> 循环是一样的。</p>
<p>因此，我们可以用 <code>repeat</code> 循环重写我们的躲猫猫游戏：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span> {</span><br><span class="line">  <span class="built_in">print</span>(number)</span><br><span class="line">  number += <span class="number">1</span></span><br><span class="line">} <span class="keyword">while</span> number &lt;= <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"准备好了没？我来啦！"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>因为检查的条件是放在后面，所以 <code>repeat</code> 循环里的代码至少会被执行一次。而 <code>while</code> 循环则是在首次运行前就会检查条件。</p>
<p>举个例子， 下面代码里的 <code>print ()</code> 函数永远都不会被运行，因为 <code>false</code> 永远是 false ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">false</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"这是 false"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Xcode 会警告我们上面代码中的 <code>print ()</code> 代码永远都不会被执行。</p>
<p>而在下面这个代码里， <code>print ()</code> 函数则至少运行一次，因为 <code>repeat</code> 只有在条件检查没有通过时才会停止执行：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"这是 false"</span>)</span><br><span class="line">} <span class="keyword">while</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h1><p>你可以使用 <code>break</code> 关键字来终止循环。让我们以一个常规的 <code>while</code> 循环为例 —— 火箭发射倒计时：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countDown = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> countDown &gt;= <span class="number">0</span> {</span><br><span class="line">  <span class="built_in">print</span>(countDown)</span><br><span class="line">  countDown -= <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"发射！"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>想象一下，宇航员感觉这个倒计时过程很无聊，决定跳过后面的数，直接发射：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> countDown &gt;= <span class="number">0</span> {</span><br><span class="line">  <span class="built_in">print</span>(countDown)</span><br><span class="line">  <span class="keyword">if</span> countDown == <span class="number">4</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"好无聊啊，让我们直接发射吧！"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  countDown -= <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>通过这次改动，只要 <code>countDown</code> 达到 4 ，那么宇航员的消息就会被打印，剩余的计数将会被忽略。</p>
<hr>
<h1 id="退出多重循环"><a href="#退出多重循环" class="headerlink" title="退出多重循环"></a>退出多重循环</h1><p>把循环放在另一个循环里，叫做 <em>嵌套</em> 循环。有的时候，你会有这种需求：同时跳出内部的循环和外部的循环。</p>
<p>举个例子， 我们可以用嵌套循环实现一个从 1 到 10 的乘法表：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">    <span class="keyword">let</span> product = i * j</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"\(i) * \(j) 等于 \(product)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果想退出循环，我们需要做两件事。首先，给外层循环加一个标签，像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">outerLoop: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">    <span class="keyword">let</span> product = i * j</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"\(i) * \(j) 等于 \(product)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>然后，在内层循环里添加条件，在条件满足时用 <code>break outerLoop</code> 同时退出内外层循环：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">outerLoop: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">    <span class="keyword">let</span> product = i * j</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"\(i) * \(j) 等于 \(product)"</span>)</span><br><span class="line">    <span class="keyword">if</span> product == <span class="number">50</span> {</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"这是一个靶心。"</span>)</span><br><span class="line">      <span class="keyword">break</span> outerLoop</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果只使用 <code>break</code> ，就只能退出内层循环，外层循环会继续运行。</p>
<hr>
<h1 id="跳过循环项"><a href="#跳过循环项" class="headerlink" title="跳过循环项"></a>跳过循环项</h1><p>如你所见， <code>break</code> 关键字可以用于退出循环。 但是假如你想要跳过当前项然后继续执行下一次循环，你可以使用 <code>continue</code> 关键字。</p>
<p>让我们写一个从 1 到 10 的循环，然后利用 Swift 的取余操作符来跳过所有的奇数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h1><p>通常来说，我们用 <code>while</code> 循环来实现无限循环：它指的是那种不会自动停止的循环，或者说只有我们想要它停止时才停止的循环。你的智能手机里的 App 都用到了无限循环，因为它们一旦开始运行，就会持续运行，不断地接收输入事件，做出响应。</p>
<p>最简单的无限循环是用 <code>true</code> 作为条件。 <code>true</code> 使得循环可以无限重复地执行。 ** 警告：** 如果你采用 <code>while true</code> 来实现循环，确保你在循环内会有一个条件检查以退出这个无限循环。</p>
<p>举个例子， 我们用 <code>while true</code> 来模拟约翰・凯奇的《4’33”》这首歌。这首歌真的很奇葩，因为整个首歌的 4 分 33 秒都是沉默，没声。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">""</span>)</span><br><span class="line">  counter += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> counter == <span class="number">273</span> {</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>循环可以重复执行某段代码，直到条件不再满足。 </li>
<li>最常见的循环是 <code>for</code> 循环，它内部会计数一个临时的常量来记录循环的次数。 </li>
<li>如果你用不上这个 <code>for</code> 循环给到你的常量，可以使用下划线来告知 Swift 忽略它。 </li>
<li>对于 <code>while</code> 循环，你需要显式地提供一个条件检查来决定循环是否执行。 </li>
<li>尽管和 <code>while</code> 循环很像， <code>repeat</code> 循环至少会执行一次循环体里的代码。 </li>
<li>你可以用 <code>break</code> 结束循环，但是在嵌套循环里， <code>break</code> 之后还要再加上标签才能跳出特定的外层循环。 </li>
<li>你可以用 <code>continue</code> 来跳过循环中特定的项。 </li>
<li>无限循环只有在你要求它停止时才会结束。如果你用了 <code>while true</code> 来实现无限循环，确保你有一个条件检查用于终止循环！ </li>
</ol>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之三 | 操作符与条件</title>
    <url>/programming/swiftswift-operators-and-conditions/</url>
    <content><![CDATA[<h1 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h1><p>到目前为止，你已经了解了 Swift 的所有基本类型，现在让我们利用操作符把它们放在一起来使用。操作符指的是那些看起来像数学符号的玩意，比如 <code>+</code> 和 <code>-</code> 。 Swift 中有大量的操作符。</p>
<p>下面有一些测试用的变量（这里特指数学里的变量，不局限于 Swift 的 <code>var</code> ）：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstScore = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> secondScore = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>让我们用 <code>+</code> 和 <code>-</code> 把它们相加或者相减：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = firstScore + secondScore</span><br><span class="line"><span class="keyword">let</span> difference = firstScore - secondScore</span><br></pre></td></tr></tbody></table></figure>

<p>我们还可以用 <code>*</code> 和 <code>/</code> 来执行乘法和除法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> product = firstScore * secondScore</span><br><span class="line"><span class="keyword">let</span> divided = firstScore /secondScore</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 有一个用于计算除法的余数的特殊操作符： <code>%</code> 。它可以计算一个数 <code>A</code> 用若干个数 <code>B</code> 填充后，剩余的空间。</p>
<p>举个例子，如果我们把 <code>secondScore</code> 设置为 4 ，那么当我们做 <code>13 % secondScore</code> 这个操作时，我们会得到 1 ，因为 4 可以填充 13 三次，余数为 1 ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> remainder = <span class="number">13</span> % secondScore</span><br></pre></td></tr></tbody></table></figure>

<a id="more"></a>

<hr>
<h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><p>Swift 支持 “操作符重载”，这是一种简明的说法，具体指的是操作符的行为可以根据它使用时的具体情境来决定。举个例子， <code>+</code> 可以用来相加整数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> doubleMeaning = <span class="number">42</span> + <span class="number">42</span></span><br></pre></td></tr></tbody></table></figure>

<p>同时， <code>+</code> 也可以用来连接字符串，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fakers = <span class="string">"Fakers gonna"</span></span><br><span class="line"><span class="keyword">let</span> action = fakers + <span class="string">"fake"</span></span><br></pre></td></tr></tbody></table></figure>

<p>你甚至还可以使用 <code>+</code> 来连接数组，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstHalf = [<span class="string">"John"</span>, <span class="string">"Paul"</span>]</span><br><span class="line"><span class="keyword">let</span> secondHalf = [<span class="string">"George"</span>, <span class="string">"Ringo"</span>]</span><br><span class="line"><span class="keyword">let</span> beatles = firstHalf + secondHalf</span><br></pre></td></tr></tbody></table></figure>

<p>记住， Swift 是一门类型安全的语言。这意味着它不允许你混用类型。举个例子，你不能把一个整数加到一个字符串上，因为这么做没有意义。</p>
<hr>
<h1 id="复合赋值操作符"><a href="#复合赋值操作符" class="headerlink" title="复合赋值操作符"></a>复合赋值操作符</h1><p>Swift 提供了一些把操作符和赋值组合起来的速记操作符，以便你可以用一次操作同时完成计算和赋值。它们看起来很像你已经认识的那些操作符，比如 <code>+</code> ，<code>-</code> ，<code>*</code> ，和 <code>/</code> ，不过需要在尾部再加上一个 <code>=</code> ，以表示把计算结果赋给操作数。</p>
<p>举个例子，如果有人考试考了 95 分，但是需要罚去 5 分，你可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">95</span></span><br><span class="line">score -= <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>

<p>类似地，你可以利用 += 来拼接字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quote = <span class="string">"The rain in Spain falls mainly on the"</span></span><br><span class="line">quote += <span class="string">"Spaniards"</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h1><p>Swift 提供了几个比较操作符，这些符号的工作方式跟你在数学中使用它们的方式很相似。</p>
<p>先来两个测试用的变量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstScore = <span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> secondScore = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>

<p>有两个可以用来检查相等的操作符。 <code>==</code> （发音 “等于”）检查两个值是否相等，而 <code>!=</code> （发音 “不等于”）则检查两个值是否不相等：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">firstScore == secondScore</span><br><span class="line">firstScore != secondScore</span><br></pre></td></tr></tbody></table></figure>

<p>还有四个用来检查两个值哪一个比较大，哪一个比较小或者相等的操作符。就跟数学里的符号一样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">firstScore &lt; secondScore</span><br><span class="line">firstScore &gt;= secondScore</span><br></pre></td></tr></tbody></table></figure>

<p>上面的这些操作符用在字符串上也是可以的，因为字符串都有一个自然的字母顺序。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"Taylor"</span> &lt;= <span class="string">"Swift"</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>你现在应该已经意识到你可以使用 <code>if</code> 语句来书写一些条件了。当你给到 Swift 一个条件时，如果条件成立， Swift 会运行你在 <code>if</code> 语句块里写的代码。</p>
<p>尝试一下。 你可以用上 Swift 最基础的函数，它叫做 <code>print ()</code> ：你提供一些文本给它，它将这些文本打印出来。</p>
<p>让我们用条件来检测二十一点扑克游戏的赢家：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstCard = <span class="number">11</span></span><br><span class="line"><span class="keyword">let</span> secondCard = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> firstCard + secondCard == <span class="number">21</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"21 点！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>花括号 <code>{</code> 和 <code>}</code> 之间的代码，在条件成立时会被执行。如果条件不成立时你想执行另外的代码，可以使用 <code>else</code> 语句：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> firstCard + secondCard == <span class="number">21</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"21 点！"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"普通点数。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你还可以使用 <code>else if</code> 来串联多个条件：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> firstCard + secondCard == <span class="number">2</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Aces，好手气！"</span>)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> firstCard + secondCard == <span class="number">21</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"21 点！"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"普通点数。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="组合条件"><a href="#组合条件" class="headerlink" title="组合条件"></a>组合条件</h1><p>Swift 提供两种操作符，以便我们把条件组合在一起，它们是 <code>&amp;&amp;</code>（发音 “与”）和 <code>||</code> （发音 “或”）。</p>
<p>举个例子，为了检查两个人的年龄是否都超过某个值，我们可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age1 = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> age2 = <span class="number">21</span></span><br><span class="line"><span class="keyword">if</span> age1 &gt; <span class="number">18</span> &amp;&amp; age2 &gt; <span class="number">18</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"两个人都超过 18 岁。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的 <code>print ()</code> 调用只有当两个年龄都大于 18 时才会被执行，而给到的两个年龄并不满足都大于 18 。实际上， Swift 并不会真的把两个条件都检查一遍，它不需要检查 <code>age2</code> 是否大于 18 ，因为当它发现 <code>age1</code> 大于 18 这个条件已经不成立时，就不会再继续检查后面的条件。</p>
<p>与 <code>&amp;&amp;</code> 不同的是，只要有任意一个条件通过测试， <code>||</code> 检查就会被认定为通过。 举个例子，下面的代码在任一年龄大于 18 时就会打印一条消息：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age1 &gt; <span class="number">18</span> || age2 &gt; <span class="number">18</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"有一个人超过 18 岁。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>你可以在一个检查中使用多次 <code>&amp;&amp;</code> 和 <code>||</code> ，但是切记不要把条件写得太过复杂，因为那样很难阅读！</p>
<hr>
<h1 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h1><p>Swift 还提供一种不常用的操作符，叫做三元操作符。它的名字源自它可以一次协同三个操作数工作的特点。首先，它会先检查第一个数里指定的条件是否满足，如果满足则返回第二个数，否则返回第三个数。</p>
<p>三元操作符是把 <code>true</code> 和 <code>false</code> 两种情况一次性考虑进去的符号，它包含问号和冒号两个部分，因此阅读起来更麻烦一些。下面是一些例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstCard = <span class="number">11</span></span><br><span class="line"><span class="keyword">let</span> secondCard = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(firstCard == secondCard ? <span class="string">"牌是一样的"</span> : <span class="string">"牌不一样"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码检查两张牌是否一样，如果一样则打印 “牌是一样的”，否则打印 “牌不一样”。我们也可以换成常规的条件语句来达到一样的检测效果：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> firstCard == secondCard {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"牌是一样的"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"牌不一样"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h1><p>如果你需要用到多个 <code>if</code> 和 <code>else if</code> ，那你可以使用另一种结构：<code>switch case</code>，它会让你的代码看起来更清晰。采用 <code>switch</code> 语句，你只需要写一次条件，然后列出所有可能的结果，并针对所有的结果编写对应的处理代码。</p>
<p>让我们来尝试一下，下面是一个值为 <code>sunny</code> 字符串的名叫 <code>weather</code> 的常量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weather = <span class="string">"sunny"</span></span><br></pre></td></tr></tbody></table></figure>

<p>我们可以使用 <code>switch</code> 语句块来打印下面四种消息中的一种：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> weather {</span><br><span class="line"><span class="keyword">case</span> <span class="string">"rain"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得带伞"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"snow"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得保暖"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sunny"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得戴墨镜"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"天气不错！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后一条 case 是 <code>default</code> ，它是不能省略的，因为 Swift 需要确保你覆盖了所有可能的 case ，即不能有遗漏的情况。所以只要天气不是 <code>rain</code> ， <code>snow</code> ，或者 <code>sunny</code> ， 默认的情况的 case 就会被运行。</p>
<p>Swift 只会运行某一个 case 里的代码。如果你希望继续执行下一个 case 的代码，你需要用到 <code>fallthrough</code> 关键字，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> weather {</span><br><span class="line"><span class="keyword">case</span> <span class="string">"rain"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得带伞"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"snow"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得保暖"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sunny"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"记得戴墨镜"</span>)</span><br><span class="line">  <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"天气不错！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h1><p>Swift 提供了两种方式给我们创建范围： 它们是 <code>..&lt;</code> 和 <code>...</code> 操作符。半开放范围操作符 <code>..&lt;</code> ，创建的范围不包含右边的值。而闭合范围操作符 <code>...</code> ，创建的范围包含右边的值。</p>
<p>范围 <code>1..&lt;5</code> 包含数字 1 ，2 ，3 和 4 ， 而范围 <code>1...5</code> 包含数字 1 ，2 ，3 ，4 和 5 。</p>
<p>对于 switch 语句块来说，范围非常有用。因为你可以把它们用于你的每条 case 。举个例子，假设我们根据某人的考试成绩打印不同的消息：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> score = <span class="number">85</span></span><br><span class="line"><span class="keyword">switch</span> score {</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>..&lt;<span class="number">50</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"你需要加把劲了。"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">50</span>..&lt;<span class="number">85</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"做的不错。"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"你真棒！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如前面提到的，这里必须有一个 <code>default case</code> 来确保所有的可能都被覆盖到。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ul>
<li>Swift 提供了用于算术和比较的操作符，它们的工作机制就像我们在数学中所熟知的那样。 </li>
<li>有一些算术操作符的复合变体，它们可以一次性完成算术和赋值两个操作，比如 <code>+=</code> ，<code>-=</code> ，等等。 </li>
<li>你可以使用 <code>if</code> ， <code>else</code> 和 <code>else if</code> 语句，基于条件判定的结果来运行不同的代码。 </li>
<li>Swift 提供一个三元操作符，把 <code>true</code> 和 <code>false</code> 两种条件检查和语句块组合在一起。尽管有的时候会看到大家在使用它们，我个人不建议你使用这个操作符。 </li>
<li>如果你基于同一个值做多种条件判定，那么你可以使用 switch 语句，这么做会使代码更清晰。 </li>
<li>我们可以用 <code>..&lt;</code> 或者 <code>...</code> 来创建范围，具体用哪一个取决于要不要包含后面那个值，即范围是否闭合。 </li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之二 | 复合类型</title>
    <url>/programming/swiftswift-complex-types/</url>
    <content><![CDATA[<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是用于存储一组值的合集。举个例子，红、绿、蓝是三基色，你可以对它们进行调和从而产生新颜色。因此颜色就可以用一个包含了红、绿、蓝三个值的数组来存储。</p>
<p>代码上，我们这么书写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> red = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">let</span> green = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">let</span> blue = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">let</span> color = [red, green, blue]</span><br></pre></td></tr></tbody></table></figure>

<p>上面的最后一行代码创建了一个数组：它以方括号开始和结束，里面的元素通过逗号分隔。</p>
<p>你可以通过书写数组名加上内部包含一个数字的方括号来读取数组里的元素。注意：这个数字代表元素在数组里的位置，几乎在所有的计算机编程语言中，这个位置都是从 <code>0</code> 开始的。所以，如果你想读取蓝色，可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">color [<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>小心：如果你尝试读取一个不存在的值， Swift 将会崩溃。例如，试图读取 <code>color [5]</code> 就不是一个好主意。</p>
<p>另外还要注意的是，如果你想使用类型注解，数组是通过方括号加里面的类型来表示的： <code>[String]</code> ，<code>[Int]</code> ，<code>[Double]</code> 和 <code>[Bool]</code> 。</p>
<a id="more"></a>

<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合跟数组类似，也是存储一组值的合集。但它们有两个区别：集合中的元素是随机存放的，而数组中的元素是顺序存放的。集合中不允许有两个相同的元素，即任何一个元素只能出现一次。数组则没有这个限制。</p>
<p>你可以直接利用数组来创建一个集合，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="type">Set</span>([<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>])</span><br></pre></td></tr></tbody></table></figure>

<p>当你在 Playground 中查看 colors 中的元素时，你看到的元素的顺序可能跟你创建 colors 时填写的顺序不同。实际上，这个顺序并非真的是每次都随机生成，只不过很有可能跟你给的顺序不同。</p>
<p>Swift 内部自有算法来生成这个顺序，但不保证跟你创建集合时传入的顺序一致。所以，通过位置来读取数组中的元素那种方式，对于读取集合中的元素是不适用的。</p>
<p>如果你试图往集合中插入一个已经存在的元素，重复的这个元素会被忽略。举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors2 = <span class="type">Set</span>([<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"blue"</span>])</span><br></pre></td></tr></tbody></table></figure>

<p>最后的 <code>colors2</code> 只会包含 <code>red</code> ，<code>green</code> 和 <code>blue</code> 各一个。</p>
<hr>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组允许你通过一个值来存储几个值。 听起来跟数组很像，但元组有所不同：你不能往元组中添加或者删除元素 —— 元组的长度是固定的。你不能改变元组中元素的类型 —— 元组创建时内部的元素类型必须是一致的。</p>
<p>你可以通过位置或者名称来访问元组中的元素。但是 Swift 不允许你访问不存在的位置或者名称。</p>
<p>元组的创建方式是把一组值放进圆括号中，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = (first: <span class="string">"Taylor"</span>, last: <span class="string">"Swift"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>你可以通过从 0 之类的位置信息来访问元组的元素：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">name.<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>

<p>或者你也可以通过名称来访问元组的元素：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">name.first</span><br></pre></td></tr></tbody></table></figure>
<p>在元组创建之后，你可以改变其中元素的值，但是不能改变它们的类型。因此，如果你尝试把 name 改成 (first: “韩梅梅”，age: 25) ，将会遭遇错误。</p>
<hr>
<h1 id="数组-vs-集合-vs-元组"><a href="#数组-vs-集合-vs-元组" class="headerlink" title="数组 vs 集合 vs 元组"></a>数组 vs 集合 vs 元组</h1><p>数组，集合和元组第一眼看上去很相似，但它们的用途是有区别的。为了帮助你更好地选择，这里有一些规则供参考：</p>
<p>如果你需要存放的元素是关联在一起被使用的，它们的个数固定，顺序或者名称也相对固定，那么你应当使用元组。举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> address = (门牌号: <span class="number">666</span>, 街道: <span class="string">"朝阳区某街道"</span>, 城市: <span class="string">"北京"</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你需要一个合集，其中的元素必须是唯一的，或者你可能需要快速地检验合集里有没有包含某个元素，那么你应当使用集合。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shoppingList = <span class="type">Set</span>([<span class="string">"苹果"</span>, <span class="string">"肉"</span>, <span class="string">"牛奶"</span>])</span><br></pre></td></tr></tbody></table></figure>

<p>如果你需要一个合集，其中的元素允许重复，或者合集中元素的顺序对你来说很重要，那么你应当使用数组。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pingpongScores = [<span class="string">"11-7"</span>, <span class="string">"8-11"</span>, <span class="string">"11-9"</span>, <span class="string">"8-11"</span>, <span class="string">"11-5"</span>, <span class="string">"13-11"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>三种类型中，数组是最常用的。</p>
<hr>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典也是用于存储一组值的合集。但跟数组用整数的位置来访问元素的方式不同的是，在字典里你可以用任何你想要的类型来充当访问标识。</p>
<p>当然，最常见的存储字典的访问标识是字符串。举个例子，我们可以创建一个基于运动员的名字来访问运动员的身高的字典：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> top3NBAHeights = [</span><br><span class="line">  <span class="string">"马努特 波尔"</span>: <span class="number">2.31</span>,</span><br><span class="line">  <span class="string">"姚明"</span>: <span class="number">2.28</span>,</span><br><span class="line">  <span class="string">"里克 施密茨"</span>: <span class="number">2.23</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>就像数组一样，字典也以方括号开始和结束，里面的元素通过逗号分隔。此外，为了把一个值（例如 2.28）存放到对应的标识（例如 “姚明”）下面，你还得用到一个冒号。</p>
<p>这些访问标识被称为 “键”，相对应的是 “值”。我们用键来读取值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">top3NBAHeights [<span class="string">"姚明"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>注意：如果你想使用类型注解，数组是通过方括号加里面的键值对类型来表示的，键值对又通过冒号分隔。举个例子， <code>[String: Double]</code> 或者 <code>[String: String]</code> 。</p>
<h2 id="字典默认值"><a href="#字典默认值" class="headerlink" title="字典默认值"></a>字典默认值</h2><p>如果你试图通过一个不存在于字典中的键读取字典中的值时， Swift 会返回给你一个 nil 。它代表没有东西。当然，这可能就是你想要 Swift 在找不到目标时返回给你的结果。不过，我们还有另外一种选择：当给定的键对应的值不存在时，我们可以指定一个默认的值返回给访问者。</p>
<p>为了演示这种操作，我们先创建一个包含了两个人最喜欢的冰淇淋的字典：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteIceCream = [</span><br><span class="line">  <span class="string">"小明"</span>: <span class="string">"巧克力"</span>,</span><br><span class="line">  <span class="string">"小红"</span>: <span class="string">"香草"</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以像这样读取小明最喜欢的冰淇淋：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">favoriteIceCream [<span class="string">"小明"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>但是当我们试图读取小华最喜欢的冰淇淋时，我们会得到一个 nil ，这代表 Swift 没有在字典里找到对应 “小华” 这个键的值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">favoriteIceCream [<span class="string">"小华"</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>这种情况下，我们可以通过指定一个默认值，比如说 “未知”，来解决这个问题。这样做之后， 当 Swift 没有从字典中找到小华最喜欢的冰淇淋时，我们得到的不再是一个 nil ，而是一个 “未知” 字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">favoriteIceCream [<span class="string">"小华"</span>, <span class="keyword">default</span>: <span class="string">"未知"</span>]</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="创建空的合集"><a href="#创建空的合集" class="headerlink" title="创建空的合集"></a>创建空的合集</h1><p>数组，集合和字典都属于合集，因为它们都是把分散的值收集起来放在一处的结构。</p>
<p>如果你想要创建一个空的合集，只需要写上类型名，然后加上一组圆括号。举个例子，创建一个键和值的类型都是 <code>String</code> 的字典，我们可以这样书写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> teams = [<span class="type">String</span>: <span class="type">String</span>]()</span><br></pre></td></tr></tbody></table></figure>

<p>之后添加元素，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">teams [<span class="string">"小红"</span>] = <span class="string">"红色"</span></span><br></pre></td></tr></tbody></table></figure>

<p>类似的，你可以像这样创建一个 <code>Int</code> 类型的空数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> results = [<span class="type">Int</span>]()</span><br></pre></td></tr></tbody></table></figure>

<p>创建集合是一个例外，方式稍有不同：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> numbers = <span class="type">Set</span>&lt;<span class="type">Int</span>&gt;()</span><br></pre></td></tr></tbody></table></figure>

<p>这是因为 Swift 只为字典和数组提供了特殊的语法，其他类型都必须使用尖括号来声明类型信息，就像集合那样。</p>
<p>当然，也可以不使用特殊语法，通过和集合类似的标准方式创建字典和数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> results = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举，通常简称 <code>enums</code> ，是一种定义一组高度关联的值的方式。它使得这组关联的值使用起来更方便。为什么这么说呢？</p>
<p>想象一下，如果你想要写一些代码表示正在做的某件事情的结果，成功或者失败，你选择了使用字符串来表示这个结果：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">"failure"</span></span><br></pre></td></tr></tbody></table></figure>
<p>不过，有人不小心写错了或者采用了不同的拼写，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result2 = <span class="string">"failed"</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="string">"fail"</span></span><br></pre></td></tr></tbody></table></figure>

<p>上面几行表示失败的字符串都各不相同，所以它们代表不一样的东西，无法让你基于失败这一结果的代码被正确执行。</p>
<p>而有了枚举，我们可以定义一个叫做 <code>Result</code> 的类型，它既可以是 <code>success</code> ，也可以是 <code>failure</code> ，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> success</span><br><span class="line">  <span class="keyword">case</span> failure</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>现在，当我们再想要表示结果时，只需要从两个值中选择一个：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result4 = <span class="type">Result</span>.failure</span><br></pre></td></tr></tbody></table></figure>

<p>这样做的好处是可以避免书写不一致字符串导致跟预期不匹配的情况发生。</p>
<h2 id="枚举关联值"><a href="#枚举关联值" class="headerlink" title="枚举关联值"></a>枚举关联值</h2><p>除了可以存储简单的值，枚举还可以存储附属于每个 <code>case</code> 的关联值。这个特性使得你可以为枚举附加额外的数据，从而让它们传达更多细微的信息。</p>
<p>举个例子，我们可以定义一个枚举，它存放了各种各样的活动类型：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Activity</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> bored</span><br><span class="line">  <span class="keyword">case</span> running</span><br><span class="line">  <span class="keyword">case</span> talking</span><br><span class="line">  <span class="keyword">case</span> singing</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的枚举类型存储的信息，可以让我们知道有人在讲话，但我们不知道讲话的内容，或者可以让我们知道有人在跑步，但我们不知道他们将跑去哪里。</p>
<p>通过枚举的关联值，我们添加额外的细节：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Activity</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> bored</span><br><span class="line">  <span class="keyword">case</span> running (destination: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> talking (topic: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> singing (volume: <span class="type">Int</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们有了更精确的信息。我们可以说某人正在谈论足球：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> talking = <span class="type">Activity</span>.talking (topic: <span class="string">"football"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h2 id="枚举原始值"><a href="#枚举原始值" class="headerlink" title="枚举原始值"></a>枚举原始值</h2><p>有的时候你可能想给枚举赋予一些原始值从而让它们可以表达某种含义。这么做可以让你动态地创建枚举，并且以不一样的方式来使用它们。</p>
<p>举个例子，你可以创建一个名叫 <code>Planet</code> 的枚举，然后让它的每条 case 存储一个整数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> mercury</span><br><span class="line">  <span class="keyword">case</span> venus</span><br><span class="line">  <span class="keyword">case</span> earth</span><br><span class="line">  <span class="keyword">case</span> mars</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Swift 会为这些 case 自动分配一个数字，同样的，是从 0 开始。你可以利用这些数字创建枚举的 case 。举个例子， <code>earth</code> 会被分配到数字 2 ，于是你可以这么创建一个 <code>earth</code> 的 case ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> earth = <span class="type">Planet</span>(rawValue: <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>如果你自行指定了一个或者几个 case 的原始值， Swift 可能会自动为剩下的 case 生成原始值，只要这些值是可以被 Swift 推断的。比如把地球算作第 2 颗行星来考虑可能不太自然（因为我们一般说它是九大行星中的第 3 颗)，于是你可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> mercury = <span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> venus</span><br><span class="line">  <span class="keyword">case</span> earth</span><br><span class="line">  <span class="keyword">case</span> mars</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样一来 Swift 就会给 <code>mercury</code> 分配数字 1 ，后面的数字基于前面的往上加， <code>earth</code> 就变成第 3 颗行星了。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ul>
<li>数组，集合，元组和字典让你可以通过单一对象存储一组值。它们实现这一点的方式各有不同，所以你需要根据具体场景来决定采用哪一种结构。</li>
<li>数组按顺序存储数据，你可以往里面添加或者删除元素，并通过位置来读取。</li>
<li>集合不按顺序存储数据，所以你不能通过位置来访问，但它提供了元素不重复的特性。</li>
<li>元组长度固定，你可以给里面的每个元素取名。这样就既可以通过位置，也可以通过名字来读取。</li>
<li>字典根据键来存储数据，因此读取元素时要用到键。</li>
<li>枚举是一种分组关联值的方法，帮你避免拼写错误。</li>
<li>你可以为枚举的每条 <code>case</code> 设置原始值，同时还可以为它们附加关联值来提供额外的信息。</li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之一 | 简单类型</title>
    <url>/programming/swiftswift-simple-types/</url>
    <content><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>当你启动 Xcode 时，它会询问你想要做的事情，选择 “Get Started with a Playground” 。 Playground 是一个可以供你输入 Swift 代码并立即看到结果的沙盒环境。</p>
<p>默认的， Xcode 将提供一个 iOS 编程环境的空白 Playground, 点击 Next，然后再点击 Create ，将 Playground 保存到你的系统桌面。</p>
<p>在本文中，我将向你介绍 “变量”，它们是你用来存储程序数据的地方。之所以被称为 “变量”，是因为它们可变，即你可以自由地改变它们的值。</p>
<p>我们将从在 Playground 中的第一行代码开始了解 “变量”，它是一行创建了一个名称为 “str” ， 值为 “Hello, playground” 的字符串变量的代码。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello, playground"</span></span><br></pre></td></tr></tbody></table></figure>

<p>这行代码创建了一个名为 <code>str</code> 的新变量，并给它赋值为 “Hello, playground” 。在 Playground 右侧的输出区域你可以看到 “Hello, playground” – 这是 Xcode 在展示我们刚刚给 <code>str</code> 设置的值。</p>
<p>既然 str 是一个变量，我们就可以改变它:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">str = <span class="string">"Goodbye"</span></span><br></pre></td></tr></tbody></table></figure>

<p>第二次的时候，你不需要再写一次 <code>var</code> ，因为这个变量在前面已经被创建过了 – 我们只需要改变它。</p>
<a id="more"></a>

<hr>
<h1 id="字符串和整型"><a href="#字符串和整型" class="headerlink" title="字符串和整型"></a>字符串和整型</h1><p>Swift 是一门类型安全的编程语言，类型安全特指的含义包括：每一个变量都必须有一个特定的 “类型”。 Xcode 为我们创建的 str 变量拥有一个由字母组合 “Hello, playground” 组成的字符串，所以 Swift 为这个变量赋予了 <code>String</code> 类型。</p>
<p>换句话说，如果我们想存储一个人的年龄，那我们可能需要创建这样一个变量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">38</span></span><br></pre></td></tr></tbody></table></figure>

<p>这个变量拥有一个整数， 所以 Swift 赋予它 <code>Int</code> 类型 –  <code>Int</code> 是 “integer” 的简写。如果你的数比较大，Swift 允许使用下划线作为千位分隔符。这些分隔符不会改变数字代表的绝对数值，它们只是让数字阅读起来更方便。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> population = <span class="number">8_000_000</span></span><br></pre></td></tr></tbody></table></figure>

<p><code>String</code> 和 <code>Int</code> 是不同的类型，不能混用。因此，你可以把 <code>str</code> 的值改成 “Goodbye”，但你不能把它改成 <code>38</code> ，因为 <code>38</code> 是一个 <code>Int</code> 类型，不是一个 <code>String</code> 类型。</p>
<hr>
<h1 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h1><p>标准的 Swift 字符串使用双引号表示，但在双引号之间你不能换行。如果你想要表示多行的字符串，需要使用将双引号首尾的引号个数由一个改成三个，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">"""</span></span><br><span class="line"><span class="string"> 这个字符串 </span></span><br><span class="line"><span class="string"> 跨越了 </span></span><br><span class="line"><span class="string"> 多行 </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure>

<p>Swift 对于书写这些引号有着特别的规定：开始的三个引号和结束的三个引号都必须独占一行，但它们占的那两行都不会算进最终的字符串里。假如你只是想利用多行字符串来使代码看起来更整洁，你可以通过在每行的行尾添加一个 \ 来确保换行不会进入最终的字符串，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str2 = <span class="string">"""</span></span><br><span class="line"><span class="string"> 这个字符串 \</span></span><br><span class="line"><span class="string"> 看起来跨越了多行， \</span></span><br><span class="line"><span class="string"> 实际上没有 </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="双精度浮点型和布尔型"><a href="#双精度浮点型和布尔型" class="headerlink" title="双精度浮点型和布尔型"></a>双精度浮点型和布尔型</h1><p>Swift 中还有两种基础的数据类型，它们是双精度浮点数类型和布尔类型，你将会经常用到它们。 <code>Double</code> 被用来代表 “双精度浮点数”，这是表示诸如 38.1 , 或者 3.141592654 这样的小数的一种高级的说法。每当你通过一个分数创建一个变量时， Swift 都会自动赋予这个变量 <code>Double</code> 类型。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pi = <span class="number">3.141</span></span><br></pre></td></tr></tbody></table></figure>

<p>双精度浮点数有别于整数，也不能混用。至于布尔类型则更简单一些：它们只有 <code>true</code> 和 <code>false</code> 两种值，所以当你用 <code>true</code> 或者 <code>false</code> 创建一个变量时， Swift 会自动赋予这个变量布尔类型。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> awesome = <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<hr>
<h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><p>你已经在前面学到了如何在代码中直接输入字符串的值，不过 Swift 还提供了一种被称为 “字符串插值” 的特性。这个特性允许你在字符串值里插入变量，从而动态地给一个 <code>String</code> 类型的变量赋值。在字符串内部，你可以放置任意类型，任意数量的变量。要放置这些变量，你需要以一个反斜杠开始，即 \，然后跟上用圆括号包起来的变量名。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">85</span> </span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"你的分数是 \(score)"</span></span><br></pre></td></tr></tbody></table></figure>

<p>你将会在 Playground 的输出区域里看到，上面的操作会把 <code>str</code> 变量的值设置为 “你的分数是 85”。</p>
<p>多尝试几次，通过字符串插值组合出任何你想要的字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> results = <span class="string">"测试结果如下： \(str)"</span></span><br></pre></td></tr></tbody></table></figure>

<p>在之后你还会学到，字符串插值不仅可以用来放置变量，还可以用来运行代码。</p>
<hr>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>前面提到变量之所以被称为变量是因为你可以随着时间的推移改变它们，这一点非常有用。不过，有些时候你只需要设置一次值然后就不再改变了，这种情况下我们使用常量。对应给变量用的 <code>var</code> 关键字，常量用 <code>let</code> 关键字表示。 <code>let</code> 关键字用来声明常量，常量的值只能被设置一次，并且无法被修改。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> taylor = <span class="string">"swift"</span></span><br></pre></td></tr></tbody></table></figure>

<p>如果你尝试改变常量的值， Xcode 会拒绝运行你的代码。这是一种安全机制，以防止你失手改变一些本来不应该被改变的东西。在书写 Swift 代码的时候，除非你明确想要改变，你应当尽量使用 <code>let</code> 关键字。实际上，如果你用了 <code>var</code> 声明变量但之后都没有再对它进行改变， Xcode 将会发出警告。</p>
<hr>
<h1 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h1><p>Swift 基于变量和常量在创建时被赋予的值为它们分配了一个类型。因此，当你书写如下的代码时， Swift 知道这里面包含了一个字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"Hello, playground"</span></span><br></pre></td></tr></tbody></table></figure>

<p>它将把 <code>str</code> 当作一个 <code>String</code> 类型，因此之后你就不能再给它赋值一个整数值或者布尔值。这个过程被称为 ** 类型推断 **。 Swift 能够基于你创建一个东西的方式来推断它的类型。  如果你想显式地声明数据的类型而不是依赖 Swift 的类型推断，你可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> album: <span class="type">String</span> = <span class="string">"Reputation"</span> </span><br><span class="line"><span class="keyword">let</span> year: <span class="type">Int</span> = <span class="number">1989</span> </span><br><span class="line"><span class="keyword">let</span> height: <span class="type">Double</span> = <span class="number">1.78</span> </span><br><span class="line"><span class="keyword">let</span> <span class="keyword">is</span>: <span class="type">Bool</span> = <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>

<p>留心布尔类型的缩写名是 <code>Bool</code> ，同样地，整数类型也是采用缩写的 <code>Int</code> 。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ul>
<li>我们使用 <code>var</code> 来创建变量，使用 <code>let</code> 来创建常量。如无必要使用变量，应当尽可能地使用常量。 </li>
<li><code>String</code> 类型通常以双引号来开始和结束。如果你想要字符串能够跨越多行，则需要把引号替换为三个。 </li>
<li><code>Int</code> 类型存储整数，<code>Double</code> 存储小数，而 <code>Bool</code> 则存储 <code>true</code> 或者 <code>false</code>。 </li>
<li>字符串插值允许你通过在字符串内部放置其他的变量和常量的方式来创建新的字符串。 </li>
<li>Swift 通过类型推断来给变量或者常量分配类型，不过你也可以显式地提供类型。 </li>
</ul>
<hr>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
</search>
