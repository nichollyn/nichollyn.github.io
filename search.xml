<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>八个常见的 SwiftUI 误用及对应的正确打开方式</title>
    <url>/development/eight-swiftui-misuses-and-correction/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmk1u8ramjj31900u0b2e.jpg" alt="zdenek-machacek-pqYGHW0_od0-unsplash"></p>
<blockquote>
<p>译自 <a href="https://www.hackingwithswift.com/articles/224/common-swiftui-mistakes-and-how-to-fix-them">https://www.hackingwithswift.com/articles/224/common-swiftui-mistakes-and-how-to-fix-them</a></p>
</blockquote>
<p>欢迎关注微信公众号「Swift 花园」</p>
<p>SwiftUI 是一个庞大且复杂的框架。使用这个框架编程无疑是享受的，但犯错的机会也不少见。这篇文章我将带大家速览 SwiftUI 初学者常犯的一些错误，并提供修正方案。</p>
<p>其中的一些错误是由于简单的误解导致。由于 SwiftUI 太大，这种情况其实容易出现。而另一些错误则与深入理解 SwiftUI 的工作方式有关，还有一些是原有的思维方式导致 —— 你可能花了很多时间编写 view 和 modifier，但没有想到用 SwiftUI 的方式简化结果。</p>
<p>开门见山，你不需要猜我会给你准备什么菜，这里我直接把八条误用先简明扼要地罗列如下，然后我们逐条深入展开：</p>
<ol>
<li><p>添加不必要的 View 和 Modifier</p>
</li>
<li><p>在需要用 <code>@StateObject</code> 的地方用了 <code>@ObservedObject</code></p>
</li>
<li><p>Modifier 顺序错误</p>
</li>
<li><p>给属性包装器添加属性观察者</p>
</li>
<li><p>在需要用描边框的地方使用了描形状</p>
</li>
<li><p>Alert 和 Sheet 与可选状态的使用</p>
</li>
<li><p>尝试改变 SwiftUI 视图后面的东西</p>
</li>
<li><p>用错误的范围动态创建视图</p>
</li>
</ol>
<hr>
<h3 id="1-添加不必要的-View-和-Modifier"><a href="#1-添加不必要的-View-和-Modifier" class="headerlink" title="1 添加不必要的 View 和 Modifier"></a>1 添加不必要的 View 和 Modifier</h3><p>让我们从最常见的一个误用开始，它会让我们编写更多的 SwiftUI 代码。这种误用的部分原因通常是我们在解决问题时编写了许多代码，但是最后忘记整理代码。还有的时候，则是旧习惯作祟，尤其是当编写者是从 UIKit 或者其他 UI 框架转到 SwiftUI 上。</p>
<p>比如，你可能希望用一个红色矩形填满屏幕？然后你像下面这样编写代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Rectangle</span>()</span><br><span class="line">    .fill (<span class="type">Color</span>.red)</span><br></pre></td></tr></tbody></table></figure>
<p>的确，上面的代码可以工作 —— 它能准确地得到你想要的效果。但是其中一半的代码是不必要的，因为你只需要像下面这样写也能实现一样的效果：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Color</span>.red</span><br></pre></td></tr></tbody></table></figure>
<p>这是因为在 SwiftUI 中，所有的颜色和形状都自动遵循了 View 协议，你可以把它们直接当成视图来使用。</p>
<p>你可能也会经常看见形状裁切，因为为了实现特定形状，应用 <code>clipShape ()</code> 是件很自然的事情。例如，可以像下面这样让我们的红色矩形拥有圆角：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Color</span>.red</span><br><span class="line">    .clipShape (<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">50</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>但这也是不要的 —— 借助 <code>cornerRadius ()</code> modifier，代码可以简化如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Color</span>.red</span><br><span class="line">    .cornerRadius (<span class="number">50</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>移除这类的冗余代码需要时间，因为你需要转变思维习惯，这一点对于 SwiftUI 的初学者来说更加困难。 因此，假如你一开始采用了这些更长版本的代码，不必担忧，多加训练。</p>
<h3 id="2-在需要用-StateObject-的地方用了-ObservedObject"><a href="#2-在需要用-StateObject-的地方用了-ObservedObject" class="headerlink" title="2 在需要用 @StateObject 的地方用了 @ObservedObject"></a>2 在需要用 <code>@StateObject</code> 的地方用了 <code>@ObservedObject</code></h3><p>SwiftUI 提供了众多属性包装器，帮助我们构建数据响应式的用户界面，其中最重要的当属 <code>@State</code>， <code>@StateObject</code> 和 <code>@ObservedObject</code>。掌握它们的使用场景非常重要，因为误用它们会给你的代码带来各种问题。</p>
<p>第一个比较直接：<code>@State</code> 用于值类型属性，并且属性由当前视图拥有。因此，整数，字符串，数组等，都是应用 <code>@State</code> 的绝佳场景。</p>
<p>后两者则有点令人困惑，你可能会经常看到下面这样的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> username = <span class="string">"@twostraws"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> model = <span class="type">DataModel</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Text</span>(model.username)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以明确的说，这么做是错误的，并且极有可能在你的应用中带来问题。</p>
<blockquote>
<p>译者注：基于代码片段说这样写一定是错误的，这个表述是不严谨的。作者应该是隐含假设了 <code>ContentView</code> 是应用的顶级视图（通常来说，如果你不改工程模板的默认输出，<code>ContentView</code> 也确实是顶级视图）。对于顶级视图来说，SwiftUI 2.0 应当使用 <code>@StateObject</code> ，它是为了解决 <code>@ObservedObject</code> 或者 <code>@EnvironmentObject</code> 对象的所有权问题。但是对于附属于顶级视图的视图层级，各子视图的数据源可以是 <code>@ObservedObject</code> 或者 <code>@EnvironmentObject</code>，因为它们的生命周期受顶级视图管理，进而可以由顶级视图统一保证数据的可用性。</p>
</blockquote>
<p>正如我前面说到的，<code>@State</code> 表示某个值类型属性由当前视图拥有，这里的 “拥有” 很重要。而 <code>@StateObject</code> 则相当于引用类型版本的 <code>@State</code>。</p>
<p>因此，上面的代码应该改成这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">@<span class="type">StateObject</span> model = <span class="type">DataModel</span>()</span><br></pre></td></tr></tbody></table></figure>
<p>当你使用 <code>@ObservedObject</code> 来创建某个对象实例时，你的视图并不拥有这个对象实例，也就是说，这个实例可以在任何时候被销毁（译者注：视图无法了解也无法干预这个时机）。狡猾的是，对象在视图还需要用它时被销毁的情况只是偶尔发生，所以你可能认为你的代码很完美。</p>
<p>需要记住的重点是 <code>@State</code> 和 <code>@StateObject</code> 表示 “视图拥有数据”，而 <code>@ObservedObject</code> 和 <code>@EnvironmentObject</code> 则没有。</p>
<h3 id="3-Modifier-顺序错误"><a href="#3-Modifier-顺序错误" class="headerlink" title="3 Modifier 顺序错误"></a>3 Modifier 顺序错误</h3><p>Modifier 的顺序在 SwiftUI 中至关重要。顺序错误不仅会导致布局在上视觉上的偏差，也会导致其行为的错误。</p>
<p>解释这个问题最经典的例子是 <code>padding</code> 和 <code>background</code> 的使用，如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font (.largeTitle)</span><br><span class="line">    .background (<span class="type">Color</span>.green)</span><br><span class="line">    .padding ()</span><br></pre></td></tr></tbody></table></figure>
<p>由于我们在 <code>background</code> 颜色之后应用 <code>padding</code>，颜色只会被直接应用在文本周围，而不是被添加留白之后的文本周围。如果你希望留白和文本背景都是绿色，应该将代码改成下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font (.largeTitle)</span><br><span class="line">    .padding ()</span><br><span class="line">    .background (<span class="type">Color</span>.green)</span><br></pre></td></tr></tbody></table></figure>
<p>当你尝试调整视图位置时，这个原理会让事情变得更有趣。</p>
<p>例如，<code>offset ()</code> modifier 会修改一个视图被渲染的位置，但并不实际改变视图的位置。也就是说，应用在 <code>offset</code> 之后的 modifier 表现得就像 <code>offset</code> 从未发生过。</p>
<p>尝试下面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font (.largeTitle)</span><br><span class="line">    .offset (x: <span class="number">15</span>, y: <span class="number">15</span>)</span><br><span class="line">    .background (<span class="type">Color</span>.green)</span><br></pre></td></tr></tbody></table></figure>
<p>你会发现文本偏移了，但背景颜色没有偏移。现在，尝试交换 <code>offset ()</code> 和 <code>background ()</code> 的位置：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font (.largeTitle)</span><br><span class="line">    .background (<span class="type">Color</span>.green)</span><br><span class="line">    .offset (x: <span class="number">15</span>, y: <span class="number">15</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>现在你会看到文本和背景都移动了。</p>
<p>另外，<code>position ()</code> modifier 会改变一个视图在其父节点中的渲染位置，但这一点是借助它先在视图周围应用一个可伸展尺寸的 frame 来实现的。</p>
<p>尝试下面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font (.largeTitle)</span><br><span class="line">    .background (<span class="type">Color</span>.green)</span><br><span class="line">    .position (x: <span class="number">150</span>, y: <span class="number">150</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>你会发现背景颜色紧贴在文本四周，并且整个视图被放置在左上角。现在，尝试对调 <code>background ()</code> 和 <code>position ()</code>：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font (.largeTitle)</span><br><span class="line">    .position (x: <span class="number">150</span>, y: <span class="number">150</span>)</span><br><span class="line">    .background (<span class="type">Color</span>.green)</span><br></pre></td></tr></tbody></table></figure>
<p>这一回你会发现整个屏幕都变成绿色了。还是因为 <code>position ()</code> 要求 SwiftUI 放置一个可伸缩尺寸的 frame 在文本视图周围，这导致视图自动占满了所有的可用空间。然后我们给视图上了绿色，所以整个屏幕呈现绿色。</p>
<p>你所应有的绝大多数 modifier 都创建了新视图 —— 应用一个 <code>position</code> 或者 <code>background</code> 时，你实际上是在将现有的视图包装起来。这个机制对于我们大有用处，我们可以多次应用 modifier，比如添加多层留白和背景：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font (.largeTitle)</span><br><span class="line">    .padding ()</span><br><span class="line">    .background (<span class="type">Color</span>.green)</span><br><span class="line">    .padding ()</span><br><span class="line">    .background (<span class="type">Color</span>.blue)</span><br></pre></td></tr></tbody></table></figure>
<p>或者应用多个 shadows 以创建很深的阴影效果：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font (.largeTitle)</span><br><span class="line">    .foregroundColor (.white)</span><br><span class="line">    .shadow (color: .black, radius: <span class="number">10</span>)</span><br><span class="line">    .shadow (color: .black, radius: <span class="number">10</span>)</span><br><span class="line">    .shadow (color: .black, radius: <span class="number">10</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="4-给属性包装器添加属性观察者"><a href="#4-给属性包装器添加属性观察者" class="headerlink" title="4 给属性包装器添加属性观察者"></a>4 给属性包装器添加属性观察者</h3><p>某些情况下你可能会为属性包装器添加诸如 <code>didSet</code> 这样的属性观察者，但它不会如你预期的那样工作。</p>
<p>例如，如果你在使用滑块，希望在滑块值改变时执行某种动作，你可能会下面这样编写代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rating = <span class="number">0.0</span> {</span><br><span class="line">        <span class="keyword">didSet</span> {</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Rating changed to \(rating)"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Slider</span>(value: $rating)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但是，这个 <code>didSet</code> 属性观察者永远都不会被调用，因为属性的值是由绑定直接修改的，而不是每次创建一个新值。</p>
<p>对此，SwiftUI 原生的方式是使用 <code>onChange ()</code> modifier，如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rating = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Slider</span>(value: $rating)</span><br><span class="line">            .onChange (of: rating) { value <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Rating changed to \(value)"</span>)</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不过，我个人更喜欢一种不同的方案：我使用基于 Binding 的扩展来返回新的绑定，其中的 <code>get</code> 和 <code>set</code> 包装的值和之前一样，但是在新值得到时也会调用处理函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Binding</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onChange</span><span class="params">(<span class="keyword">_</span> handler: @escaping <span class="params">(Value)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Binding</span>&lt;<span class="type">Value</span>&gt; {</span><br><span class="line">        <span class="type">Binding</span>(</span><br><span class="line">            <span class="keyword">get</span>: { <span class="keyword">self</span>.wrappedValue },</span><br><span class="line">            <span class="keyword">set</span>: { newValue <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.wrappedValue = newValue</span><br><span class="line">                handler (newValue)</span><br><span class="line">            }</span><br><span class="line">        )</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>有了这个扩展，我们就可以把绑定的动作直接附着在滑块视图上：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rating = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Slider</span>(value: $rating.onChange (sliderChanged))</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sliderChanged</span><span class="params">(<span class="keyword">_</span> value: Double)</span></span> {</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Rating changed to \(value)"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>挑选最适合你的方案。</p>
<h3 id="5-在需要用描边框的地方使用了描形状"><a href="#5-在需要用描边框的地方使用了描形状" class="headerlink" title="5 在需要用描边框的地方使用了描形状"></a>5 在需要用描边框的地方使用了描形状</h3><p>不理解 <code>stroke ()</code> 和 <code>strokeBorder</code> 的区别是初学者常犯的错误。尝试下面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">    .stroke (<span class="type">Color</span>.red, lineWidth: <span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>注意看，你会发现圆的左边缘和右边缘怎么不见了？（译者：这里预设你是竖屏运行程序，高度大于宽高）这是因为 <code>stroke ()</code> modifier 会把描边居中对齐在形状的轮廓线上，所以一个 20 个点的红色描边会绘制 10 个点到形状的边缘线外部，10 个点在边缘线内部 —— 这就导致了你看到圆形的左右超出屏幕的现象。</p>
<p>作为对照，<code>strokeBorder ()</code> 则是把整个描边都绘制在形状内部，所以它不会放大形状的边框。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">    .strokeBorder (<span class="type">Color</span>.red, lineWidth: <span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>相比于使用 <code>strokeBorder ()</code>，使用 <code>stroke ()</code> 有一个好处是它返回的是一个新形状，而不是一个新视图。这使得你可以创建出某些本来难以实现的效果，比如给一个形状描两次边：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">    .stroke (style: <span class="type">StrokeStyle</span>(lineWidth: <span class="number">20</span>, dash: [<span class="number">10</span>]))</span><br><span class="line">    .stroke (style: <span class="type">StrokeStyle</span>(lineWidth: <span class="number">20</span>, dash: [<span class="number">10</span>]))</span><br><span class="line">    .frame (width: <span class="number">280</span>, height: <span class="number">280</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="6-Alert-和-Sheet-与可选状态的使用"><a href="#6-Alert-和-Sheet-与可选状态的使用" class="headerlink" title="6 Alert 和 Sheet 与可选状态的使用"></a>6 Alert 和 Sheet 与可选状态的使用</h3><p>当你在学习使用 sheet 和可选型的时候，很容易想到把 sheet 的展示绑定到像下面这样的 Boolean：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> selectedUser: <span class="type">User?</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> showingAlert = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Show Alert"</span>) {</span><br><span class="line">                selectedUser = <span class="type">User</span>(id: <span class="string">"@twostraws"</span>)</span><br><span class="line">                showingAlert = <span class="literal">true</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        .alert (isPresented: $showingAlert) {</span><br><span class="line">            <span class="type">Alert</span>(title: <span class="type">Text</span>(<span class="string">"Hello, \(selectedUser!.id)"</span>))</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当然，这可以正确工作 —— 而且这个方案容易理解。但是一旦你越过了初级阶段，你就应当考虑换成可选型的实现方案。这个方案去掉了 Boolean，也不必强制解包。唯一的要求是你所监听的目标需要遵循 <code>Identifiable</code>。</p>
<p>举个例子，我们可以在 <code>selectedUser</code> 发生变化的任何时候展示警告弹窗，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> selectedUser: <span class="type">User?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Show Alert"</span>) {</span><br><span class="line">                selectedUser = <span class="type">User</span>(id: <span class="string">"@twostraws"</span>)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        .alert (item: $selectedUser) { user <span class="keyword">in</span></span><br><span class="line">            <span class="type">Alert</span>(title: <span class="type">Text</span>(<span class="string">"Hello, \(user.id)"</span>))</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这会使得你的代码更加易于读写，并且避免因为强制解包可能带来的麻烦。</p>
<h3 id="7-尝试改变-SwiftUI-视图后面的东西"><a href="#7-尝试改变-SwiftUI-视图后面的东西" class="headerlink" title="7 尝试改变 SwiftUI 视图后面的东西"></a>7 尝试改变 SwiftUI 视图后面的东西</h3><p>SwiftUI 初学者最常犯的一个错误是他们常常试图去改变 SwiftUI 视图的背景。代码通常长下面这个样子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">            .background (<span class="type">Color</span>.red)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这会展示一个白色的屏幕，中间是红色背景色只匹配文本区域的文本视图。而大多数人的本意其实是想让整个屏幕的背景呈现出红色。这个时候他们会想，SwiftUI 背后究竟是什么样的 UIKit 视图呢？</p>
<p>当然，背后肯定是有一个 UIKit 视图，它由 <code>UIHostingController</code> 管理，角色类似于一个 UIKit 视图控制器。但是假如你通过 SwiftUI 试图去踏足 UIKit 的领地，你的改动很可能会让 SwiftUI 呈现出奇怪的结果，或者你甚至都没法直接改动 UIKit。</p>
<p>实际上，想到达成大多数人想要的效果，SwiftUI 里的实现方式应该是像下面这样的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .frame (maxWidth: .infinity, maxHeight: .infinity)</span><br><span class="line">    .background (<span class="type">Color</span>.red)</span><br><span class="line">    .ignoresSafeArea ()</span><br></pre></td></tr></tbody></table></figure>
<h3 id="8-动态视图的范围参数错误"><a href="#8-动态视图的范围参数错误" class="headerlink" title="8 动态视图的范围参数错误"></a>8 动态视图的范围参数错误</h3><p>有多个 SwiftUI 视图的构造器允许我们传入范围，这个事实让许多复杂视图的创建过程变得十分简单。</p>
<p>例如，假设我们想要展示一个拥有 4 个项目的列表，我们只需要这样写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rowCount = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">List</span>(<span class="number">0</span>..&lt;rowCount) { row <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Row \(row)"</span>)</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样写本身没问题，不过一旦你需要在运行时改变范围时，问题就来了。你看我已经用 <code>@State</code> 属性包装器把想要改变的行数变成可修改的，所以我们可以用一个按钮来修改它的值：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">"Add Row"</span>) {</span><br><span class="line">    rowCount += <span class="number">1</span></span><br><span class="line">}</span><br><span class="line">.padding (.top)</span><br></pre></td></tr></tbody></table></figure>
<p>运行代码，点击按钮，Xcode 调试输出会输出警告，而列表视图纹丝不动 —— 这个方案不管用。</p>
<p>问题出在你既没有为列表的参数提供 <code>Identifiable</code> 协议实现，也没有提供指定的 id 参数，以此告诉 SwiftUI 这个范围会动态变化：（译者：实际上并不是 “告诉 SwiftUI 范围会动态变化”，而是明确范围的项怎样才算变化。<code>Identifiable</code> 或者 id 参数明确了两个项之间是如何区别。能够区别开的项目才能侦测变化）。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">0</span>..&lt;rowCount, id: \.<span class="keyword">self</span>) { row <span class="keyword">in</span></span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Row \(row)"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>代码改成这样就没问题了。</p>
<hr>
<p>封面来自 <a href="https://unsplash.com/@zmachacek?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Zdeněk Macháček</a> on <a href="https://unsplash.com/s/photos/owl?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>development</tag>
        <tag>swiftui</tag>
      </tags>
  </entry>
  <entry>
    <title>在 SwiftUI 中使用 NSUserActivity</title>
    <url>/programming/use-nsuseractivity-in-swiftui/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1glu3tdup4dj318y0u0he0.jpg" alt="chewy-EV9_vVMZTcg-unsplash"></p>
<p>欢迎关注微信公众号「Swift 花园」</p>
<blockquote>
<p>译自 <a href="https://swiftui-lab.com/nsuseractivity-with-swiftui/">https://swiftui-lab.com/nsuseractivity-with-swiftui/</a></p>
</blockquote>
<blockquote>
<p>译者注：作者为了扩展他的 SwiftUI 应用去研究了 NSUserActivity，发现关于 NSUserActivity 的大量信息都已经过时了。比如，绝大多数关于 Handoff 的文章都是 Handoff 特性刚有的时候发布的，而那个时候还没有 scene 的概念，所有逻辑都是通过 application 的 delegate 处理的。之后 scene 出现了，许多代码被移到了 scene delegate，原来的 Handoff 示例也就失效了。如果你是刚开始学习 NSUserActivity，一定会感到困惑，而现在 SwiftUI 也支持用户活动，但现在又没有 scene 了，变化更大，所以作者认为需要写一篇新的文档来介绍 SwiftUI 中 NSUserActivity 的使用。</p>
</blockquote>
<p>NSUserActivity 令人费解的另一个原因是它是一个可以用来处理多个不相干功能的东西。它的各项属性只在某些情况下相关，多数情况下却是没有关联的。</p>
<p>下面是有关 NSUserActivity 的一些总结：</p>
<ul>
<li><strong>Universal Links</strong>: Universal links 是可以在关联应用或者 Safari 中打开的 URL。</li>
<li><strong>SiriKit</strong>: Siri 可以调起你的应用并且告知你它想要做什么。</li>
<li><strong>Spotlight</strong>: 定义你的应用可以做的动作，这些动作会被引入 Spotlight 的搜索结果中。</li>
<li><strong>Handoff</strong>: 即 “接力”，指一个应用可以继续另一个应用的工作，或者一台设备上的相同应用可以继续另一个设备上的应用的工作。</li>
</ul>
<p>这篇文档会提供一系列示例，逐步介绍 SwiftUI 中提供的用于处理 NSUserActivity 的方法，其中上面提到的每一种情况都会有示例。</p>
<h3 id="重要的笔记"><a href="#重要的笔记" class="headerlink" title="重要的笔记"></a>重要的笔记</h3><p>SwiftUI 中跟 NSUserActivity 有关的方法包括：<strong>onOpenURL ()</strong>, <strong>userActivity ()</strong>, <strong>onContinueUserActivity ()</strong> 和 **handlesExternalEvents ()**。注意，这些方法只有当你的应用采用的是 SwiftUI 应用生命周期时才能工作。如果你的项目还是使用 scene delegate，引入这几个方法会在控制台输出下面的消息：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Cannot use Scene methods for URL, NSUserActivity, and other External Events </span><br><span class="line">without using SwiftUI Lifecycle. Without SwiftUI Lifecycle, </span><br><span class="line">advertising and handling External Events wastes resources, and will have unpredictable results.</span><br></pre></td></tr></tbody></table></figure>
<p>个人经验，上面的消息中提到的不可预测的结果，实际上完全可以预测：所有这些方法都将被忽略。</p>
<h3 id="User-Activity-的两面"><a href="#User-Activity-的两面" class="headerlink" title="User Activity 的两面"></a>User Activity 的两面</h3><p>根据 Apple 的 <a href="https://developer.apple.com/documentation/foundation/nsuseractivity">官方文档</a>，一个用户活动（user activity）对象代表了某个应用在某个时刻的状态：</p>
<blockquote>
<p>An <strong>NSUserActivity</strong> object provides a lightweight way to capture the state of your app and put it to use later. You create user activity objects and use them to capture information about what the user was doing, such as viewing app content, editing a document, viewing a web page, or watching a video. When the system launches your app and an activity object is available, your app can use the information in that object to restore itself to an appropriate state.</p>
<p>某个 <strong>NSUserActivity</strong> 对象提供一种捕捉你的应用状态的轻量级方式。你创建 user activity 对象，并用它们来捕获用户正在做的事情的信息，比如查看应用内容，编辑文档，阅览网页，或者观看视频。当系统启动你的应用时，如果活动对象可用，你的应用可以利用对象中的信息把应用还原成合适的状态。</p>
</blockquote>
<p>理解了概念，我们就可以区分用户活动中的两个关键时刻：其一，用户活动创建（稍后说明何时、如何创建）；其二，系统决定启动或者恢复某个应用，并且为应用提供一个 NSUserActivity，以便应用展示相关的 UI。我们接下来会学习如何在应用中对用户活动做出反应。</p>
<p>注意，尽管一个应用可以有多个 scene，但某个时刻只有一个 scene 会获得用户活动。在本文中我们还将了解到获取用户活动的 scene 是如何被确定的…</p>
<hr>
<h3 id="Universal-Links"><a href="#Universal-Links" class="headerlink" title="Universal Links"></a>Universal Links</h3><h5 id="介绍-onOpenURL"><a href="#介绍-onOpenURL" class="headerlink" title="介绍 onOpenURL ()"></a>介绍 onOpenURL ()</h5><p>Universal Links 对于把应用集成到网站十分有用。建立 Universal Links 需要几个步骤，Apple 为其提供了详细的文档：<a href="https://developer.apple.com/ios/universal-links/">Universal Links</a>。</p>
<p>在 SwiftUI 中使用 <strong>NSUserActivity</strong> 的所有用法中，Universal Links 是最容易实现的。尽管 Universal Links 本质上是使用 NSUserActivity 来启动或者恢复你的应用，但假如你的应用是走 SwiftUI 应用生命周期，你却根本看不到 NSUserActivity 的踪影！</p>
<p>在 UIKit 里实现 Universal Links ，一般是在 scene delegate 里这么做：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scene</span><span class="params">(<span class="keyword">_</span> scene: UIScene, <span class="keyword">continue</span> userActivity: NSUserActivity)</span></span> {</span><br><span class="line">    <span class="keyword">if</span> userActivity.activityType == <span class="type">NSUserActivityTypeBrowsingWeb</span>  {</span><br><span class="line">        doSomethingWith (url: userActivity.webpageURL)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>但现在没有了 scene delegate，我们只需要简单地使用 <code>onOpenURL</code> 方法，它会得到 <code>URL</code> 对象，而不是 NSUserActivity 对象：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">SomeView</span>()</span><br><span class="line">            .onOpenURL { url <span class="keyword">in</span></span><br><span class="line">                doSomethingWith (url: url)</span><br><span class="line">            }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">doSomethingWith</span><span class="params">(url: URL?)</span></span> {</span><br><span class="line">        ...</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="SiriKit"><a href="#SiriKit" class="headerlink" title="SiriKit"></a>SiriKit</h3><h5 id="介绍-onContinueUserActivity"><a href="#介绍-onContinueUserActivity" class="headerlink" title="介绍 onContinueUserActivity ()"></a>介绍 onContinueUserActivity ()</h5><p>我们可以给一个应用中的特定部分定义快捷指令。在 iOS 中，这个动作可以借助 “快捷指令” 应用来实现，但我们也可以在应用内通过代码实现。UIKit 有一些专门的 UI 元素来处理这件事，但 SwiftUI 中并没有直接可用的方法，所以这一节中的例子会包含一个 UIViewControllerRepresentable，它的作用是提供一个按钮，点击这个按钮可以打开系统的模态表单，让用户创建或者编辑快捷指令。</p>
<p>一旦快捷指令创建，我们就可以调用 Siri 指令来执行它。它会启动或者恢复我们的应用，并且通过 NSUserActivity 提供用户希望我们执行的快捷指令的细节信息。SwiftUI 对此为我们提供了一个 <strong>onContinueUserActivity ()</strong></p>
<p>在下面的例子中，通过指令 “Hey Siri, show random animal” （或者某些其它的预置指令），系统会启动我们的应用并导航到某个随机的动物视图。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> Intents</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要记得把下面的声明添加到 Info.plist 文件的 NSUserActivityTypes 数组中 </span></span><br><span class="line"><span class="keyword">let</span> aType = <span class="string">"com.example.show-animal"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Animal</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> image: <span class="type">String</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> animals = [<span class="type">Animal</span>(id: <span class="number">1</span>, name: <span class="string">"Lion"</span>, image: <span class="string">"lion"</span>),</span><br><span class="line">               <span class="type">Animal</span>(id: <span class="number">2</span>, name: <span class="string">"Fox"</span>, image: <span class="string">"fox"</span>),</span><br><span class="line">               <span class="type">Animal</span>(id: <span class="number">3</span>, name: <span class="string">"Panda"</span>, image: <span class="string">"panda-bear"</span>),</span><br><span class="line">               <span class="type">Animal</span>(id: <span class="number">4</span>, name: <span class="string">"Elephant"</span>, image: <span class="string">"elephant"</span>)]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> selection: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">NavigationView</span> {</span><br><span class="line">            <span class="type">List</span>(animals) { animal <span class="keyword">in</span></span><br><span class="line">                <span class="type">NavigationLink</span>(</span><br><span class="line">                    destination: <span class="type">AnimalDetail</span>(animal: animal),</span><br><span class="line">                    tag: animal.id,</span><br><span class="line">                    selection: $selection,</span><br><span class="line">                    label: { <span class="type">AnimalRow</span>(animal: animal) })</span><br><span class="line">            }</span><br><span class="line">            .navigationTitle (<span class="string">"Animal Gallery"</span>)</span><br><span class="line">            .onContinueUserActivity (aType, perform: { userActivity <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.selection = <span class="type">Int</span>.random (<span class="keyword">in</span>: <span class="number">0</span>...(animals.<span class="built_in">count</span> - <span class="number">1</span>))</span><br><span class="line">            })</span><br><span class="line">            </span><br><span class="line">        }.navigationViewStyle (<span class="type">StackNavigationViewStyle</span>())</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnimalRow</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> animal: <span class="type">Animal</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">HStack</span> {</span><br><span class="line">            <span class="type">Image</span>(animal.image)</span><br><span class="line">                .resizable ()</span><br><span class="line">                .frame (width: <span class="number">60</span>, height: <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(animal.name)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AnimalDetail</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> showAddToSiri: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">let</span> animal: <span class="type">Animal</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> shortcut: <span class="type">INShortcut</span> = {</span><br><span class="line">        <span class="keyword">let</span> activity = <span class="type">NSUserActivity</span>(activityType: aType)</span><br><span class="line">        activity.title = <span class="string">"Display a random animal"</span></span><br><span class="line">        activity.suggestedInvocationPhrase = <span class="string">"Show Random Animal"</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">INShortcut</span>(userActivity: activity)</span><br><span class="line">    }()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">20</span>) {</span><br><span class="line">            <span class="type">Text</span>(animal.name)</span><br><span class="line">                .font (.title)</span><br><span class="line"></span><br><span class="line">            <span class="type">Image</span>(animal.image)</span><br><span class="line">                .resizable ()</span><br><span class="line">                .scaledToFit ()</span><br><span class="line">            </span><br><span class="line">            <span class="type">SiriButton</span>(shortcut: shortcut).frame (height: <span class="number">34</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>下面是用于创建快捷指令和编辑模态表单的 <strong>UIViewControllerRepresentable</strong>：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> IntentsUI</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SiriButton</span>: <span class="title">UIViewControllerRepresentable</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">let</span> shortcut: <span class="type">INShortcut</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">makeUIViewController</span><span class="params">(context: Context)</span></span> -&gt; <span class="type">SiriUIViewController</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">SiriUIViewController</span>(shortcut: shortcut)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">updateUIViewController</span><span class="params">(<span class="keyword">_</span> uiViewController: SiriUIViewController, context: Context)</span></span> {</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SiriUIViewController</span>: <span class="title">UIViewController</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> shortcut: <span class="type">INShortcut</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(shortcut: <span class="type">INShortcut</span>) {</span><br><span class="line">        <span class="keyword">self</span>.shortcut = shortcut</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(nibName: <span class="literal">nil</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init</span>?(coder: <span class="type">NSCoder</span>) {</span><br><span class="line">        <span class="built_in">fatalError</span>(<span class="string">"init (coder:) has not been implemented"</span>)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad ()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">let</span> button = <span class="type">INUIAddVoiceShortcutButton</span>(style: .blackOutline)</span><br><span class="line">        button.shortcut = shortcut</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.view.addSubview (button)</span><br><span class="line">        view.centerXAnchor.constraint (equalTo: button.centerXAnchor).isActive = <span class="literal">true</span></span><br><span class="line">        view.centerYAnchor.constraint (equalTo: button.centerYAnchor).isActive = <span class="literal">true</span></span><br><span class="line">        button.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">        button.delegate = <span class="keyword">self</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SiriUIViewController</span>: <span class="title">INUIAddVoiceShortcutButtonDelegate</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(<span class="keyword">_</span> addVoiceShortcutViewController: INUIAddVoiceShortcutViewController, <span class="keyword">for</span> addVoiceShortcutButton: INUIAddVoiceShortcutButton)</span></span> {</span><br><span class="line">        addVoiceShortcutViewController.delegate = <span class="keyword">self</span></span><br><span class="line">        addVoiceShortcutViewController.modalPresentationStyle = .formSheet</span><br><span class="line">        present (addVoiceShortcutViewController, animated: <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">present</span><span class="params">(<span class="keyword">_</span> editVoiceShortcutViewController: INUIEditVoiceShortcutViewController, <span class="keyword">for</span> addVoiceShortcutButton: INUIAddVoiceShortcutButton)</span></span> {</span><br><span class="line">        editVoiceShortcutViewController.delegate = <span class="keyword">self</span></span><br><span class="line">        editVoiceShortcutViewController.modalPresentationStyle = .formSheet</span><br><span class="line">        present (editVoiceShortcutViewController, animated: <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SiriUIViewController</span>: <span class="title">INUIAddVoiceShortcutViewControllerDelegate</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addVoiceShortcutViewController</span><span class="params">(<span class="keyword">_</span> controller: INUIAddVoiceShortcutViewController, didFinishWith voiceShortcut: INVoiceShortcut?, error: Error?)</span></span> {</span><br><span class="line">        controller.dismiss (animated: <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addVoiceShortcutViewControllerDidCancel</span><span class="params">(<span class="keyword">_</span> controller: INUIAddVoiceShortcutViewController)</span></span> {</span><br><span class="line">        controller.dismiss (animated: <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SiriUIViewController</span>: <span class="title">INUIEditVoiceShortcutViewControllerDelegate</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">editVoiceShortcutViewController</span><span class="params">(<span class="keyword">_</span> controller: INUIEditVoiceShortcutViewController, didUpdate voiceShortcut: INVoiceShortcut?, error: Error?)</span></span> {</span><br><span class="line">        controller.dismiss (animated: <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">editVoiceShortcutViewController</span><span class="params">(<span class="keyword">_</span> controller: INUIEditVoiceShortcutViewController, didDeleteVoiceShortcutWithIdentifier deletedVoiceShortcutIdentifier: UUID)</span></span> {</span><br><span class="line">        controller.dismiss (animated: <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">editVoiceShortcutViewControllerDidCancel</span><span class="params">(<span class="keyword">_</span> controller: INUIEditVoiceShortcutViewController)</span></span> {</span><br><span class="line">        controller.dismiss (animated: <span class="literal">true</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="Spotlight"><a href="#Spotlight" class="headerlink" title="Spotlight"></a>Spotlight</h3><h5 id="介绍-userActivity"><a href="#介绍-userActivity" class="headerlink" title="介绍 userActivity ()"></a>介绍 userActivity ()</h5><p>Spotlight 的搜索结果可以包含应用中的通用活动。为了让 Spotlight 学会你的活动，你需要在这些活动出现时对外发布，以便 Spotlight 发现它们。要在 SwiftUI 中发布 NSUserActivities，我们需要使用 <strong>userActivity ()</strong> modifier。</p>
<p>在下面的例子中，我们有一个售卖冰淇淋的应用。每当我们选择了某个冰淇淋尺寸，应用将对外发布冰淇淋尺寸；每当有用户搜索冰淇淋时，我们的应用将出现在搜索结果中。如果用户选择了我们的应用对于的搜索结果项，我们的应用将被调起，并且将用户带到最后公布的冰淇淋尺寸。</p>
<p>注意，系统会优化 <strong>userActivity ()</strong> 闭包的调用时机。然而不幸的是，这一点并没有文档说明。系统很聪明，知道该如何保存当前的信息，避免不停更新。在调试的时候，建议你最好在 userActivity 闭包中加入打印语句。</p>
<p>下面的例子中还包含了一个 “Forget” 按钮，这对于调试十分有帮助。它会清除掉已经发布的用户活动，以便将应用从 Spotlight 的搜索结果中移除。注意，NSUserActivity 有一个可选属性：<strong>expirationDate</strong>，如果将其置为 <code>nil</code>，则活动永远不会过期。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"><span class="keyword">import</span> Intents</span><br><span class="line"><span class="keyword">import</span> CoreSpotlight</span><br><span class="line"><span class="keyword">import</span> CoreServices</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要记得把下面的声明添加到 Info.plist 文件的 NSUserActivityTypes 数组中 </span></span><br><span class="line"><span class="keyword">let</span> aType = <span class="string">"com.example.icecream-selection"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IceCreamSize</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> price: <span class="type">Float</span></span><br><span class="line">    <span class="keyword">let</span> image: <span class="type">String</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sizes = [</span><br><span class="line">    <span class="type">IceCreamSize</span>(id: <span class="number">1</span>, name: <span class="string">"Small"</span>, price: <span class="number">1.0</span>, image: <span class="string">"small"</span>),</span><br><span class="line">    <span class="type">IceCreamSize</span>(id: <span class="number">2</span>, name: <span class="string">"Medium"</span>, price: <span class="number">1.45</span>, image: <span class="string">"medium"</span>),</span><br><span class="line">    <span class="type">IceCreamSize</span>(id: <span class="number">3</span>, name: <span class="string">"Large"</span>, price: <span class="number">1.9</span>, image: <span class="string">"large"</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> selection: <span class="type">Int?</span> = <span class="literal">nil</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">NavigationView</span> {</span><br><span class="line">            <span class="type">List</span>(sizes) { size <span class="keyword">in</span></span><br><span class="line">                <span class="type">NavigationLink</span>(destination: <span class="type">IceCreamDetail</span>(icecream: size),</span><br><span class="line">                               tag: size.id,</span><br><span class="line">                               selection: $selection,</span><br><span class="line">                               label: { <span class="type">IceCreamRow</span>(icecream: size) })</span><br><span class="line">            }</span><br><span class="line">            .navigationTitle (<span class="string">"Ice Creams"</span>)</span><br><span class="line">            .toolbar {</span><br><span class="line">                <span class="type">Button</span>(<span class="string">"Forget"</span>) {</span><br><span class="line">                    <span class="type">NSUserActivity</span>.deleteAllSavedUserActivities {</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">"done!"</span>)</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">        }</span><br><span class="line">        .onContinueUserActivity (aType, perform: { userActivity <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> icecreamId = userActivity.userInfo?[<span class="string">"sizeId"</span>] <span class="keyword">as</span>? <span class="type">NSNumber</span> {</span><br><span class="line">                selection = icecreamId.intValue</span><br><span class="line"></span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line">        .navigationViewStyle (<span class="type">StackNavigationViewStyle</span>())</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IceCreamRow</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> icecream: <span class="type">IceCreamSize</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">HStack</span> {</span><br><span class="line">            <span class="type">Image</span>(icecream.image)</span><br><span class="line">                .resizable ()</span><br><span class="line">                .frame (width: <span class="number">80</span>, height: <span class="number">80</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">VStack</span>(alignment: .leading) {</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"\(icecream.name)"</span>).font (.title).fontWeight (.bold)</span><br><span class="line">                <span class="type">Text</span>(<span class="string">"$ \(String (format: "</span>%<span class="number">0</span>.2f<span class="string">", icecream.price))"</span>).font (.subheadline)</span><br><span class="line">                <span class="type">Spacer</span>()</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IceCreamDetail</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> icecream: <span class="type">IceCreamSize</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"\(icecream.name)"</span>).font (.title).fontWeight (.bold)</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"$ \(String (format: "</span>%<span class="number">0</span>.2f<span class="string">", icecream.price))"</span>).font (.subheadline)</span><br><span class="line"></span><br><span class="line">            <span class="type">Image</span>(icecream.image)</span><br><span class="line">                .resizable ()</span><br><span class="line">                .scaledToFit ()</span><br><span class="line">            </span><br><span class="line">            <span class="type">Spacer</span>()</span><br><span class="line">        }</span><br><span class="line">        .userActivity (aType) { userActivity <span class="keyword">in</span></span><br><span class="line">            userActivity.isEligibleForSearch = <span class="literal">true</span></span><br><span class="line">            userActivity.title = <span class="string">"\(icecream.name) Ice Cream"</span></span><br><span class="line">            userActivity.userInfo = [<span class="string">"sizeId"</span>: icecream.id]</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> attributes = <span class="type">CSSearchableItemAttributeSet</span>(itemContentType: kUTTypeItem <span class="keyword">as</span> <span class="type">String</span>)</span><br><span class="line">            </span><br><span class="line">            attributes.contentDescription = <span class="string">"Get a delicious ice cream now!"</span></span><br><span class="line">            attributes.thumbnailData = <span class="type">UIImage</span>(named: icecream.image)?.pngData ()</span><br><span class="line">            userActivity.contentAttributeSet = attributes</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Advertising: \(icecream.name)"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="Handoff-接力"><a href="#Handoff-接力" class="headerlink" title="Handoff - 接力"></a>Handoff - 接力</h3><p>基于已经介绍的方法，我们可以创建一个接力应用了。这将是一个可以在另外的设备上接力工作的应用。两个设备上的应用可以是同一个应用或者不同的应用。这种情况通常发生在我们分发了应用的两个不同版本的时候：比如一个是 iOS 版本，另一个是 macOS 版本。</p>
<p>为了让接力能够工作，相关的应用都需要注册在同一个开发者团队的标识下面，并且在所有参与的应用的 Info.plist 中配置 <strong>NSUserActivityTypes</strong> 实体。</p>
<p>有关于接力的更多实现细节，可以参考 Apple 的 <a href="https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html">网站</a>。</p>
<p>下面的示例实现了一个简单的 web 浏览器，通过调用 <strong>userActivity ()</strong> 发布用户正在浏览的页面以及他在页面上滚动的位置。</p>
<p>假如用户切换到了另一个设备，当同一个应用被调起或者恢复时，<strong>onContinueUserActivity ()</strong> 闭包将被调用，应用可以借此打开同一个页面，并且滚动到他在之前设备上浏览到的页面位置。</p>
<p>用户活动可以通过 userInfo 字典的形式提供负载数据，它是我们存放特定于接力活动信息的地方。在这个示例中，即页面滚动位置（百分比）和所打开页面的 URL。此外，还包含了发布此活动的应用的 bundle id，它只是用来调试的信息，便于我们准确地知道发生的事情。</p>
<p>注意，示例的代码在 iOS 和 macOS 上都能工作，这是为了让你能够同时创建两个应用，并且测试 iOS 设备和 Mac 设备之间的接力。</p>
<p>最后，虽然跟 NSUserActivity 无关，这个示例还封装了一个 WKWebView，这是演示 javascript 事件（这个示例中的 <code>onScroll</code>）如何更新你的 SwiftUI 视图绑定的绝佳示例。完整的 WebView 代码可以从下面的 gist 文件找到：<a href="https://gist.github.com/swiftui-lab/a873bf413770db6fd1a525fa424ce8cd">WebView.swift</a></p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> SwiftUI</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要记得把下面的声明添加到 Info.plist 文件的 NSUserActivityTypes 数组中 </span></span><br><span class="line"><span class="keyword">let</span> activityType = <span class="string">"com.example.openpage"</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">StateObject</span> <span class="keyword">var</span> data = <span class="type">WebViewData</span>()</span><br><span class="line">    </span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> reload: <span class="type">Bool</span> = <span class="literal">false</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">HStack</span> {</span><br><span class="line">                <span class="type">TextField</span>(<span class="string">""</span>, text: $data.urlBar, onCommit: { <span class="keyword">self</span>.loadUrl (data.urlBar) })</span><br><span class="line">                    .textFieldStyle (<span class="type">RoundedBorderTextFieldStyle</span>())</span><br><span class="line">                    .disableAutocorrection (<span class="literal">true</span>)</span><br><span class="line">                    .modifier (<span class="type">KeyboardModifier</span>())</span><br><span class="line">                    .frame (maxWidth: .infinity)</span><br><span class="line">                    .overlay (<span class="type">ProgressView</span>().opacity (<span class="keyword">self</span>.data.loading ? <span class="number">1</span> : <span class="number">0</span>).scaleEffect (<span class="number">0.5</span>), alignment: .trailing)</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                <span class="type">Button</span>(action: {</span><br><span class="line">                    <span class="keyword">self</span>.data.scrollOnLoad = <span class="keyword">self</span>.data.scrollPercent</span><br><span class="line">                    <span class="keyword">self</span>.reload.toggle ()</span><br><span class="line">                }, label: { <span class="type">Image</span>(systemName: <span class="string">"arrow.clockwise"</span>) })</span><br><span class="line">                </span><br><span class="line">                <span class="type">Button</span>(<span class="string">"Go"</span>) {</span><br><span class="line">                    <span class="keyword">self</span>.loadUrl (data.urlBar)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            .padding (.horizontal, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">            <span class="type">Text</span>(<span class="string">"\(data.scrollPercent)"</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="type">WebView</span>(data: data)</span><br><span class="line">                .id (reload)</span><br><span class="line">                .onAppear { loadUrl (data.urlBar) }</span><br><span class="line">        }</span><br><span class="line">        .userActivity (activityType, element: data.url) { url, activity <span class="keyword">in</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">let</span> bundleid = <span class="type">Bundle</span>.main.bundleIdentifier ?? <span class="string">""</span></span><br><span class="line">            </span><br><span class="line">            activity.addUserInfoEntries (from: [<span class="string">"scrollPercent"</span>: data.scrollPercent,</span><br><span class="line">                                               <span class="string">"page"</span>: data.url?.absoluteString ?? <span class="string">""</span>,</span><br><span class="line">                                               <span class="string">"setby"</span>: bundleid])</span><br><span class="line">            </span><br><span class="line">            logUserActivity (activity, label: <span class="string">"activity"</span>)</span><br><span class="line">        }</span><br><span class="line">        .onContinueUserActivity (activityType, perform: { userActivity <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> page = userActivity.userInfo?[<span class="string">"page"</span>] <span class="keyword">as</span>? <span class="type">String</span> {</span><br><span class="line">                <span class="comment">// Load handoff page</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.data.url?.absoluteString != page {</span><br><span class="line">                    <span class="keyword">self</span>.data.url = <span class="type">URL</span>(string: page)</span><br><span class="line">                }</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Restore handoff scroll position</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> scrollPercent = userActivity.userInfo?[<span class="string">"scrollPercent"</span>] <span class="keyword">as</span>? <span class="type">Float</span> {</span><br><span class="line">                    <span class="keyword">self</span>.data.scrollOnLoad = scrollPercent</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            </span><br><span class="line">            logUserActivity (userActivity, label: <span class="string">"on activity"</span>)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">loadUrl</span><span class="params">(<span class="keyword">_</span> string: String)</span></span> {</span><br><span class="line">        <span class="keyword">if</span> string.hasPrefix (<span class="string">"http"</span>) {</span><br><span class="line">            <span class="keyword">self</span>.data.url = <span class="type">URL</span>(string: string)</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">self</span>.data.url = <span class="type">URL</span>(string: <span class="string">"https://"</span> + string)</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.data.urlBar = <span class="keyword">self</span>.data.url?.absoluteString ?? string</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">logUserActivity</span><span class="params">(<span class="keyword">_</span> activity: NSUserActivity, label: String = <span class="string">""</span>)</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(label) TYPE = \(activity.activityType)"</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(label) INFO = \(activity.userInfo ?? [:])"</span>)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">KeyboardModifier</span>: <span class="title">ViewModifier</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">body</span><span class="params">(content: Content)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="keyword">#if</span> os (iOS)</span><br><span class="line">            <span class="keyword">return</span> content</span><br><span class="line">                .keyboardType (.<span class="type">URL</span>)</span><br><span class="line">                .textContentType (.<span class="type">URL</span>)</span><br><span class="line">        <span class="keyword">#else</span></span><br><span class="line">            <span class="keyword">return</span> content</span><br><span class="line">        <span class="keyword">#endif</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="Scene-选择"><a href="#Scene-选择" class="headerlink" title="Scene 选择"></a>Scene 选择</h3><h5 id="介绍-handlesExternalEvents"><a href="#介绍-handlesExternalEvents" class="headerlink" title="介绍 handlesExternalEvents ()"></a>介绍 handlesExternalEvents ()</h5><p>当系统启动或者恢复我们的应用的时候，它必须确定哪个 scene 能够接受到用户活动（某一个时刻只有一个能接收到）。为了帮助它做出这个决策，我们的应用可以用上 <strong>handlesExternalEvents ()</strong> 方法。不幸运是，写这篇文档的时候 (Xcode 12, beta 6)，这个方法貌似不起作用，而且 macOS 上虽然有支持，但缺少平台定义文件。</p>
<p>所以我这里将通过注释来说明它的工作方式，等将来真正可用时，我会更新这篇文章。</p>
<p>这个方法有两个版本。一个用于 WindowGroup 场景：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlesExternalEvents</span><span class="params">(matching conditions: Set&lt;String&gt;)</span></span> -&gt; <span class="keyword">some</span> <span class="type">Scene</span></span><br></pre></td></tr></tbody></table></figure>
<p>另一个用于视图：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handlesExternalEvents</span><span class="params">(preferring: Set&lt;String&gt;, allowing: Set&lt;String&gt;)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span></span><br></pre></td></tr></tbody></table></figure>
<p>两种版本中我们都会指定一个字符串 <code>Set</code>，系统用它来跟 NSUserActivity 的 <strong>targetContentIdentifier</strong> 属性做比对。假如找到匹配项，对应的 scene 会被选用。如果不指定这个 <code>Set</code>，或者没有找到匹配项，则实际行为由具体平台决定。例如，在 iPadOS 上会选择一个已经现有的 scene，而在 macOS 上，新的 scene 会被创建。</p>
<p>在只支持一个 scene 的系统上，这个方法将被忽略。</p>
<p>注意，<strong>targetContentIdentifier</strong> 在 <strong>UNNotificationContent</strong> 和 <strong>UIApplicationShortcutItem</strong> 中也有提供，因此 <strong>handlesExternalEvents ()</strong> 大概率也会支持它们。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Apple 关于 NSUserActivity 的文档资料非常多，所以我建议你去查阅这些文档。但目前 缺少 SwiftUI 的示例。这篇文章的目的就是为你提供一些在 SwiftUI 中实践 NSUserActivity 的启动代码。</p>
<hr>
<p>封面来自 <a href="https://unsplash.com/@chewy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Chewy</a> on <a href="https://unsplash.com/s/photos/nature?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText">Unsplash</a></p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>SwiftUI</tag>
        <tag>iOS 开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift 5.3 新特性</title>
    <url>/programming/whats-new-in-swift-5-3/</url>
    <content><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggwdc1o5lmj315o0rswg0.jpg" alt="swift-evolution-4"></p>
<p>欢迎关注微信公众号「Swift 花园」</p>
<p>Swift 5.3 有不少变化，这其中包括多模式 catch 语句，多拖尾闭包，以及 Swift Package Manager 的一些重要改变。</p>
<p>本文会带你浏览一些主要的变化，同时提供参考代码，以便你可以自行尝试。以下是要介绍的新特性的清单：</p>
<ul>
<li>多模式 catch 语句</li>
<li>多拖尾闭包</li>
<li>为枚举自动生成的 Comparable 实现</li>
<li>self. 书写省略</li>
<li>基于类型的程序入口</li>
<li>基于上下文泛型声明的 <code>where</code> 语句</li>
<li>枚举的 cases 可以作为 protocol witnesses</li>
<li>重新提炼的 <code>didSet</code> 语义</li>
<li>新的 Float16 类型</li>
<li>Swift Package Manager 支持二进制依赖，资源等更多类型</li>
</ul>
<h3 id="多模式-catch-语句"><a href="#多模式-catch-语句" class="headerlink" title="多模式 catch 语句"></a>多模式 catch 语句</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0276-multi-pattern-catch-clauses.md">SE-0276</a> 引入了一个可以在单个 <code>catch</code> 块中捕获多个错误 case 的特性，这能让我们免除错误处理时的重复代码。</p>
<p>例如，下面的代码用枚举定义了错误的两种情况：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">TemperatureError</span>: <span class="title">Error</span> </span>{</span><br><span class="line">    <span class="keyword">case</span> tooCold, tooHot</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当我们读取到温度时，既可以抛出两种错误中的某一个，也可以返回 “OK”：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getReactorTemperature</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="number">90</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkReactorOperational</span><span class="params">()</span></span> <span class="keyword">throws</span> -&gt; <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">let</span> temp = getReactorTemperature ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> temp &lt; <span class="number">10</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">TemperatureError</span>.tooCold</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> temp &gt; <span class="number">90</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="type">TemperatureError</span>.tooHot</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在捕获错误的环节，SE-0276 允许我们用逗号分隔来表示我们要以相同方式处理  <code>tooHot</code> 和 <code>tooCold</code>。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">try</span> checkReactorOperational ()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 结果: \(result)"</span>)</span><br><span class="line">} <span class="keyword">catch</span> <span class="type">TemperatureError</span>.tooHot, <span class="type">TemperatureError</span>.tooCold {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 关闭反应堆 &amp; quot;</span>)</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 未知错误 &amp; quot;</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>处理的 case 可以是任意数量的。</p>
<h3 id="多拖尾闭包"><a href="#多拖尾闭包" class="headerlink" title="多拖尾闭包"></a>多拖尾闭包</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0279-multiple-trailing-closures.md">SE-0279</a> 引入了多拖尾闭包，这使得调用包含多个闭包的函数可以更简单地实现。</p>
<p>这个特性在 SwiftUI 中非常受欢迎。原来形如下面这样的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OldContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> showOptions = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: {</span><br><span class="line">            <span class="keyword">self</span>.showOptions.toggle ()</span><br><span class="line">        }) {</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"gear"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>可以被改写成：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> showOptions = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span> {</span><br><span class="line">            <span class="keyword">self</span>.showOptions.toggle ()</span><br><span class="line">        } label: {</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"gear"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>理论上并不要求 <code>label:</code> 要跟在前一个闭包的 <code>}</code> 后面，所以你甚至可以像下面这样书写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BadContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> showOptions = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span> {</span><br><span class="line">            <span class="keyword">self</span>.showOptions.toggle ()</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        label: {</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"gear"</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不过，我会建议你当心代码的可读性 —— 像上面的 <code>label</code> 那样的代码块，在 Swift 里看起来更像是标签化的代码块，而不是 <code>Button</code> 构造器的第二个参数。</p>
<p>** 注：** 有关 Swift 的多拖尾闭包特性的讨论非常热烈。我想提醒大家的是，像这种类型的语法变动一开始看起来可能会有点别扭，我们需要耐心，给它时间，在实践中体会它带来的结果。</p>
<h3 id="为枚举自动生成的-Comparable-实现"><a href="#为枚举自动生成的-Comparable-实现" class="headerlink" title="为枚举自动生成的 Comparable 实现"></a>为枚举自动生成的 Comparable 实现</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0266-synthesized-comparable-for-enumerations.md">SE-0266</a> 使得我们可以为枚举生成 <code>Comparable</code> 实现，同时不要求我们声明关联值，或者要求关联值本身必须是 <code>Comparable</code> 的。这个特性让我们可以在同类型的枚举之间用 <code>&lt;</code>，<code>&gt;</code> 和类似的比较操作符来进行比较。</p>
<p>例如，假设我们有一个枚举，它描述了衣服的尺寸，我们可以要求 Swift 为它自动生成 <code>Comparable</code> 实现，代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Size</span>: <span class="title">Comparable</span> </span>{</span><br><span class="line">    <span class="keyword">case</span> small</span><br><span class="line">    <span class="keyword">case</span> medium</span><br><span class="line">    <span class="keyword">case</span> large</span><br><span class="line">    <span class="keyword">case</span> extraLarge</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们就可以创建两个这个枚举的实例，并且用 <code>&lt;</code> 进行比较：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shirtSize = <span class="type">Size</span>.small</span><br><span class="line"><span class="keyword">let</span> personSize = <span class="type">Size</span>.large</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> shirtSize &lt; personSize {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"T 恤 太小了！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>自动生成的实现，也能很好地适应枚举的 <code>Comparable</code> 关联值。例如，假设我们有一个枚举，描述了某个队伍获取世界杯冠军的次数，代码可以这样实现：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">WorldCupResult</span>: <span class="title">Comparable</span> </span>{</span><br><span class="line">    <span class="keyword">case</span> neverWon</span><br><span class="line">    <span class="keyword">case</span> winner (stars: <span class="type">Int</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们用不同的值来创建枚举的不同实例，并且让 Swift 对它们进行排序：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> americanMen = <span class="type">WorldCupResult</span>.neverWon</span><br><span class="line"><span class="keyword">let</span> americanWomen = <span class="type">WorldCupResult</span>.winner (stars: <span class="number">4</span>)</span><br><span class="line"><span class="keyword">let</span> japaneseMen = <span class="type">WorldCupResult</span>.neverWon</span><br><span class="line"><span class="keyword">let</span> japaneseWomen = <span class="type">WorldCupResult</span>.winner (stars: <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams = [americanMen, americanWomen, japaneseMen, japaneseWomen]</span><br><span class="line"><span class="keyword">let</span> sortedByWins = teams.sorted ()</span><br><span class="line"><span class="built_in">print</span>(sortedByWins)</span><br></pre></td></tr></tbody></table></figure>
<p>排序过程会把未获得世界杯冠军的队伍放在前面，然后是日本女子队，再然后是美国女子队 —— 两组 <code>winner</code> 的队被认为是大于两组 <code>neverWon</code> 的队，而 <code>winner (stars: 4)</code> 被认为是大于 <code>winner (stars: 1)</code>。</p>
<h3 id="self-书写省略"><a href="#self-书写省略" class="headerlink" title="self. 书写省略"></a>self. 书写省略</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0269-implicit-self-explicit-capture.md">SE-0269</a> 使得我们可以在一些不必要的地方省略 <code>self</code> 。在这个改变之前，我们需要在所有的闭包当中对引用 <code>self</code> 的属性或者方法冠以 <code>self.</code>，以便显式地明确语义。但有的时候由于闭包不可能产生引用循环，<code>self</code> 是多余的。</p>
<p>例如，之前我们需要把代码写成下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OldContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">List</span>(<span class="number">1</span>..&lt;<span class="number">5</span>) { number <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">self</span>.cell (<span class="keyword">for</span>: number)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cell</span><span class="params">(<span class="keyword">for</span> number: Int)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Cell \(number)"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对 <code>self.cell (for:)</code> 的调用不会产生引用循环，因为它是在结构体内使用。多亏了 SE-0269，上面的代码现在可以免去 <code>self.</code>：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewContentView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">List</span>(<span class="number">1</span>..&lt;<span class="number">5</span>) { number <span class="keyword">in</span></span><br><span class="line">            cell (<span class="keyword">for</span>: number)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">cell</span><span class="params">(<span class="keyword">for</span> number: Int)</span></span> -&gt; <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Cell \(number)"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这个特性对于大量使用闭包的框架非常有用，包括 SwiftUI 和 Combine。</p>
<h3 id="基于类型的程序入口"><a href="#基于类型的程序入口" class="headerlink" title="基于类型的程序入口"></a>基于类型的程序入口</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0281-main-attribute.md">SE-0281</a> 引入了一个新的 <code>@main</code> 属性，它可以让我们声明程序的入口。这个特性使得我们可以精确地控制程序启动时要执行的代码，对于命令行程序尤其有帮助。</p>
<p>例如，当我们创建一个终端应用时，我们必须创建一个叫 main.swift 的文件，然后把启动代码放在里面：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OldApp</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Running!"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="type">OldApp</span>()</span><br><span class="line">app.run ()</span><br></pre></td></tr></tbody></table></figure>
<p>Swift 会自动把 main.swift 看作最顶层的代码，创建 <code>App</code> 实例并且运行。即便在 SE-0281 之后这个做法都一直被延续，但现在你可以干掉 main.swift 了，转而使用 <code>@main</code> 属性来标记某个包含静态 <code>main</code> 方法的结构体或者类，让它充当程序入口：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@main</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewApp</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Running!"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码所在的程序运行时，Swift 会自动调用 <code>NewApp.main ()</code> 来启动程序流程。</p>
<p>新的 <code>@main</code> 属性对于 UIKit 和 AppKit 开发者来说可能有点属性，因为我们正是用 <code>@UIApplicationMain</code> 和 <code>@NSApplicationMain</code> 来标记 app 代理的。</p>
<p>不过，使用 <code>@main</code> 的时候有一些注意事项：</p>
<ul>
<li>已经有 main.swift 文件的 app 不能使用这个属性</li>
<li>不能有一个以上的 <code>@main</code> 属性</li>
<li><code>@main</code> 属性只能用在最顶层的类型上 —— 这个类型不继承自任何其他类</li>
</ul>
<h3 id="基于上下文泛型声明的-where-语句"><a href="#基于上下文泛型声明的-where-语句" class="headerlink" title="基于上下文泛型声明的 where 语句"></a>基于上下文泛型声明的 <code>where</code> 语句</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0267-where-on-contextually-generic.md">SE-0267</a> 引入一个新特性，你可以给泛型类型或者扩展添加带有 <code>where</code> 语句限定的函数。</p>
<p>例如，我们创建了一个简单的 <code>Stack</code>，可以压栈，出栈元素：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> array = [<span class="type">Element</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(<span class="keyword">_</span> obj: Element)</span></span> {</span><br><span class="line">        array.append (obj)</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> {</span><br><span class="line">        array.popLast ()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>借助 SE-0267，我们现在可以添加一个 <code>sorted ()</code> 方法给这个 <code>Stack</code>，并且要求这个方法只有在 <code>Stack</code> 的泛型参数 <code>Element</code> 遵循 <code>Comparable</code> 协议的时候才能使用：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Stack</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sorted</span><span class="params">()</span></span> -&gt; [<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> {</span><br><span class="line">        array.sorted ()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="枚举的-cases-可以作为-protocol-witnesses"><a href="#枚举的-cases-可以作为-protocol-witnesses" class="headerlink" title="枚举的 cases 可以作为 protocol witnesses"></a>枚举的 cases 可以作为 protocol witnesses</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0280-enum-cases-as-protocol-witnesses.md">SE-0280</a> 使得枚举可以参与 protocol witness matching，这是一种表述我们可以更容易地匹配协议要求的技术方式。</p>
<p>例如，你可以编写代码处理各种类型的数据，但是假如数据不见了怎么办呢？当然，你可以借助空合运算符，每次都提供一个默认值。不过。你可以借助协议来要求默认值，然后让各种类型遵循这个协议：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Defaultable</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue: <span class="type">Self</span> { <span class="keyword">get</span> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让整数有默认值 0</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span>: <span class="title">Defaultable</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue: <span class="type">Int</span> { <span class="number">0</span> }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让数组有默认值空数组 </span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Array</span>: <span class="title">Defaultable</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue: <span class="type">Array</span> { [] }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让字典有默认值空字典 </span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Dictionary</span>: <span class="title">Defaultable</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue: <span class="type">Dictionary</span> { [:] }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>SE-0280 使得我们能对枚举做出一样的控制。比如，你有一个 <code>padding</code> 枚举，它能接收像素值，厘米值，或者是系统的默认值：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Padding</span>: <span class="title">Defaultable</span> </span>{</span><br><span class="line">    <span class="keyword">case</span> pixels (<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> cm (<span class="type">Int</span>)</span><br><span class="line">    <span class="keyword">case</span> defaultValue</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样的代码在 SE-0280 之前是无法实现的 —— Swift 会抱怨 <code>Padding</code> 不满足协议。但是，如果你仔细琢磨一下，协议其实是满足的：我们需要一个静态的 <code>defaultValue</code>，它返回 <code>Self</code>，换言之，就是某个遵循协议的具体类型，而这正是 <code>Padding.defaultValue</code> 提供的。</p>
<h3 id="重新提炼的-didSet-语义"><a href="#重新提炼的-didSet-语义" class="headerlink" title="重新提炼的 didSet 语义"></a>重新提炼的 <code>didSet</code> 语义</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0268-didset-semantics.md">SE-0268</a> 调整了 <code>didSet</code> 属性观察者的工作方式，以便它们能更高效地工作。对于这个优化你不需要改动任何代码，自动获得一个小小的性能提升。</p>
<p>在内部，Swift 做出的改变是在设置新值时不再查询旧值。如果你不使用旧值，也没有设置 <code>willSet</code>，Swift 会即时修改数值。</p>
<p>假如你需要用到旧值，只需要引用 <code>oldValue</code> 即可，方式如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">didSet</span> {</span><br><span class="line">    <span class="keyword">_</span> = oldValue</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="新的-Float16-类型"><a href="#新的-Float16-类型" class="headerlink" title="新的 Float16 类型"></a>新的 Float16 类型</h3><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0277-float16.md">SE-0277</a> 引入了一个新的半精度浮点类型，<code>Float16</code>。这个精度在图像编程和机器学习中十分常见。</p>
<p>新类型和 Swift 原来的其他类型相似：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> first: <span class="type">Float16</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">let</span> second: <span class="type">Float32</span> = <span class="number">11</span></span><br><span class="line"><span class="keyword">let</span> third: <span class="type">Float64</span> = <span class="number">7</span></span><br><span class="line"><span class="keyword">let</span> fourth: <span class="type">Float80</span> = <span class="number">13</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="Swift-Package-Manager-支持二进制依赖，资源等更多类型"><a href="#Swift-Package-Manager-支持二进制依赖，资源等更多类型" class="headerlink" title="Swift Package Manager 支持二进制依赖，资源等更多类型"></a>Swift Package Manager 支持二进制依赖，资源等更多类型</h3><p>Swift 5.3 为 Swift Package Manager (SPM) 带来了很多提升，恕我不能在这里一一举例。不过我们可以讨论一下 SPM 有哪些变化以及为什么会有这些变化。 </p>
<p>首先，<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0271-package-manager-resources.md">SE-0271</a> (Package Manager Resources) 使得 SPM 能包含诸如图片，音频，JSON 等类型的资源。这个机制可不只是把文件拷进最终的 app bundle 这么简单 —— 举个例子，我们可以应用一个自定义处理步骤到我们的 assets，比如为 iOS 优化图片。为此，新增的 <code>Bundle.module</code> 属性就是用来在运行时访问这些 assets 的。<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0278-package-manager-localized-resources.md">SE-0278</a> (Package Manager Localized Resources) 进一步支持了资源的本地化版本，例如提供适用某个国家的图片。</p>
<p>其次，<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0272-swiftpm-binary-dependencies.md">SE-0272</a> (Package Manager Binary Dependencies) 使得 SPM 可以使用二进制包。这意味着像 Firebase 这样的闭源 SDK 现在也可以通过 SPM 集成了。</p>
<p>再次，<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0273-swiftpm-conditional-target-dependencies.md">SE-0273</a> (Package Manager Conditional Target Dependencies) 可以让我们指定为特定平台和配置使用依赖。例如，我们可能在为 Linux 平台编译时，额外需要某些特定的框架，或者我们在本地测试的时候需要一些依赖调试用的框架。</p>
<p>值得一提的是，SE-0271 的 “Future Directions” 一节中提到了对资源的安全访问 —— 这意味着像 <code>Image ("avatar")</code> 这样的代码之后会变成 <code>Image (module.avatar)</code> 。</p>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Tech | How to implement a ‘sacrifice’ skill - take bullets for companion 🐺🐺🐺</title>
    <url>/unity-portfolio/tfaces-game-match-hero-progress-daily-20200310/</url>
    <content><![CDATA[<p>In our latest game development, I implemented an interesting action: “jumping block”.</p>
<p>The team used this skill on the white wolf guard.  The specific skill is called “sacrifice”. 🤨</p>
<blockquote>
<p>Whenever the wolf leader around him receives deadly ballistic damage, the heroic white wolf guard will take a deep leap and block this damage for his boss.</p>
</blockquote>
<p>Here is the video demonstration on Youtube:</p>
<video src="https://www.youtube.com/watch?v=LCN8_GVhync" type="video/mp4" controls="controls" width="100%" height="100%">
</video>


<p>And here is the schematic diagram:</p>
<p><img src="/images/ward fellow by take a bullet for them.png" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>The realization of the jumping block is very interesting 🤪. It is a combination of mathematics and physics.</p>
<p>Let’s skip the unimportant part and look directly at the most critical code:</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A callback invoked when we find a particle(i.e. our bullet) is flying toward something</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="collisionInstance"&gt;</span>a manager contains information about the particle<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="estimatedArrival"&gt;</span>estimated time of flight<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">OnParticleHeadingToTarget</span>(<span class="params">ParticleCollisionInstance collisionInstance, <span class="keyword">float</span> estimatedArrival</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Check if the bullet is flying toward our fellow</span></span><br><span class="line">    <span class="keyword">if</span> (collisionInstance != <span class="literal">null</span> &amp;&amp; collisionInstance.HeadingTarget == wolfFellow.gameObject)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Calculate which point should I jump in order to take the bullet for my fellow</span></span><br><span class="line">        jumpSpot = collisionInstance.EvaluateNecessaryArrival(<span class="number">4f</span>, <span class="keyword">out</span> <span class="keyword">float</span> time);</span><br><span class="line">        <span class="comment">// of course, you should look at the bullet when you try to take it.</span></span><br><span class="line">        lookSpot = collisionInstance.gameObject.transform.position;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Every creature has its react time when something happens</span></span><br><span class="line">        <span class="keyword">float</span> reactTime = (_dollAction <span class="keyword">as</span> WolfDollAction).WardJumpToApexDuration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reactTime &lt;= time)</span><br><span class="line">        {</span><br><span class="line">            Invoke(<span class="keyword">nameof</span>(WardFellow), time - reactTime);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Ward fellow, for wolf guard, warding is implemented by jump to take bullet for fellow</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WardFellow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WolfDollAction wolfAction = _dollAction <span class="keyword">as</span> WolfDollAction;</span><br><span class="line"></span><br><span class="line">    wolfAction.TriggerJumpWard(wolfFellow, jumpSpot, lookSpot);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>the mathematical part, <code>EvaluateNecessaryArrival</code>：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Evaluate necessary arrival which we must pass through</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="distanceToHeadingTarget"&gt;</span>distance for the arrival to the target<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="estimatedTime"&gt;</span>out parameter, a estimated time by when we arrive<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>the vector of the must-pass arrival<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">EvaluateNecessaryArrival</span>(<span class="params"><span class="keyword">float</span> distanceToHeadingTarget, <span class="keyword">out</span> <span class="keyword">float</span> estimatedTime</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Target</span></span><br><span class="line">    <span class="keyword">var</span> heading = HeadingTargetSpot - transform.position;</span><br><span class="line">    <span class="comment">// Distance</span></span><br><span class="line">    <span class="keyword">var</span> currentDistance = heading.magnitude;</span><br><span class="line">    <span class="comment">// Direction</span></span><br><span class="line">    <span class="keyword">var</span> direction = heading / currentDistance;</span><br><span class="line"></span><br><span class="line">    Vector3 arrival = HeadingTargetSpot + direction * -distanceToHeadingTarget;</span><br><span class="line">    estimatedTime = (currentDistance - distanceToHeadingTarget) / MainFlyingParticleVelocity.magnitude;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrival;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>It’s not that difficult, right? 🙊  Hoping you enjoy this skill. 😬</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>unity-portfolio</category>
      </categories>
      <tags>
        <tag>programming</tag>
        <tag>unity</tag>
        <tag>portfolio</tag>
      </tags>
  </entry>
  <entry>
    <title>用 “流水线” 设计拆解复杂处理流程</title>
    <url>/development/programming-use-pipeline-to-tackle-complexity/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<blockquote>
<p>建议横屏阅读代码</p>
</blockquote>
<ul>
<li>本文的主要价值：提供一种抽象复杂逻辑，达成功能复用的思路</li>
<li>关键词：语义提炼、动态具名</li>
<li>本文约 4000 字，建议阅读时间 12 分钟。</li>
</ul>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在软件开发中，我们常常会遇到一种场景：随着产品功能的扩展，出现了多个具备高度相似性的功能单元。作为功能单元，它们可能有着相似的交互逻辑，提供同类的输入数据和输出数据。并且，对于用户来说，它们都在处理同一个的东西。</p>
<p>举个例子，比如一款修图 app ，它包含了一组编辑功能，每个功能都作用于一张图片，处理之后的图片，还可以作为其他功能的输入。作为编辑工具，在每个功能内部，可能还需要支持撤销和重做这样的用户操作。我们容易想到的是，这些功能间存在着许多可以进行复用设计的代码。</p>
<p>本文基于一次回顾发起，出于记录和分享的目的：一次代码重构，一款之前我参与开发的图像处理应用。</p>
<hr>
<h1 id="重构的具体背景"><a href="#重构的具体背景" class="headerlink" title="重构的具体背景"></a>重构的具体背景</h1><p>请看下面这幅图：</p>
<p><img src="/images/black_box.png" alt="某个图像功能模块的结构图"></p>
<p>元素不多，让我解释一下。图中的 “__内存图像管理 + 效果处理__” 是一个 “__黑盒子__”。“逻辑黑盒” 有的时候是好事，有的时候是坏事。那这里的黑盒子算好事还是坏事呢？ 既然对这种设计做了重构，多半是有痛点了。这里，我们重点探讨一下它的负面效应。 </p>
<p>在具体业务场景下，这个黑盒子有两个问题：</p>
<ul>
<li>图像处理接口粒度太大，难以复用代码；</li>
<li>图像 <strong>管理</strong> 和图像 <strong>效果处理</strong> 被绑定在一起。使得外部难以灵活的接触和使用图像。强调一下，管理和效果处理是两件事。前者是站在用户的角度，后者是站在服务提供者的角度。更高层应用逻辑的开发者，对于更底层支撑 API 的开发者来说，也是用户。</li>
</ul>
<h1 id="“管道”-概念的提炼"><a href="#“管道”-概念的提炼" class="headerlink" title="“管道” 概念的提炼"></a>“管道” 概念的提炼</h1><p>黑盒子的两个问题在重构时都得到了解决，但第一个问题与本文要分享的设计思想关联不大，不做展开。</p>
<p>为了说明我们是如何解决第二个问题的，这里先引入两个概念：“__流水线__” 和 “__例程__”。相信对于从事编程类工作的读者来说，这两个词不会陌生。</p>
<blockquote>
<p><strong>流水线</strong>  pipeline，[计] 又称管道，管线。<br><strong>例程</strong>  routine，[计] 程序；日常工作；例行公事</p>
</blockquote>
<p>在我们的案例中，<code>Pipeline</code> 相当于内存中的图像状态机，提供了基本的图像管理功能，例如加入图像，删除图像，复制图像，移动图像，等等。<code>Routine</code> 相当于各个图像功能单元中的通用事务，比如说，对于每个图像功能单元，都需要在其开始运作时从某处获得一份初始的图像，并在其结束运作时输出一份 <strong><em>最终的</em></strong> 图像到另一处。我们还约定，<code>Routine</code> 中的事务会基于 <code>Pipeline</code> 来完成。可以具体解释成这样：每个 <code>Routine</code> 都会包含一组典型的图像处理动作，这些处理动作借助一个或者多个 <code>Pipeline</code> 的通用操作，以及每个 <code>Pipeline</code> 的差异化操作来完成（后面会具体说明这个 ___差异化的图像处理步骤___）。</p>
<p>从这里开始，我们不妨把 “__流水线__” 的叫法直接替换成 “__管道__”，因为后面会用到一些比喻性的描述，我个人它们觉得基于 “管道” 一词衍生出来，会比用 “流水线” 来得更自然。接下来，我们对 “管道” 这个意象再做进一步的挖掘，可以设计出下面这些对应关系（表格中左侧的概念只是一种比喻，读者可自行体会，这里不会详细解读）</p>
<table>
<thead>
<tr>
<th>比喻</th>
<th>原对象</th>
</tr>
</thead>
<tbody><tr>
<td>“管道”</td>
<td>图像状态机</td>
</tr>
<tr>
<td>“流体”</td>
<td>图像</td>
</tr>
<tr>
<td>“节点”</td>
<td>图像状态</td>
</tr>
<tr>
<td>“流动”</td>
<td>图像状态流转</td>
</tr>
<tr>
<td>“锋面”(流体的最前端)</td>
<td>当前正在处理的图像状态</td>
</tr>
<tr>
<td>“连通性”</td>
<td>状态机内的图像以及图像状态机之间都是可串联的</td>
</tr>
</tbody></table>
<p>“流体” 是一个名词，它对应的是图像，涉及到存储模型。根据 “流体” 的特性，我们可以想象，或者说推断，管道里的图像存储模型应该会被设计为平行结构。</p>
<p>请读者联想一个类比， &lt;__化妆 / 整容  VS  软件上美化照片上的人脸__&gt; ，再思考一下，两者在存储模型和工序这两个方面有什么异同？ </p>
<p>回到正题，我配了五幅图来描述管道在具体实现中的五个特性：</p>
<ol>
<li>“流体” 由一系列 “节点” 组成。“节点”，即图像的状态，它的含义构成了我们对某一个图像的本征性认知。通俗地讲，图像状态能够帮助我们在特定的场景下把不同的图像区分开来。举个例子，有协同开发的两位程序员，对于 “美颜” 和 “滤镜” 这两个步骤的认知达成了共识。于是，我们就可以建立两个节点：“美颜”、“滤镜”，然后在开发过程中使用这两个节点来 <em>协作</em> 。注意，图像状态不是图像本身。对于图像状态的代码实现，我们可以使用一个极轻量的数据结构 —— 字符串。它体现的是 __占位符思想__，而我想要强调占位符的三个重要好处：它们是 __可预见的__（基于认知共识）、__可预置的__（很轻量）、__可固化的__（可复用代码的一个内在要求）。</li>
</ol>
<p><img src="/images/nodes.png" alt="节点及同位节点"></p>
<ol start="2">
<li>“管道” 通过衔接 “节点” 构成 “连通”。在 “节点” 中，有必要特别介绍的是 “同位节点”。它指的是：几个步骤在 <strong>同一个图像</strong> 上先后发生。在时间上有先后，但在空间上始终操作同一份存储。我后面会再用到这个描述。</li>
</ol>
<p><img src="/images/connectivity.png" alt="连通性"></p>
<ol start="3">
<li><p>“流动” 的 “流体” 会有一个 <strong>最前部</strong> ，就好像水流的最前端，又称为 “锋面” (Waterfront)，对应着这样一个事实：“管道” 中所有的图像，在同一时间里，只会有 <strong>唯一的</strong> 图像处于 <strong>可操作</strong> 的状态，这个状态代表着 <strong>图像的变化趋势</strong> 。具体到代码实现，可能会是一组带有 * 同步关键字 * 的方法，加上一个唯一的指向当前状态的指针。我们通过 <strong>引导</strong> 和 <strong>操刀</strong> 这个趋势，把图像 “引向” 最终要呈现出来的样子。在图示中，我有意使用了绿色代表原始的、最初的，使用红色代表成熟的、完全体的。<code>Pipeline</code> 专注于做一件事：把图像从一种状态转化为另外一种状态。这期间，可能要经历多个 “节点”，而 “锋面” 的意义就在于，它保证了一件事。那就是 <code>Pipeline</code> 的操刀者可以确信，这一刻只有他自己在引导图像的 “流向”，没有人会干扰到他。</p>
<p><img src="/images/waterfront.png" alt="锋面"></p>
</li>
<li><p>“流动” 可以是双向的（相比生产车间的 “流水线”，“管道” 之所以更贴切，在于后者可以实现双向的流动，对应到图像，相当于实现反向编辑，或者说撤销到一个处理步骤之前的状态）</p>
</li>
<li><p>“流体” 如果 “分流”，则可以出现多个 “锋面”，对应着图像的 <strong>并行处理</strong> 。</p>
<p><img src="/images/shunt.png" alt="分流"></p>
</li>
</ol>
<h1 id="“管道”-的具体实现"><a href="#“管道”-的具体实现" class="headerlink" title="“管道” 的具体实现"></a>“管道” 的具体实现</h1><p>如前所述，“流体” 其实就是图像，简单封装即可。我们主要实现的是 “__节点__”、“__锋面__”、 “__流动__” 和 “__连通__”。</p>
<h2 id="节点的实现方案和意义"><a href="#节点的实现方案和意义" class="headerlink" title="节点的实现方案和意义"></a>节点的实现方案和意义</h2><p>我们先来看一种典型的图像处理过程中可能会采用的写法，代码为 swift 实现：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 图像 xyz</span></span><br><span class="line"><span class="keyword">var</span> xyz: <span class="type">MyImage</span></span><br><span class="line"><span class="comment">// 图像 ijk</span></span><br><span class="line"><span class="keyword">var</span> ijk: <span class="type">MyImage</span></span><br><span class="line"><span class="comment">// 图像 abc </span></span><br><span class="line"><span class="keyword">var</span> abc: <span class="type">MyImage</span></span><br></pre></td></tr></tbody></table></figure>
<p>当然，现代编程语言的语法特性，可以让你省去写各种 getter/setter 的样板代码，从而节省代码量。但这不是重点，重点在于 —— 上述这种代码无法复用。因为每一个图像的引用都被赋予了 <strong>具体</strong> 的含义：同样的写法不太可能完全地适用于另外一个图像处理场景。比如说，另外那个图像处理场景很可能不会用到描述为 ijk 的图像，可能会用到描述是 uvw 的图像。因此，采取这种写法会遇到的一个典型问题是：每新增一个图像处理场景，我们都需要新增若干个特定描述的图像声明。在编码层面，这无疑是一项繁冗的工作。</p>
<p>上面说的图像引用，其实正是我们的图像 “管道” 里的某个 “节点”。思考一个问题，如果要对 “节点” 实现代码复用，你会怎么做？稍微提示一下，关键在于 “__具体__” 这两个字。</p>
<p>是的，如果我们能想到，上面的写法中代码之所以不能复用，根源在于图像引用的用途已经被 __具体定义__（同时也是被具体 __约束__），那么我们就更有可能往这样一个方向思考问题的解决方案：能不能把图像引用 “去具体化” ，让它的含义在具体场景到来时才被赋予呢？</p>
<p>讲到这一层，有些读者可能已经想到一种数据结构 —— 字典。是的，没有什么奇淫巧技，只用字典，就能实现 “去具体化”，解决这个代码复用问题中的最大障碍 —— 既然无法预知我们可能需要处理什么样的图像，可能需要处理多少份图像，并且这些未知数总是易变的，那为什么不让具体场景的使用者来 <strong>动态添加</strong> 这些图像引用，并且为它们具名呢？图像部分被复用的代码，这里只声明了一样东西，就是从图像状态表述到图像引用的映射表。它提供了一个之前的写法不具备的特点，而这个特点是达成复用的必要前提：图像存取的方式是 __统一的__，__有限的__，从而是 __可固化的__。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> stateTagToImageMap = [<span class="type">String</span>:<span class="type">MyImage</span>]()</span><br></pre></td></tr></tbody></table></figure>
<p>我们用一个 <strong>字符串标签</strong> 来表示图像的状态。对于图像 “管道” 的使用者来说，他只需要理解每个标签的含义，通过标签来存取图像并进行处理。在这些标签中，我们再提炼出几个具有通用含义的代表性标签：比如，<code>original</code> 代表 “<strong>最初的__”，<code>processed</code> 代表 “__加工完成的__”，这正是前文提到的 __占位符</strong> 。容易理解，在一份可复用的代码库中，你可以声明并且预置许多 <strong>占位符</strong> 。但你不会在这个代码库里声明同样数量的图像引用 —— 这样很奇怪对吧？哪怕从程序实现的角度来说，没有分配实际空间的引用并不一定会占据更多的内存。在后面列举的代码范例中，我们将会经常地用到 <code>original</code> 和 <code>processed</code> 这样的标签。</p>
<p>不妨阅读下面这段代码，这就是一种使用标签来操作对应图像的写法。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 显示两个处理步骤之后的图像 </span></span><br><span class="line">pipeline.from (.original) <span class="comment">// 从原始的图像开始 </span></span><br><span class="line">        .copyTo (.processed) <span class="comment">// 拷贝出一份图像用于处理，对应标签 processed</span></span><br><span class="line">        .doProcess (tag: .processed, specificProcess1)  <span class="comment">// 在 processed 上执行处理 1</span></span><br><span class="line">        .doProcess (tag: .processed, specificProcess2) <span class="comment">// 在 processed 上执行处理 2</span></span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed)) <span class="comment">// 取得 processed 标签代表的图像并且展示 </span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="锋面的实现方案和意义"><a href="#锋面的实现方案和意义" class="headerlink" title="锋面的实现方案和意义"></a>锋面的实现方案和意义</h2><p>解决了 “节点” 的设计，我们再来看基于 “节点” 提炼出来的 “锋面” 要怎么设计。容易理解，“__锋面__” 是最前面的那个 “节点” ，具有 __唯一性__，对应具体的图像处理代码中就是 “当前正在被处理的那个图像”。在设计图像管道对外提供的处理 API 时，我们约定处理动作一定只能发生在这个 “__当前的__” 图像上，这样就能够保证我们的 “图像流” 总是按照我们想要的方向流动，并且在这个过程中，“图像流” 是不会被篡改的。这也是我们的图像编辑功能要实现撤销和重做功能的基本前提。</p>
<p>还是上面那段代码，现在可以去掉实际处理步骤的标签参数。因为我们约束了处理只能发生在 <strong>唯一的__、__当前的</strong> 图像上。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 显示一个处理步骤之后的图像 </span></span><br><span class="line">pipeline.from (.original) <span class="comment">// 从原始的图像开始 </span></span><br><span class="line">        .copyTo (.processed) <span class="comment">// 拷贝出一份图像用于处理，对应标签 processed</span></span><br><span class="line">        .doProcess (specificProcess1) <span class="comment">// 隐含了在 processed 上执行处理 1</span></span><br><span class="line">        .doProcess (specificProcess2) <span class="comment">// 隐含了在 processed 上执行处理 2</span></span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed)) <span class="comment">// 取得 processed 标签代表的图像并且展示 </span></span><br></pre></td></tr></tbody></table></figure>
<p>如果要求能够回撤到第一个处理步骤之后的状态，再做第二个处理步骤，并且第二个处理步骤的参数是可以改变的。可以这么做：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 显示一个处理步骤之后的图像，但我们在过程中保留了第一个步骤的状态 </span></span><br><span class="line">pipeline.from (.original)</span><br><span class="line">        .copyTo (<span class="string">"specificProcess1"</span>) <span class="comment">// 相比一步到位，这里多存储了第一个步骤的状态 </span></span><br><span class="line">        .doProcess (specificProcess1)</span><br><span class="line">        .copyTo (.processed)</span><br><span class="line">        .doProcess (specificProcess2.setParams (params1))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整第二个步骤的某些参数，重新显示图像 </span></span><br><span class="line">pipeline.from (<span class="string">"specificProcess1"</span>) <span class="comment">// 之前存储了第一个步骤的状态，直接从这个步骤开始 </span></span><br><span class="line">        .copyTo (.processed)</span><br><span class="line">        .doProcess (specificProcess2.setParams (params2))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed))</span><br></pre></td></tr></tbody></table></figure>
<h2 id="流动和连通性的实现方案"><a href="#流动和连通性的实现方案" class="headerlink" title="流动和连通性的实现方案"></a>流动和连通性的实现方案</h2><p>有了 “节点” 和 “锋面”，“流动” 和 “连通” 就有了作用的主体。对应到图像编辑功能，“__流动__” 其实就是图像从一个状态变成另外一个状态的过程。“__连通__” 则更好理解，一个管道出来的图像可以被另外一个管道接纳，由此构成管道之间的连接。连接在一起的每一节 “__小管道__” 各司其职，灵活组合，再构成更长跨度的 “__大管道__” 或者 “__管道网络__”，从而协同完成复杂的业务流程。</p>
<p>回归到代码，我们来看一组步骤稍多的图片处理工序，看它是如何体现出管道的 “流动性” 和 “连通性”。刨去内部的实现细节，整合或者忽略一些与管道设计思想关联不大的逻辑，以下代码在流程上算是比较接近实际生产环境了。虽然采用的是伪代码，相信读者可以看懂。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** 主功能区，不妨将它的例程称为 Main</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 可以从这里进入各子功能处理图片再回到这里展示新的图片 </span></span><br><span class="line"><span class="comment"> * 3. 撤销到经过某个步骤处理之前的图像或者重做出之前做过但是被撤销掉的某个步骤的图像   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineMain</span>.startFrom (imageFile) {</span><br><span class="line">    <span class="type">RoutineMain</span>.pipeline.loadFrom (imageFile, .original) <span class="comment">// 从图片中加载初始的图像 </span></span><br><span class="line">}</span><br><span class="line"><span class="type">RoutineMain</span>.showCurrent () {</span><br><span class="line">    showImage (<span class="type">RoutineMain</span>.pipeline.front () <span class="comment">// 显示 “锋面”</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美型” 的功能区，对应的例程称为 FaceLift</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸轮廓，五官进行形状调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineFaceLift</span>.startFrom (<span class="type">RoutineMain</span>.pipeline.front ().copy ())</span><br><span class="line"><span class="type">RoutineFaceLift</span>.process () {</span><br><span class="line">    <span class="type">RoutineFaceLift</span>.pipeline</span><br><span class="line">         <span class="comment">// 这个过程用户无法干预，不会有 “重做”，因此我们可以直接在原稿上操作 </span></span><br><span class="line">        .from (.original)</span><br><span class="line">        .doProcess (faceLift_step_1_process)</span><br><span class="line">        .doProcess (faceLift_step_2_process)</span><br><span class="line">        .doProcess (faceLift_step_3_process)</span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美型” 处理好的图像提交给主功能 </span></span><br><span class="line"><span class="type">RoutineMain</span>.accept (<span class="type">RoutineFaceLift</span>.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “滤镜” 的功能区，对应的例程称为 Filter</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 滤镜化处理图像 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineFilter</span>.startFrom (<span class="type">RoutineMain</span>.pipeline.front ().copy ());</span><br><span class="line"><span class="type">RoutineFilter</span>.process () {</span><br><span class="line">    <span class="type">RoutineFilter</span>.pipeline</span><br><span class="line">        <span class="comment">// 这个过程中用户决定要选用哪个具体的滤镜，因此每次都需要基于原稿复制一份再滤镜化 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"awful"</span>)))</span><br><span class="line">        ... <span class="comment">// 皱眉，这个不好，换一个！</span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"notbad"</span>)))</span><br><span class="line">        ... <span class="comment">// 托腮，这个还行，再换个试试～</span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"perfect"</span>)))</span><br><span class="line">        ... <span class="comment">// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “滤镜” 处理好的图像提交给主功能 </span></span><br><span class="line"><span class="type">RoutineMain</span>.accept (<span class="type">RoutineFilter</span>.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美颜 ” 的功能区，对应的例程称为 SkinBeauty</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸皮肤进行色相调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像给 Main 功能 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineSkinBeauty</span>.startFrom (<span class="type">RoutineMain</span>.pipeline.front ().copy ());</span><br><span class="line"><span class="type">RoutineSkinBeauty</span>.process () {</span><br><span class="line">    <span class="type">RoutineSkinBeauty</span>.pipeline</span><br><span class="line">        <span class="comment">// 这个过程用户可以调节一个滑竿来控制色相参数，每次都基于原稿复制一份再调色相 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_weak))</span><br><span class="line">        ... <span class="comment">// 托腮，效果好像不明显，加强一点 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_much)))</span><br><span class="line">        ... <span class="comment">// 皱眉，好像有点过头了，往回调一点 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_just_right)</span><br><span class="line">        ... <span class="comment">// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美颜” 处理好的图像提交给主功能 </span></span><br><span class="line"><span class="type">RoutineMain</span>.accept (<span class="type">RoutineSkinBeauty</span>.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纠结一下。。</span></span><br><span class="line"><span class="comment">// 犹豫，要不还是不美颜了吧？</span></span><br><span class="line"><span class="type">RoutineMain</span>.undo ();</span><br><span class="line"><span class="comment">// 迟疑，滤镜也不要了？</span></span><br><span class="line"><span class="type">RoutineMain</span>.undo ();</span><br><span class="line"><span class="comment">// 思考中。。。</span></span><br><span class="line"><span class="comment">//... 不行，还是都加回来吧 </span></span><br><span class="line"><span class="type">RoutineMain</span>.redo ().redo ();</span><br><span class="line"><span class="comment">// 端详 5 分钟。。。完美～</span></span><br><span class="line">save (); <span class="comment">// 收工，准备发朋友圈 </span></span><br></pre></td></tr></tbody></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于 “管道” 的设计思路和实现方案介绍到此。我们可以回顾一下，本文开始所提到 “黑盒子” 设计的第二个问题：“图像 <strong><em>管理</em></strong>  和图像 <strong><em>效果处理</em></strong>  被绑定在一起。”，在管道方案中是不是已经解决了呢？</p>
<blockquote>
<p>“管道” 设计的基石是 <strong>无差别地管理图像</strong> ，被管理的每一个图像，由最初将其投入管道的创建者为其定义标签。最初的创建者和后来的协同者，只需要对这个标签的含义达成 <strong>共识</strong> 便可以进行协作。“管道” 的思想是模拟 “<strong>流体__” 的运行方式来实现图像处理过程，通过 “__节点__” 的设定来 __分解</strong> 处理步骤，通过 “<strong>锋面__” 的操控来 __聚焦</strong> 每个单步的操作，通过 <strong>连通性</strong> 来将 <strong>分治</strong> 的逻辑重新 <strong>串联</strong> 起来完成复杂的功能。</p>
</blockquote>
]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>development</tag>
        <tag>programming</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 笔记 | MVVM In SwiftUI</title>
    <url>/development/note-swiftui-mvvm/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<blockquote>
<p>译自 <a href="https://augmentedcode.io/2020/01/05/mvvm-in-swiftui/">MVVM in SwiftUI</a></p>
</blockquote>
<p>让我们用 MVVM (model-view-view model) 来构建一个应用，其中的每个 SwiftUI 视图都有自己的 model 。这会是一个拥有两个视图的 app : 一个电影列表以及一个用于添加电影的表单。新增的电影存在在 <code>MovieStore</code> ，它由两个 view models 共享。我们将通过 environment 来共享 MovieStore ，也就说，当我们需要时，会从 environment 中读取。</p>
<h2 id="用-Movie-和-MovieStore-来表示数据"><a href="#用-Movie-和-MovieStore-来表示数据" class="headerlink" title="用 Movie 和 MovieStore 来表示数据"></a>用 Movie 和 MovieStore 来表示数据</h2><p>Movie 是一个很小的结构体，只存储了标题和评分。标题和评分都是可变的，因为我们需要在 AddMovieView 里更新它们。这个结构体也遵循 <code>Identifiable</code> 协议，因为我们将用 List 视图来展示所有的电影。List 需要能够标识内容中的每一项，而遵循这个协议是最简单的方式。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Movie</span>: <span class="title">Equatable</span>, <span class="title">Identifiable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id = <span class="type">UUID</span>()</span><br><span class="line">    <span class="keyword">var</span> fullTitle: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> givenRating: <span class="type">Rating</span> = .notSeen</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Movie</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Rating</span>: <span class="title">Int</span>, <span class="title">CaseIterable</span> </span>{</span><br><span class="line">        <span class="keyword">case</span> notSeen, terrible, poor, decent, good, excellent</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>MovieStore 也很简单，不过实际的 app 会包含更多的逻辑：持久化，删除等等。我们用 <code>Published</code> 属性包装器来为订阅者自动提供发布。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieStore</span> </span>{</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> allMovies = [<span class="type">Movie</span>]()</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="keyword">_</span> movie: Movie)</span></span> {</span><br><span class="line">        allMovies.append (movie)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了将共享的 <code>MovieStore</code> 插入环境，我们需要使用自定义的 EnvironmentKey 。自定义 key 仅仅只是一个遵循  <code>EnvironmentKey</code> 协议的自定义 key 。我们需要提供类型和默认值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MovieStoreKey</span>: <span class="title">EnvironmentKey</span> </span>{</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Value</span> = <span class="type">MovieStore</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue = <span class="type">MovieStore</span>()</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EnvironmentValues</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> movieStore: <span class="type">MovieStore</span> {</span><br><span class="line">        <span class="keyword">get</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>[<span class="type">MovieStoreKey</span>]</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">set</span> {</span><br><span class="line">            <span class="keyword">self</span>[<span class="type">MovieStoreKey</span>] = newValue</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果我们不插入自己的 <code>MovieStore</code> 实例到 environment ，那就会使用 defaultValue 默认值。典型情况下，我们会在视图体系之外初始化这个特定实例。</p>
<h2 id="SceneDelegate-和-MovieScene-呈现"><a href="#SceneDelegate-和-MovieScene-呈现" class="headerlink" title="SceneDelegate 和 MovieScene 呈现"></a>SceneDelegate 和 MovieScene 呈现</h2><p>MovieStore 作为依赖项，在构造函数被传给 view model 。我们将使用存储在 SceneDelegate 的实例。再次申明，在实际的 app 中，这种依赖项很可能是处于一个独立的容器或者别的类似的东西。 MovieListView 是我们要呈现的第一个视图，因此我们会初始化 view model ， view ，并且插入 MovieStore 实例到 environment ，以便后续使用。 (movieStore keypath 是通过 EnvironmentValues 的 extension 来定义的)。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SceneDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIWindowSceneDelegate</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> movieStore = <span class="type">MovieStore</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scene</span><span class="params">(<span class="keyword">_</span> scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</span></span> {</span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">MovieListView</span>.<span class="type">ViewModel</span>(movieStore: movieStore)</span><br><span class="line">        <span class="keyword">let</span> contentView = <span class="type">MovieListView</span>(viewModel: viewModel).environment (\.movieStore, movieStore)</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> windowScene = scene <span class="keyword">as</span>? <span class="type">UIWindowScene</span> <span class="keyword">else</span> { <span class="keyword">return</span> }</span><br><span class="line">        <span class="keyword">let</span> window = <span class="type">UIWindow</span>(windowScene: windowScene)</span><br><span class="line">        window.rootViewController = <span class="type">UIHostingController</span>(rootView: contentView)</span><br><span class="line">        <span class="keyword">self</span>.window = window</span><br><span class="line">        window.makeKeyAndVisible ()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="MovieListView-和对应的-ViewModel"><a href="#MovieListView-和对应的-ViewModel" class="headerlink" title="MovieListView 和对应的 ViewModel"></a>MovieListView 和对应的 ViewModel</h2><p>在 SwiftUI 中，view model 遵循 <code>ObservableObject</code> 协议，使用 @Published 属性包装器。 ObservableObject 的默认实现提供了 <code>objectWillChange</code> publisher 。 @Published 属性包装器能在属性将要改变时自动发射这个 publisher 。在 MovieListView 中，我们用 @ObservedObject 属性包装器声明 view model 属性。这会使得该视图订阅 objectWillChange publisher ，并且在 objectWillChange 发动时自动刷新视图。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MovieListView</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">let</span> movieStore: <span class="type">MovieStore</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cancellables = [<span class="type">AnyCancellable</span>]()</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">init</span>(movieStore: <span class="type">MovieStore</span>) {</span><br><span class="line">            <span class="keyword">self</span>.movieStore = movieStore</span><br><span class="line">            cancellables.append (movieStore.$allMovies.assign (to: \.movies, on: <span class="keyword">self</span>))</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> movies = [<span class="type">Movie</span>]()</span><br><span class="line">        @<span class="type">Published</span> <span class="keyword">var</span> isPresentingAddMovie = <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MovieListView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">Environment</span>(\.<span class="keyword">self</span>) <span class="keyword">var</span> environment</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">ViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">NavigationView</span> {</span><br><span class="line">            <span class="type">List</span>(<span class="keyword">self</span>.viewModel.movies) { movie <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(movie.fullTitle)</span><br><span class="line">            }.navigationBarTitle (<span class="string">"Movies"</span>)</span><br><span class="line">                .navigationBarItems (trailing: navigationBarTrailingItem)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> navigationBarTrailingItem: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: {</span><br><span class="line">            <span class="keyword">self</span>.viewModel.isPresentingAddMovie = <span class="literal">true</span></span><br><span class="line">        }, label: {</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"plus"</span>).frame (minWidth: <span class="number">32</span>, minHeight: <span class="number">32</span>)</span><br><span class="line">        }).sheet (isPresented: <span class="keyword">self</span>.$viewModel.isPresentingAddMovie) {</span><br><span class="line">            <span class="keyword">self</span>.makeAddMovieView ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAddMovieView</span><span class="params">()</span></span> -&gt; <span class="type">AddMovieView</span> {</span><br><span class="line">        <span class="keyword">let</span> movieStore = environment [<span class="type">MovieStoreKey</span>]</span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">AddMovieView</span>.<span class="type">ViewModel</span>(movieStore: movieStore)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AddMovieView</span>(viewModel: viewModel)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你会注意到，MovieStore 时用了两份，一份在 view model 中，一份放在环境中。</p>
<p><code>AddMovieView</code> 和它的 view model 是在用户点击导航栏上的加号按钮时被创建的。环境属性包装器可以被用于获取整个环境或者借助特定键获取某个值。在这个案例中我们访问了整个环境对象，然后在需要的时候借助 MovieStoreKey 访问 MovieStore 。或者你也可以使用 @Environment (.movieStore) var movieStore 来代替。</p>
<h2 id="AddMovieView-和对应的-ViewModel"><a href="#AddMovieView-和对应的-ViewModel" class="headerlink" title="AddMovieView 和对应的 ViewModel"></a>AddMovieView 和对应的 ViewModel</h2><p><code>AddMovieView</code> 的 view model 是随着 MovieStore 一同被初始化的，它内部呈现了一个 Movie 实例。 Published 属性包装器和 MovieListView 的 view model 里的用法相似。 内部的 movie 对象是一个私有的属性， TextField 和 Picker 都采用双向 Binding 。 Binding 是一种 view 和 model 间的双向连接方式。另外，还有一个 <code>canSave</code> 属性，它是用来控制导航栏上的保存按钮是否启用。保持按钮只有在标题有填充的时才启用。</p>
<p>简单复习一下视图更新的流程：TextField 或者 Picker 会利用 Binding 来更新私有属性 <code>newMovie</code> 。 因为 newMovie 属性使用了 @Published 属性包装器，它会发射 ObservableObject 的 objectWillChange publisher 。 SwiftUI 自动订阅 objectWillChange ，因为 view model 的属性用了 @ObservedObject 。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AddMovieView</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">let</span> movieStore: <span class="type">MovieStore</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">init</span>(movieStore: <span class="type">MovieStore</span>) {</span><br><span class="line">            <span class="keyword">self</span>.movieStore = movieStore</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        @<span class="type">Published</span> <span class="keyword">private</span> <span class="keyword">var</span> newMovie = <span class="type">Movie</span>(fullTitle: <span class="string">""</span>)</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">lazy</span> <span class="keyword">var</span> title = <span class="type">Binding</span>&lt;<span class="type">String</span>&gt;(<span class="keyword">get</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.fullTitle</span><br><span class="line">        }, <span class="keyword">set</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.fullTitle = $<span class="number">0</span></span><br><span class="line">        })</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">lazy</span> <span class="keyword">var</span> rating = <span class="type">Binding</span>&lt;<span class="type">Movie</span>.<span class="type">Rating</span>&gt;(<span class="keyword">get</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.givenRating</span><br><span class="line">        }, <span class="keyword">set</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.givenRating = $<span class="number">0</span></span><br><span class="line">        })</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">var</span> canSave: <span class="type">Bool</span> {</span><br><span class="line">            <span class="keyword">return</span> !newMovie.fullTitle.isEmpty</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">()</span></span> {</span><br><span class="line">            movieStore.add (newMovie)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddMovieView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">Environment</span>(\.presentationMode) <span class="keyword">private</span> <span class="keyword">var</span> presentationMode</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">ViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">NavigationView</span> {</span><br><span class="line">            <span class="type">Form</span> {</span><br><span class="line">                titleSection</span><br><span class="line">                ratingSection</span><br><span class="line">            }.navigationBarTitle (<span class="string">"Add Movie"</span>, displayMode: .inline)</span><br><span class="line">                .navigationBarItems (leading: leadingBarItem, trailing: trailingBarItem)</span><br><span class="line">                .navigationViewStyle (<span class="type">StackNavigationViewStyle</span>())</span><br><span class="line">             </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> titleSection: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Section</span>() {</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">"Title"</span>, text: viewModel.title)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ratingSection: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Section</span>() {</span><br><span class="line">            <span class="type">Picker</span>(<span class="type">LocalizedStringKey</span>(<span class="string">"Rating"</span>), selection: viewModel.rating) {</span><br><span class="line">                <span class="type">ForEach</span>(<span class="type">Movie</span>.<span class="type">Rating</span>.allCases, id: \.rawValue) {</span><br><span class="line">                    <span class="type">Text</span>($<span class="number">0</span>.localizedName).tag ($<span class="number">0</span>)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> leadingBarItem: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: { <span class="keyword">self</span>.presentationMode.wrappedValue.dismiss () }, label: {</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Cancel"</span>)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> trailingBarItem: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: {</span><br><span class="line">            <span class="keyword">self</span>.viewModel.save ()</span><br><span class="line">            <span class="keyword">self</span>.presentationMode.wrappedValue.dismiss ()</span><br><span class="line">        }, label: {</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Save"</span>).disabled (!<span class="keyword">self</span>.viewModel.canSave)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们创建了一个只有两个视图的简单 app 。两个视图都有各自的 view model ，并且都依赖 MovieStore 。一个 view model 中触发了 MovieStore 的改变，这些改变会被另一个 view model 观察到。另外，我们还了解了 SwiftUI 的 environment 以及如何从 view model 中触发 view 更新。</p>
<hr>
]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>development</tag>
        <tag>swiftui</tag>
      </tags>
  </entry>
  <entry>
    <title>SwiftUI 应用 | 浇水提醒 app</title>
    <url>/development/note-swiftui-dynamic-user-notification-on-apple-watch/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="用-SwiftUI-在-Apple-Watch-上构建动态通知"><a href="#用-SwiftUI-在-Apple-Watch-上构建动态通知" class="headerlink" title="用 SwiftUI 在 Apple Watch 上构建动态通知"></a>用 SwiftUI 在 Apple Watch 上构建动态通知</h1><blockquote>
<p>译自 <a href="https://augmentedcode.io/2020/02/02/dynamic-user-notification-on-apple-watch-with-swiftui/">Dynamic user notification on Apple Watch with SwiftUI</a><br>源码地址：<a href="https://github.com/laevandus/WaterMyPlants">WaterMyPlants</a></p>
</blockquote>
<p>集成了推送或者本地通知的 app 可以定制 apple watch 上的通知。本文是关于如何在 apple watch 上实现动态通知的笔记。样例工程实现一个提醒给植物浇水的功能。我们会聚焦在添加通知视图，省略从 iOS app 发送通知的步骤。</p>
<h2 id="为-Apple-Watch-添加富文本通知添加构建目标"><a href="#为-Apple-Watch-添加富文本通知添加构建目标" class="headerlink" title="为 Apple Watch 添加富文本通知添加构建目标"></a>为 Apple Watch 添加富文本通知添加构建目标</h2><p>如果工程里没有 App Watch app ，你需要添加它。在 Xcode 中，我们新增一个构建目标，并配置成包含通知场景。打开 New -&gt; Target:</p>
<img src="/images/watch_app_target.png" width="80%" height="80%" style="margin: 10 auto;">

<p>确保 User Interface 选择，并且 “Include Notification Scene” 选中。我们将会把它嵌入当前的 iOS app ，所以 “Embed in Companion App” 要选择当前 app 。值得一提的是，从 iOS 13 和 WatchOS 6 开始，Apple Watch app 已经可以独立存在了。</p>
<img src="/images/watch_app_target_2.png" width="80%" height="80%" style="margin: 10 auto;">

<p>点击完成，Xcode 会询问激活新的 scheme ，点击激活，它会自动选择新建的目标，所以我们可以直接开始写代码了。先检查工程，会发现 Xcode 加了两个目标：watch app 和 extension。App 包含了 storyboard ，而 extension 包含了所有的代码。 storyboard 是提供基于 <code>WKHostingController</code> 的子类的 HostingController 演示用的场景。这个类负责承载你的 Apple Watch app 的 SwiftUI 视图。另外，还有两个场景，分别是静态和动态通知。我们对动态通知感兴趣，在 storyboard 里可以看见动态视图是由 <code>NotificationController</code> 提供的，它是 <code>WKUserNotificationHostingController</code> 的子类，承载通知的 SwiftUI 视图。这里就是我们给通知提供自定义界面的地方。如果通知的分类和 storyboard 里预先定义的匹配，就会选择动态通知视图。</p>
<h2 id="解析通知的-payload-并设置动态通知视图"><a href="#解析通知的-payload-并设置动态通知视图" class="headerlink" title="解析通知的 payload 并设置动态通知视图"></a>解析通知的 payload 并设置动态通知视图</h2><p>NotificationController 的职责是消费用户通知的 payload ，并生成 SwiftUI 视图来展示它们。用户通知是从 <code>didReceive</code> 函数接收的，我们需要释放信息，用于视图。在本地测试的时候，我们可以把测试数据写在 <code>PushNotificationPayload.apns</code> 文件里。因为我们要展示的是关于植物的信息，所有我们添加一个植物对象到文件中。同时，我们还需要把通知分类修改成某个有含义的字符串。确保你设置新的分类时正确更新 storyboard 。</p>
<figure class="highlight json"><table><tbody><tr><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"aps"</span>: {</span><br><span class="line">        <span class="attr">"alert"</span>: {</span><br><span class="line">            <span class="attr">"body"</span>: <span class="string">"Test message"</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Optional title"</span>,</span><br><span class="line">            <span class="attr">"subtitle"</span>: <span class="string">"Optional subtitle"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="attr">"category"</span>: <span class="string">"WATERING_REMINDER"</span>,</span><br><span class="line">        <span class="attr">"thread-id"</span>: <span class="string">"plantid123"</span></span><br><span class="line">    },</span><br><span class="line">     </span><br><span class="line">    <span class="attr">"plant"</span>: {</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"plantid123"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Aloe"</span>,</span><br><span class="line">        <span class="attr">"lastDate"</span>: <span class="number">1579937802</span>,</span><br><span class="line">        <span class="attr">"nextDate"</span>: <span class="number">1580515200</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<img src="/images/watch_app_target_3.png" width="50%" height="50%" style="margin: 10 auto;">

<p>当我们访问 <code>UNNotification.request.content.userInfo</code> 拿到植物的信息时，我们可以用 <code>Decodable</code> 和 <code>JSONDecoder</code> 将代表植物的字典转换成值类型。 <code>JSONDecoder</code> 接收 <code>JSON</code> 数据，所以我们先用 <code>JSONSerialization</code> 包装数据，然后把包装的结果传给 <code>JSONDecoder</code> 。 或者我们也可以手动从 <code>userInfo</code> 字典里读取所有的值，然后创建出植物类型。留意，我们需要用 view model 来提供数据给 SwiftUI ，而不是直接使用 <code>Plant</code> 类型。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span>: <span class="title">Decodable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastDate: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> nextDate: <span class="type">Date</span></span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">let</span> plantInfo = notification.request.content.userInfo [<span class="string">"plant"</span>] <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">Any</span>]</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.data (withJSONObject: plantInfo, options: [])</span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        decoder.dateDecodingStrategy = .secondsSince1970</span><br><span class="line">        <span class="keyword">let</span> plant = <span class="keyword">try</span> decoder.decode (<span class="type">Plant</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">        viewModel = <span class="type">NotificationViewModel</span>(plant: plant)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> <span class="keyword">let</span> nsError <span class="keyword">as</span> <span class="type">NSError</span> {</span><br><span class="line">        <span class="built_in">print</span>(nsError.localizedDescription)</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>另外，我们想要添加三个用户可以执行的动作：标记植物已经浇水，推后提醒，或者安排明天再提醒。这些动作是用 <code>UNNotificationAction</code> 实例表示。当用户点击任意其中一个时，<code>UNUserNotificationCenter</code> 的委托方法会被调用，并且带有该动作的 <code>identifier</code> 。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> doneTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Done"</span>, comment: <span class="string">"Done button title in notification."</span>)</span><br><span class="line"><span class="keyword">let</span> laterTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Later"</span>, comment: <span class="string">"Later button title in notification."</span>)</span><br><span class="line"><span class="keyword">let</span> tomorrowTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Tomorrow"</span>, comment: <span class="string">"Tomorrow button title in notification."</span>)</span><br><span class="line">notificationActions = [</span><br><span class="line">    <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_done"</span>, title: doneTitle, options: []),</span><br><span class="line">    <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_later"</span>, title: laterTitle, options: []),</span><br><span class="line">    <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_tomorrow"</span>, title: tomorrowTitle, options: [])</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p><code>NotificationController</code> 的完整实现如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationController</span>: <span class="title">WKUserNotificationHostingController</span>&lt;<span class="title">NotificationView</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> viewModel: <span class="type">NotificationViewModel?</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> body: <span class="type">NotificationView</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NotificationView</span>(viewModel: viewModel!)</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="keyword">_</span> notification: UNNotification)</span></span> {</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="keyword">let</span> plantInfo = notification.request.content.userInfo [<span class="string">"plant"</span>] <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">Any</span>]</span><br><span class="line">            <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.data (withJSONObject: plantInfo, options: [])</span><br><span class="line">            <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">            decoder.dateDecodingStrategy = .secondsSince1970</span><br><span class="line">            <span class="keyword">let</span> plant = <span class="keyword">try</span> decoder.decode (<span class="type">Plant</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">            viewModel = <span class="type">NotificationViewModel</span>(plant: plant)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> <span class="keyword">let</span> nsError <span class="keyword">as</span> <span class="type">NSError</span> {</span><br><span class="line">            <span class="built_in">print</span>(nsError.localizedDescription)</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">let</span> doneTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Done"</span>, comment: <span class="string">"Done button title in notification."</span>)</span><br><span class="line">        <span class="keyword">let</span> laterTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Later"</span>, comment: <span class="string">"Later button title in notification."</span>)</span><br><span class="line">        <span class="keyword">let</span> tomorrowTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Tomorrow"</span>, comment: <span class="string">"Tomorrow button title in notification."</span>)</span><br><span class="line">        notificationActions = [</span><br><span class="line">            <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_done"</span>, title: doneTitle, options: []),</span><br><span class="line">            <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_later"</span>, title: laterTitle, options: []),</span><br><span class="line">            <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_tomorrow"</span>, title: tomorrowTitle, options: [])</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="呈现通知的-NotificationView"><a href="#呈现通知的-NotificationView" class="headerlink" title="呈现通知的 NotificationView"></a>呈现通知的 NotificationView</h2><p>上面提到 view model <code>NotificationViewModel</code> 为 NotificationView 提供文本，它主要处理日期的格式化字符。 </p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotificationViewModel</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> plant: <span class="type">Plant</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(plant: <span class="type">Plant</span>) {</span><br><span class="line">        <span class="keyword">self</span>.plant = plant</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> plant.name</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> subtitle: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSLocalizedString</span>(<span class="string">"NotificationView_Subtitle"</span>, comment: <span class="string">"Notification suggestion text"</span>)</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        formatter.dateFormat = <span class="type">DateFormatter</span>.dateFormat (fromTemplate: <span class="string">"dMMMM"</span>, options: <span class="number">0</span>, locale: .current)</span><br><span class="line">        <span class="keyword">return</span> formatter</span><br><span class="line">    }()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> lastWatering: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> format = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationView_LastWatering"</span>, comment: <span class="string">"Last watering date."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: format, dateFormatter.string (from: plant.lastDate))</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> nextWatering: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> format = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationView_NextWatering"</span>, comment: <span class="string">"Next watering date."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: format, dateFormatter.string (from: plant.nextDate))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>SwiftUI 视图很简单，4 个文本。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotificationView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> viewModel: <span class="type">NotificationViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">Text</span>(viewModel.title).font (.title)</span><br><span class="line">            <span class="type">Text</span>(viewModel.subtitle).font (.subheadline)</span><br><span class="line">            <span class="type">Divider</span>()</span><br><span class="line">            <span class="type">Text</span>(viewModel.lastWatering).font (.body).multilineTextAlignment (.center)</span><br><span class="line">            <span class="type">Text</span>(viewModel.nextWatering).font (.body).multilineTextAlignment (.center)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<img src="/images/watch_notification_1.png" width="30%" height="30%" style="margin: 10 auto;">

<img src="/images/watch_notification_2.png" width="30%" height="30%" style="margin: 10 auto;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们往一个 iOS app 中添加了 watch app ，实现一个通知分类的动态通知视图。我们学习了如何解析通知数据，添加动作按钮。下一步是在 companion iOS app 里基于按钮的 identifier 处理对应通知动作。</p>
<hr>
<h1 id="拉取和显示数据"><a href="#拉取和显示数据" class="headerlink" title="拉取和显示数据"></a>拉取和显示数据</h1><p> 这一节的主题是从 compasion iOS app 的 CoreData 存储中获取数据，需要借助 WatchConnectivity framework 。</p>
<h2 id="iOS-和-WatchOS-app-之间的-session"><a href="#iOS-和-WatchOS-app-之间的-session" class="headerlink" title="iOS 和 WatchOS app 之间的 session"></a>iOS 和 WatchOS app 之间的 session</h2><p> iOS app 用 CoreData 来存储植物列表，记录了每株植物上一次和下一次浇水的日期。在这里，没有 web 服务，所有的东西都存在设备上。那么如何把持久化存储中的数据拿给 WatchOS app 使用呢？</p>
<p>我们会用到 WatchConnectivity framework 来做 iOS 和 WatchOS app 之间的交互。连接是在 iOS 和 WatchOS app 上都激活 <code>WCSession</code> 来实现的。因此，第一步是添加一个管理 <code>WCSession</code> 的类到 iOS 工程，我们不妨称它为 WatchConnectivityProvider (稍后也会添加一个相似的类到 WatchOS app)。它的主要职能是建立 <code>WCSession</code> ，处理 <code>WCSessionDelegate</code> ，其中包含从 CoreData 存储拉取数据。因此，有一个叫 <code>NSPersistentContainer</code> 的参数会提供对 <code>CoreData</code> 栈的访问 (借由访问 performBackgroundTask 函数)。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchConnectivityProvider</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> persistentContainer: <span class="type">NSPersistentContainer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">WCSession</span> = .<span class="keyword">default</span>, persistentContainer: <span class="type">NSPersistentContainer</span>) {</span><br><span class="line">        <span class="keyword">self</span>.persistentContainer = persistentContainer</span><br><span class="line">        <span class="keyword">self</span>.session = session</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p><code>WCSession</code> 是通过调用 activate () 来激活，激活过程是异步的。激活的响应通过 <code>session (_:activationDidCompleteWith:error:)</code> 委托访问返回。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">guard</span> <span class="type">WCSession</span>.isSupported () <span class="keyword">else</span> {</span><br><span class="line">        os_log (.debug, log: .watch, <span class="string">"watch session is not supported"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"activating watch session"</span>)</span><br><span class="line">    session.activate ()</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="keyword">_</span> session: WCSession, </span></span></span><br><span class="line"><span class="function"><span class="params">             activationDidCompleteWith activationState: WCSessionActivationState, </span></span></span><br><span class="line"><span class="function"><span class="params">             error: Error?)</span></span> {</span><br><span class="line">    os_log (.debug, </span><br><span class="line">               log: .watch, </span><br><span class="line">               <span class="string">"did finish activating session % lu (error: % s)"</span>, </span><br><span class="line">               activationState == .activated, </span><br><span class="line">               error?.localizedDescription ?? <span class="string">"none"</span>) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在 watchOS extension target 那边，我们会添加相似的代码，不过名字不一样，叫 “PhoneConnectivityProvider” 。当两个类都创建完成后，我们需要初始化并调用 connect ，分别在 <code>SceneDelegate</code> (iOS) 和 <code>ExtensionDelegate</code> (watchOS) 中完成。注意，在 iOS app 这边，我们需要实现两个委托方面，不过目前我们简单打印就可以了。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sessionDidBecomeInactive</span><span class="params">(<span class="keyword">_</span> session: WCSession)</span></span> {</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"session became inactive"</span>)</span><br><span class="line">}</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sessionDidDeactivate</span><span class="params">(<span class="keyword">_</span> session: WCSession)</span></span> {</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"session deactivated"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了测试 session ，我们需要先编译并运行，然后在编译运行 watchOS app 。如果一切工作正常， Xcode 调试窗口会打印出消息： “did finish activating session 1 (error: none)”. 这表明 session 已经建立并且正在运行，我们可以两个 app 间发送消息了。</p>
<h2 id="Fetching-plants-from-iOS-app"><a href="#Fetching-plants-from-iOS-app" class="headerlink" title="Fetching plants from iOS app"></a>Fetching plants from iOS app</h2><p>因为 iOS 和 watchOS app 之间的通信依赖字典，所以第一步是定义一组两个 app 共享使用的 key 。这样可以减少误拼写的风险，所以我们可以添加新文件，并且同时包含到 iOS app target 和 watchOS extension target 中去。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WatchCommunication</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> requestKey = <span class="string">"request"</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> responseKey = <span class="string">"response"</span></span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Content</span>: <span class="title">String</span> </span>{</span><br><span class="line">        <span class="keyword">case</span> allPlants</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第二步是在 <code>PhoneConnectivityProvider</code> (watchOS app extension target) 中实现一个 <code>refreshAllPlants (completionHandler)</code> 函数，用来发送消息给 iOS app ，并且等待植物数据的数组返回。 <code>WCSession</code> 有一个叫  <code>sendMessage (_:replyHandler:errorHandler:)</code> 的函数，我们可以用它来发送一个字典给 iOS app ，然后等待 reply handler 。我们会用 WatchCommunication.requestKey 和 WatchCommunication.Content.allPlants 枚举的 rawValue 来构建消息。这种模式便于后续扩展，你只要添加更到 case 到枚举就可以了。在 reply handler 中，我们期望得到一个字典的数组，描述所有的植物。让我们先看一眼完整的实现，然后再讨论字典是如何被转换成 <code>Plant</code> 值类型的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refreshAllPlants</span><span class="params">(withCompletionHandler completionHandler: @escaping <span class="params">([Plant]?)</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">    <span class="keyword">guard</span> session.activationState == .activated <span class="keyword">else</span> {</span><br><span class="line">        os_log (.debug, log: .phone, <span class="string">"session is not active"</span>)</span><br><span class="line">        completionHandler (<span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">let</span> message = [<span class="type">WatchCommunication</span>.requestKey: <span class="type">WatchCommunication</span>.<span class="type">Content</span>.allPlants.rawValue]</span><br><span class="line">    session.sendMessage (message, replyHandler: { (payload) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> plantDictionaries = payload [<span class="type">WatchCommunication</span>.requestKey] <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]]</span><br><span class="line">        os_log (.debug, log: .phone, <span class="string">"received % lu plants"</span>, plantDictionaries?.<span class="built_in">count</span> ?? <span class="number">0</span>)</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        decoder.dateDecodingStrategy = .secondsSince1970</span><br><span class="line">        <span class="keyword">let</span> plants = plantDictionaries?.<span class="built_in">compactMap</span>({ <span class="type">Plant</span>(dictionary: $<span class="number">0</span>, decoder: decoder) })</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async {</span><br><span class="line">            completionHandler (plants)</span><br><span class="line">        }</span><br><span class="line">    }, errorHandler: { error <span class="keyword">in</span></span><br><span class="line">        os_log (.debug, log: .phone, <span class="string">"sending message failed: % s"</span>, error.localizedDescription)</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>iOS app 上处理 CoreData 和 Plant 类型的是一个 NSManagedObject 子类的对象。watchOS app extension 定义了它自己的 <code>Plant</code> 值类型，因为它并没有 CoreData 栈。为了将字典转换成值类型，我们可以使用 “Storing struct in UserDefault” 中描述的方法，只需要额外配置 <code>JSONDecoder</code> 使用的 <code>dateDecodingStrategy</code>  为 <code>secondsSince1970</code> 。理由是我们希望以自 1970 年之后的秒数来存储日期。转换字典到值类型的过程用到了 <code>JSONSerialization</code> ，它只支持 <code>NSString</code> ， <code>NSNumber</code> ， <code>NSArray</code> ， <code>NSDictionary</code> ， 或者 <code>NSNull</code> 。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Plant value type in WatchOS app extension</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span>: <span class="title">Identifiable</span>, <span class="title">Decodable</span>, <span class="title">DictionaryDecodable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastWateringDate: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> nextWateringDate: <span class="type">Date</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// Plant class in iOS app</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Plant</span>: <span class="title">NSManagedObject</span>, <span class="title">Identifiable</span> </span>{</span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> lastWateringDate: <span class="type">Date</span></span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> nextWateringDate: <span class="type">Date</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第三步是在 iOS app 端处理消息，并且提供数据给 watchOS app 。我们需要做的是实现 session 的委托，从 CoreData 栈中获取字典数据。 先看下完整实现，然后逐一拆解。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="keyword">_</span> session: WCSession, didReceiveMessage message: [String: <span class="keyword">Any</span>], replyHandler: @escaping <span class="params">([String: <span class="keyword">Any</span>])</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"did receive message: % s"</span>, message [<span class="type">WatchCommunication</span>.requestKey] <span class="keyword">as</span>? <span class="type">String</span> ?? <span class="string">"unknown"</span>)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> contentString = message [<span class="type">WatchCommunication</span>.requestKey] <span class="keyword">as</span>? <span class="type">String</span> , <span class="keyword">let</span> content = <span class="type">WatchCommunication</span>.<span class="type">Content</span>(rawValue: contentString) <span class="keyword">else</span> {</span><br><span class="line">        replyHandler ([:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">switch</span> content {</span><br><span class="line">    <span class="keyword">case</span> .allPlants:</span><br><span class="line">        persistentContainer.performBackgroundTask { (managedObjectContext) <span class="keyword">in</span>            </span><br><span class="line">            <span class="keyword">let</span> all = <span class="type">Plant</span>.allPlantsDictionaryRepresentation () <span class="keyword">as</span>! [[<span class="type">String</span>: <span class="type">Any</span>]]</span><br><span class="line">            <span class="comment">// Replace Date with Double</span></span><br><span class="line">            <span class="keyword">let</span> converted = all.<span class="built_in">map</span> { (plantDictionary) -&gt; [<span class="type">String</span>: <span class="type">Any</span>] <span class="keyword">in</span></span><br><span class="line">                plantDictionary.mapValues { (value) -&gt; <span class="type">Any</span> <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> date = value <span class="keyword">as</span>? <span class="type">Date</span> {</span><br><span class="line">                        <span class="keyword">return</span> date.timeIntervalSince1970</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">return</span> value</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }                </span><br><span class="line">            <span class="keyword">let</span> response = [<span class="type">WatchCommunication</span>.responseKey: converted]</span><br><span class="line">            replyHandler (response)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>第一步是查看接收到的字典，看看 watchOS app 请求的是哪些内容。然后我们访问持久化存储，获取表示 Plant 的字典，把其他的日期转换成 1970 年后秒数的形式 (以便 watchOS app 能够在字典上使用 <code>JSONSerialization</code>)，然后把数据发送回 watchOS app 。注意，从 CoreData 中获取字典形式的 Plant 很容易：我们首先是请求 <code>NSDictionary</code> 类型的数据，并且将结果类型属性设置为 <code>.dictionaryResultType</code> 。对于各庞大的模型，我们可能还会用到属性集合 (propertiesToFetch) 。不过目前，所有的属性都被添加到字典中了。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Plant</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> entityName = <span class="string">"Plant"</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">makeDictionaryRequest</span><span class="params">()</span></span> -&gt; <span class="type">NSFetchRequest</span>&lt;<span class="type">NSDictionary</span>&gt; {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSFetchRequest</span>&lt;<span class="type">NSDictionary</span>&gt;(entityName: entityName)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">allPlantsDictionaryRepresentation</span><span class="params">()</span></span> -&gt; [<span class="type">NSDictionary</span>] {</span><br><span class="line">        <span class="keyword">let</span> request = makeDictionaryRequest ()</span><br><span class="line">        request.resultType = .dictionaryResultType</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> request.execute ()</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> <span class="keyword">let</span> nsError <span class="keyword">as</span> <span class="type">NSError</span> {</span><br><span class="line">            os_log (.debug, log: .plants, <span class="string">"failed fetching all plants with error % s % s"</span>, nsError, nsError.userInfo)</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="用-SwiftUI-在-watchOS-app-中构建-UI"><a href="#用-SwiftUI-在-watchOS-app-中构建-UI" class="headerlink" title="用 SwiftUI 在 watchOS app 中构建 UI"></a>用 SwiftUI 在 watchOS app 中构建 UI</h2><p>Xcode 中 watchOS app 的模板是借助 storyboard 初始化 <code>HostingController</code>， 这个控制器负责提供初始的 SwiftUI 视图。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostingController</span>: <span class="title">WKHostingController</span>&lt;<span class="title">PlantListView</span>&gt; </span>{</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> connectivityProvider: <span class="type">PhoneConnectivityProvider</span> = {</span><br><span class="line">        <span class="keyword">let</span> provider = <span class="type">PhoneConnectivityProvider</span>()</span><br><span class="line">        provider.connect ()</span><br><span class="line">        <span class="keyword">return</span> provider</span><br><span class="line">    }()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> listViewModel = <span class="type">PlantListViewModel</span>(connectivityProvider: connectivityProvider)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> body: <span class="type">PlantListView</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">PlantListView</span>(viewModel: listViewModel)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>PlantListView</code> 是一个显示植物列表的简单视图，它用 <code>PhoneConnectivityProvider</code> 的 <code>refreshAllPlants (withCompletionHandler:)</code> 来处理刷新植物的逻辑。 SwiftUI 视图会在 view model 改变时自动更新。这是因为 view model 的 <code>plants</code> 属性使用了 <code>@Published</code> 属性包装器，而 view model 本身是 <code>ObservableObject</code> ，这是 SwiftUI 视图中为 view model 采用的属性包装器 (更多信息可以阅读 refreshing SwiftUI view in MVVM in SwiftUI) 。注意，这里的 view model 是 SwiftUI 视图显现时刷新内容的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PlantListViewModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> connectivityProvider: <span class="type">PhoneConnectivityProvider</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(plants: [<span class="type">Plant</span>] = [], connectivityProvider: <span class="type">PhoneConnectivityProvider</span>) {</span><br><span class="line">        <span class="keyword">self</span>.plants = plants</span><br><span class="line">        <span class="keyword">self</span>.connectivityProvider = connectivityProvider</span><br><span class="line">        refresh ()</span><br><span class="line">    }</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> plants: [<span class="type">Plant</span>]</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">refresh</span><span class="params">()</span></span> {</span><br><span class="line">        connectivityProvider.refreshAllPlants { [<span class="keyword">weak</span> <span class="keyword">self</span>] (plants) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> plants = plants <span class="keyword">else</span> { <span class="keyword">return</span> }</span><br><span class="line">            <span class="keyword">self</span>?.plants = plants</span><br><span class="line">        }</span><br><span class="line">    }    </span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlantListView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">PlantListViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">List</span>(<span class="keyword">self</span>.viewModel.plants) { plant <span class="keyword">in</span></span><br><span class="line">                <span class="type">PlantCell</span>(viewModel: <span class="type">PlantCellViewModel</span>(plant: plant))</span><br><span class="line">            }</span><br><span class="line">        }.onAppear {</span><br><span class="line">            <span class="keyword">self</span>.viewModel.refresh ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>PlantListView</code> 用 <code>PlantCell</code> 来显示独立的视图。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlantCell</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> viewModel: <span class="type">PlantCellViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">4</span>) {</span><br><span class="line">            <span class="type">Text</span>(viewModel.title).font (.headline).multilineTextAlignment (.center)</span><br><span class="line">            <span class="type">Text</span>(viewModel.subtitle).font (.footnote).multilineTextAlignment (.center)</span><br><span class="line">        }.padding (<span class="number">8</span>)</span><br><span class="line">            .frame (minWidth: <span class="number">0</span>, maxWidth: .greatestFiniteMagnitude)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlantCellViewModel</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> plant: <span class="type">Plant</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> plant.name</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        formatter.dateFormat = <span class="type">DateFormatter</span>.dateFormat (fromTemplate: <span class="string">"dMMMM"</span>, options: <span class="number">0</span>, locale: .current)</span><br><span class="line">        <span class="keyword">return</span> formatter</span><br><span class="line">    }()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> subtitle: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> format = <span class="type">NSLocalizedString</span>(<span class="string">"PlantCellView_NextWatering"</span>, comment: <span class="string">"Next watering date."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: format, <span class="type">Self</span>.dateFormatter.string (from: plant.nextWateringDate))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>我们在 iOS 和 watchOS app 上都添加 <code>WCSessions</code> ，实现相关的委托方法以处理 session 和接收到的消息。然后，我们定义一个简单的通信模式，并在 watchOS app 端实现刷新植物的方法，在 iOS 端实现 CoreData 集成。当数据访问创建完成后，我们在 watchOS app 上用 SwiftUI 视图显示植物的列表。</p>
<hr>
]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>watchOS</tag>
        <tag>development</tag>
        <tag>swiftui</tag>
      </tags>
  </entry>
  <entry>
    <title>大纲 | SwiftUI 教程</title>
    <url>/uncategorized/outline-swiftui-tutorials/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views">源</a></p>
<h1 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章 基础"></a>第一章 基础</h1><h2 id="创建和绑定视图"><a href="#创建和绑定视图" class="headerlink" title="创建和绑定视图"></a>创建和绑定视图</h2><h3 id="1-创建项目和探索-Canvas"><a href="#1-创建项目和探索-Canvas" class="headerlink" title="1 创建项目和探索 Canvas"></a>1 <strong>创建项目和探索 Canvas</strong></h3><p>要点：</p>
<ol>
<li>创建项目时 User Interface 选择 “SwiftUI”</li>
<li>基础扩展：演示 Xcode 界面布局，菜单</li>
<li>SwiftUI 文件的两部分：描述视图内容和布局的主结构体，预览</li>
<li>显示隐藏 Canvas 面板快捷键</li>
<li>演示实时预览 （改变 body 里的代码） SwiftUI 开发体验的核心卖点之一<br>进阶资源：声明式 UI 、Flutter 和 SwiftUI 的比较，拖尾闭包语法</li>
</ol>
<h3 id="2-自定义文本视图"><a href="#2-自定义文本视图" class="headerlink" title="2 自定义文本视图"></a>2 自定义文本视图</h3><p>要点：</p>
<ol>
<li>演示从预览中的检视 UI 元素，顺便提一下 modifier ，演示 Font modifier</li>
<li>代码和视图的关系：source of truth (真理之源)</li>
<li>演示预览、检视器和代码的自动同步</li>
</ol>
<h3 id="3-通过堆叠组合视图"><a href="#3-通过堆叠组合视图" class="headerlink" title="3 通过堆叠组合视图"></a>3 通过堆叠组合视图</h3><p>要点</p>
<ol>
<li>body 属性只返回一个视图<br>进阶资源：关于 body 属性的文章</li>
<li>介绍三类 stacks ，HStack, VStack，ZStack</li>
<li>介绍 Xcode 的结构化编辑：嵌套、检视、提取等。通用的 ” 右键菜单 “ ，SwiftUI 专有的 Cmd + 点击<br>进阶资源：Flutter</li>
<li>演示 embed in vstack</li>
<li>演示添加控件： + 按钮，快捷键</li>
<li>演示两层 Stack 嵌套，演示 Spacer 的使用。<br>进阶资源：Spacer 的特性</li>
<li>演示 padding<br>进阶资源：padding 的各种版本</li>
</ol>
<h3 id="4-创建自定义图像视图"><a href="#4-创建自定义图像视图" class="headerlink" title="4 创建自定义图像视图"></a>4 创建自定义图像视图</h3><p>要点</p>
<ol>
<li>简介 image view ，常见图片相关概念：mask，边缘 (border)，投影 (drop shadow)</li>
<li>基础扩展： 添加资源到 asset catalog</li>
<li>演示创建新的 SwiftUI 文件，CircleImage</li>
<li>演示 Image () 构造器，演示 clipShaper modifier, Circle mask<br>进阶：mask 遮蔽</li>
<li>演示 overlay， shadow</li>
</ol>
<h3 id="5-让-UIKit-和-SwiftUI-一起工作"><a href="#5-让-UIKit-和-SwiftUI-一起工作" class="headerlink" title="5 让 UIKit 和 SwiftUI 一起工作"></a>5 让 UIKit 和 SwiftUI 一起工作</h3><ol>
<li>如何在 SwiftUI 中使用 UIKit 里的视图？关键词：wrap, UIViewRepresentable 协议<br> 进阶资源：wrap，协议</li>
<li>[学习曲线] 跳过，后续再来说明。<br> MapKit 相关知识点</li>
</ol>
<h3 id="6-构成视图-Compose-Views-——-需要练习"><a href="#6-构成视图-Compose-Views-——-需要练习" class="headerlink" title="6 构成视图 (Compose Views) —— (需要练习)"></a>6 构成视图 (Compose Views) —— (需要练习)</h3><p>要点：</p>
<ol>
<li>选择容器 —— stacks，文字、图像、Spacer、自定义视图</li>
<li>调整视图 —— modifier，属性</li>
<li>打开源链接，演示样例 app 界面变化过程。</li>
</ol>
<p>检查理解的测验。</p>
<hr>
<h2 id="构建-List-和导航"><a href="#构建-List-和导航" class="headerlink" title="构建 List 和导航"></a>构建 List 和导航</h2><h3 id="1-了解样本数据"><a href="#1-了解样本数据" class="headerlink" title="1 了解样本数据"></a>1 了解样本数据</h3><p>要点：</p>
<ol>
<li>理解 Model ，粗浅理解为数据，相对于视图<br>进阶资源：MVC 设计模式，结构体和类的区别，数据格式，json</li>
<li>带一些新的关键字，协议</li>
<li>进阶扩展：为什么要用扩展 Landmark 的 image 属性</li>
<li>json 数据格式</li>
</ol>
<h3 id="2-创建-“行”-视图"><a href="#2-创建-“行”-视图" class="headerlink" title="2 创建 “行” 视图"></a>2 创建 “行” 视图</h3><p>要点</p>
<ol>
<li>创建新 SwiftUI 文件，起名 LandmarkRow.swift</li>
<li>进阶扩展：存储属性和计算属性</li>
<li>介绍 Image resizable modifier</li>
</ol>
<h3 id="3-自定义预览"><a href="#3-自定义预览" class="headerlink" title="3 自定义预览"></a>3 自定义预览</h3><p>要点</p>
<ol>
<li>previewLayout<br>进阶资源：previewDevice</li>
</ol>
<h3 id="4-创建列表"><a href="#4-创建列表" class="headerlink" title="4 创建列表"></a>4 创建列表</h3><p>要点</p>
<ol>
<li>List 的元素可以是动态的、静态的或者混合的<br>进阶资源：SwiftUI 的 List</li>
<li>使用 List<br>进阶资源：</li>
</ol>
<h3 id="5-创建动态列表"><a href="#5-创建动态列表" class="headerlink" title="5 创建动态列表"></a>5 创建动态列表</h3><p>要点</p>
<ol>
<li>List 接收 <code>identifiable</code> 的数据<br>进阶资源：Swift keypath 语法，SwiftUI 的 List、ForEach<br>进阶资源：闭包、拖尾闭包语法</li>
<li>Identifiable 协议：id 属性的约定</li>
</ol>
<h3 id="6-在-List-之间建立导航"><a href="#6-在-List-之间建立导航" class="headerlink" title="6 在 List 之间建立导航"></a>6 在 List 之间建立导航</h3><p>要点</p>
<ol>
<li>NavigationView<br>进阶资源：SwiftUI 给视图 “赋能” 的方式</li>
<li>标题、导航按钮<br>进阶资源：标准化 UI</li>
<li>NavigationLink</li>
</ol>
<h3 id="7-数据传递"><a href="#7-数据传递" class="headerlink" title="7 数据传递"></a>7 <strong>数据传递</strong></h3><p>要点</p>
<ol>
<li>演示改动</li>
</ol>
<h3 id="8-生成动态预览"><a href="#8-生成动态预览" class="headerlink" title="8 生成动态预览"></a>8 生成动态预览</h3><p>要点</p>
<ol>
<li>演示实现方式<br>进阶：对移动开发的意义</li>
</ol>
<hr>
<h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h2><h3 id="1-标记最爱的地标"><a href="#1-标记最爱的地标" class="headerlink" title="1. 标记最爱的地标"></a>1. 标记最爱的地标</h3><p>要点</p>
<ol>
<li>添加一个图标：系统图标、缩放、着色<br>进阶：SF Symbols，着色</li>
</ol>
<h3 id="2-过滤列表视图"><a href="#2-过滤列表视图" class="headerlink" title="2 过滤列表视图"></a>2 过滤列表视图</h3><p>要点</p>
<ol>
<li>@State 属性</li>
</ol>
<h3 id="3-添加控件以触发-State"><a href="#3-添加控件以触发-State" class="headerlink" title="3 添加控件以触发 State"></a>3 添加控件以触发 State</h3><p>要点</p>
<ol>
<li>绑定：$ 语法</li>
</ol>
<h3 id="4-用-Observable-Object-存储"><a href="#4-用-Observable-Object-存储" class="headerlink" title="4 用 Observable Object 存储"></a>4 用 Observable Object 存储</h3><p>要点</p>
<ol>
<li>ObservableObject 协议</li>
<li>@Published 属性</li>
</ol>
<h3 id="5-在视图中接收模型对象"><a href="#5-在视图中接收模型对象" class="headerlink" title="5 在视图中接收模型对象"></a>5 在视图中接收模型对象</h3><p>要点：</p>
<ol>
<li>环境变量: EnvironmentOjbect 属性声明，environmentObject 传入</li>
<li>where 语句</li>
</ol>
<h3 id="6-为每个地标创建按钮"><a href="#6-为每个地标创建按钮" class="headerlink" title="6 为每个地标创建按钮"></a>6 为每个地标创建按钮</h3><p>要点：演示</p>
<hr>
<h1 id="第二章-绘制和动画"><a href="#第二章-绘制和动画" class="headerlink" title="第二章 绘制和动画"></a>第二章 绘制和动画</h1><hr>
<h1 id="第三章-App-设计和布局"><a href="#第三章-App-设计和布局" class="headerlink" title="第三章 App 设计和布局"></a>第三章 App 设计和布局</h1><h1 id="构成复杂界面"><a href="#构成复杂界面" class="headerlink" title="构成复杂界面"></a>构成复杂界面</h1><h2 id="1-Home-视图"><a href="#1-Home-视图" class="headerlink" title="1 Home 视图"></a>1 Home 视图</h2><p>要点</p>
<p>Home 界面<br>   进阶：心智模式：干扰和专注，简单和复杂 （通知）</p>
<h2 id="2-分类列表"><a href="#2-分类列表" class="headerlink" title="2 分类列表"></a>2 分类列表</h2><p>要点</p>
<ol start="0">
<li>分类 =&gt; 建立层级 （“抽屉”、容器）=&gt; 寻找</li>
<li>用字典将地标分组</li>
<li>重温 List、ForEach、keypath 的用法</li>
</ol>
<h2 id="3-增加地标分类的内容"><a href="#3-增加地标分类的内容" class="headerlink" title="3 增加地标分类的内容"></a>3 增加地标分类的内容</h2><p>要点</p>
<ol>
<li>重温 Stack</li>
<li>ScrollView (.horizontal), ForEach</li>
</ol>
<h2 id="4-构成-Home-视图"><a href="#4-构成-Home-视图" class="headerlink" title="4 构成 Home 视图"></a>4 构成 Home 视图</h2><p>要点</p>
<ol>
<li>改造 CategoryRow</li>
<li>listRowInsets、EdgeInsets</li>
</ol>
<h2 id="5-添加导航"><a href="#5-添加导航" class="headerlink" title="5 添加导航"></a>5 添加导航</h2><p>要点</p>
<ol>
<li>重温 NavigationLink</li>
<li>Image .renderingMode , Text .foregroundColor</li>
<li>重温 @State， 重点: sheet<br>进阶：alert, 内建的环境变量 .presentationMode</li>
<li>导航栏按钮 navigationBarItems</li>
</ol>
<hr>
<h2 id="和-UI-控件合作"><a href="#和-UI-控件合作" class="headerlink" title="和 UI 控件合作"></a>和 UI 控件合作</h2><h3 id="1-显示用户资料"><a href="#1-显示用户资料" class="headerlink" title="1 显示用户资料"></a>1 显示用户资料</h3><h3 id="2-编辑模式"><a href="#2-编辑模式" class="headerlink" title="2 编辑模式"></a>2 编辑模式</h3><p>要点</p>
<ol>
<li>editMode</li>
<li>条件视图，wrappedValue</li>
</ol>
<h3 id="3-定义资料编辑器"><a href="#3-定义资料编辑器" class="headerlink" title="3 定义资料编辑器"></a>3 定义资料编辑器</h3><p>要点</p>
<ol>
<li>Divider</li>
<li>Toggle</li>
<li>Picker</li>
<li>DatePicker</li>
</ol>
<h3 id="4-延后编辑的生效"><a href="#4-延后编辑的生效" class="headerlink" title="4 延后编辑的生效"></a>4 延后编辑的生效</h3><p>要点</p>
<ol>
<li>编辑草稿</li>
<li>可取消的编辑</li>
<li>onAppear, onDisappear</li>
</ol>
<hr>
<h1 id="第四章-Framework-集成"><a href="#第四章-Framework-集成" class="headerlink" title="第四章 Framework 集成"></a>第四章 Framework 集成</h1><h2 id="与-UIKit-对接"><a href="#与-UIKit-对接" class="headerlink" title="与 UIKit 对接"></a>与 UIKit 对接</h2><h3 id="1-创建视图来表示-UIPageViewController"><a href="#1-创建视图来表示-UIPageViewController" class="headerlink" title="1 创建视图来表示 UIPageViewController"></a>1 创建视图来表示 UIPageViewController</h3><p>要点</p>
<ol>
<li>UIViewControllerRepresentable, #makeUIViewController, #updateUIViewController<br>进阶资源：回调</li>
<li>用 SwiftUI 的 view 来构建 UIPageViewController 中的 controller</li>
<li>map</li>
</ol>
<h3 id="2-创建-ViewController-的数据源"><a href="#2-创建-ViewController-的数据源" class="headerlink" title="2 创建 ViewController 的数据源"></a>2 创建 ViewController 的数据源</h3><p>要点</p>
<ol>
<li>使用 Coordinator, UIPageViewControllerDataSource</li>
</ol>
<h3 id="3-用-SwiftUI-中的视图状态跟踪-Page"><a href="#3-用-SwiftUI-中的视图状态跟踪-Page" class="headerlink" title="3 用 SwiftUI 中的视图状态跟踪 Page"></a>3 用 SwiftUI 中的视图状态跟踪 Page</h3><p>要点</p>
<ol>
<li>@State, @Binding 的传递</li>
<li>UIPageViewControllerDelegate</li>
</ol>
<h3 id="4-添加一个自定义页面控制"><a href="#4-添加一个自定义页面控制" class="headerlink" title="4 添加一个自定义页面控制"></a>4 添加一个自定义页面控制</h3><p>要点</p>
<ol>
<li>UIViewRepresentable</li>
<li>UIPageControl, UIControl<br>进阶资源：“控件”</li>
<li><strong>target-action pattern</strong> , *<strong>delegate</strong>， <strong>#selector</strong></li>
<li>**@objc 关键字 **</li>
<li>可选进阶：起名字，一个名字在多个层次中使用<br>PageControl, UIPageControl</li>
<li>可选进阶：PageViewController 和 PageControl 之间如何联动</li>
</ol>
<hr>
<h2 id="创建-watchOS-App"><a href="#创建-watchOS-App" class="headerlink" title="创建 watchOS App"></a>创建 watchOS App</h2><h3 id="1-添加-watchOS-目标"><a href="#1-添加-watchOS-目标" class="headerlink" title="1 添加 watchOS 目标"></a>1 添加 watchOS 目标</h3><p>要点</p>
<ol>
<li>激活 watch app 的 scheme</li>
<li>Supports Running Without iOS App Installation<br>进阶内容：watchOS 6.0, watch app 和 iOS app 的关系</li>
</ol>
<h3 id="2-在目标间共享文件"><a href="#2-在目标间共享文件" class="headerlink" title="2 在目标间共享文件"></a>2 在目标间共享文件</h3><p>要点</p>
<ol>
<li>文件 inspector, Target membership 段</li>
<li>watchkit app 和 watchkit extension 的区别<br>进阶内容：watch app 的结构</li>
</ol>
<h3 id="3-创建细节视图"><a href="#3-创建细节视图" class="headerlink" title="3 创建细节视图"></a>3 创建细节视图</h3><p>要点</p>
<ol>
<li>适配不同尺寸的屏幕</li>
<li>**where 语句 **</li>
<li>scaleToFill, scaleToFit</li>
</ol>
<h3 id="4-添加-watchOS-的地图视图"><a href="#4-添加-watchOS-的地图视图" class="headerlink" title="4 添加 watchOS 的地图视图"></a>4 添加 watchOS 的地图视图</h3><p>要点</p>
<ol>
<li>WKInterfaceObjectRepresentable<br>进阶：为什么不能像复用 CircleImage 那样直接复用 iOS 里写好的地图视图？SwiftUI 的定位（learn once, apply everywhere）</li>
<li>添加到 detail 界面</li>
</ol>
<h3 id="5-创建跨平台的列表视图"><a href="#5-创建跨平台的列表视图" class="headerlink" title="5 创建跨平台的列表视图"></a>5 创建跨平台的列表视图</h3><p>要点</p>
<ol>
<li>** 泛型 <strong>，</strong> 类型推断 **</li>
<li>对应修改 iOS scheme 的 Home 视图，LandmarkList 的初始化，重温拖尾闭包。</li>
<li>LandmarkList 预览怎么解决？ #if, #else, #endif, typealias</li>
</ol>
<h3 id="6-在-watch-app-中）添加-Landmarks-List"><a href="#6-在-watch-app-中）添加-Landmarks-List" class="headerlink" title="6 (在 watch app 中）添加 Landmarks List"></a>6 (在 watch app 中）添加 Landmarks List</h3><p>要点</p>
<ol>
<li>切换 scheme</li>
<li>思考题：watch app 为什么没有 Home ?</li>
</ol>
<h3 id="7-创建自定义的通知接口"><a href="#7-创建自定义的通知接口" class="headerlink" title="7 创建自定义的通知接口"></a>7 创建自定义的通知接口</h3><p>要点</p>
<ol>
<li>** 如何正确地使用通知？**</li>
<li>构建通知视图：swift 的 init 模式</li>
<li>通知控制：WKUserNotificationHostingController, #didReceive, </li>
<li>UNNotification</li>
<li>通知配置：Notification Category, apns 文件模拟远程通知</li>
<li>切换到 Notification scheme</li>
</ol>
<hr>
<h2 id="创建-macOS-app"><a href="#创建-macOS-app" class="headerlink" title="创建 macOS app"></a>创建 macOS app</h2><h3 id="1-创建-macOS-目标"><a href="#1-创建-macOS-目标" class="headerlink" title="1 创建 macOS 目标"></a>1 创建 macOS 目标</h3><p>要点</p>
<ol>
<li>Deployment Target<br>进阶资源：** 软件兼容（向前兼容）<strong>，</strong> 版本号 **</li>
</ol>
<h3 id="2-共享数据和-Assets"><a href="#2-共享数据和-Assets" class="headerlink" title="2 共享数据和 Assets"></a>2 共享数据和 Assets</h3><p>要点</p>
<ol>
<li>Membership</li>
</ol>
<h3 id="3-Row-视图"><a href="#3-Row-视图" class="headerlink" title="3 Row 视图"></a>3 Row 视图</h3><h3 id="4-组装视图"><a href="#4-组装视图" class="headerlink" title="4 组装视图"></a>4 组装视图</h3><p>要点</p>
<ol>
<li>List (selection: Binding&lt;Set<selectionvalue>)</selectionvalue></li>
</ol>
<h3 id="5-过滤器视图"><a href="#5-过滤器视图" class="headerlink" title="5 过滤器视图"></a>5 过滤器视图</h3><p>要点</p>
<ol>
<li>相同控件在不同平台上的外观</li>
<li>preview 中样例的 .constant 用法</li>
<li>数组相加</li>
<li>通用规范：复杂条件，注意使用括号</li>
</ol>
<h3 id="6-组合列表和过滤器视图"><a href="#6-组合列表和过滤器视图" class="headerlink" title="6 组合列表和过滤器视图"></a>6 组合列表和过滤器视图</h3><h3 id="7-复用-CircleImage"><a href="#7-复用-CircleImage" class="headerlink" title="7 复用 CircleImage"></a>7 复用 CircleImage</h3><p>要点</p>
<ol>
<li>属性默认值</li>
</ol>
<h3 id="8-macOS-上的地图视图"><a href="#8-macOS-上的地图视图" class="headerlink" title="8 macOS 上的地图视图"></a>8 macOS 上的地图视图</h3><p>要点</p>
<ol>
<li>善用 extension 分治代码</li>
</ol>
<h3 id="9-构建细节视图"><a href="#9-构建细节视图" class="headerlink" title="9 构建细节视图"></a>9 构建细节视图</h3><h3 id="10-Master-Detail-视图"><a href="#10-Master-Detail-视图" class="headerlink" title="10 Master Detail 视图"></a>10 Master Detail 视图</h3><p>要点</p>
<ol>
<li>mac (iPad) 上的应用布局，NavigationView</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>计算方法 03 | 科学哲学</title>
    <url>/social-science/quantitative-method-philosophy-of-science/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="认识论-Epistemology"><a href="#认识论-Epistemology" class="headerlink" title="认识论 (Epistemology)"></a>认识论 (Epistemology)</h1><p>在把假说 - 演绎法作为获取世界知识的最佳途径之前。第一个问题是：现实的本性？什么是现实？什么存在？因此，我们首先要问，获得的知识到底是关于什么的知识。解决这类问题的哲学领域叫做 <strong>本体论 (ontology)</strong> —— 对存在的研究。第二个问题涉及获取知识的方法。假设的确有一个现实：原则上是可知的，那么我们能获取哪些现实的知识？怎么获取？哲学领域中考虑这类问题的叫 <strong>认识论 (epistemology)</strong> —— 认识的研究或理论。</p>
<p>我们从后一个问题开始讲。假设有一个可知的现实，我们如何来获取知识。有很多不同的认识论观点，我们这里讨论两个最重要的观点。</p>
<p>第一个是 <strong>理性主义 (rationalism)</strong> 。理性主义者认为知识通过理性获得，用我们大脑的逻辑和理性思维能力，可以推断世界的真理，而无需借助经验。</p>
<p>哲学家柏拉图和笛卡尔结合了理性主义和其他观点，认为至少某些自然结构的抽象概念是天生的，是我们与生俱来的。就是说，我们的大脑能轻易理解这些概念，因为我们已经知道了，只要用推理回忆或辨识即可。</p>
<p><strong>经验主义 (Empiricism)</strong> 反对这一观点，经验主义者认为感官经验才是最主要方式。一些绝对经验主义者甚至认为，这是获取世界知识的唯一方式。</p>
<p>亚里士多德被认为是第一个经验主义者，他认为关于自然的基本真理来自感官经验。我们可以通过演绎推理获取更多知识，但观察是所有知识的基础。亚里士多德不相信天赋观念 (innate ideas) 。其实，他创造了 “白板” 这个词，指出每个人生下来就是一块白板。我们的知识并不是预先确定的，大脑可以接受任何概念。</p>
<p>当然，亚里士多德不是激进的经验主义者。他不反对理性思维加入进来，他也不反对用一些抽象的、不能直接观察的概念。</p>
<p>我觉得伽利略算是温和的经验主义者。他很注重观察法和实验法，但他也极度依赖逻辑推理。伽利略有句名言 “自然之书以数学语言写就”。他完全不排斥运用思想实验，也在他的假说中引入不可观测的性质。</p>
<img src="/images/sci-phil_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>后来的经验主义者如培根，尤其是休谟和逻辑实证主义者，都是绝对经验主义者，坚信只有感官经验才能获得世界的真知。他们认为建立在无法被直接观测的共相上的论断没有意义。</p>
<p>现代的经验主义就是范弗拉森的建构经验主义。它强调感官经验在归纳法和演绎法中都有作用，但它也允许理论术语存在，对应不能直接观测的实体。建构经验主义的目标是提出实证上恰当的解释，只要它表述的世界与观测到的一致，即可被接受。建构经验主义者会说因为存在不可观测的性质，真假无法判断。这承认了知识是暂时的，因为未来总存在发现新的反例的可能。</p>
<hr>
<h1 id="本体论-Ontology"><a href="#本体论-Ontology" class="headerlink" title="本体论 (Ontology)"></a>本体论 (Ontology)</h1><p>我们来说说本体论 (ontology) 即现实的本质是什么。</p>
<p>有很多对立的观点。在深入各种哲学观点之前，我先来解释这些观点里两个主要区别。第一点，现实是否独立存在于人类思想之外。当我们感知世间万物，它们真的脱离我们而真实存在吗？或者只是我们思想构建的心理表征，只能说存在于我们的思想。第二点是关于本体状态的殊相 (particular) 和共相 (universal)。殊相是指具体实例或能观察到属性的事件；共相或者说不可观察的性质，就是指那些无法直接观察到的普遍性质。</p>
<p>我们来举个例子，爱是我们无法直接观察到的普遍性质，但能通过行为表达或具现。因此当我家猫爬上我的膝盖打个小盹，这就是爱这个共相的具体实例。重力是另一个不可观察的共相，重力可用具体实例来表现。例如，当我打翻猫食盆，它就会掉在地上。</p>
<p>我们来看一下不同的本体论观点，看看他们对殊相和共相问题，以及对现实是外部存在还是仅存于思想内的看法。</p>
<p>唯心主义 (Idealism) 哲学观认为我们感知的现实完全存在于脑内。在我们精神世界感知到之前，外部物质世界的存在与我们无关。现实其实是精神世界的映射，重力和爱是存在的，但仅在我们的思想里，与之相关的具体实例也是如此。唯心主义者会说：猫睡在我膝上，以及碗掉在地上，这都是你想出来的。</p>
<p>对唯心主义而言，共相或不可观察的性质，它们是否真的在外部独立存在无关紧要。因为他们认为殊相和共相都是存在的，但都是精神世界的映射。</p>
<p>和唯心主义相对的是唯物主义 (Materialism) 。唯物主义认为思想世界外有独立存在的世界，唯物主义还认为一切由独立的物质世界构成。这就是说一切都是实物相互作用的结果，包括我们的意识、情绪和思想，这些是我们大脑和物质世界相互作用的副产品。</p>
<p>和唯心主义刚好相反，这是物质对精神。唯物主义只关注世界的物质组成，和唯心主义类似，它并不关心如何区分殊相和共相。</p>
<p>现实主义 (Realism) 又有所不同，就像唯物主义者，现实主义者坚持外部现实世界独立于人类思想存在，但现实主义者还坚持，像爱和重力这种共相是真实的，其存在形式取决于现实主义的类型。柏拉图式的现实主义认为像重力、爱这种共相，真的存在但我们观察不到，其位于一个独立的抽象位面。科学现实主义则更温和，它认为把共相用于现象观察能得到坚实可靠的主张。</p>
<p>在科学现实主义中，像爱和重力这种共相，和可观察的殊相位于同样的本体状态。之所以能假设不可测性的存在，是因为其对构造成功的科学主张有用且经常很必需。</p>
<p>最后是唯名论 (名义主义，Nominalism) 。这个观点在共相方面与现实主义完全对立，它承认现实独立于人类思想存在，但否认共相的存在。唯名论认为没有重力或爱这回事儿，只有掉落的物品以及经常在你膝盖打呼噜的猫。根据唯名论，我们用重力和爱这些术语，只因为能帮助理解世界，但共相不是真实存在的。</p>
<hr>
<h1 id="方法-Approaches"><a href="#方法-Approaches" class="headerlink" title="方法 (Approaches)"></a>方法 (Approaches)</h1><p>至今为止我讲到的科学方法的发展，主要在自然科学领域。物理学 physics、天文学 astronomy、生物学 biology，但在 19 世纪下半叶， <strong>社会科学 (social sciences)</strong> 开始登上历史舞台。</p>
<p>这段时期，人们又重拾了现实主义的本体论观点，即假设物质世界是真实的，我们感知的是外部世界，是独立于我们思想存在的。</p>
<p>认识论的观点越来越实证主义 (positivistic) ，这意味着科学家认为我们可以通过观察和实验来获取有关世界本质的知识。这种现实实证观点大多应用于自然现象方面，但随着社会科学发展并成为独特的科学领域，问题来了：现实主义观点是否适用于社会学和心理学现象呢？</p>
<p>根据 <strong>客观主义 (objectivism)</strong> 的观点，现实主义本体论立场确实适用于心理学和社会学现象，比如智力和社会凝聚力是外部的、独立的性质，是独立于我们的心理表征的。</p>
<p>客观主义可以建构主义 (constructivism) 做对比。</p>
<img src="/images/sci-phil_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>根据建构主义，社会现象的本质取决于所涉及的社会角色。这意味着现实不是独立和外在的，而被认为是基于观察者和情境的心理建构。比如，快乐或女性气质这些属性不是外在的，不是永恒的，也不能被客观定义。要如何看待这些属性以及它们的意义，取决于观察者的文化背景、社会族群及特定的历史时期。那么，如果心理现实和社会现实是建构的、主观的、难以捉摸的，我们如何了解它呢？怎样的认识论立场适合建构主义的本体论立场？</p>
<p>事实上，有一组互相联系的观念，统称为 <strong>解释主义 (interpretivism)</strong> 。解释主义的观点都假设研究者关于社会现象的经历或观察，可能与这些社会现象亲历者的经历大相径庭。所以重点应该放在参与者的角度来解读现象。</p>
<p>我想讲的三个解释主义观点是 <strong>解释学 (hermeneutics)</strong> 、 <strong>现象学 (phenomenology)</strong> 和 <strong>诠释社会学 (verstehen)</strong> ，它们在如何获得心理学和社会现实的理解上有些微差别。</p>
<p>先来看看解释学。这个术语来自神学，是关于解读经文。解释学旨在通过解读人们在社会情境下的行为 来解释社会现象。研究者需要将情境纳入考量，并试着理解人们如何看待这世界，以此来理解他们的行为。</p>
<p>现象学与解释学密切相关。它的首要前提是人不是无生命的对象，他们会思考和感知周遭的世界，而这会影响他们的行为。为了理解他们的行为，就需要调查他们给自己所经历的现象赋予的意义。这意味着调查人们如何从自身的角度探究世界。要切身了解他人对自己经历的理解，研究者需要尽可能地消除自己先入为主的观念。</p>
<p>诠释社会学是第三种解释主义观点，它与解释学和现象学有紧密联系。诠释社会学主要与社会学家马克斯・韦伯 (Max Weber) 相关。诠释社会学是指对社会现象的移情理解。研究者需要站在研究对象的立场，来解读他们如何看待世界，只有这样研究者才能解释他们的行为。比如，如果欧洲研究者想在一个与世隔绝的亚马逊部落中探究快乐。他们需要站在部落的角度，考虑到部落的社会情境。对部落来说，或许集体比个人更重要，这可能意味着快乐被认为是一种集体属性，甚至根本不适用于个人。现在，为了理解这种完全不同的世界观，研究者需要将自己沉浸在他们研究的人或族群的文化中。</p>
<p>当然，建构解释主义的观点存在一些问题。首先，有分层解读的问题 —— 研究者的解读；研究对象的解读；而将发现放进一个框架或关联一个理论时，又进行了解读。每多一层解读，就增大了误解的机会。第二个更严重的问题是结果缺乏可比性。在我们的例子中，快乐是主观的，在不同的文化中意义不同。我们不能就这么进行比较。这意味着我们永远无法提出普适解释或理论，而仅仅适用于特定人群或特定时段。第三个问题是参考系的不同。如果参考系与研究者相去甚远，研究者就很难站在研究对象的立场上，从而甚至难以发现社会情境中的相关方面。</p>
<p>建构 - 解释主义的观点常与科学的定性方法有关。换言之，观察是通过非结构化访谈或参与性观察进行的，而研究者是他们中的一份子。数据来源于一个或少数几个研究对象，通过解读文本或录制的素材对数据进行定性分析。反之，客观 - 实证观点于定量研究方法相关。得到的观察结果可以被计数或测量，所以多个研究对象的数据可以整合在一起，选取的研究对象代表更大的人群，或许可以支持一个普适解释。而且数据用量化统计手段来分析。</p>
<p>尽管定性方法通常与建构主义的科学观点相关，而定量方法与客观主义观点相关，这并不是限制我们仅使用定性或定量方法的理由。两种方法都各有优劣。对有些研究问题来说，定性方法更好；其他情况下 定量方法可能更合适。事实上，将两种方法互补结合在一起的方法，越来越受到欢迎。</p>
<hr>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>当然最后，科学的总体目标是获得知识，但可以分为更多具体的目标，区分目标的方式有获取知识的类型以及获取知识的目的。</p>
<p><strong>普遍性研究 (universalistic research)</strong> 试图提供能广泛使用的解释。</p>
<p>例如，假设玩暴力电脑游戏会导致攻击行为。这与具体游戏或特定玩家没有关系，因为我们假定的是玩暴力游戏和攻击性间的相关性，这适用于任何暴力游戏，如 GTA 、使命召唤等等；我们还假设相关性适用于男性和女性，任何年龄、任何文化背景的人。</p>
<p>普遍性研究致力描述或解释的现象，能用于所有人、所有群体或社会。</p>
<p>科学方法也能用于特殊性研究。特殊性研究致力描述或解释发生在特定环境下的现象，或者涉及特定群体。</p>
<p>例如，在荷兰将法定饮酒年龄从 16 岁升至 18 岁后，我们能调查荷兰青年酒精中毒住院人数的变化。关键是在特定的时间、地点、群体内调查影响的大小。不要指望在不同国家或十年里再次改变饮酒年龄会有同样结果。所以研究目的既可以是普遍性的，也可以是特殊性的。说得简短些就是：可获得普遍性或特定的知识。</p>
<p><strong>基础研究 (fundamental research)</strong> 和 <strong>应用研究 (applied research)</strong> 间关系很近，重叠度很高。</p>
<p>应用研究为了直接解决问题，其开发和应用知识是为了提高人类福祉。假设我们想帮助抑郁人群，我们认为抑郁是孤独造成的。我们就可以建立一个项目，目的是减少孤独感以降低抑郁程度。我们让孤独抑郁的人去养只猫，来观察是否真的由于不再孤独降低了抑郁程度。</p>
<p>基础研究相较于应用研究旨在获取知识，就是为了增进了解。基础研究的唯一目的是加深了解身边的世界，不需要能立即应用和接解决问题。例如，调查孤独和抑郁间的相关性，用大规模调查来看是否越感觉孤独的人越抑郁，反之亦然。这里是为了揭示孤独和抑郁间的相关性。也许我们想看看是否男性女性都有这种相关性，不同文化和年龄也有这种相关性。但注意，我们不关心如何治疗抑郁，这里的目的更多的是了解相关性，不是帮助抑郁人群。</p>
<p>大多数基础研究是普遍性研究，但有时候基础研究也会是特殊性研究。例如，在非常特定的情形下的研究。好比我们调查玩暴力游戏和攻击行为的相关性，就在阿姆斯特丹特定的初犯少年犯群体中，他们都来自权贵阶级。在玩暴力游戏和攻击行为相关性方面，这个非常特定的问题群体能提供有趣的新见解。注意，我们不观察该群体如何改造或不再犯罪。</p>
<p>应用研究常是特殊性研究，旨在特定环境、特定群体中解决问题，但它也可以是普遍性的研究。以养猫来减少抑郁的研究为例，我们可以扩展这项应用研究，比较照顾友善易交流的猫和拒绝接触的猫的人群。这会更有针对性地帮助找到何种治疗有效，但这也加入了普遍性元素，我们还可以调查它对孤独的意义。仅仅有个活物存在就够了吗？还是需要有互动？很多时候，应用研究的结果会产生新的见解，这些见解会和介入或治疗相关，但它们也会提供基础的知识。</p>
<p>因此，两种研究类型会互相增强。</p>
<hr>
]]></content>
      <categories>
        <category>social-science</category>
      </categories>
      <tags>
        <tag>计量方法</tag>
        <tag>社会科学</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 笔记 | 地图 API</title>
    <url>/development/note-ios-map-api/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="CLLocationManager-CLLocationManagerDelegate"><a href="#CLLocationManager-CLLocationManagerDelegate" class="headerlink" title="CLLocationManager, CLLocationManagerDelegate"></a>CLLocationManager, CLLocationManagerDelegate</h1><p>监控目标区域，进入、离开，Beacon 相关</p>
<h2 id="MKMapView-MKCoordinateRegion-MKMapItem"><a href="#MKMapView-MKCoordinateRegion-MKMapItem" class="headerlink" title="MKMapView, MKCoordinateRegion, MKMapItem,"></a>MKMapView, MKCoordinateRegion, MKMapItem,</h2><ul>
<li>坐标 CLLocationCoordinate2D （CoreLocation）</li>
<li>MKMapItem</li>
<li>罗盘按钮 MKCompassButton</li>
</ul>
<ul>
<li>用 Array:compactMap 获取一个可选型集合到非可选型且不包含 nil 的映射集合。</li>
</ul>
<h2 id="KVO-Compliant-KVO-兼容"><a href="#KVO-Compliant-KVO-兼容" class="headerlink" title="KVO Compliant (KVO 兼容)"></a>KVO Compliant (KVO 兼容)</h2><p>KVO is key-value observing.</p>
<h2 id="MKLocalSearch-查找附近，MKLocalSearchCompleter"><a href="#MKLocalSearch-查找附近，MKLocalSearchCompleter" class="headerlink" title="MKLocalSearch 查找附近，MKLocalSearchCompleter"></a>MKLocalSearch 查找附近，MKLocalSearchCompleter</h2><h2 id="UISearchResultsUpdating"><a href="#UISearchResultsUpdating" class="headerlink" title="UISearchResultsUpdating"></a>UISearchResultsUpdating</h2><figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">updateSearchResults (<span class="keyword">for</span> searchController: <span class="type">UISearchController</span>)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>development</tag>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title>watchOS 学习笔记 | 最小可行 Complication</title>
    <url>/development/note-watchos-minimum-viable-complication/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<blockquote>
<p>要做一个 watch app，逻辑上，你会先想到从主 UI 开始。毕竟，notfication 和 complication 是可选的。人们说到 app ，通常指的就是主 UI 。</p>
</blockquote>
<blockquote>
<p>但是，如果要做一个在表盘用于浏览空气质量指数的 watch app ，你会先想到 complication 。 watchOS 设计的三大准则之一是 <strong>glanceable</strong> ，意味着用户能在扫一眼手表，以尽快的方式看到想要的信息，理想的时间最多几秒钟。 complication 可以让看到这些信息，比从 app 启动栏访问主 UI 快得多。</p>
</blockquote>
<blockquote>
<p>不同于 iOS ，watchOS 的应用并不要求主 UI 一定得是最常用的使用方式 —— 如果用例使得通知和 complication 更合理的话。主 UI 可以充当用户想要查看更具体信息或者特定的动作时的 “回退” 方案。</p>
</blockquote>
<p>那么，为什么我们不跳过 view controller ，直接尝试构建一个 complication 呢？</p>
<p>以下是 Kuba 构建的一个简单的 MVP 版本的 watch app ，只有一个 complication (支持 1~2 种变体)。这个 app 没有 UI ，主试图只有一个黑盒子，一行 WKInterface* 对象相关的代码都没有。</p>
<p>这个没有 UI 的 watch app 的用途是获取空气质量的信息（PM10，PM2.5，$ NO_2 $ 等)，每个小时更新一次，但足够用了。</p>
<img src="/images/minimum-complication-watch-app.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>下面先了解一些基础知识。</p>
<hr>
<h1 id="Complication-时间线"><a href="#Complication-时间线" class="headerlink" title="Complication 时间线"></a>Complication 时间线</h1><p>管理 complications 的 API 单独从 WatchKit 分离出来，位于 ClockKit 中，以 <code>CLK</code> 前缀标识。</p>
<p>有一些 complication 在你抬腕时就是可见的。当手表的屏幕亮起，你希望立即看到渲染的 complication widget ，它显示的数据当下就必须是最新的 —— 用户很可能只看了它一秒钟不到，因此没有时间在这个时候启动网络请求。</p>
<p>Apple 也不可能采用 7 天 24 小时的方式让应用在后台运行扩展 —— 电池撑不住。</p>
<p>所以工作方式实际上是这样的：你的应用指定一个 <strong>complication data source</strong>  (<code>CLKComplicationDataSource</code>) ，然后每当它接收到新的数据时 (无论运行在前台或者后台)，它告诉 <strong>complication server</strong> (<code>CLKComplicationServer</code>) 通过数据源刷新数据。数据源返回一个 <strong>timeline</strong> 数据 (一个 <code>CLKComplicationTimelineEntry</code> 的对象) —— timeline 告诉 watchOS complication 在给定时间点到下一个时间点之前应该显示什么数字、文本、图标或者它们的组合。系统缓存这份数据。并且在正确的时间点自动更新显示的内容 —— 你的 app 只有在需要返回 timeline 时才会被唤起，但实际上也可以做到不需要唤起。你可以预先准备一整天的内容，只要你的数据足够提前。</p>
<p>下图是一个经典的天气 app 的例子，点标记 timeline 实体，上面的线显示每个实体被展示的时长。</p>
<img src="/images/timeline1.png" width="68%" height="68%" style="margin: 10 auto;">

<p>而这个是日历 app 的 complication ：</p>
<img src="/images/timeline2.png" width="68%" height="68%" style="margin: 10 auto;">

<p>取决于 app 类型，你需要的数据可能是未来的，过去的，两者都有，或者只需要当前状态。</p>
<p>在 Kuba 的案例中，他用的是过去的数据 —— 因为 PM10 这种数据不可能精确预测，它受到很多因素影响，某些是人为的 (比如烧煤取暖这类日常活动)</p>
<h1 id="Time-Travel"><a href="#Time-Travel" class="headerlink" title="Time Travel"></a>Time Travel</h1><p>Timeline 的设计还用到 watchOS 的另外一个特性，叫做 <strong>“Time Travel”</strong> ，它使得你可以在表盘上向前或者向后滚动时间，并更新 complication —— 这使得你可以看到诸如一场比赛中比分变化的过程，或者一只股票在一天中股价变化的过程。</p>
<p>watchOS 5 中这个特性被完全移除了，这意味着现在没办法看过去时间点的数据了。所以在实践中，实现处理过去数据这部分的 complication API 没有意义。</p>
<p>未来的数据仍然有价值 —— 虽然没有办法直接滚动操作了，但是 time travel 还可以工作，只不过是单方向固定节奏了。</p>
<p>有趣的是，这部分无用的 API 尚未被废弃，这意味着未来有回归的可能。</p>
<h1 id="Comlication-家族"><a href="#Comlication-家族" class="headerlink" title="Comlication 家族"></a>Comlication 家族</h1><p>在 watchOS 5 中你可以选择多达 26 种样式的表盘。不同的表盘可以适应不同数量和形状的 complications 。这些形状或者 complication 空间的变体被称为 <strong>complication famlilies</strong> ，目前有 10-11 种 families 可用：</p>
<ul>
<li>Modular Small, 用于所有的经典模块化表盘，也可用于 Siri 表盘的角落</li>
<li>Modular Large, 只能用在模块化表盘中间唯一的位置</li>
<li>Circular Small, 用于一些不同的表盘 (e.g. Activity)</li>
<li>Utilitarian Small (有 “flat” 变体) 和 Utilitarian Large, 用于占据表盘一半以上空间，展示一条水平的内容 (它有一个模式，容易跟 Circular Small 混淆)</li>
<li>Extra Large, 只用在 X-Large 表盘上</li>
<li>Graphic Corner, Graphic Circular, Graphic Bezel 和 Graphic Rectangular, 只用在 Apple Watch 4 系列的 Infograph 表盘</li>
</ul>
<p>你可以支持其中任意多你想要的家族子集，当然，理想情况下一个好的 app 是支持所有这些家族，因为不同的人偏好不同的表盘。</p>
<p>项目中为了让事情简单一些，我们只添加了对 Modular Small 和 Circular Small 的支持（覆盖了 11 中表盘，如果没算错的话）。</p>
<h1 id="内容模板"><a href="#内容模板" class="headerlink" title="内容模板"></a>内容模板</h1><p>由于资源的限制，你无法在 complication 空间随意绘制东西，你只能使用预定义的模板。模板限定了它们可以包含的内容类型和排布方式。你唯一的选择是选择一种模块，适配给定的空间，放入文本，图标或者值。</p>
<p>举个例子， Circular Small 家族有 6 种可用的模块：</p>
<p>.ringImage, 中间一个图标，然后一个围绕它的环，其他环的哪些部分被填充可以由你指定<br>.ringText, 中间是文本，然后一个围绕它的环 (实际中，文本通常是 1 到 3 位数字)<br>.simpleImage, 就是个简单的图标<br>.simpleText, 就是个标签<br>.stackImage, 上面一个小图标，下面是短的标签<br>.stackText, 两行短文本</p>
<p>大部分模块都只有极其有限的空间用于展示内容，有的时候你需要绞尽脑汁想如何利用给定的空间。如果实在想不出来，那么放弃对特定 complication 家族的支持也是可以的。</p>
<p>你的 app 会一些不同的状态 —— 例如，有或者没有数据，空或者非空数据列表，有或者没有进行中的活动等等。所以根据状态来选用不同的模块是可以的（比如，某些状态用数字，某些状态用图标）。每当你构建 timeline 时，你可以创建全新的模板对象并且用它们填充内容，所以只要你开心，甚至可以每次采用随机模板。</p>
<h1 id="文本和图像-providers"><a href="#文本和图像-providers" class="headerlink" title="文本和图像 providers"></a>文本和图像 providers</h1><p>为了渲染不同类型内容的灵活性， timeline 数据并非简单地以 <code>String</code> 或者 <code>UIImage</code> 对象的形式返回，而是借助某种可用的 <strong>provide</strong> 对象封装。这些 provider 使得你的内容可以更加动态，根据时间和上下文变化。</p>
<p>对于文本，最简单的选项是 <code>CLKSimpleTextProvider</code> ，你可以指定单一的字符串以及一个可选的简短版本，如果空间无法容纳完整字符串，则选取简短版本。</p>
<p>作为替代方案，有几种时间相关内容的 provider 可供选择：</p>
<ul>
<li><code>CLKDateTextProvider</code> 输出日期 (日 / 月)</li>
<li><code>CLKTimeTextProvider</code> 输出特定时间 (小时 / 分钟)</li>
<li><code>CLKTimeIntervalTextProvider</code> 输出时间范围 (from-to)</li>
<li><code>CLKRelativeDateTextProvider</code> 输出自某个时间开始或者到某个时间结束 (例如 “2 小时后”)</li>
</ul>
<p>上面最后一种会随着时间的流逝自动更新，你只需要配置一次目标时间戳，而不用每小时或者更频繁地手动更新，例如 “5 小时后”，“4 小时后” 等等。</p>
<p>对于图像，你通常用 <code>CLKImageProvider</code> 。它让你指定一个模板图像（被渲染为单色）和一个颜色。多少情况下，这个颜色会被忽略，因为大部分表盘都是以用户选定的单一颜色渲染所有的 complications 。有一个叫 <code>CLKFullColorImageProvider</code> 的模块可以以全彩的方式渲染图像，但只在新的 Infograph 表盘才用到。</p>
<p>模拟 Infograph 表盘上的 complications 还用到一些 <code>CLKGaugeProvider</code> —— 它们是用于配置新表盘角落里的彩色弧线。</p>
<hr>
<p>出发！</p>
<p>首先，创建工程，使用模板 “watchOS &gt; iOS App with WatchKit App” ，确保 “Include Complication” checkbox 勾选。</p>
<p>工程将包含 3 个 targets：</p>
<ul>
<li>SmogWatch, 它是 iOS app (这个案例里我们基本不碰这部分)</li>
<li>SmogWatch WatchKit App, UI 部分，只包含了 storyboard, (包括主 UI 和可能的 notification 场景) 以及 asset catalog 。</li>
<li>SmogWatch WatchKit Extension, 包含所有的 WatchKit 代码</li>
</ul>
<p>在导航栏中选择 “SmogWatch WatchKit App” 目标运行。</p>
<img src="/images/sim-new-app.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h1 id="设计模板"><a href="#设计模板" class="headerlink" title="设计模板"></a>设计模板</h1><p>如上文所提，为了让事情更简单，我们只是实现 Modular Small 和 Circular Small complication 家族。不过默认情况下所有的 complication 家族都是启用的，所以你需要禁用掉其他的。</p>
<p>打开 “SmogWatch WatchKit Extension” target 的配置页，在 “General” tab 你会看见一个可以触发 complication 家族的列表：</p>
<img src="/images/enabled-complications.png" width="68%" height="68%" style="margin: 10 auto;">

<p>接下来，要确定每个 complication 家族要采用什么模板。在 <a href="https://developer.apple.com/documentation/clockkit">CloudKit 文档</a> 中，找到 Modular Small 家族。在它的页面上，你会看到 7 种可用的模板类以及它们的效果截屏。</p>
<p>在我们的案例中，我们主要显示小数字，所以下面几种选项可能是合理的：</p>
<ul>
<li>显示数字，例如 “75” - 可读性没问题，但是第一眼看数字代表什么不明显</li>
<li>以一个圆来显示数字 - 弧应该怎么算，没有上限怎么办？</li>
<li>以上面是图标，下面是数字的方式显示</li>
<li>以两行文本显示</li>
</ul>
<p>最后，我选择了像下面这样的样式：</p>
<img src="/images/modular-small.png" width="10%" height="10%" style="margin: 10 auto;">

<p>这个方案解决了展示 app 是什么的类型，同时也支持解释不同类型参数的问题，缺陷是使得字体更小了，尤其是 3 个数字的情况。尽管仍然可读，但是 Circular Small 版本肯定效果不好。因此，对于 Circular Small ，选项相似，也选择了两行文本的版本。</p>
<img src="/images/circular-small.png" width="7%" height="7%" style="margin: 10 auto;">

<p>上面这个可读性差很多，但是 Circular Small 是非常通用的 complication 家族，因此基本上对所有使用者都是一个挑战。Apple 自己的 complications ，比如世界时钟，日出、日落，看起来也没有好多少。我们这里可以放弃 “PM” ，但这样一来又搞不清 app 是干什么用的，所以折中，把 “PM10” 缩短为 “PM” 。有可能上面用图标效果会更好，读者可以尝试一下。</p>
<hr>
<h1 id="实现-Complication-数据源"><a href="#实现-Complication-数据源" class="headerlink" title="实现 Complication 数据源"></a>实现 Complication 数据源</h1><p>现在，打开样板代码 <code>ComplicationController</code> 类，这里已经数据源协议所有要求的方法了，一些是空实现，但其中大多数我们并不需要。</p>
<p>注意，所有的方法都是通过一个 handler callback 返回数据的。这使得你可以通过某些异步的方式加载要求的数据 —— 理论上，你是可以按需在用到时再加载这些数据，但实际上我们绝不应该这么做。 </p>
<p>所有的方法都传入一个 CLKComplication 对象作为参数，它让你知道系统现在正为哪一种 complication 向你询问数据，这个对象只有一个字段叫 family ，这意味着在一个 Modular 表盘上，你无法区分同族的两个 complication 实例，但是不同族的可以。</p>
<p>因此，这个信息绝对是必须的 —— 不仅因为不同家族外观看起来不一样，也是为了让编译器匹配你返回的模板类型。</p>
<p><code>CLKComplicationDataSource</code> 协议里只有 <code>getSupportedTimeTravelDirections</code> 和 <code>getCurrentTimelineEntry</code> 两个方法是必须得实现的，但我们会先从一个可选的方法开始讲。</p>
<h1 id="样例模板"><a href="#样例模板" class="headerlink" title="样例模板"></a>样例模板</h1><p>我们要看的第一个方法是 <code>getLocalizableSampleTemplate</code> ，在文件的底部 —— 你有可能会需要在把 complication 添加到表盘之前先实现这个方法。</p>
<p>这个方法让你返回一个 complication 的 “样例” 外观，它是当用户在表盘配置视图中设置 complication 时用到的。这里应当展示一些随机数据，表现你的 complication 一般情况下的外观，就像你在应用的网站或者应用商店上放的截图那样的东西。</p>
<p>在这个方法中，我们需要返回一个 <code>CLKComplicationTemplate</code> 对象 —— 在实际的 timeline 中，我们也会返回一样的东西。不过这里不指定时间戳。对于两种 complication 家族，我们都用标准的 <code>CLKSimpleTextProvider</code> 来封装返回的文本。 在样例模板里，我们用 “50” 来代替真实值。</p>
<p>下面是代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLocalizableSampleTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTemplate?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"50"</span>)</span><br><span class="line">        handler (template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"50"</span>)</span><br><span class="line">        handler (template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>记得总是返回匹配给定 complication 家族的模板。不幸的是，好像没有可以在编译期检查这个过程的机制。</p>
<p>这里，我们为两种家族都选用了 “stack text” 模板，因此都有 <code>line1TextProvider</code> 和 <code>line2TextProvider</code> 属性。如果你选择另外的配置的话，可能的属性有 <code>imageProvider</code> ， <code>headerTextProvider</code> ， <code>ringStyle</code> 等等。</p>
<p>如果系统向我们请求其他我们不支持的 complication 类别的话，我们在默认 case 抛出断言 —— 但这不应该发生，因为我们已经禁用所有其他类型的 complication 。用 <code>preconditionFailure</code> 触发崩溃是为了确保自己不忘掉一些东西，最终版本其实应该返回 nil 更安全。</p>
<p>之所以先说这部分，是因为无论你在这个模板返回了什么，它都会被系统缓存。如果你改变了代码再次运行，你不会看到任何效果 —— 你需要从模拟器中删除 app ，重新安装以便更新版本。</p>
<p>现在，当你运行 app ，你可以编辑表盘（通过用力按压 MacBook 的 touchpad ，或者在菜单 Hardware &gt; Touch Pressure），选择一个 complication 空间，并且选择你的 complication ：</p>
<img src="/images/watch-face-editing-1.png" width="25%" height="25%" style="margin: 10 auto;">

<p>注意，默认你的 app 名是 app target 的完整名，这会有点长。为了把它改成更可读的，打开 WatchKit app target 的 <code>Info.plist</code> (注意，是 app 而不是 extension 的) 然后把 “Bundle display name” 改成 “SmogWatch” 。</p>
<p>当你退出编辑模式并返回表盘，你会看到你放置 complication 的地方有一个空白的空间 —— 别急，我们接下来就着手处理这块。</p>
<h1 id="getSupportedTimeTravelDirections"><a href="#getSupportedTimeTravelDirections" class="headerlink" title="getSupportedTimeTravelDirections"></a>getSupportedTimeTravelDirections</h1><p>这个方法告知系统你的 app 在过去、未来、两个方向或者只有当前时刻拥有数据。因为之前提到过去的数据已经不再使用了，所以只有返回 <code>.forward</code> 或者空列表是有意义的。由于我们并不需要预测未来的空气质量，所以我们只需要返回一个空的列表：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSupportedTimeTravelDirections</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimeTravelDirections)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    handler ([])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里返回的东西决定了系统是否会调用 <code>getTimelineStartDate</code> ， <code>getTimelineEndDate</code> ， <code>getTimelineEntries (for:before:limit:withHandler:)</code> 和 <code>getTimelineEntries (for:after:limit:withHandler:)</code> 这些方法，以询问你 timeline 在两个方向上延展的长度，时点。如果我们返回 <code>[]</code> ，那么系统只会询问当前时点。</p>
<p>不过这些方法都是可选的，所以如果你都不实现它们， watchOS 会假定当前时点没有什么有趣的东西。</p>
<h1 id="getCurrentTimelineEntry"><a href="#getCurrentTimelineEntry" class="headerlink" title="getCurrentTimelineEntry"></a>getCurrentTimelineEntry</h1><p>这是整个协议核心的代码，它是我们返回最新数据点的地方。</p>
<p>timeline 数据是以一个或者多个 <code>CLKComplicationTimelineEntry</code> 对象返回的。一个 timeline 实体其实就是一个时间戳加上一个或者多个指派的数据 provider ，里面填充着你需要的数据。实体借由时间戳验证。</p>
<p>目前我们还没有实际拥有数据，不过别担心 —— 我们可以先返回一个静态数值，比如 75 ，就像样例模板中的做法一样。我们使用当前时间作为时间戳，因为根据前面方法返回的设定，我们不会被询问任何在当前时点之前的时段数据。</p>
<p>下面是 <code>getCurrentTimelineEntry</code> 的初始版本:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentTimelineEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimelineEntry?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> entry: <span class="type">CLKComplicationTimelineEntry</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"75"</span>)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: <span class="type">Date</span>(), complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"75"</span>)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: <span class="type">Date</span>(), complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    handler (entry)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当你添加了以上两个方法，编译运行你的 app 到模拟器。你应该会在 complication 里看到我们配置的模板和数值：</p>
<img src="/images/watch-complication-75.png" width="25%" height="25%" style="margin: 10 auto;">

<p>如果你还是没有看到效果，那可能是因为系统缓存了之前编译版本的状态。为了强制加载 complication ，你可以进入编辑模式，切到不同的 complication ，退出编辑模式。 然后再进入编辑模式，切回你的 complication 。</p>
<h1 id="可选的方法"><a href="#可选的方法" class="headerlink" title="可选的方法"></a>可选的方法</h1><p>在数据源协议中还有一些其他的协议，但针对我们的用途，我们只需要用到 <code>getTimelineEntries (for:after:limit:withHandler:)</code> 。这个方法询问我们早前传入的 timeline 时点之后的时点。当我们写的 app 需要提前了解某个时点时，会用到这个方法。例如，天气预报，日历事件，todo list 上预定的任务等。不过，大部分 app 只需要显示当前实体就够了。</p>
<p>我们在这个 app 中使用这个 API 的作用是，我们很可能需要在时点过去之后将未来版本的数据标记为过时。如果你查看的是 6 个小时前的空气质量，它很可能是没什么价值的，因为当前的空气很有可能已经发生显著的变化。在 Krakow ，这种变化可能发生在 2 个小时内。例如，起风或者风停了。所以，我们可能在几小时后自动隐藏掉当前数值，借助添加一个几小时后的 “重置” 数据来实现。如果我们成功地在每个小时更新了数据，那么备选的第二个时点的数据永远不会被展示，但是如果有些东西出错了，那么当时间变化足够长，会在时点到来时借助这个 API 来更新数据。</p>
<p>我认为 watchOS 之前应该也是这么干的，至少在 Time Travel 功能里是这么做的 —— 文档里也提到了。不过这本该是 <code>getTimelineStartDate</code> 和 <code>getTimelineEndDate</code> 方法存在的意义 —— 但是由于这两个 API 不起作用 (Time Travel)，所以实现它们也没意义。 </p>
<hr>
<h1 id="从网络上获取真实数据"><a href="#从网络上获取真实数据" class="headerlink" title="从网络上获取真实数据"></a>从网络上获取真实数据</h1><p>对于第一个版本，我们用使用 Małopolska 地区空气监控系统的公共数据 (仅限波兰) 。</p>
<p>前端通过一个挺复杂的 POST 请求，发送到 URL <a href="http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz">http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz</a> ，然后解析返回的 Json 数据。</p>
<p>这个主题并不是跟 watchOS 特定相关，它是特定于 web API —— 所以这里不详细描述，下面是拉取和解析数据的完整代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">DataURL</span> = <span class="string">"http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KrakowPiosDataLoader</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> d = <span class="type">DateFormatter</span>()</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 不确定下面是否必须，安全起见 </span></span><br><span class="line">        <span class="comment">//see https://developer.apple.com/library/archive/qa/qa1480/</span></span><br><span class="line">        d.locale = <span class="type">Locale</span>(identifier: <span class="string">"en_US_POSIX"</span>)</span><br><span class="line"> </span><br><span class="line">        d.dateFormat = <span class="string">"dd.MM.yyyy"</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 确保我们用的是 CET 时区 —— 比如说你是在莫斯科 </span></span><br><span class="line">        <span class="comment">// 你在 2 月 19 号午夜之后请求 19.02.2019 （这时候在波兰还是 2 月 18 号）</span></span><br><span class="line">        <span class="comment">// 你将拿不到数据 </span></span><br><span class="line">        d.timeZone = <span class="type">TimeZone</span>(identifier: <span class="string">"Europe/Warsaw"</span>)!</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    }()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> dataStore = <span class="type">DataStore</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> session: <span class="type">URLSession</span> = {</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.ephemeral</span><br><span class="line">        config.timeoutIntervalForResource = <span class="number">10.0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: config)</span><br><span class="line">    }()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">queryString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> query: [<span class="type">String</span>: <span class="type">Any</span>] = [</span><br><span class="line">            <span class="string">"measType"</span>: <span class="string">"Auto"</span>,</span><br><span class="line">            <span class="string">"viewType"</span>: <span class="string">"Parameter"</span>,</span><br><span class="line">            <span class="string">"dateRange"</span>: <span class="string">"Day"</span>,</span><br><span class="line">            <span class="string">"date"</span>: dateFormatter.string (from: <span class="type">Date</span>()),</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//hardcoded ID for PM10 on a specific station</span></span><br><span class="line">            <span class="comment">//we'll make it configurable later</span></span><br><span class="line">            <span class="string">"viewTypeEntityId"</span>: <span class="string">"pm10"</span>,</span><br><span class="line">            <span class="string">"channels"</span>: [<span class="number">148</span>]</span><br><span class="line">        ]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> jsonData = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.data (withJSONObject: query, options: [])</span><br><span class="line">        <span class="keyword">let</span> json = <span class="type">String</span>(data: jsonData, encoding: .utf8)!</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//don't ask me, that's what the API expects</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"query=\(json)"</span></span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(<span class="keyword">_</span> completion: @escaping <span class="params">(Bool)</span></span></span> -&gt; ()) {</span><br><span class="line">        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="type">DataURL</span>)!)</span><br><span class="line">        request.httpBody = queryString ().data (using: .utf8)!</span><br><span class="line">        request.httpMethod = <span class="string">"POST"</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: sending request to %@ with %@ ..."</span>,</span><br><span class="line">            <span class="type">DataURL</span>, queryString ())</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> task = session.dataTask (with: request) { (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = error {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: received error: %@"</span>, <span class="string">"\(error)"</span>)</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: received response: %@"</span>,</span><br><span class="line">                    data != <span class="literal">nil</span> ? <span class="string">"\(data!.count) bytes"</span> : <span class="string">"(nil)"</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data = data {</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> obj = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject (with: data, options: []) {</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> json = obj <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] {</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> data = json [<span class="string">"data"</span>] <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] {</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> series = data [<span class="string">"series"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]] {</span><br><span class="line"> </span><br><span class="line">                                <span class="comment">//there would be more than one data series if we passed</span></span><br><span class="line">                                <span class="comment">//multiple "channel IDs" (e.g. for more than 1 station)</span></span><br><span class="line">                                <span class="keyword">if</span> <span class="keyword">let</span> first = series.first {</span><br><span class="line">                                    <span class="keyword">if</span> <span class="keyword">let</span> points = first [<span class="string">"data"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>]] {</span><br><span class="line"> </span><br><span class="line">                                        <span class="comment">//the data series is an array of up to 26 hourly</span></span><br><span class="line">                                        <span class="comment">//measurements; we only take the last one for now</span></span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> point = points.last {</span><br><span class="line">                                            <span class="keyword">let</span> date = <span class="type">Date</span>(</span><br><span class="line">                                                timeIntervalSince1970: <span class="type">Double</span>(point [<span class="number">0</span>])!</span><br><span class="line">                                            )</span><br><span class="line">                                            <span class="keyword">let</span> value = <span class="type">Double</span>(point [<span class="number">1</span>])!</span><br><span class="line"> </span><br><span class="line">                                            <span class="keyword">self</span>.dataStore.currentLevel = value</span><br><span class="line">                                            <span class="keyword">self</span>.dataStore.lastMeasurementDate = date</span><br><span class="line"> </span><br><span class="line">                                            <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: saving data: "</span> +</span><br><span class="line">                                                <span class="string">"%.0f at %@"</span>, value, <span class="string">"\(date)"</span>)</span><br><span class="line"> </span><br><span class="line">                                            success = <span class="literal">true</span></span><br><span class="line">                                        }</span><br><span class="line">                                    }</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> !success {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: no data found"</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            completion (success)</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        task.resume ()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不要忘记在最后用 <code>resume ()</code> 启动任务。</p>
<h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul>
<li>我们向 API 请求 PM10 的数据，硬编码请求当天和特点地点。</li>
<li>我们只取最后的测量结果 (多数情况下是最近一两个小时的数据)</li>
<li>如果我们拿到数据，存储一个数字，表示 PM10 的浓度，以及测量的时间点</li>
<li>通知调用方我们拿到或者没有拿到数据</li>
</ul>
<p>上面的代码用了老式的 Json 解析方法，因为我认为这样比较容易理解。</p>
<p>我用老式的 <code>NSLog</code> 而不是 Swift 的 <code>print ()</code> ，是因为后者只会显示在 Xcode 的控制台，并不会记录到系统日志，所以在控制台 app 的诊断日志里看到，在某些情况下你需要在 app 没有连接 mac 时跟踪它的行为。</p>
<p>还有，注意我们是在前台请求数据，用最基本的 URL session 。这不是通常我们最理想的应用方案 —— 理想的，所有的请求都应该是在后台 URL sessions 中完成，不过这里只是一个最小可用原型，先保持这样吧。</p>
<p>不过我们通过把超时时间设置为每次请求不超过 10 秒钟来限制了 URL session。 这里 <code>timeoutIntervalForResource</code> 的用法，而不是 <code>timeoutIntervalForRequest</code> 或者 <code>timeoutInterval</code> 很重要，因为自上一次接收到数据包后，后面两个只会在空闲时间工作，而我们希望控制总的请求时间。之所以要控制总时间，是因为看起来这里边有一个针对后台任务的硬性限制，并且没有在文档中提到：如果一个 app 超出了 15 秒的后台运行时间，它会被立即杀死，崩溃报告如下：</p>
<blockquote>
<p>Termination Reason: CAROUSEL, Background App Refresh watchdog transgression. Exhausted wall time allowance of 15.00 seconds. Termination Description: SPRINGBOARD, CSLHandleBackgroundRefreshAction watchdog transgression: eu.mackuba.SmogWatch.watchkitapp.watchkitextension exhausted real (wall clock) time allowance of 15.00 seconds (…)</p>
</blockquote>
<p>为了便于你了解最后一次检测的时间点，我们把 <code>lastMeasurementDate</code> 时间戳存进了 <code>DataStore</code> ，这是一个我们可以用来实现之前提到的 “过时数据 特性的潜在结构。</p>
<p>那么这个 <code>DataStore</code> 究竟是什么？其实只是 <code>UserDefaults</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">CurrentLevelKey</span> = <span class="string">"CurrentLevel"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">LastMeasurementDate</span> = <span class="string">"LastMeasurementDate"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataStore</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> defaults = <span class="type">UserDefaults</span>.standard</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Double?</span> {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> defaults.object (forKey: <span class="type">CurrentLevelKey</span>) <span class="keyword">as</span>? <span class="type">Double</span> }</span><br><span class="line">        <span class="keyword">set</span> { defaults.<span class="keyword">set</span>(newValue, forKey: <span class="type">CurrentLevelKey</span>) }</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> lastMeasurementDate: <span class="type">Date?</span> {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> defaults.object (forKey: <span class="type">LastMeasurementDate</span>) <span class="keyword">as</span>? <span class="type">Date</span> }</span><br><span class="line">        <span class="keyword">set</span> { defaults.<span class="keyword">set</span>(newValue, forKey: <span class="type">LastMeasurementDate</span>)}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后，我们需要添加一个例外域名到 WatchKit Extension target 的 App Transport Security 设置中，因为这个域名不支持 Https 。</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionDomains<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>monitoring.krakow.pios.gov.pl<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionAllowsInsecureHTTPLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="显示真实数据"><a href="#显示真实数据" class="headerlink" title="显示真实数据"></a>显示真实数据</h1><p>为了实际加载数据，我们需要在某个地方调用这个类的方法。我们来看一看 <code>ExtensionDelegate</code> 这个类，它实现了 <code>WKExtensionDelegate</code> —— 基本上就是一个 WatchKit 版本的 <code>UIApplicationDelegate</code> 。就像所有的 app 代理， <code>WKExtensionDelegate</code> 有许多生命周期方法，这些方法会被系统在各种时刻调用： <code>applicationWillEnterForeground</code> ， <code>applicationDidBecomeActive</code> ， <code>applicationWillResignActive</code> 和 <code>applicationDidEnterBackground</code> 等等。</p>
<p>这里头我们目前唯一会用到的是 <code>applicationDidFinishLaunching</code> 。这个方法会在 app 进程启动时被调用 —— 无论是通过 app launcher 或者通过 Xcode ，又或者从后台启动。只要是 app 需要被唤起，并且之前已经被系统清理掉的时候，这个周期都会运行 (通常在晚上，被系统杀死的情况经常发生) 。</p>
<p>无论何时， app 启动或者在后台重启，我们都希望借助这个机会立即拉取最新的数据，如果我们得到响应，重新加载所有活动的 complication （活动的 complication 指那些在当前选择的表盘上显示的 complication）。</p>
<p>所以我们将这样做：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: applicationDidFinishLaunching ()"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> success {</span><br><span class="line">            <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了拉取数据，我们调用了 KrakowPiosDataLoader 类，然后在有任何新数据的情况下重载加载 complications ，否则的话就不必了。在 watchOS 上，不要浪费时间做无用功，这是一条通用的准则。</p>
<p>为了重新加载 complications ，我们得拿到活动 complication 的列表，这是借由全局共享的  <code>CLKComplicationServer</code> 实例来获得的，并且也通过它的 <code>reloadTimeline (for:)</code> 方法来重新加载那些活动的 complication 。如果打算在已经存在的 timeline 实体后追加新的 timeline 实体，我们也可以用另一个相似方法  <code>extendTimeline (for:)</code> ，两者的区别是前者我们希望立刻用新数据替换掉之前的数据。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadActiveComplications</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">let</span> server = <span class="type">CLKComplicationServer</span>.sharedInstance ()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> complication <span class="keyword">in</span> server.activeComplications ?? [] {</span><br><span class="line">        server.reloadTimeline (<span class="keyword">for</span>: complication)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码会触发一轮对你的 <code>CLKComplicationDataSource</code> 的调用 —— 有的时候是一会之后，不过通常几乎都是立刻发生。现在我们有了真实数据，我们可以回到之前写的 <code>getCurrentTimelineEntry</code> 方法，然后把占位的代码替换成实际的逻辑：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentTimelineEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimelineEntry?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> store = <span class="type">DataStore</span>()</span><br><span class="line">    <span class="keyword">let</span> entry: <span class="type">CLKComplicationTimelineEntry</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> valueLabel: <span class="type">String</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> lastMeasurement = store.lastMeasurementDate, <span class="keyword">let</span> level = store.currentLevel {</span><br><span class="line">        valueLabel = <span class="type">String</span>(<span class="type">Int</span>(level.rounded ()))</span><br><span class="line">        date = lastMeasurement</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        valueLabel = <span class="string">"--"</span></span><br><span class="line">        date = <span class="type">Date</span>()</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: valueLabel)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: date, complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: valueLabel)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: date, complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    handler (entry)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在，当我们运行 app 时，点击 home 按钮返回表盘时，我们会看到一个刚刚借助 API 加载的真实数据：</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">ExtensionDelegate: applicationDidFinishLaunching ()</span><br><span class="line">KrakowPiosDataLoader: sending request to http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz with</span><br><span class="line">query={"viewTypeEntityId": "pm10", "measType": "Auto", "viewType": "Parameter", "dateRange": "Day",</span><br><span class="line">"date": "24.02.2019", "channels": [148]} ...</span><br><span class="line">KrakowPiosDataLoader: received response: 1553 bytes</span><br><span class="line">KrakowPiosDataLoader: saving data: 46.4462 at 2019-02-24 10:00:00 +0000</span><br></pre></td></tr></tbody></table></figure>
<img src="/images/watch-complication-46.png" width="34%" height="34%" style="margin: 10 auto;">

<hr>
<h1 id="安排更新"><a href="#安排更新" class="headerlink" title="安排更新"></a>安排更新</h1><p>最后的拼图是确保我们可以按照有规律的间隔加载新的数据并重新加载 complication 。有一些场景你可以更新 complications ：</p>
<ul>
<li>当你的 app 处于前台时，你总是可以做这件事 —— 但你无法依赖它定期发生。</li>
<li>当你接受到一些静默的推送通知时，尤其是专门为这种用途设计的 (借助 PushKit framework ，采用  PKPushTypeComplication 类型) —— 当你的数据以不规则间隔更新时，这种机制会有用 —— 当外部发生一些事件时。</li>
<li>当 iPhone app 以某种方式接收到新的数据并把它传输给 watch 时</li>
<li>通过计划定期的后台刷新 —— 当你希望拉取数据而不是被动等推送时，这种方式更好。</li>
</ul>
<p>注意，不管你采用哪种策略，对于我们刷新数据的频率以及完成刷新的用时，有许多限制。 (比如，每天不超过 50 个推送通知) —— 如果你用尽了所有的时间或者每天可用的推送数量，你将无法再在后台运行，有可能要等到第二天。对于这点约束，看起来没有什么特别好的方案可以绕过，你也不应该尝试去寻找这类方案。</p>
<p>既然我们知道城市监测站每小时发送一次新的测量数据，我们会使用计划好的后台刷新来更新我们的 complication ，并且会在 <code>ExtensionDelegate</code> 中完成。</p>
<p>为了确保我们的 app ，我们需要实现一样我称为 “后台刷新循环” 的东西：当 app 启动或者重启时，我们安排一次后台刷新，然后当 app 被这个后台刷新唤起时，我们做的第一件事就是安排下一次后台刷新，以确保若干时间后总有新的刷新被计划。</p>
<p>我们会在所有其他事情之前开始做刷新计划，因为我们无法知道在我们的 app 被挂起或者杀死之前还有多少可用的时间。否则，如果在我们设置下一次刷新之前 app 就被挂起，那么 app 就相当于没设闹钟就睡过去了，那么它将会睡过头。 😉</p>
<p>现在，让我们再看一下 <code>applicationDidFinishLaunching</code> 方法，我们需要在 web 请求发送之前增加一个新的方法调用 <code>scheduleNextReload ()</code> :</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: applicationDidFinishLaunching ()"</span>)</span><br><span class="line"> </span><br><span class="line">    scheduleNextReload ()</span><br><span class="line"> </span><br><span class="line">    <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> success {</span><br><span class="line">            <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="计算下一次刷新时间"><a href="#计算下一次刷新时间" class="headerlink" title="计算下一次刷新时间"></a>计算下一次刷新时间</h1><p>在计划下一次刷新前，我们首先需要定出下一次刷新的时机。</p>
<p>为了优化后台刷新的耗时，尽可能利用好珍贵的后台时间，思考清楚我们的数据究竟需要在何时和以何种频率改变。一个很好的例子是 —— 证券交易只发生在工作时间，不在工作时间内，股票价格不会变化，所以在夜间重载不会改变的数据是没有意义的。</p>
<p>我对获取数据的 API 做了一些测试，新的数据几乎总是 1 个整小时的 0 到 10 分钟内添加。所以我决定每小时请求一次刷新，总是在每小时的 15 分做这件事 (10:15 ， 然后 11:15， 然后 12:15 ，以此类推)。为了实现这种方式，我们需要一个辅助方法来让我们基于当前时间找到最接近 xx:15 的时间 —— 幸运的是，利用 NSCalendar API 很容易做到：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextReloadTime</span><span class="params">(after date: Date)</span></span> -&gt; <span class="type">Date</span> {</span><br><span class="line">    <span class="keyword">let</span> calendar = <span class="type">Calendar</span>(identifier: .gregorian)</span><br><span class="line">    <span class="keyword">let</span> targetMinutes = <span class="type">DateComponents</span>(minute: <span class="number">15</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> nextReloadTime = calendar.nextDate (</span><br><span class="line">        after: date,</span><br><span class="line">        matching: targetMinutes,</span><br><span class="line">        matchingPolicy: .nextTime</span><br><span class="line">    )!</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果和当前时间间隔小于 5 分钟，那么跳过，尝试下一个小时 </span></span><br><span class="line">    <span class="keyword">if</span> nextReloadTime.timeIntervalSince (date) &lt; <span class="number">5</span> * <span class="number">60</span> {</span><br><span class="line">        nextReloadTime.addTimeInterval (<span class="number">3600</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> nextReloadTime</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="计划后台刷新"><a href="#计划后台刷新" class="headerlink" title="计划后台刷新"></a>计划后台刷新</h1><p>最后，为了在计算好的未来时点请求更新，我们需要在 <code>WKExtension</code> (等价于 <code>UIApplication</code>) 上调用  <code>scheduleBackgroundRefresh</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleNextReload</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">let</span> targetDate = nextReloadTime (after: <span class="type">Date</span>())</span><br><span class="line"> </span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: scheduling next update at %@"</span>, <span class="string">"\(targetDate)"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="type">WKExtension</span>.shared ().scheduleBackgroundRefresh (</span><br><span class="line">        withPreferredDate: targetDate,</span><br><span class="line">        userInfo: <span class="literal">nil</span>,</span><br><span class="line">        scheduledCompletion: { <span class="keyword">_</span> <span class="keyword">in</span> }</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你传入的日期是你希望你的 app 被唤起的时间。当然，系统会把它看做一种提示 —— 你的 app 实际被唤起的时间还可能取决于各种因素（我猜测这其中包含电量，充电状态，网络访问，你请求刷新的频率，你每次刷新的耗时，等等）。所以，不要假定你的 app 总是能在固定的间隔运行。</p>
<p>不过，基于我的测试，在实践中一个拥有一个活动 complication ，每隔一个小时更新的 app ，通常在 10 秒以后的请求时间，在白天的表现比在夜间充电的表现要好很多，或者 app 运行频繁，或者 app 处于 dock 但是没有 complication 时，后台任务被调用的机会更少。不在 dock 也不没有 complication 的 app ，几乎不被调用。</p>
<p><code>scheduledCompletion</code> 块在文档中被描述为 “A block that is called by the system after the background app refresh task has completed” ，但是实际上它是在下一个刷新任务计划完成时就被立即执行。不过由于它是一个可选的参数，你可以提供一个空的块。至于 <code>userInfo</code> ，它可以传递一些元数据给后台任务的 handler ，但这里我们用不上。</p>
<h1 id="处理后台任务"><a href="#处理后台任务" class="headerlink" title="处理后台任务"></a>处理后台任务</h1><p>watchOS 上的后台刷新是通过在各种时刻从后台唤起你的 app ，然后调用代理方法 <code>handle (_ backgroundTasks:)</code> ，传给它一个或者多个取决于上下文的 “后台任务”。这个方法对于你的 app 后台事务至关重要，不管你构建的 app 是什么类型，几乎一定要在这里做些事情。</p>
<p>任务的类型有不少，但你应当做跟当时接收到的任务相关的工作。比如有的任务是处理 URLSession 返回的数据，有的任务是处理 iPhone 返回的数据，有的任务是处理 Siri 快捷方式，但是这里我们要处理的是一种通过之前的 <code>scheduleBackgroundRefresh</code> 发起的任务 —— 这是一种最普通的 <code>WKApplicationRefreshBackgroundTask</code> 。这种任务意味着你的 app 是由于你自己的请求而被唤起的，以便你可以运行一些后台的 URL 请求，更新你的 complication 等等。</p>
<p>当 app 在后台被唤起时，在 <code>handle (_ backgroundTasks:)</code> 方法中，我们做的事情跟启动时的差不多 —— 我们计划下一次刷新，并尝试更新数据。注意，我们只用了 <code>WKApplicationRefreshBackgroundTask</code> ，忽略其他的任务类型。不过，在完成任务后，记得总是调用 <code>setTaskCompletedWithSnapshot ()</code> 方法，这很关键，即便对于那些被你忽略掉并且不处理的任务。不过，调用这个方法表明我们的事干完了，在这之后我们的 app 可能会被挂起。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(<span class="keyword">_</span> backgroundTasks: Set&lt;WKRefreshBackgroundTask&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> backgroundTasks {</span><br><span class="line">        <span class="keyword">switch</span> task {</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> backgroundTask <span class="keyword">as</span> <span class="type">WKApplicationRefreshBackgroundTask</span>:</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: handling WKApplicationRefreshBackgroundTask"</span>)</span><br><span class="line"> </span><br><span class="line">            scheduleNextReload ()</span><br><span class="line"> </span><br><span class="line">            <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> success {</span><br><span class="line">                    <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">                }</span><br><span class="line"> </span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: completed WKApplicationRefreshBackgroundTask"</span>)</span><br><span class="line">                backgroundTask.setTaskCompletedWithSnapshot (<span class="literal">false</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            task.setTaskCompletedWithSnapshot (<span class="literal">false</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>让 watchOS 模拟器运行 app 后台刷新任务需要一些技巧，即使你已经安排它们在一会之后运行。如果你测试时发现不工作，可以尝试随机切换 app ，主屏和表盘，直到后台刷新任务可以工作。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就这些，我们完成了！🎉 我们得到一个每小时运行的 app ，从 web API 加载新数据，显示到你选择的表盘上，你只要抬腕就能看到它。</p>
<p>依我看来，为了构建一个带 complication 的最小可行的 watch app ，你需要做这些事：</p>
<ol>
<li>确定你的 app 想要在 complication 上展示的最重要的东西。</li>
<li>确定你的 complication 内容什么时候改变，你的 timeline 存放什么以及存在哪里。</li>
<li>浏览 complication 家族以及对应可用的模板，确定哪些最适合你</li>
<li>实现从 web 或者系统 API 加载数据的代码</li>
<li>实现 complication 数据源要求的方法，以构建 <code>CLKComplicationTimelineEntry</code> 和 <code>CLKComplicationTemplate</code> 对象，以合适的方式展示你的内容。</li>
<li>确保你的 app 定期更新，用计划的后台刷新或者借助推送通知 (分析你的数据变化的模式，以便优化后台时间)</li>
<li>测试，测试，再测试，用任何你能想到的场景和组合 🙂</li>
</ol>
<p>如果你只是构建一个静态的 complication ，永远不更新，就像 Apple 的 “launcher” 型的 complications ， 比如 Breathe ， Maps ， Reminders 等等。那么，你只需要做这些事：</p>
<ol>
<li>为所有支持的 complications 挑选一个图标。</li>
<li>实现数据源方法，用 “single icon” 模板返回单一实体的 timeline 。</li>
</ol>
<p>这种情况下你不需要计划后台刷新以更新 complication ，因为它永远不变。不过，由于 complication 需要链接到真实 app 时，也有大量工作需要做。 😉</p>
<p>工程中的代码可以从这个仓库找到: <a href="https://github.com/mackuba/SmogWatch">https://github.com/mackuba/SmogWatch</a> (master 分支最新代码，或者对应这篇文档的 post2 分支的版本)。 它是 WTFPL-licensed ，所以尽管拿去用，你可以分享给我你都做出什么好玩的东西！</p>
]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>watchOS</tag>
        <tag>development</tag>
      </tags>
  </entry>
  <entry>
    <title>watchOS 学习笔记 | Big Picture</title>
    <url>/development/note-watchos-big-picture/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="watchOS-应用"><a href="#watchOS-应用" class="headerlink" title="watchOS 应用"></a>watchOS 应用</h1><p>相比 macOS，iOS 和 tvOS ，watchOS (目前为止) 并非是完全独立的平台，一定程度上依赖配对的 iPhone 。</p>
<blockquote>
<p>watchOS 6.0 之后，watch app 可以独立发布和安装，也就说，应用生态上可以独立了。但是，某些功能要想发挥最大的效用，还要借助 iPhone 设备的计算能力。毕竟，后者目前还是要强大很多。可以这么理解，当需要用到 watch 本身不具备的硬件能力时，如视频拍摄，你仍可以把 watch 视为控制器。这个跟人们看待早期智能手表的视角一致。</p>
</blockquote>
<h1 id="Watch-app-和扩展"><a href="#Watch-app-和扩展" class="headerlink" title="Watch app 和扩展"></a>Watch app 和扩展</h1><p>watchOS app 跟 iOS app 最显著的差异是前者被严格的分成了两部分。第一部分称为 Watch app —— 有点混淆对吧？正常理解，两部分加起来才是一个完整的 app 。但字面上，这个主要由 UI 构成的部分就叫 Watch app ，所以我们干脆以 UI 来代表，第二个部分是 WatchKit 扩展。两部分有各自独立的数据容器，如果需要共享容器中的文件，需要用到 <strong>App Groups</strong> 。</p>
<p>watch OS 6 引入 SwiftUI 后，情况变得有些复杂。因为 SwiftUI 中，UI 即代码。原来的 watch app 部分只有一个 hosting view 。</p>
<h1 id="这些年-watchOS-的变化"><a href="#这些年-watchOS-的变化" class="headerlink" title="这些年 watchOS 的变化"></a>这些年 watchOS 的变化</h1><p>watchOS 1 中，app UI 运行在 watch 上，但扩展运行在 iPhone 上。扩展可以很容易地与设备上的其他 iOS app 通信，但扩展和 watch UI 之间的通信是设备间的，因此整个 app 运行很慢。</p>
<p>watchOS 2 中，扩展被移到了 watch 上。watch app 和 iOS app 通信需要借助 <strong>WatchConnectivty framework</strong> 。因为扩展处于 watch 上，所以能用到 SDK 自然变少了。当然，后来各种缺失的 SDK 也被陆续添加到 watchOS 中。</p>
<p>watchOS 4 中，扩展和 UI 被合为一个进程运行。当然，这一点对开发者来说相对无感，唯一的效果是 app 运行的更快了。</p>
<p>watch OS 5 以前，WatchKit app 需要依赖 iPhone 的连接来完成大部分通信。它只能连接 iPhone 连接过的 “已知 Wi-Fi 网络” 。watch OS 5 引入了连接全新 WiFi 网络的能力。</p>
<p>在 watch OS 5 及之前的版本，watch app 总是要求有一个伴生的 iOS app 。watch app 是内置在 iOS app bundle 中，它的安装也是通过先安装 iOS app ，再间接下载到 watch 上来完成的。最近的 watch OS 6 ，watch app 真正意义上宣布独立。你既可以采用之前的 iOS app + watch app 的方式， 也可以只开发独立的 watch app 。watch app 不再是内置在 iOS app 中，两者被分隔在各自平台的 App Store 发布。因此，对于因特网的连接方式，最新的建议是 借助 <strong>URLSession</strong> ，<strong>CloudKit</strong> 等直接下载数据到 watch ，只有在真的需要跟 iPhone 交换数据时才用到 <strong>WatchConnectivity</strong> 。</p>
<hr>
<h1 id="多于一个用户接口"><a href="#多于一个用户接口" class="headerlink" title="多于一个用户接口"></a>多于一个用户接口</h1><p>iOS app 通常有一个主要的用户入口。人们想到 iOS app 的时候，通常想到的是主界面上的图标。当然，也有各种扩展可以访问 app 的不同部分，但是通常被认为是主 app 的附属。你使用 app 的主要姿势是打开主 app 。</p>
<p>来到 watchOS ，情况大不相同。主 UI ，根据你的用例，很有可能不是最常被使用的部分。其主要原因在于 iPhone 和 Apple Watch 完全不同的交互模式。你不可能像在 iPhone 上那样在 watch 的屏幕上花很长的时间浏览内容吧？很显然，那很不舒服。</p>
<p>对于 watchOS ，Apple 一直重复的关键词是 <strong>glances</strong> 或者说 <strong>glanceable</strong> 。期望的 app 交互方式是：抬起手腕，看表，做一两个点击（或者甚至都不点击），或者转一下数字表冠，然后放下手腕，回到现实。这一系列动作的平均时间是以秒计的。实际上，建议是在 2 秒内让用户找到目标信息 (glanceable) 或者执行动作 (actionable) 。</p>
<p>如果你用过 watchOS app ，你应该知道通过主 app 找到目标信息需要一点技巧。首先，你要在主屏上那一堆六边形网格中找到 app ，然后点击，等待加载，然后在 app 的不同屏之间寻找你要的东西。基于此，也取决于你的 app 类型，极有可能你的主 UI 只会偶尔被用到。 WatchKit app 实际上提供了一些其他的入口来交互，它们可能更重要。</p>
<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>通知实际上是 watch 的一个绝佳的应用场景。花不到一秒的时间看一眼手表，比从口袋里掏出手机来省事不少吧？许多人会告诉你，他们戴 watch 的主要用途就是看通知。</p>
<p>但是，通知用的好不好，对不对，主要还是取决于你的 app 类型，通知的目的。比如，你的目的是不定期的通知用户某些事情发生了，通知可以是你的 app 很重要的一部分。典型的，提醒事项 app 。</p>
<p>watchOS 上通知的 UI 有三种变体：</p>
<ul>
<li>只有预制的静态信息</li>
<li>非交互式的动态信息</li>
<li>可交互的动态信息，watchOS 5 引入 </li>
</ul>
<p>watch OS 6 允许推送绕过 iPhone ，只到达 Apple Watch 的远程通知。</p>
<h3 id="Glances-Dock"><a href="#Glances-Dock" class="headerlink" title="Glances / Dock"></a>Glances / Dock</h3><p>watchOS 1 开始，引入了一种被叫做 <strong>glance</strong> 的界面，卡片式，可点击，水平滚动。借助 storyboard 上单独的场景构建。</p>
<p>watchOS 3 开始，<strong>glance</strong> 被废弃，由 <strong>dock</strong> 取代，后者是通过按压表侧的长按钮访问。它的工作方式和 glance 相似，但是卡片的外观是基于主 app 的实际 UI (类似 iOS 上的体验)，通过系统对 app 生命周期某些节点的快照来实现。当你完成滚动，选择了某个 app 后，系统会唤醒这个 app ，不久之后这个 app 实际的 live 视图会更新 dock 的静态图片。</p>
<p>watch OS 4 之后，dock 变成竖向滚动，跟 iOS 的体验更相似。</p>
<h3 id="Complications"><a href="#Complications" class="headerlink" title="Complications"></a>Complications</h3><p>“<strong>Complications</strong>“ 是 Apple 给表盘上的各种 widget 取的一个比较有逼格的名字。</p>
<img src="/images/watch-complications.png" width="68%" height="68%" style="margin: 10 auto;">

<p>Complications 有很多不同的家族，为不同的表盘设计 —— 圆形的，矩形的，小的，大的。这些 complictions 的共同点是展示信息的空间极其有限，一直可见（激活状态），因此需要保持最新状态。</p>
<p>你可以想象，complication 的特点是不可能通过让 app 持续运行在后台，并且完全访问表盘的方式来实现的。因为这样做电池撑不住。</p>
<p>Apple 的解决方案是你需要周期性的提前提供一个包含给定时间范围的 <strong>timeline</strong> 数据给 complication 用于显示。系统存储这份数据，到时间点了自动切换到正确的状态。你不能在 complication 里随意显示内容 —— 你只能从给定的 complication 家族中选择预先定义好的模板，然后填充一些精心准备的，允许系统在必要时简化以便适配可用空间的数据。</p>
<p>这里面的一个挑战是：如何找出有用的东西，填充到这么小的空间里 —— 同时这也是一个能简化工作的约束，因为你只有有限的选项。</p>
<p>Apple 一开始就说了，complications 只对部分 app 有意义 —— 因而并非每个 app 都有一些关键信息，可以展示为一个数字或者一行文本。不过，从 watchOS 3 开始，官方建议所有的 app 都实现一个 complication ，即便这个 complication 只是一个静态的启动器。（个人认为这个要求对用户的意义在于，用户可以在表盘上添加特定 app 的 complication ，仅仅作为启动器也是有价值的）。技术层面，系统可以针对当前表格的启动器，做一些优化，以便 app 启动更快。</p>
<h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><p>最后一个入口就是 Siri 了， watchOS 5 以后，Siri 可以用于更多的用例，例如发消息，todo list 等等。</p>
<hr>
<h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://mackuba.eu/2018/12/18/watchkit-adventure-1-the-big-picture/">MacKuba 关于 WatchKit 的文章 1</a></p>
<p><a href="https://mackuba.eu/2019/03/06/watchkit-adventure-2-mvc/">MacKuba 关于 WatchKit 的文章 2</a></p>
<p><a href="https://github.com/mackuba/SmogWatch">MacKuba 的一个 apple watch 项目</a></p>
]]></content>
      <categories>
        <category>development</category>
      </categories>
      <tags>
        <tag>watchOS</tag>
        <tag>development</tag>
      </tags>
  </entry>
  <entry>
    <title>AR | ARKit 概览</title>
    <url>/computer-tech/ar-arkit-overview/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><ul>
<li><strong>运动跟踪 (motion tracking)</strong> 使得手机理解和追踪它相对于世界的位置。</li>
<li><strong>环境理解 (environmental understanding)</strong> 使得手机可以侦测各种表面的尺寸和位置：水平的，竖直的，成一定角度的，比如地面，咖啡桌或者墙面。</li>
<li><strong>光线评估 (light estimation)</strong> 使得手机可以估计环境当前的光照条件。</li>
</ul>
<hr>
<h1 id="ARKit"><a href="#ARKit" class="headerlink" title="ARKit"></a>ARKit</h1><h2 id="ARKit-3"><a href="#ARKit-3" class="headerlink" title="ARKit 3"></a>ARKit 3</h2><p>ARKit 3 带给人们不可思议的体验。通过 People Occlusion，ARKit 3 知道人们和 AR 对象在哪里，并适当地遮挡 scene。ARKit 3 使用 Motion Capture 跟踪人们的运动，将其输入到 AR scene 中。它还可以同时跟踪最多三张人脸，支持 collaborative sessions 等等。</p>
<h4 id="People-Occlusion"><a href="#People-Occlusion" class="headerlink" title="People Occlusion"></a>People Occlusion</h4><p>现在 AR 内容能呈现在人们的身后和前面，使 AR 体验更加沉浸化。同时，在大多数环境能实现绿幕风格的效果。</p>
<h4 id="Motion-Capture"><a href="#Motion-Capture" class="headerlink" title="Motion Capture"></a>Motion Capture</h4><p>用一台相机实时捕捉人们的运动。通过将人们身体的位置和运动，理解为一系列关节和骨骼，您可以使用运动和姿势作为 AR 体验的输入 —— 将人们放置在 AR 的中心。</p>
<h4 id="Simultaneous-Front-and-Back-Camera"><a href="#Simultaneous-Front-and-Back-Camera" class="headerlink" title="Simultaneous Front and Back Camera"></a>Simultaneous Front and Back Camera</h4><p>现在，你可以在前置和后置摄像头上同时使用人脸和世界跟踪。例如，用户可以只使用他们的脸部，与后置摄像头的 AR 内容交互。</p>
<h4 id="Multiple-Face-Tracking"><a href="#Multiple-Face-Tracking" class="headerlink" title="Multiple Face Tracking"></a>Multiple Face Tracking</h4><p>现在 ARKit 人脸跟踪可以一次跟踪最多三张人脸，使用 iPhone X, iPhone XS, iPhone XS Max, iPhone XR 和 iPad Pro 的 TrueDepth 摄像头。该摄像头为 Memoji 和 Snapchat 等前置摄像头的体验提供能力。</p>
<h4 id="Collaborative-Sessions"><a href="#Collaborative-Sessions" class="headerlink" title="Collaborative Sessions"></a>Collaborative Sessions</h4><p>通过多人之间的实时协作会话，您可以构建一个协作的 world map，让您更快地开发 AR 体验，让用户像进入多人游戏一样，更快地进入共享的 AR 体验。</p>
<h4 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h4><p>一次检测多达 100 幅图像，并自动地估计图像的物理大小。3D 对象检测更加稳定，因为对象在复杂环境中可以更好地被识别。现在，机器学习被用来更快地检测环境中的平面。</p>
<h2 id="Reality-Composer"><a href="#Reality-Composer" class="headerlink" title="Reality Composer"></a>Reality Composer</h2><p>Reality Composer 是一款针对 iOS 和 Mac 的功能强大的新应用，可以轻松创建交互式 AR 体验，而无需 3D 经验。可以使用 live linking ，在您的 Mac、iPhone 和 iPad 之间无缝地移动。 RealityKit 是一个全新的高级框架，包含 photo-realistic 渲染、相机特效、动画、物理等功能，专为 AR 而构建。</p>
<p>现在，任何人都可以快速地原型化和制作 AR 体验的内容，这些内容可以使用 Xcode 集成到应用程序中或者导出到 AR Quick Look 。Reality Composer 让您在 iOS 和 Mac 上构建动画和交互，以丰富您的 3D 内容。</p>
<h4 id="Built-in-AR-Library"><a href="#Built-in-AR-Library" class="headerlink" title="Built-in AR Library"></a>Built-in AR Library</h4><p>导入您自己的 USDZ 文件，或者利用内置 AR 库中数百个现成的虚拟对象。该库为各种 assets 利用 procedural content generation ，您可以自定义虚拟对象的大小、样式等。</p>
<h4 id="Animations-and-Audio"><a href="#Animations-and-Audio" class="headerlink" title="Animations and Audio"></a>Animations and Audio</h4><p>增加移动、缩放等动画，比如虚拟对象的 “摆动” 或 “旋转”。当用户点击对象、靠近对象或触发其他触发器，您可以选择要进行的操作。您还可以利用 spatial audio 为您的 AR 场景添加真实感。</p>
<h4 id="Seamless-Tools"><a href="#Seamless-Tools" class="headerlink" title="Seamless Tools"></a>Seamless Tools</h4><p>Reality Composer 被包含在 Xcode ，也是一款 iOS APP 。因此您可以在 iPhone 或 iPad 上 build 、 test 、 tune 和模拟 AR 体验。利用 live linking ，您可以在 Mac 和 iOS 之间快速切换，创建吸引人的复杂的 AR 体验。</p>
<h4 id="Record-and-Play"><a href="#Record-and-Play" class="headerlink" title="Record and Play"></a>Record and Play</h4><p>有了 iOS 版的 Reality Composer，您可以记录 AR 体验运行位置的传感器和摄像机数据，然后在构建 APP 时在 iOS 上播放这些数据。</p>
<h2 id="RealityKit"><a href="#RealityKit" class="headerlink" title="RealityKit"></a>RealityKit</h2><p>这个全新的高级框架是从头开始创建的，专门用于 AR ，包括 photo-realistic 渲染、相机特效、动画、物理等等。它还有一个 Swift API 。使用集成的 ARKit 、基于物理的渲染、变换和骨骼动画、 spatial audio 和刚体物理， RealityKit 使 AR 开发比以往任何时候都更快、更容易。</p>
<h4 id="World-class-Rendering-RealityKit"><a href="#World-class-Rendering-RealityKit" class="headerlink" title="World-class Rendering RealityKit"></a>World-class Rendering RealityKit</h4><p>使用基于物理的真实材质、环境反射、 grounding shadows 、 camera noise 、 motion blur 等，将虚拟内容与现实世界无缝融合，使虚拟内容与现实世界几乎无法区分。</p>
<h4 id="Scalable-Performance"><a href="#Scalable-Performance" class="headerlink" title="Scalable Performance"></a>Scalable Performance</h4><p>RealityKit 利用最新的 Metal 特性充分利用 GPU ，充分利用 CPU 缓存和多核，提供难以置信的流畅的视觉效果和物理模拟。因为它自动地伸展每个 iOS 设备的 AR 体验的性能，所以您只需要创建一个 AR 体验。</p>
<h4 id="Swift-API"><a href="#Swift-API" class="headerlink" title="Swift API"></a>Swift API</h4><p>容易使用但功能强大的 RealityKit 使用 Swift 丰富的语言特性并提供完整的功能。因此您可以更快地构建增强现实体验，而无需抄模板代码。</p>
<h4 id="Shared-AR-Experiences"><a href="#Shared-AR-Experiences" class="headerlink" title="Shared AR Experiences"></a>Shared AR Experiences</h4><p>RealityKit 使网络开发工作变得简单，例如保持一致的状态、优化网络流量、处理数据包丢失或 performing ownership transfers 。</p>
<hr>
]]></content>
      <categories>
        <category>computer-tech</category>
      </categories>
      <tags>
        <tag>AR</tag>
        <tag>ARKit</tag>
      </tags>
  </entry>
  <entry>
    <title>计算方法 02 | 科学的起源</title>
    <url>/social-science/quantitative-method-origin/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="古典时期-Classical-Period"><a href="#古典时期-Classical-Period" class="headerlink" title="古典时期 (Classical Period)"></a>古典时期 (Classical Period)</h1><p>最早寻求事物的自然或俗世解释而非神的解释的思想家，是古希腊学者泰勒斯 (Thales)、毕达哥拉斯 (Pythagoras) 和德谟克利特 (Democritus) 等人。但最先思考如何获得知识的 是两千三百多年前的柏拉图 (Plato) 和亚里士多德 (Aristotle) 。</p>
<p>对柏拉图来说，外部世界及其中的事物，只是它们理想形式的不完美投射或影子。这些理想形式往往被描绘成在墙上投下影子。</p>
<img src="/images/sci-ori_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>柏拉图是一个 <strong>哲学实在论者 (philosophical realist)</strong> 。他认为 <strong>现实 (reality)</strong> 即理想世界，是独立于人的思想之外存在的。对他来说，这些理想并非只是我们心中的抽象概念，它们真实存在，但独立于物质世界之外。</p>
<p>他认为既然我们看到的物质世界是真实的 <em>不完美投射 (imperfect reflection)</em> ，我们就不能从感官经历中认识到 <strong>现实的本质 (the true nature of reality)</strong> 。他坚信理想形式的知识只能通过推理论证获得。所以柏拉图被称为 <strong>理性主义者 (rationalist)</strong> 。</p>
<p>他的学生亚里士多德也是个实在论者。他认为现实独立存在于人类的思想之外。但对亚里士多德来说，现实就是物质世界，没有单独的抽象形象存在。在如何了解事物本质上，他也与柏拉图意见相左。亚里士多德是 <strong>经验主义者 (empiricist)</strong> 。他认为感官经验准确地代表了现实。所以我们可以用感官去理解现实。他认为，归根结底知识来源于观察。但这并不意味着他仅对观察感兴趣，他依然将推理论证视作了解和解释自然的最佳方式。事实上，他建立了 <strong>形式逻辑 (formal logic)</strong> ，更确切地说是 <strong>三段论 (syllogism)</strong> 。</p>
<img src="/images/sci-ori_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这有一个三段论的例子。</p>
<blockquote>
<p>“所有人都会死去，而所有希腊人都是人类，因此所有希腊人都会死。”</p>
</blockquote>
<p>如果两个前提为真，那么结论必然为真。把此结论当作新三段论的前提，我们就能积累知识。但这只在前提确实为真的情况下成立。看看这个：</p>
<blockquote>
<p>“所有哺乳动物都长毛，而猫都是哺乳动物，所以猫全都长毛。”</p>
</blockquote>
<p>第一个前提是错的，这就意味着结论不一定对，不是积累知识的好基础。</p>
<p>那么如何确保前提是正确的呢？你可以用另一个三段论来证明它。但当然你需要不停地证明这些前提，有一套你认为毫无争议的初始前提。亚里士多德认为，这些 <strong>基础前提 (fundamental premises)</strong> ，可以通过观察世界的基本形式或规律来决定。不巧他并未意识到他的某些观察选择性太强，导致一些基础前提在我们现在看来错得彻彻底底。比如，以他的观察为依据，昆虫有四条腿，男人比女人的牙齿多。</p>
<p>亚里士多德可能看到蜉蝣用四条腿走路得出了这个结论，但实际上蜉蝣与其他昆虫一样都有六条腿。也有可能他检查了自己和那些男性朋友的牙齿，但只查看了女佣的牙齿，她们更有可能因为营养不良而牙齿变少。他并没有意识到这点，他的观察是不准确的。即便如此，他和柏拉图的观念仍在近两千年内占据了主流。直到 16 世纪末期，人们才意识到他们的观点是有缺陷的。</p>
<img src="/images/sci-ori_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>他们时代之后的科学方法是如何发展的呢？古希腊人有很多科技进步。比如，托勒密 (Ptolemy) 将行星运动描述为：地球位于宇宙的中心，静止不动；其他行星，包括太阳都沿着各自的小轨道绕地球运动。必须要加上这些大环套小环，才能解释行星有时逆行的奇怪现象。</p>
<p>托勒密的模型能进行准确的预测，但人们并不认为它描述了真实的行星运动，它只能解释现象。</p>
<img src="/images/sci-ori_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>希腊城邦消亡后，在罗马帝国的兴衰更替间，以及中世纪的最初几百年，几乎没有任何科学进展。柏拉图和之后亚里士多德的哲学观点一直是主流，直到 16 世纪末新的科学革命拉开了启蒙时代的序幕。</p>
<p>让我们来看看哪些进步最终引导了革命。</p>
<p>首先，阿拉伯和波斯学者比如伊本・哈桑 (Ibn al-Hasan) ，比鲁尼 (Al Biruni) 和伊本西纳 (Ibn Sina) 开始使用系统观察和实验。强调无偏见的观察，而不只是逻辑推理。之后，在前人的基础上，英国的格罗斯泰斯特 (Grosseteste) 和罗杰・培根 (Roger Bacon) 提倡使用归纳 (induction) 与演绎 (deduction) 。</p>
<p><strong>归纳 (Induction)</strong> ，即通过特定观察得到一般解释。 <strong>演绎 (Deduction)</strong> ，即用一般解释预测特定结果。</p>
<p>第三个重大发展是印刷机的发明，这为科学革命创造了极好的条件。更多学者的成果得到了广泛的传播，其中就包括哥白尼 (Copernicus) 的《天体运行论》(De Revolutionibus Orbium Coelestium) ，这是引领科学革命的第四个重大发展。在哥白尼的新行星运动模型中，行星包括地球都围绕太阳运动。这与当时的宗教教义不符，教会接受亚里士多德和托勒密的模型，即地球位于宇宙中心。很多历史学家认为，哥白尼不敢发表他的成果，因为他害怕教会会因为违背教义惩罚他。但他最终还是发表了他的新模型，但加上了给教皇的特别献词，声称如果托勒密能炮制一个轨道怪异且只能解释现象的模型，那么他也应该享有同等的自由。他暗示他的模型仅仅是个实用的模型，而不是确切的表述。</p>
<p>他是否真心相信这一点也不得而知，不久他就与世长辞了。在这之后 60 年都没有引发骚动。很多人认为，科学革命和启蒙时代由哥白尼而始，但其他人认为荣誉应该归于第一个拒绝向天主教低头，坚持认为日心说模型才是现实的真实描述的人。</p>
<p>这个人就是伽利略・伽利雷 (Galileo Galilei) 。</p>
<hr>
<h1 id="启发-Enlightenment"><a href="#启发-Enlightenment" class="headerlink" title="启发 (Enlightenment)"></a>启发 (Enlightenment)</h1><p>伽利略 (Galileo) 被认为是现代科学之父，因为他开始将科学从哲学、伦理学和神学中分离，这些原来都在天主教的严格管控之下。</p>
<p>有人已经默默拥护基于 <strong>观察和实验 (observation and experimentation)</strong> 的科学方法，而不是使用 __神学推理 (theological reasoning)__，但伽利略是第一个这样光明正大做的人<br>。他也反对亚里士多德的几个理论，这些理论被天主教视为教义。</p>
<p>例如，他驳斥了亚里士多德说重物落地比轻物更快的观点。伽利略用了思想实验来证明这个观点，表明除了观察，他也重视 <strong>逻辑推理 (logical reasoning)</strong> 。当然，他最出名的是质疑亚里士多德和托勒密有关地球是宇宙中心的观点。他支持哥白尼的日心，即太阳是宇宙中心。伽利略对金星进行了系统的观察，发现行星只有绕太阳转而不是绕地球转才说得通。</p>
<p>哥白尼认为，日心说模型恰恰解释了这个现象，说明该模型准确预测了我们对行星的观察，但他却说这模型并非反映物理现实。相反，伽利略却毫无顾忌地声称地球就是绕着太阳转的。</p>
<p>天主教不喜欢伽利略离经叛道的想法。他们对伽利略进行宗教审判，把他软禁起来直到去世。</p>
<img src="/images/sci-ori_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>发明笛卡尔坐标系的 勒内・笛卡尔 (René Descartes) 和伽利略是同一时代的。虽然笛卡尔也反对亚里士多德许多的观点，但他同意知识应当基于 <strong>第一原理 (First principle)</strong> 。因为他认为我们的感官和思想很容易被欺骗，他决定放弃所有哪怕只有一点点疑问的想法。一旦移除了所有的怀疑，就只剩下一点可以确定 —— 即他在思考，那么他一定存在。我思故我在。</p>
<img src="/images/sci-ori_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>他最终得出结论：我们只能用 <strong>推理 (reasoning)</strong> 来了解世界本质。</p>
<p>弗朗西斯・培根 (René Descartes) 和笛卡尔一样，认为科学知识应当基于第一原理。但和笛卡尔相反，培根坚持认为这只能通过 <strong>归纳法 (inductive methods)</strong> 。归纳法就是把对特定实例的观察，用于总结普遍规律或解释。假设我每次碰到的天鹅都是白色的，我就能归纳出普遍规律：所有天鹅都是白色的。培根相信，不仅仅是第一原理，所有的知识都只能用归纳法获取，也就是这种基于感官经验总结出解释的方法。这就是为什么他被视作 <strong>经验主义 (empiricism)</strong> 之父。经验主义就是关于经验或观察。</p>
<p>大卫・休谟 (René Descartes) 把经验主义发挥到了极致 —— 只接受感官数据为知识来源，且摈弃与直接观察结果不符的理论概念。他认为现实的本质只由物体的特征组成，而不是物体本身。经验主义的极端形式叫做 <strong>怀疑主义  (skepticism)</strong> 。我来给你举个例子，比如有个实物 —— 一只猫。什么使得这只猫能成为猫 是它的各种属性 它的尾巴、胡须、颜色、皮毛、体型。如果把组成猫的属性都移走，那剩下的是啥都没了，猫的本质埋藏在其特征中。</p>
<p>休谟也指出了归纳法的问题：即使持续反复观察一个现象，但也没法保证下一次观察到的和前一次相同。</p>
<p>至少在欧洲人的长期观念中，所有的天鹅目击记录都证明天鹅是白色的。直到在澳州发现黑天鹅后，才知道原来还有黑的。换句话说，即使再多的验证观察，也不能确实证明关于世界的科学命题是真的。所以如果你要求所有的知识都只能基于观察，那么你永远不能确定你知道些什么。</p>
<p>19 世纪初，部分是针对休谟的怀疑主义， <strong>德国唯心主义 (German Idealism)</strong> 的哲学运动流行起来。唯心主义者相信我们的精神构筑了现实，我们对世界的体验是精神的重构，因此科学探索应当专注于通过自身推理能获得什么。唯心主义者主要关注的问题是非物质的东西，像自我、上帝、本质、存在和因果，他们也因使用模糊和过度复杂的语言而受到强烈批评。</p>
<p>在十九世纪第二次工业革命前夕，科学家开始对唯心主义者的形而上学失去耐心。在科学、医药和技术飞速发展的时代，他们对存在本质的思考变得越来越没用。在 20 世纪初，一种新的科学哲学登上舞台，提议彻底返回经验主义，这项运动叫做 <strong>逻辑实证主义 (logical positivism)</strong> 。</p>
<hr>
<h1 id="现代科学-Modern-Science"><a href="#现代科学-Modern-Science" class="headerlink" title="现代科学 (Modern Science)"></a>现代科学 (Modern Science)</h1><p>第一次世界大战过后，由于不满于德国那群专注于知识的第一原理和世界的本质的唯心主义者的 <strong>形而上学 (metaphysics)</strong> ，一群数学家、科学家和哲学家组成了维也纳学派 (Vienna Circle)。</p>
<p>维也纳学派的成员，摩里茲・石里克 (Moritz Schlick)、奥托・诺伊拉特 (Otto Neurath) 和鲁道夫・卡纳普 (Rudolf Carnap) 认为唯心主义者关于自我存在的问题毫无意义，因为这些问题无法回答。他们提出了新的科学哲学思想 ——  <strong>逻辑实证主义 (Logical Positivism)</strong> 。它重新将科学定义成是研究对世界有意义的命题。那么，要使一个命题有意义，它必须可验证，也就是有验证标准。这意味着要能确定命题的真实性。</p>
<p>有意义的命题有两种： <strong>分析命题 (analytic statements)</strong> 和 <strong>综合命题 (synthetic statements)</strong> 。</p>
<p>分析命题会 <strong>同义反复 (tautological)</strong> ，一定是真的。比如说，单身汉未婚，所有正方形都有四条边。这些是 <strong>先验命题 (priori statements)</strong> ，如定义和纯逻辑命题。它们不取决于世界的状态，因此也不需要通过观察来验证。它们可以被运用在数学和逻辑中，分析命题的新组合可以用形式逻辑验证。</p>
<p>综合命题依存于世界的状态。比如说，所有单身汉都快乐和所有猫天生都有尾巴。这些命题是 <strong>后验的 (posteriori)</strong> —— 它们只能通过观察验证。逻辑实证主义者认为，这些命题应始终可公开研究。同时，命题不许提及无法观察的实体，如电子或重力，因为它们无法被直接观察到。如果命题提及了无法观察的实体 或不是同义反复的，或不合逻辑的，或经验上不可验证的，那么它就是无意义的。这样一来，形而上学、神学和伦理学之类的主题，就完美地从科学中被剔除了。</p>
<p>当然，源自观察的标准和验证无法处理归纳法问题。明确证明或验证一个命题的确切证据永远都不够。总有可能在未来发现矛盾的地方。所以就把验证标准的强度弱化了，只要求确认而不是验证就可以了。</p>
<p>另一个非常严格的规则也必须改变了 —— 不许提及无法观察的实体造成了大麻烦：像电子、重力和抑郁这种无法被直接观察，但它们在科学解释中是不可或缺的。</p>
<p>这些以及归纳法问题，使逻辑实证主义出现了一个更温和版本 —— <strong>逻辑经验主义 (logical empiricism)</strong> 。</p>
<p>卡尔・波普尔 (Karl Popper) 也被戏称为维也纳学派的官方反对者，是他们的主要批判者之一。他认为要区分命题是否有意义，应建立在 <strong>可证伪性 (falsification)</strong> 的标准上，而不是能否 <strong>证实 (verification)</strong> 。</p>
<p>他认为，我们永远不能用观察来确切验证或证明一个命题，但我们可以用与之矛盾的证据有力驳斥。他认为一个命题必须有可证伪性才有意义。他提出科学家应该积极进行冒险的实验，它们能把找到与假说矛盾的证据的可能性最大化。如果我们找到了这样的反面证据，就能从中找到改进假说的线索。 <strong>只有反面证据缺失时 该假说才能暂时成立。</strong></p>
<p>现在，威拉德・冯・奥曼・奎因 (Willard Van Orman Quine) 证明，这个标准也有问题。在杜恒 - 奎因论题 (Duhem-Quine thesis) 中，他认为没有假说能够被单独验证，总有 <strong>背景假设 (background assumptions)</strong> 和 <strong>辅助假设 (supporting hypotheses)</strong> 来支持。如果找到了反面证据，根据波普尔的理论，我们的科学解释是错的，应该被驳回。但根据奎因的理论，我们总可以驳回某个背景假设或辅助假说，而不是科学解释本身。这样就挽救了原始假说。</p>
<p>托马斯・库恩 (Thomas Kuhn) 指出，科学并非脱胎于验证或证伪原则的严格应用。如果数据与假设不符，假设不会被立刻驳回或修改，科学是在一定的框架或 <strong>范式 (paradigm)</strong> 内进行。建立的假说要适用这个范式，意外结果使假说需要修正。但只要其适合范式即可。但当越来也多的反面证据累积起来，危机就出现了 这就导致了 <strong>范式转换 (paradigm shift)</strong> 。新的范式被采用，然后循而往复。</p>
<img src="/images/sci-ori_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>即使变成较弱形式的逻辑经验主义，逻辑实证主义也不能从波普尔、奎因等人的批判中幸存。所以，我们发展出一种更实用的科学哲学。如今的科学家采用 __假说 - 演绎法 (hypothetico-deductive method)__，其结合了归纳和演绎的方法；要求可证伪性；仅在假说有临时支持时接受重复确认。</p>
<img src="/images/sci-ori_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>哲学层面上，很多科学家可能会喜欢巴斯・范・弗拉森的 <strong>建构经验主义 (constructive empiricism)</strong> ，其主张科学是为了产生基于大量经验的理论。知识需要观察，但不可观察的实体也是允许的。接受一个科学理论并不意味永远认同 —— 这是对世界的真实表述。建构经验主义者认为，只要在观察范围内，即可接受科学主张为真实。该命题是否真实代表了不可观察的实体，我们无需判断，这只是目前对观察结果的最佳解释，仅此而已。</p>
<hr>
]]></content>
      <categories>
        <category>social-science</category>
      </categories>
      <tags>
        <tag>计量方法</tag>
        <tag>社会科学</tag>
      </tags>
  </entry>
  <entry>
    <title>计量方法 01 | 科学是什么？</title>
    <url>/social-science/quantitative-methods-what-science-is/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="非科学的方法-Non-scientific-Methods"><a href="#非科学的方法-Non-scientific-Methods" class="headerlink" title="非科学的方法 (Non-scientific Methods)"></a>非科学的方法 (Non-scientific Methods)</h1><p>为了知道为什么我们需要科学方法，让我们来看看在日常生活中人们的认知基于什么。</p>
<img src="/images/non-sci_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>人们可能会基于 <strong>直觉 (intuition)</strong> 或 <strong>信念 (belief)</strong> 而认为某事是正确的。</p>
<p>让我们来看下我对我的猫 Misha 所拥有的坚定信念：我相信 Misha 在所有人中最爱我 —— 我就是知道他爱我胜过其他所有人，我能在内心深处感受到。那么这种信念算不算是知识的坚实基础？并不是，简单地相信某件事并不会让它成真。我们坚信不疑的事情可能最后被证明是假的。还有，如果有人持相反的观点会怎样？如果我的未婚夫认为 Misha 爱他多一些呢？</p>
<img src="/images/non-sci_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p><strong>仅仅通过较量我们的观点，是无法得出谁对谁错的。</strong></p>
<p>我们可以数每个观点的支持人数，然后得到一个大部分或是 <strong>一致同意的观点 (consensus)</strong> ，但是这也不能作为知识的坚实基础。仅因为大部分人认同某事是并不意味着它就是真的。几世纪以来，几乎人人都认为地球是平的，但结果证明他们错了 —— 地球是圆的。</p>
<p>另一个知识的来源就是 <strong>权威 (authority)</strong> 的观点。这也不是一个很好的来源。一些诸如政治领袖、专家、科学家等权威的观点，也只是一种观点。权威或许能接触到更多或更好的知识，但他们出于个人利益也会推动自己的观点被大众接受，他们的职业和名誉都依赖于此。假设我的未婚夫找到了一个懂猫语的人，那人声称 Misha 更爱我的未婚夫。当然我会对这一专业观点表示怀疑，尤其当他是受我未婚夫雇佣的时候。我可以找到我自己的猫咪专家来和未婚夫的猫语者打擂台。但这时我们又有两个相反的观点了 —— 我们需要的是 <strong>证据 (evidence)</strong> 。</p>
<p>那么我们该如何用证据来解决 Misha 更爱谁的争论呢？</p>
<p>假设我总是 <strong>观察 (observe)</strong> 到每次下班回家后 Misha 总会过来坐在我的腿上而不是我未婚夫的腿上。我就运用了对客观世界，也就是对下班后 Misha 坐谁的腿上的 <strong>观察 (ovservation)</strong> 来证明我说的 Misha 更爱我这个 <strong>命题 (statement)</strong> 。</p>
<p>以 <strong>随机观察 (casual observation)</strong> 取证得到的认识，比前面其他方法了解到的认识更有根据一些，但这仍然不够好。 <em>因为人们并不十分擅长观察</em> 。我们倾向于 <strong>选择性观察</strong> ，并且记住与我们观念相符的事情。比如我可能恰好忘记了， Misha 在早饭的时候总是坐在我未婚夫的腿上。</p>
<p>除了选择性知觉外还存在许多 <strong>偏见 (bias)</strong> ，会让随机观察成为一个棘手的认识来源。我们运用 <strong>逻辑 (logic)</strong> 的能力也是如此。 <strong>逻辑推理 (logical reasoning)</strong> 得出的认识看上去是有坚实基础的，但 <strong>非形式逻辑推理 (informal logical reasoning)</strong> 并不总是具有一致性。人们在日常生活中进行推理时，总会不停地出现 <strong>谬误 (fallacy)</strong> 或 <strong>逻辑矛盾 (logical inconsistency)</strong> 。</p>
<img src="/images/non-sci_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果想获得更准确的认识，确定我们对世界的解释是正确的，那就还需要点别的东西。我们不能依赖于主观的、无法证实的来源 —— 诸如信念、观点、舆论。我们也不能相信随机观察和非形式逻辑，因为它们可能被我们的信念严重扭曲。</p>
<p>我们需要 <strong>系统观察</strong> ，摒弃任何偏见，辅以一致的逻辑。换言之 我们需要 <strong>科学方法</strong> 。</p>
<hr>
<h1 id="科学方法-Scientific-Method"><a href="#科学方法-Scientific-Method" class="headerlink" title="科学方法 (Scientific Method)"></a>科学方法 (Scientific Method)</h1><p>当我们试图解释世上事物运行原理时，为了确保知识有效，我们需要科学方法，而不是依靠观点、信念、随意观察和非形式逻辑。它们都太主观且容易出错。</p>
<p>科学方法基于 <strong>系统观察 (systematic observation)</strong> 和 <strong>逻辑一致性 (consistent logic)</strong> 。使用科学方法，增加了我们得出正确解释的机率。同时，我们也可以通过科学方法鉴定 <strong>科学主张 (scientific claim)</strong> 、 <strong>假说 (hypothesis)</strong> ，以及鉴定在我们实证研究中用来支撑假说的那些 <strong>经验证据 (empirical evidence)</strong> 的说服力。</p>
<p>科学方法有六大原则科学方法有六大原则。如果我们的研究符合这些原则，就能归为科学研究。</p>
<img src="/images/sci-method_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这个假说亦可以与其他科学论断一较高下，为我们的世界提供尽可能最好的解释。</p>
<p>第一条原则是：假说应该可以 <strong>在实证中检验 (empirically testable)</strong> ，即支持或反驳假说的经验证据、物证或观测结果都是可以收集的。</p>
<p>比如我假设家里的猫爱我多于我未婚夫。要实证检验这个假说，我们需要收集观察结果或数据。但如何观察这只猫对我们的喜爱程度呢？我们不能询问猫的看法。假设我们都认为猫是无法像人类那样表达爱意的，那就没什么好观察的了。所以这条假说不符合实证可检验的原则。</p>
<p>第二原则是：<strong>可重复性 (replicability)</strong> 。一项研究及其发现结果都应该具有可重复性。这意味着重复原研究是可以得到一致结果的。</p>
<p>如果预期结果只出现了一次，或出现次数极少，那这个结果可能只是巧合。如果一个假说能被重复确认，它会更为可靠。所以一项研究需要经受住重复和复制的考验。比如我说服未婚夫认同 “猫在谁腿上呆得久就更喜欢谁” 这个评判标准。现在我观察到这周猫趴在我腿上的时间，是它呆在未婚夫腿上时间的两倍。那意味着我的假说是正确的吗？猫咪就爱我多一点吗？如果接下来几周这个观察结果保持不变，那么我的假说就是靠谱的。但如果观察了一周这只猫就死了怎么办？如此一来我们就无法验证这个假说了，这个研究再也无法重复。</p>
<p>要验证结果是否可重复，我们必须按原研究的条件和过程进行重复。假如我们处理过程不同，于是得到了别的结果，这表明原研究不可重复吗？答案当然是否定的。重复失败可能是由于我们改变了程序。</p>
<p>第三原则是 <strong>客观性 (objectivity)</strong> ，指他人能自行重复该实验而无需求助原研究者。“客观” 的字面意思是谁来进行研究不重要。基于假说跟其程序的描述，每个人都应该得到相同的结论。因此研究者提出的假说、概念、程序应尽量客观。这要求清楚明确地定义所有研究元素，不给主观解释留任何余地。</p>
<p>假设我认为猫咪拿脸蹭我是示爱的表现，但我没有明确告诉我未婚夫这一条，那么我衡量爱意的程序就是主观的。即使我们同时对猫进行系统性观察，结果仍然会因观察者而异。较之我未婚夫，我会认为猫示爱次数更多。这个例子中的结论是主观的，因此不具有可比性，而我们经常对此毫无自觉。如果我们没有明确讨论并就示爱标志达成共识，那么我们的猫咪爱意衡量程序则不够客观。</p>
<p>第四原则是 <strong>透明性 (transparency)</strong> 。保持透明度与客观性原则密切相关。在科学界，不论是你的支持者还是批评者，任何人都应该可以重复得出你的结论。这要求研究者共享他们建立的假设 —— 如何定义概念、使用了什么研究程序，还有一切和进行精确复制相关的所有信息。</p>
<p>第五原则指出一个假说应该具有 <strong>可证伪性</strong> 。可证伪性是一个非常重要的原则。如果你能想象出一种情形会使观察与假说出现矛盾，那么它就是可证伪的。如果我们想不出有什么样的反例存在，那这个假说就不可能被推翻。</p>
<p>比如你问一个有坚定宗教信仰的人，有什么证据可以证明他们的信仰是虚假的？不管你提出什么样的反例，他们可能都要争辩。这些事实并不违背自己的忠诚信仰。这种仅源于纯信念的观点，比如宗教，是不属于科学范畴的。如果对任何形式的证据，该假说都不接受其为反例，那这个假说根本没有讨论意义，也不用再寻求证实，因为结论已经在那里了。</p>
<p>我们要讲的第六点也是最后的原则是 <strong>逻辑一致性 (logical consistency)</strong> 。一个假说应该保持逻辑上的一致或连贯。这是指假说不会有任何自相矛盾的地方。比如 ，一个支撑假说的子假设是否与假说冲突。</p>
<p>我们观察得出的结论也应该保持逻辑一致性。这就是说，在整个过程中，研究者对正面或反面证据的标准应该一致。</p>
<p>让我继续用猫的例子进行说明。我的假说是猫更爱我，所以预测他会在我腿上呆更久。但要是它趴在我未婚夫腿上更久呢？我会说猫能察觉到趴在我腿上让我不舒服，因为他爱我多一些所以照顾我情绪便趴得少了。显然，这就是逻辑不一致。为了让观察结果符合我的假说，我对观察结果进行了 “再解读”。顺便一提，这也会让我的假说无法证伪。不管猫是否常趴我腿上，我都会得出它爱我的结论。</p>
<p>总结一下，科学方法要求我们构造的假说为实证可检验的，这就是说观察结果可以支撑或反驳假说；可重复性，也就是假说是可以被重复测试的；客观性，指他人可以独立检验这个假说；透明性，指假说与结果都公之于人，以便他人检验；可证伪性，指找到反例的可能性是存在的。最后，逻辑一致性是指假说本身保持内在的一致性，支持或反驳假说的观察结论也应逻辑一致。</p>
<p>最后一点，科学方法只在态度端正的情况下才有效。为了提出更好的假说，研究者们应该对自己和他人的研究持批判态度，所以他们应该做到公开透明、乐于接受批判。如果别人有更好的解释，就放弃他们心爱的假说。如此，科学界才能像进化系统一样 —— 只有最合适、最可靠的假说存留下来。</p>
<hr>
<h1 id="科学主张-Scientific-Claims"><a href="#科学主张-Scientific-Claims" class="headerlink" title="科学主张 (Scientific Claims)"></a>科学主张 (Scientific Claims)</h1><p>我已经讲过了有关我们周围世界的命题、假说以及解释，我没有准确解释就用了这些通用术语。是时候阐明清楚了。</p>
<p>关于周遭世界的科学主张，可分为不同类别。一些科学主张会比别的主张描述或解释更多现象。同样，某些科学主张对于我们周围的世界，命题、假说以及解释提供了更可信的描述或解释。我们发现某些主张会更准确一些，比起别的来有更多证据支持。</p>
<p>在科学中，最基本的主张是 <strong>观察 (observation)</strong> 。观察可以是对世界准确或不准确的 <strong>表达（(representation)</strong> 。</p>
<p>假设我观察我的猫：姜黄色毛，重 6.5 公斤。大多数科学家会接受这个观察结果，作为我们周围世界某一方面较为准确的投射 —— 假设体重秤有效且可靠的。但就解释力度而言，他们会发现这个观察非常无趣 —— 观察本身没有很大信息量，它不能描述属性间的一般联系，无法解释任何事。</p>
<p>但这不表示观察不重要。观察是经验科学的基础，但是观察本身不是很有用，观察本身是最无趣的科学主张，因为它没什么解释能力。观察在确定或反驳假说时会变得有用。</p>
<p><strong>假说 (hypothesis)</strong> 是一种 <strong>命题 (hypothesis)</strong> ，它描述了 <strong>属性 (hypothesis)</strong> 间的 <strong>模式 (pattern)</strong> 或一般关系。假说也可以对它描述的模式进行解释。我们建立这样一个假说：姜黄色猫一般都会超重，概率比其他颜色的猫要高得多。我可以用解释来延伸这个假说，就是毛色和肥胖间的相关性。比如，通过证明控制姜黄毛色和发出饱腹信号的基因是连锁的。</p>
<p>假说的 <strong>可信度范围 (plausibility)</strong> 可以从非常不确定到非常确定。一个假说若是没有支持，那么它就是不确定的。比如这是个新且未经检验的假说。假说也能被很多实证研究强烈支持，从而变得更确定。</p>
<img src="/images/sci-claim_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假设的一种特殊类型就是 <strong>定律 (law)</strong> ，定律是对 <strong>关系 (relation)</strong> 或模式非常精确的描述 —— 精确到总是能用 <strong>数学公式 (mathematical equations)</strong> 表达。它们通常被证明得很完整，所以它们如此精确。比如，我把猫食盆从 56 米高的地方扔下去，且我知道万有引力常数，然后用牛顿的万有引力定律就能很准确地预测这个碗掉到地上要花多长时间。</p>
<p>定律能做出很精确的预测 但它们通常不会解释其描述的关系。在这里，是距离、时间和重力之间的关系。当然，社会科学方面的定律很少能表达成公式。我们对个人和人群的了解还太少，还不能得到如此精度的固定行为模式，并用来推测出科学定律。</p>
<img src="/images/sci-claim_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>好，接下来我们来讲讲 <strong>“理论 (theory)”</strong> 的概念。在日常生活中，理论意味着 <strong>未被证明的 (unsubstantiated)</strong> 命题，有根据的猜想。但是在科学中，理论指的是许多相关现象的总体解释。在自然和行为科学中，理论由被经验证据强烈支持的各种假说构成。在社会科学中，更多的是定性研究和历史比较的方法。当理论经受住了逻辑上、历史上或定性分析的驳斥时，可以认为该理论高度可信。</p>
<img src="/images/sci-claim_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在科学范畴里，理论的解释最为完善，是我们拥有的最接近准确的东西，因为它们由经科学方法审视并留存的假说构成。当然，这不意味着科学理论是确定或真实的。世上有许多证明完备的理论最终也被取代了，比如牛顿力学就为相对论让路了。 <strong>科学的世界里没有确定性，只有暂时的最佳解释 (provisional best explanation)。</strong></p>
<hr>
]]></content>
      <categories>
        <category>social-science</category>
      </categories>
      <tags>
        <tag>计量方法</tag>
        <tag>社会科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二十三 | 第一类错误和第二类错误</title>
    <url>/data-science/statistics-type-i-and-type-ii-errors/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="第一类错误和第二类错误"><a href="#第一类错误和第二类错误" class="headerlink" title="第一类错误和第二类错误"></a>第一类错误和第二类错误</h1><p>回忆一下此前提到过的庭审的例子。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。</p>
<p>在审判时，有四种可能的结果。一，被告确实有罪且被判有罪，这是个正确的决定。二，被告确实无辜且被判无罪，这也是正确的决定。三，被告实际上是无辜的，但被判有罪，这是错误的决定。四，被告实际上有罪的，但是被判无罪，这也是错误的决定。</p>
<p>这也是我们在实施显著性检验时会发生的情况。辩方观点类似零假设为真，而被告有罪则等效于零假设为假。判被告有罪类似拒绝零假设，而无罪释放则等同于不拒绝零假设。这会导致四种可能的情形。其中的两种，你做了正确的决定，包括零假设的确为真并且你没有拒绝它以及零假设的确为假并且你拒绝了它。但也有两种你做了错误的决定，包括零假设为真而你拒绝了它以及零假设的确为假而你没有拒绝它。第一个错误我们称为 <strong>第一类错误 (type I error)</strong> ，或者说 <strong>伪阳性 (false positive)</strong> 。第个错误我们称为 <strong>第二类错误 (type II error)</strong> ，或者说 <strong>伪阴性 (false negative)</strong> 。</p>
<img src="/images/t1t2_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我给你举个例子。想象你的零假设是：美国的持证水肺潜水者总体， 50% 有超过 35 小时的潜水经验。换言之， $ \pi = 0.5 $ 。备选假设是它是另外一个百分比，换言之， $ \pi \neq 0.5 $ 。你问了一组简单随机抽样的 500 个美国潜水者，你发现有 0.56 的比例有超过 35 小时的潜水经验。现在，假定你的零假设实际上是真的，当你决定基于你的样本数据拒绝零假设时，一个第一类错误就出现了。 </p>
<img src="/images/t1t2_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<a id="more"></a>

<p>如果零假设为真，抽样分布是像下面这样的：</p>
<img src="/images/t1t2_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果你的显著性水平 $ \alpha $ 等于 0.05 ，通过查询 z 表得到临界值是 -1.96 和 1.96 。你的检验统计量落在拒绝域内。换言之，你要拒绝零假设。这件事情发生的概率是 0.025 加上 0.025 ，等于 0.05 。意味着第一类错误发生的概率等于显著性水平。</p>
<img src="/images/t1t2_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>由此，你可能想到要降低显著性水平。</p>
<img src="/images/t1t2_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>但是，这不一定是个好主意。如果你在零假设实际为真时降低了错误地拒绝它的概率，你实际上增加了零假设实际为假而你错误地没有拒绝它的概率。 </p>
<img src="/images/t1t2_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>犯第二类错误的概率我们称为 $ \beta $ 。</p>
<img src="/images/t1t2_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>计算 $ \beta $ 相当复杂，它依赖各种因素，例如 $ \alpha $ 的值，样本容量以及参数的真实值。基于这个原因，我们并不会去计算 $ \beta $ 的值，但重要的是你需要意识到，当我们试图降低某一类错误的概率时，另一类错误的概率会上升。</p>
<img src="/images/t1t2_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>当零假设为假时，并且你实施了检验，你希望检验的 <strong>功效 (power)</strong> 是高的。检验的功效是拒绝零假设的概率，给定它为假，换言之，一个检验的功效等于 1 减去第二类错误的概率，也就是 $ 1 - \beta $ 。</p>
<img src="/images/t1t2_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>为什么功效这么重要呢？是这样的，当你要实施一项研究之前，它可以帮助你确定你需要多少的参与者。在你实施完研究之后，它能帮助你确定结论不是统计显著的。</p>
<p>最后一个提示，在实践中，你永远无从得知某个决定正确与否。我们唯一能做的是控制做出不正确决定的概率。</p>
<hr>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>想象你是一个对鲸鲨感兴趣的潜水者，你想要知道这些巨大的动物平均的身长有多少。我们还假设你已经花费了很多年在世界各地研究了这些生物。这些年你已经测量了 258 头鲸鲨。因为你已经测量了世界各地的鲸鲨，我们假定这 258 头鲸鲨可以被看作一个简单随机样本。平均的长度等于 8.3 米，样本标准差是 3.4 米，并且鲸鲨长度的分布也近似正态分布。</p>
<img src="/images/t1t2ex_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在这一节中，我们将检验三种备选假设和一种零假设：鲸鲨总体的长度均值等于 8 米。第一个假设是总体均值不是 8 米。第二个假设是均值大于 8 米，第三个假设是总体均值小于 8 米。所有这几种情况中，我们都把显著性水平设为 0.10 。 </p>
<img src="/images/t1t2ex_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>首先，我们得检查我们的假定。如我之前说过的，鲸鲨的选择可以看作是简单随机抽样，并且我们也看到鲸鲨身长的分布近似正态。因此，我们没有理由预期总体分布会和正态分布差异巨大。再者，这也不是个问题，因为我们的样本量相当大。 </p>
<p>现在，让我们计算检验统计量，它的值对于几个假设都是一样的，毕竟，样本均值和零假设一样。</p>
<img src="/images/t1t2ex_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>代入公式， 8.3 减去 8 ，除以 3.4 除以 258 的平方根，等于大约 1.42 。</p>
<p>现在，我们开始第一个备选假设，它断言总体均值不是 8 米。我们画出相关的抽样分布，并显示零假设的值。我们需要基于 0.01 的显著性水平做双尾检验，查询 t 表格得到临界值 -1.66 和 1.66 ，检验统计量等于 1.42 不在拒绝域内因为我们不拒绝零假设。这意味着基于 0.10 的显著性水平，我们不能得出总体均值不是 8 的结论。</p>
<img src="/images/t1t2ex_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>第二个备选假设是总体均值大于 8 。抽样分布一样，但这一次我们做右尾检验。查询 t 表格得临界值是 1.29 ，这一次检验统计量是落在拒绝域内。因此在这种情况下，我们拒绝零假设，并且下结论总体的均值的确大于 8 。</p>
<img src="/images/t1t2ex_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>最后的备选假设是总体均值小于 8 。在这种情况下，我们做左尾检验，它是右尾的镜像，所以相关的临界值是 -1.29 。现在我们的检验统计量是 1.42 ，对于临界值时一个极端值，但它在分布的另一边。这意味着，它也不在拒绝域内，因此我们也不拒绝零假设。</p>
<img src="/images/t1t2ex_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>最后的例子显示，画出抽样分布很重要。否则，你可能会无法注意到检验统计量相对于临界值处于分布的另一边。不论检验的结果如何，有两件事是可以确定的。第一，鲸鲨真的很大。第二，教程即将结束，我要放假啦～感谢阅读！</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二十二 | 分步计划和置信区间</title>
    <url>/data-science/statistics-step-by-step-plan-and-ci/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="分步计划"><a href="#分步计划" class="headerlink" title="分步计划"></a>分步计划</h1><p>比较以下两种期望。一，你期望超过半数的持证美国潜水者有超过 35 小时的潜水经验。二，所有持证美国潜水者的平均潜水时长超过 35 小时。第一眼，两个期望看起来很相似。但是，在第一个例子中，你面对的是比例，你感兴趣的是潜水经验超过 35 小时的潜水者的比例。而第二个例子中，你关心的是均值。你想知道潜水时长的均值。因此，当实施显著性检验时，你需要特别注意你的方法。</p>
<p>这一节中，我将以分布计划的方式来引导你。想象你问了一个容量是 500 个持证潜水者的简单随机样本，他们的潜水时长是多少个小时。假设你发现 0.57 的比例有超过 35 小时的潜水经验，时长均值是 35.5 小时，均值是 8 小时。在我们的样本中，<br>潜水经验的变量分布近似正态。下面是分布计划全图：</p>
<img src="/images/sbs_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>第一步，评估你面对的是比例还是均值，这个我们已经讨论过。第一个例子是比例，第二个例子是均值。</p>
<p>第二步，形式化你的假设。在比例的例子中，零假设是：$ \pi = \pi_0 $ ，在均值的例子中，零假设是 $ \mu = \mu_0 $ 。我们可以有三种类型的备选假设：如果你做双尾检验，是 $ \pi\neq\pi_0 $ 或者 $ \mu\neq\mu_0 $ ；如果你做单尾的右尾检验，是 $ \pi\geq\pi_0 $ 或者 $ \mu\geq\mu_0 $ ；如果你做单尾的左尾检验，是 $ \pi\leq\pi_0 $ ，$ \mu\leq\mu_0 $ 。我们零假设是： $ \pi=0.5,\mu=35 $ ，备选假设是 $ \pi\geq0.5,\mu\geq35 $ 。因此我们需要实施右尾检验。</p>
<p>第三步，检查你的假定是否满足。在两个例子中，随机化都是必要的。你的样本必须通过随机抽样的方法收集，或者说，随机化的实验。在比例的例子中，根据零假设的比例，样本容量乘以比例以及 1 减去样本容量再乘以比例，必须等于或者大于 15 。均值的例子则要求总体分布近似正态。但实践中，这一点只有样本容量很小，且做的是单尾检验时才重要。对于我们的例子，所有的假定都满足。</p>
<p>第四步，确定显著性水平 $ \alpha $ 。常用的显著性水平是 0.05 。我们的检验将基于 $ \alpha=0.05 $ 。</p>
<p>第五步，计算检验统计量。在比例的例子中，公式是 $ z = \frac {p-\pi_0}{se_0} , se_0 = \sqrt {\frac {\pi_0 (1-\pi_0)}{n}} $ ，在均值的例子中，公式是 $ t = \frac {\bar x-\mu_0}{se_0} , se_0 = \frac {s}{n} $ 。注意，在比例的案例中，我们使用 z 分布，而在均值的案例中，我们使用 t 分布。</p>
<p>第六步，抽取相关的抽样分布，展示零假设和检验统计量，补上拒绝域和对应的临界值。在比例的案例中，</p>
<p>第七步，评估你的检验统计量是否落在拒绝域内。</p>
<p>第八步，决定是否拒绝零假设。</p>
<p>第九步，解释你的发现。</p>
<p>在下结论之前，值得提醒的是，不拒绝零值假设并不暗含你就可以接受零值假设。在第二个例子中，我们不拒绝零值假设，即潜水时长等于 35 小时的假设，但并不能得出潜水时长就等于 35 小时的结论。</p>
<hr>
<h1 id="显著性检验和置信区间"><a href="#显著性检验和置信区间" class="headerlink" title="显著性检验和置信区间"></a>显著性检验和置信区间</h1><p>假设你问样本容量为 500 的水肺潜水者他们潜水了多少个小时，均值是 36 小时，标准差是 8 小时，变量的样本分布近似于正态。基于样本信息，你希望推断总体的参数 $ \mu $ ，这是我们所知的推断统计学 —— 基于样本信息得出样本所在总体的结论。  </p>
<p>推断统计学有两种方法。其一，通过均值的置信区间来推断区间估计。其二，用显著性检验来推断点估计。在这一节中，我将向你展示这两种方法其实关联密切。</p>
<img src="/images/sbs_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假定你预期潜水时长的均值不是 35 小时，你将做一个显著性检验。我们对均值感兴趣，检验统计量如下：</p>
<img src="/images/sbs_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>零假设是： $ \mu = 35 $ ，备选假设是： $ \mu \neq 35 $ 。我们的假定满足，分析基于简单随机样本并且样本足够大，并且样本近似正态分布。检验统计量等于 36 减去 35 ，除以 8 除以 500 的平方根，等于 2.80 。抽样分布看起来是这样的。</p>
<img src="/images/sbs_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们可以通过查询 t 表找到对应双尾检验显著性水平 0.05 的临界点是 $ \pm1.984 $ 。因此我们的检验统计量落在拒绝域内。我们将拒绝零假设，得出潜水时长不等于 35 小时的结论。</p>
<p>现在，如果我们构造 95% 的置信区间，会发生什么呢？公式如下：样本均值，加减 95% 置信水平对应的 t 分数，乘以标准误差，这个标准误差等于标准差除以样本容量的平方根。相关的 t 分数是 1.984 ，代入公式，得到置信区间是 35.29 到 36.71 。由此我们有信心说，通过无限重复的抽样， 95% 的情况下区间会包含实际的总体均值。这个区间给了我们关于总体均值的一个有说服力的范围。和显著性测试一样，这个置信区间也告诉我们，总体的样本均值不是 35 。通常，双尾显著性检验的结果与置信区间的结果是一致的。</p>
<img src="/images/sbs_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>更准确的说，如果双尾显著性检验的 P 值等于或者小于 0.05 ，那么 95% 置信区间也不包含零假设的值。类似的，如果双尾检验的 P 值大于 0.05 ，那么 95% 置信区间将包含零假设的值。</p>
<img src="/images/sbs_5_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这听起来很合理，对吧？它以下图表示。你会看到，观察值 36 落在拒绝域内，而对应的置信区间也不包含零假设的总体均值。</p>
<img src="/images/sbs_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在假设观察到的均值是 35.5 ，而不是 36 ，这样的话，我们的检验统计量将变成 1.40 ，它不落在拒绝域内。我们因此不拒绝零假设，相似的，置信区间的两个端点编程 34.79 和 36.21 ，则包含了零假设的均值 35 。</p>
<img src="/images/sbs_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们可以有信息说，通过无限重复抽样， 95% 的情况区间会包含实际的总体均值。这意味着零假设有说服力，我们不该拒绝零假设。也说明了，构建置信区间的方法和双尾假设检验的方法虽然看起来不同，但是数学上是相关的，彼此一致。</p>
<img src="/images/sbs_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二十一 | 假设检验和显著性检验</title>
    <url>/data-science/statistics-hypotheses-and-significance-test/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h1><p>教程来到最后一个模块，很快我要放假了。明天我将背起行囊，出发去潜水。好吧，让我们再谨慎一点，我并不完全确定明天我能成行。我的航班可能延误，我可能睡过头误了航班，或者可能生病导致无法去潜水。总之，我期望明天出发，但我并不能完全地确定。或者说，不能 100% 确定。</p>
<p>当研究人员对于他们感兴趣的参数有所期待时，我们在讨论的是 <strong>统计假设 (statistical hypotheses)</strong> 。这一节将介绍统计假设。他们构成了 <strong>显著性检验 (significance testing)</strong> 方法中最主要的部分。一个统计假设，其实就是一个关于总体的期望。通常，假设会被形式化为一条对总体参数持有特定值或者落在特定范围的声明。这种声明是基于研究或者理论。基于样本的信息，我们评价一个假设靠谱与否。这个过程我们称为显著性检验，它是一种用样本数据来检验提前形式化的假设的方法。就像置信区间一样，显著性检验是一种推断统计学的方法。毕竟，我们也是用样本数据来推断关于总体参数的结论。</p>
<img src="/images/hypo_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们先来看 <strong>零假设检验 (null-hypothesis testing)</strong> ，在这种检验中，显著性检验基于两个假设， <strong>零假设 (null hypothesis)</strong> 和 <strong>备选假设 (alternative hypothesis)</strong> 。零假设以 $ H_0 $ 注记，备选假设以  $ H_a $ 注记。零假设断言你感兴趣的参数是某个特定值。它通常代表变量之间没有关联的情况，或者组与组之间没有差异的情况。它是一个当你的样本数据表明它不太可能发生时需要被拒绝的假设。而备选假设断言你感兴趣的参数落在另一个范围。通常，零假设和备选假设互斥。如果你做显著性测试，假设零假设为真，除非你的数据有很强的反面证据。</p>
<img src="/images/hypo_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>想象一个法庭的庭审。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。这正是显著性检验里发生的事情。辩护无辜相当于零假设，而有罪预期则等同于备选假设。</p>
<img src="/images/hypo_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在研究实践中，你对于参数的期望是以备选假设的方式出现，而零假设就是对立面，但它必须是一个单值，不能是一个范围。你只有在数据提供强力佐证时才能认定零假设成立。</p>
<img src="/images/hypo_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<a id="more"></a>

<p>举个例子，假设你有理由相信全体美国人中有 3% 有过水肺潜水的经历。那么这里的零假设和备选假设分别是什么呢？你的期望被视为备选假设。我们把它写下来， $ H_a:\pi\leq0.03 $ ，零假设是对立面，但必须表示为单一值，因此 $ H_0:\pi=0.03 $ 。</p>
<img src="/images/hypo_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假设你对水肺潜水的最大深度很感兴趣。你有理由期望美国潜水者的最大潜水深度均值 <em>不是</em> 25 米。你的备选假设是 $ \mu\neq25 $ ，零假设是 $ \mu=25 $ 。很简单，不是吗？</p>
<img src="/images/hypo_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>记住这条：在显著性检验中，你总是假定你的零假设成立，如果你为备选假设找到足够的支撑，就拒绝零假设。如果你没有找到足够的证据，你就不能拒绝它。但没能拒绝零假设并不意味着零假设就是真的。你可以拿法庭的例子再回味一下。在庭审中，被告被假定无罪。如果有足够的证据证明他或者她有罪，则定罪。没有足够的证据，被告则不会被定罪。但这并不意味着你可以得出他或者她是无辜的结论。</p>
<!-- more -->

<h1 id="关于比例的检验"><a href="#关于比例的检验" class="headerlink" title="关于比例的检验"></a>关于比例的检验</h1><p>假定你对有多少美国人有过水肺潜水经历这个问题感兴趣，你也有理由相信少于 3% 的美国人有这种经历。这意味着你的备选假设是 $ \pi\leq0.03 $ ，你的零假设是 $ \pi=0.03 $ 。</p>
<p>这一节中，我们将学习如何在对比例感兴趣时实施显著性检验。我们是这样来实施检验的：先假定我们感兴趣的总体参数有某个值，在我们收集到来自总体的样本后估计这个值的可能性。因为我们看到是一个样本，所以聚焦在抽样分布。我们可以决定，比如给定总体比例是 0.03 时样本比例的抽样分布。看下图，我们这样来实施检验：评估标准差（因为面对的是抽样分布，所以是标准误差），样本观察到的比例远离总体比例，这个标准误差的数值我们称为 <strong>检验统计量 (test statistic)</strong> 。</p>
<img src="/images/tap_0.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>想象我们抽取了 1000 个美国人，受试者中有水肺潜水经历的人比例等于 0.02 。接下来，我们这么做：</p>
<img src="/images/tap_0_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你看到一个样本比例的抽样分布，我们假定零值假设为真，总体比例确实等于 0.03 。那么一个样本比例为 0.02 的总体，有多大的可能性其比例真的是 0.03 呢？为了回答这个问题，我们计算检验统计量，或者说样本统计和假定的总体参数之间的偏移幅度。标准误差远离均值的数量用 z 分数表示，我们可以计算样本统计量距离总体均值有多少个 z 分数。 公式如下：</p>
<img src="/images/tap_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>先计算零假设的标准误差，它等于 0.03 乘以 0.97 再除以 1000 ，取平方根，大约是 0.005 。因为我们的检验统计量是 0.02 减去 0.03 ，除以 0.005 ，等于 -1.85 。这意味着当零假设为真时，我们的样本比例落在总体比例 1.85 个标准误差之下。 这是否足以拒绝零假设呢？</p>
<img src="/images/tap_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>基于这个信息，我们可以查询 z 表格，对应的概率值是 0.0322 ，这个概率值我们称为 <strong>P 值 (P-value)</strong> 。 P 值告诉我们，基于总体比例是 0.03 的前提，要找到一个比例是 0.02 的样本，可能性是很低的。但是否低到可以拒绝零假设了呢？这取决于我们选择 <strong>显著性水平 (significance level)</strong> 。在我们实施检验之前，我们需要决定 P 值要达到多小以拒绝零假设。最常用的显著性水平是 0.05 ，这时我们说样本提供了足够的证据拒绝零假设。我们的 P 值是 0.3222 ，小于 0.05 。所以如果我们把显著性水平设置在 0.05 ，我们需要拒绝零假设。这也被我们称为 <strong>拒绝域 (reject region)</strong> 。</p>
<img src="/images/tap_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>形成拒绝域边界的临界 z 值是 -1.64 ，你可以通过查询 z 表格得到它，它对应 0.05 概率的左尾。我们的检验统计量是 -1.85 ，落在拒绝域内。因此我们需要拒绝零假设，并且得出结论：美国有水肺潜水经历的人的比例低于 0.03 。我们说，这个结论是 <strong>统计显著的 (statistically significant)</strong> 。</p>
<img src="/images/tap_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在这个例子中，我们的检验基于备选假设是 $ \pi\leq0.03 $ 。因此，我们只聚焦在抽样分布的一边 —— 左边。这叫做 <strong>单尾检验 (one-tailed test)</strong> 。那如果我们的备选检验是 $ \pi\neq0.03 $ 呢？如果是那样的话，我们将不再只聚焦在分布的左边，而分布的两边。这种检验叫做 <strong>双尾检验 (two-tailed test)</strong> 。 </p>
<img src="/images/tap_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果我们还是采用 0.05 作为显著性水平，这意味着左边对应的累积概率是 0.025 ，右边也是。同样可以查询 z 表得到，对应的拒绝域的临界点分别是 -1.96 和 1.96 。现在，我们的检验统计量 -1.85 不再落在拒绝域内，意味着我们不能再拒绝零假设 $ \pi = 0.03 $ 。这说明，选择单尾或者双尾检验，对于结论有重大的差别。实践中，双尾检验要常用的多。我的建议是，只有你有非常好的理论依据时才使用单尾检验。</p>
<p>现在，让我们来改变显著性水平，看看会发生什么。比如，我们可以显著性水平设置为 0.01 ，这意味着我们在 P 值小于 0.01 时拒绝零假设。如果做单尾检验， 0.01 的显著性水平对于 -2.33 。</p>
<img src="/images/tap_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在我们的例子中，检验统计量没有落在拒绝域，因此不拒绝零假设。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如你所见，选择单尾或者双尾检验，会强烈地改变结果。需要记住的是，大部分单尾或者双尾检验都是基于 0.05 的显著性水平。</p>
<img src="/images/tap_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h1 id="关于均值的检验"><a href="#关于均值的检验" class="headerlink" title="关于均值的检验"></a>关于均值的检验</h1><p>你好奇潜水者会在水下待多长时间吗？这个时间取决于他们的氧气罐，经验，潜水深度以及许多其他因素。假设你有理由期望美国潜水者在携带平均水平的氧气罐下潜到平均深度，可以待在水下超过 60 分钟，并且假设你也接触到了 100 个有经验的美国水肺潜水者，测量了他们在携带平均水平的氧气罐待在平均深度下的时长。这个样本的均值是 62 分钟，标准差是 5 分钟。</p>
<p>你预期潜水者可以在水下待超过 60 分钟，这导致了下面这样一个零假设： $ \mu = 60 $ ，备选假设是 $ \mu\geq60 $ 。我们实施一个关于总体均值的显著性检验，抽样分布如下：</p>
<img src="/images/tam_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是一个均值等于 60 的样本均值的抽样分布， 60 是零假设的值。那么基于这样一个总体，一个样本的均值等于 60 的可能性有多大呢？ 同样，为了回答这个问题，我们计算检验统计量，它是样本均值偏离总体均值的标准误差。你可能记得如何计算标准误差 —— 我们需要用总体的标准差，因为我们不知道这个值，需要用样本标准差估计。因为这隐含着额外的误差，我们引入 t 分布来取代 z 分布。</p>
<img src="/images/tam_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们的检验统计量是通过下面的公式计算：</p>
<img src="/images/tam_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>由样本均值减去零假设的均值，然后除以样本均值的标准误差。标准误差等于样本标准差除以样本容量的平方根。</p>
<p>我们先计算出标准误差， 5 除以 100 的平方根，得 0.5 。 62 减去 60 ，再除以 0.5 ，得到 4 。这是否足以拒绝零假设呢？仍然取决于显著性水平。让我们引入最常用的显著性水平 0.05 。做单尾检验，查询 t 表，临界值是 1.67 。</p>
<img src="/images/tam_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>注意到我们的自由度是 99 ，但表里向下最接近的是 60 ，我们需要查看 $ t_{90%} $ ，因为右尾累积概率 0.05 。你需要记住， $ t_{90%} $ 代表置信水平为 90% ，也就表示分布的两尾加起来有 10% ，左右尾各 0.05 。</p>
<p>结果如下，我们的检验统计量 4 落在拒绝域内，意味着我们需要拒绝总体均值是 60 分钟的零假设。</p>
<img src="/images/tam_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们可以总结，平均情况下，有经验的美国潜水者携带平均的氧气量潜到平均的深度，能够在水下待超过 60 分钟。如果我们的期望并不是超过 60 分钟，而是不等于 60 分钟呢？</p>
<img src="/images/tam_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这种情况下，我们做双尾检验。假设显著性水平设置为 0.01 ，左尾和右尾的累积概率分别为 0.005 。查表，对应的临界值分别为 -2.66 和 2.66 ，而我们的检验统计量是 4 。因此，我们还是要拒绝零假设，并对我们的发现做统计显著的结论。</p>
<img src="/images/tam_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因为我们现在做了双尾检验，所以我们的临时结论现在变成了有经验的美国潜水者在携带平均氧气量，潜到平均深度后，能待在水下的平均时间不等于 60 分钟。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二十 | 样本容量</title>
    <url>/data-science/statistics-sample-size/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<p>还是前面的新生儿父母睡觉减少时长的例子，由于我们无法去询问你家乡所有的年轻父母。我们采取简单随机抽样。一个很关键的问题是 —— 样本应该取多大。应该是 50 个就够了？或者 至少 300 个或者 1000 个？</p>
<p>这一节中，我们将分布讨论对均值和比例感兴趣的不同情况。</p>
<p>先从均值开始。样本容量主要取决于三个因素。首先是你想要的精度。记得吗，置信区间是通过点估计加减一个误差界限来得到的。你允许多大的误差界限，如果你希望它越小，那么你的样本容量就得越大。其次，你的样本容量还依赖你想要的置信水平。越大的置信水平，需要越大的样本容量。最后，数据的变异性也影响样本容量的选择。你的变量的标准差越大，你需要的样本容量也越大。公式如下：</p>
<p>$$ n = \frac {\sigma^2z^2}{m^2} $$</p>
<p>n 代表样本容量，m 代表误差界限，$ \sigma $ 代表总体的标准差， z 代表 z 分数。显而易见，你不知道总体的标准差，而且你还没抽取样本也不知道样本的标准差。所以，你需要利用 <strong>合理的猜测 (educated guess)</strong> 来估计一个值。</p>
<p>让我来演示这个过程是怎么样的。想象我们想要 95% 的置信水平，对应这个置信水平的 z 分数是 1.96 ，并且我不希望误差界限宽过 0.3 小时，就取 0.3 小时吧。现在我们可以填完这个公式的一部分了。现在我们需要对 $ \sigma $ 进行合理猜测了。如果已经存在这方面的研究而且你知道变量的标准差，可以简单地采纳这个标准差。但是，如果这样一个研究之前并未做过，就必须靠我们自己的猜测。我先假定某些父母根本没法睡，某些父母睡觉少于 5 个小时，并且父母们也不可能睡的比之前还多。因此，我们假定变量服从正态分布， 95% 的父母睡觉时间介于 0 到 5 个小时之间。均值是 2.5 小时，标准差是 1.25 小时。毕竟， 95% 是落在均值左右两个标准差范围内，两个标准差等于 2.5 ，那么一个标准差就是 1.25 。我们用这组数字完成公式，得到 66.69 ，取整，得出结论我们需要 67 个受试者。</p>
<p>对于比例感兴趣而不是均值的情况，也可以采取类似的方式。假设我们想知道新生儿在换尿布时便便的比例，我想要 99% 的置信水平，误差界限 0.10 。公式非常相似：</p>
<p>$$ n = \frac {p (1-p) z^2}{m^2} $$</p>
<p>m 是 0.10 ，z 可由查表得 2.58 ，它对应 99% 置信水平。我们不知道的是 p 。还是采用合理的猜测，或者采用一种被称为 <strong>安全方法 (safe approach)</strong> 的方式。你会发现 $ p (1-p) $ 的最大值是 0.25 ，它发生在 p = 0.5 的时候，于是我们用 p = 0.5 完成公式，0.5 乘以 0.5 乘以 2.58 的平方除以 0.10 的平方，得到 166.41 ，即 167 位受试者。</p>
<p>在理想世界中，你可以去寻求大样本，比如说 1000 位受试者或者更多。但是，在现实世界中，我们的时间有限，资源有限，无法抽取大样本。因此，计算所需的样本容量可以帮助我们把成本降到最低。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十九 | 比例的置信区间和置信水平</title>
    <url>/data-science/statistics-confidence-interval-for-proportion/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="比例的置信区间"><a href="#比例的置信区间" class="headerlink" title="比例的置信区间"></a>比例的置信区间</h1><p>在过去的几周中我认识到新生儿喜欢排便，频繁地排便。恰好我的女儿 Lois 尤其喜欢在特定的情况下排便 —— 在我给她换尿布的时候。我说真的，一旦她决定上厕所 (answer nature’s call) ，一上就是六次。是的，六次，发生在换尿布的过程中。</p>
<img src="/images/statistics_cip_1.jpg" width="33%" height="33%" style="margin: 10 auto;">

<p>这正常吗？我不确定，但我知道我需要搞清楚。假定我随机问 100 个新生儿的父母，他们的宝宝是否喜欢在换尿布时排便。在这一节教程中，我会告诉你，如何基于这样一个研究，构建一个估计总体比例的置信区间。</p>
<p>假定我的 100 的受试者里有 17% 报告他们的宝宝喜欢在换尿布时排便， 83% 的受试者报告他们的宝宝不会这样做。我们由此得到一个 0.17 的比例，这个比例的新生儿父母的宝宝喜欢在换尿布时排便。当我们为比例构建置信区间时，我们引入样本比例的抽样分布。我们知道，只要样本足够大，这个抽样分布就是正态分布，并且均值等于总体比例 $\pi$ ，标准差 $\sigma_p$ 等于 $ \sqrt {\frac {\pi (1-\pi)}{n}} $ 。我们还知道，找到一个比例处于均值两个标准差范围内的样本的概率，同时也是总体的比例，是 0.95 。 更精确的说，如果我们对应概率的 z 分数，我们会得到 1.96 。这意味着我们有 95% 的机会确定我们的样本比例会落在总体比例 1.96 个标准差范围内，这被我们称为 <strong>误差界限 (margin of error)</strong> 。我们用于计算 95% 置信区间的公式如下：</p>
<p>$$ p\pm1.96\sigma_p , \sigma_p = \sqrt {\frac {\pi (1-\pi)}{n}} $$</p>
<p>其中 1.96 是对应 95% 置信区间的 z 分数。所以上面的公式我们也可以写成：</p>
<p>$$ p\pm {Z_{95%}}\sigma_p , \sigma_p = \sqrt {\frac {\pi (1-\pi)}{n}} $$</p>
<p>我们这里讨论的是 95% 的置信区间，意味着如果我们能从总体抽取无限多的样本，那么 95% 的情况下，我们的置信区间会包含总体比例 $\pi$ 。不过，你可能注意到，我们并不知道总体比例 $\pi$ 的值，所以就无从计算样本比例的抽样分布的标准差。因此，我们用一个估计值来代替总体参数 $\pi$ ，这个估计值来自样本统计量， $P$ ，由此得到下面的公式：</p>
<p>$$ p\pm {Z_{95%}}(se) , se = \sqrt {\frac {p (1-p)}{n}} $$</p>
<p>就像我们为均值构建置信区间时一样，我们称这个估计的标准差为 <strong>标准误差 (standard error)</strong> ，又称为标准误。 作为与均值的置信区间的对比，在构建比例的置信区间时，我们并不使用 t 分布。不过，你的数据需要满足一个必要的假定。你必须要有至少 15 个成功和 15 个失败。换言之， $np \geq 15$ 并且 $n (1-p) \geq 15$ 。如果不满足，那 你就不能基于上面的公式计算置信区间。现在回到例子，我们有 0.17 的比例报告宝宝在换尿布时排便。公式如下：</p>
<p>$$ p\pm {Z_{95%}}(se) , se = \sqrt {\frac {p (1-p)}{n}} $$</p>
<p>让我们先计算标准误差。0.17 乘以 0.83 ，除以 100 ，然后取平方根，结果是 0.038 。误差界限等于 1.96 乘以 0.038 ，约定于 0.07 。 0.17 减去 0.07 等于 0.10 ，0.17 加上 0.07 等于 0.24 。因此我们的置信区间是 0.10 到 0.24 。这意味着我们有 95% 的信心说，总体比例落在 0.10 到 0.24 之间。或者说，如果我们能抽取无限多容量为 100 的样本，那么对于每个样本我们计算这个误差界限下的置信区间，有 95% 的情况这个区间会包含总体的比例。这个 95% 置信区间说明，大部分宝宝并不喜欢在换尿布时排便。但另一方面，如果他们确实在这个时候排便了，也并奇怪。我们有 95% 的信心说有 10% 到 24% 的宝宝确实会在换尿布时排便。</p>
<hr>
<h1 id="置信水平"><a href="#置信水平" class="headerlink" title="置信水平"></a>置信水平</h1><p>95% 的置信区间，告诉我们对于我们的点估计有 95% 的可信度，这个点估计可以是均值或者比例。或者说，如果能够抽取无限多的样本，近似于我们当前的样本，对所有的样本基于相同的误差界限计算 95% 的置信区间。那么 95% 的情况下，总体的参数值回落在这个置信区间内。同时也意味着， 5% 的情况，这个方法会产生一个不包含实际总体参数的区间。</p>
<p>如果你希望减少错误推断的可能性，你可以诉诸更大的置信区间，比如说 99% 。这一节中，我将向你演示如何改变置信水平，以及这么做会带来什么结果。</p>
<p>99% 置信区间和 95% 置信区间的唯一区别是不同的 z 分数，通过查询 z 表，代入公式，最终我们算得 99% 置信区间是 0.07 到 0.27 。对于 90% 的置信区间，结果是 0.11 到 0.23 。</p>
<p>我以图形演示，你会看到，更高的置信水平导致更宽的置信区间。换言之，我们想获得可信度越高的推断，那么就要接受更宽的误差界限。因此，我们需要在可信度和精度之间折中。在多数情况下，我们采用 95% 置信区间。</p>
<img src="/images/statistics_cil.jpg" width="33%" height="33%" style="margin: 10 auto;">

<p>这个原理同样适用于均值的置信区间，区别在于在比例中，我们查询相关的 z 分数而在均值的案例中，我们查询相关的 t 分数，并且均值的计算中还要用到自由度，即 n 减去 1 。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十八 | 均值的推断和置信区间</title>
    <url>/data-science/statistics-inference-and-confidence-interval/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="统计推断"><a href="#统计推断" class="headerlink" title="统计推断"></a>统计推断</h1><p>这一节我们以睡眠为例。假设你通常每晚睡 8 个小时，你突然做了年轻爸爸或者年轻妈妈，你的睡眠时间减少到每晚 5 个小时，这意味着每晚减少 3 个小时，相当于每周 20 个小时，每年 1000 个小时，差不多 40 天。换言之，如果你家宝宝继续保持他 / 她的睡眠时间，一年之后你会比之前少睡 大约 40 天。</p>
<p>回到统计学，想象你想要知道你家乡的年轻父母在孩子刚出生那一年减少了多少睡眠。在这一节中我们将讨论统计推断。我们会基于样本信息，得出关于总体的结论。我们将会区分两种统计推断的方法，一种叫 <strong>统计估计 (statistical estimation)</strong> ，另一种叫 <strong>假设检验 (hypothesis testing)</strong> 。在这篇教程中，我们将先了解统计估计。 </p>
<p>有两种方式估计总体参数的值，其一叫 <strong>点估计 (point estimate)</strong> ，它是一个对于总体参数的最佳猜想。其二是 <strong>区间估计 (interval estimate)</strong> ，它是一个我们预期参数会落在的范围。 </p>
<p>想象我们抽取了 60 个受试者样本，有了第一个小孩后每晚减少的睡眠小时数均值为 2.6 小时。这个均值是一个对于总体均值很好的点估计。换言之，$ \bar x $ ，是一个对于 $ \mu $ 的很好的点估计。不过，单一的点估计无法告诉我们估计是否接近我们感兴趣的总体参数。因此，研究人员通常还希望知道点估计可能的准确度。他们借由计算区间估计来显示这种准确度。</p>
<p>区间估计是一个最有可能包含总体实际参数值的数字区间。基于我们的样本均值 2.6 小时，我们可以预测，比如说，你家乡新生儿父母每晚睡眠减少的平均小时数介于 2.3 小时到 2.9 小时之间。</p>
<p>这个区间包含总体参数值的概率，被我们称为 <strong>置信水平 (confidence level)</strong> ，置信水平总是一个接近 1 的值，多数情况下是 0.95 。接下来我们将讨论有 95% 置信水平的区间。</p>
<a id="more"></a>

<hr>
<h1 id="已知总体标准差，求均值的置信区间"><a href="#已知总体标准差，求均值的置信区间" class="headerlink" title="已知总体标准差，求均值的置信区间"></a>已知总体标准差，求均值的置信区间</h1><p>假设我们知道 60 个年轻父母的样本在第一个小孩出生后睡眠减少小时数的标准差是 0.9 小时，也知道总体的标准差是 1.1 小时。（实践中，不太可能知道这个参数，但这里我们先假定你知道）</p>
<p>这一节中，我们将学习如何基于样本信息和总体的标准差来构造 <strong>置信区间 (confidence interval)</strong> 。首先，我们来解释一下这样一个置信区间应该如何解读。</p>
<p>为了构造一个置信区间，我们需要用到样本均值的抽样分布。毕竟，我们是在处理一个来自总体的样本。 我们知道，只要样本足够大，抽样分布就是正态分布的，并且均值等于总体的均值，标准差等于总体的标准差除以样本数 n 的平方根。我们还知道，找到距离样本均值少于等于两个标准差的概率是 0.95 。更精确的，如果查询对应概率的 z 分数，我们会得到 -1.96 和 1.96 。</p>
<p>这意味着我们有 95% 的机会令样本均值落在总体均值 1.96 个标准差范围内。 1.96 个标准差的距离我们称为 <strong>误差界限 (margin error)</strong> 。误差界限告诉我们用样本均值 $ \bar x $ 估计总体均值的准确程度。 95% 置信区间的公式如下：</p>
<img src="/images/ci_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>它是由点估计或者样本均值加减误差界限，即 1.96 个标准差。注意我们是在处理样本均值的抽样分布。因此分布的标准差等于 $ \frac {\sigma}{\sqrt {n}} $ 。接下来请集中注意力，因为过程会有点复杂。 </p>
<p>假设你抽取一个样本，样本均值由某个点表示，从均值往两侧有一根线表示误差界限。它们一起构成了 95% 的置信区间。如果样本均值落在红色区域，则置信区间包含总体均值 $ \mu $ 。如果样本均值不落在红色区域，则置信区间不包含总体均值 $ \mu $ 。我们讨论的是 95% 的置信区间，这意味着随机选择一个样本，它包含总体均值的概率是 0.95 ，不包含总体均值的 0.05 。换言之，如果我们抽取无限多个样本， 95% 的情况，我们的置信区间会包含总体的均值。</p>
<p>现在让我们回到例子。例子中样本均值是 2.6 小时。总体标准差 1.1 。样本容量是 60 ，现在我们有了计算置信区间需要的全部数字。公式如下：</p>
<p>$$ \bar x\pm1.96\sigma_{\bar x} $$</p>
<p>我们知道 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ ，即 $ \frac {1.1}{\sqrt {60}} $ ，得到 0.142 。接下来计算误差界限， 1.96 乘以 0.142 ，约等于 0.28 。样本均值等于 2.6 ，因此 95% 置信区间是 2.6 减去 0.28 到 2.6 加上 0.28 的区间，即 2.32 到 2.88 。我们可以说，我们有 95% 的信心确定这个区间包含了实际的总体均值。更精确地说，如果我们从总体中抽取无限多个大小为 60 的样本，并且对于每个样本，我们计算误差界限， 95% 的情况下，总体的均值会落在样本的置信区间内。</p>
<img src="/images/ci_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果新生儿父母的这种境况会持续一年，我们有 95% 的信息说，这些人会减少 2.32 乘以 365 小时到 2.88 乘以 365 小时的睡眠时间，或者说， 846.8 小时到 1,051.2 小时，又或者说， 35.3 到 43.8 个整天。</p>
<hr>
<h1 id="未知总体标准差，求均值的置信区间"><a href="#未知总体标准差，求均值的置信区间" class="headerlink" title="未知总体标准差，求均值的置信区间"></a>未知总体标准差，求均值的置信区间</h1><p>95% 置信区间用于评估总体的均值，它告诉我们我们有 95% 的信息这个区间包含实际的总体均值。利用这个公式 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ ，你可以计算区间的两个端点。这个公式有一个问题，为了计算置信区间，你需要知道总体的标准差。然而，我们通常并不知道这个参数。毕竟，我们本来就在用样本推测总体的参数。</p>
<p>这一节中，我们将学习如何在不知道总体参数的情况下做出推断。解决方案是我们估计总体的标准差，因而我们要引入另一个分布，它叫 <strong>T 分布</strong> 。让我来告诉它如何工作。</p>
<p>想象我们问了 60 个年轻家庭他们在有了第一个孩子之后睡眠时间少了多少个小时，均值是 2.6 小时，标准差是 0.9 小时。为了构建一个 95% 的置信区间，我们需要用到 $\bar x\pm1.96 \sigma_{\bar x}$ ，<br>或者可以写成 $\bar x\pm {Z_{95 %}} \sigma_{\bar x}$ 。这一次，我们不知道总体的标准差。</p>
<img src="/images/ci_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此我们用样本的标准差来估计总体的标准差，公式变成: $\bar x\pm {Z_{95 %}} s_e$ ，其中 $ s_e = \frac {s}{\sqrt {n}} $</p>
<img src="/images/ci_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们把 $ se $ 这个估计的抽样分布的标准差称为 <strong>标准误差 (standard error)</strong> 。但是因为我们现在是估计标准差，所以我们在计算中引入了额外的误差。基于此，我们引入另一个分布， z 分布。由于额外的误差，我们现在使用 T 分布，公式如下。</p>
<p>$\bar x\pm {t_{95 %}} se$</p>
<img src="/images/ci_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在让我来详细解释 t 分布和 t 分数。 t 分布跟标准正态分布非常之相似，它是钟形的，对称的，并且均值是 0 。但是，它有一点点区别。 因为我们现在是估计抽样分布的标准差，我们引入了额外的误差。当我们的样本比较小时，这个误差很可观。 t 分布将这小样本的这个误差考虑在内了，因此它比标准正态分布稍微宽一点，标准差更大一些。如下：</p>
<img src="/images/ci_5_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>黑色的分布是标准正态分布，蓝色的分布是 t 分布。 t 分布的准确形状取决于样本容量。样本越大，t 分布越接近标准正态分布。更准确的说， t 分布的形状取决于单一个参数，我们称为 <strong>自由度 (degrees of freedom)</strong> ，以 $ df $ 注记。 t 分布中的自由度等于样本容量 n - 1 。这意味着我们实际上有许多不同的 t 分布，每一个都有单独的 $ df $。比如，自由度为 2 的 t 分布：</p>
<img src="/images/ci_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>自由度为 5 的 t 分布：</p>
<img src="/images/ci_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>自由度为 30 的 t 分布：</p>
<img src="/images/ci_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以看到，当我们有 30 或者更大自由度时， t 分布几乎就等同于标准正态分布。更准确的说，标准正态分布其实就是自由度等于无限的 t 分布。 </p>
<img src="/images/ci_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>同标准正态分布和 z 分数一样，我们也可以为特定的 t 分数寻找累积概率。重要的区别在于，这些概率依赖于自由度。当你计算一个 95% 置信区间时，你可以为所有可能的自由度找到对应 95% 置信水平的 t 分数，这个表格称为 <strong>t 表格</strong> ，它和 z 表格类似。</p>
<img src="/images/ci_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我用睡眠时间的例子来演示。样本中睡眠减少小时数的均值是 2.6 小时，标准差是 0.9 小时，样本容量是 60 。计算 95% 置信区间的公式：</p>
<img src="/images/ci_11.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我们从标准误差开始，它等于样本标准差除以 n 的平方根，即 0.9 除以 60 的平方根，得到 0.116 。我们的标准误差，或者说，估计的样本均值的抽样分布的标准差等于 0.116 。为了计算误差界限，我们需要用标准误差乘以 95% 置信区间的 t 分数。如你所知， t 分数取决于自由度。自由度 df 等于 n - 1 。我们有 60 个样本，因此 60-1 的 50 。在 t 表格中，我们在列中查找 95% 置信水平，在行中查找 59 自由度。因为表格中没有报告 59 自由度，我们向下取 50 自由度。对应的 t 分数是 2.009 。</p>
<img src="/images/ci_12.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此我们用 0.116 乘以 2.009 ，大约 0.23 。从样本均值 2.6 中加减这个值后，得到我们的置信区间是 2.37 到 2.83 。我们有 95% 的信心认为这个区间包含实际的总体均值。</p>
<p>为了计算总体均值的置信区间，有两个假定需要满足。首先，你的数据是随机获取的。换言之，样本必须是随机样本，否则你的发现就不是合法的。其次，总体必须近似正态分布。这一点可能是个问题，因为总体中的许多变量可能并不是正态分布的。不过，好消息是，采用 t 分布来构造置信区间，可以有效对抗第二个假设破坏。也就是说，即使违反了假设，这种统计方法仍然是健壮的。最后，在基于 t 分布构造置信区间是，你还需要对异常值保持机警。如果数据里有异常值，那么这个方法可能会失效。因此要记得在开始之前检查数据。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十七 | 样本比例的抽样分布</title>
    <url>/data-science/statistics-sampling-distribution-of-sample-proportion/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="抽样分布比例"><a href="#抽样分布比例" class="headerlink" title="抽样分布比例"></a>抽样分布比例</h1><p>想象你住在巴黎，你知道所有的学生中有 0.10 的比例把自己看做嬉皮士。你想要知道这个比例的抽样分布是什么样的。注意，在这里计算总体均值是没有什么意义的。因为你感兴趣的变量是一个二元标量。学生们可以选择认定自己是或者不是嬉皮士。均值和这样一个二元变量无关。</p>
<p>在本节教程中，我将解释一个总体比例的抽样分布是长什么样。你知道巴黎有 10% 的学生认为自己是嬉皮士，这意味着总体比例，用 $ \pi $ 注记，等于 0.10 。现在想象我们从这个总体中抽取 200 个学生。样本的比例，用 $ p $ 注记，将会是一个接近 0.10 的数字，比如 0.09 或者 0.12 。</p>
<p>如果抽取了 5 组样本，样本比例可能如下：</p>
<img src="/images/sdp_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这样样本比例的直方图可能如下：</p>
<img src="/images/sdp_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有五个值，全部都出现一次，它们的概率都是 0.2 。现在，你抽取 25 组样本，分布可能如下：</p>
<img src="/images/sdp_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>抽取 50 个样本，分布如下：</p>
<img src="/images/sdp_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>无限多组样本，分布如下：</p>
<img src="/images/sdp_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是样本比例的抽样分布，分布的均值是 0.10 ，等于总体的比例。为了表明我们是处理抽样分布的均值，均值被注记为 $ \mu_p $ ，下标 p 是为了说明我们正在处理的分布的分数不是个体的分数，而是样本比例。如你所见，逻辑上和样本均值的抽样分布一模一样。</p>
<a id="more"></a>

<img src="/images/sdp_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在样本均值的抽样分布案例中，如果总体本身是正态分布或者样本容量足够，那抽样分布是近似钟形的。通用最小需要 30 个样本数。在样本比例的抽样分布中，只有当你拥有至少 15 个正向的 case 以及至少 15 个负向 case 的前提下，你才能确信分布是钟形的，即至少 15 个嬉皮士和 15 个非嬉皮士。公式表达如下：</p>
<p>$$ n\pi \geq 15 $$<br>$$ n (1 - \pi) \geq 15 $$</p>
<p>这对于我们的例子意味着什么呢？首先，样本容量和总体比例的乘积必须大于等于 15 。在我们的案例中，即 200 乘以 0.10 ，等于 20 个嬉皮士。其次，总体比例和 $ 1 - \pi $ 的乘积必须大于等于 15 。在我们的案例中，即 200 乘以 (1-0.10)，等于 200 乘以 0.90 ， 等于 180 个非嬉皮士。 因此我们可以下结论，抽样分布将会是钟形的，因为 20 和 180 都大于 15 。有一个相当直接的公式可以计算样本比例的抽样分布的标准差。我们以 $ \sigma_p $ 注记标准差，你知道 $ \sigma $ 代表标准差，而添加的 p 则表明我们正在讨论的是样本比例的抽样分布。 为了计算这个标准差，公式如下：</p>
<p>$$ \sigma_p = \sqrt {\frac {\pi (1-\pi)}{n}} $$ </p>
<p>在我们的案例中，标准差算出来是 0.02 。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>对于二元类别变量，计算总体均值和标准差没有意义。取而代之的是，我们计算分类变量的比例。对于二元变量，我们只有总体的比例 $ \pi $ 。</li>
<li>相似的逻辑也适用于样本。我们也只有样本比例 p 。对于样本比例的抽样分布来说，我们的确有均值和标准差。只要知道总体的比例，抽样分布的这些参数也很容易计算出来。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十六 | 样本均值的抽样分布和中心极限定理</title>
    <url>/data-science/statistics-sampling-distribution-and-central-limit-theorem/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="抽样分布"><a href="#抽样分布" class="headerlink" title="抽样分布"></a>抽样分布</h1><p>研究人员经常会用样本来推断样本所处的总体。为了做这件事，他们需要用到统计世界中非常重要的一种概率分布 —— <strong>抽样分布 (sampling distribution)</strong> 。</p>
<p>这一节中，我将向你解释抽样分布是什么。需要特别注意的是，抽样分布是帮助研究人员基于仅仅一个样本得出关于总体结论的桥梁。另外说明，在这节教程中，我们假装自己知道总体是什么样的。因为在研究实践中，我们通过永远都无法得知总体的全貌。这一步对于理解推断统计学至关重要。</p>
<p>好吧，让我们进入正题。想象有一群北欧的嬉皮士组织了一场胡子节庆典。庆典将在挪威首都奥斯陆附近的一个小岛举行。显然，你能想到庆典的受众是有胡子的男性。组织售出了 5,000 张门票，并且提供了往来小岛的免费运送。</p>
<img src="/images/sdl_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>拥有门票的人将在奥斯陆的港口集结。组织将他们随即分装到运送乘客前往该岛的船上，每条船搭载 30 名庆典的粉丝。</p>
<img src="/images/sdl_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，有一艘船迷失在挪威的群岛间。雪上加霜的是，手机网络崩溃了，因此组织无法联系上船长，船上的乘客也无法联系上组织。所有组织决定派出一些雇员去搜寻走失的船只。你正是其中的一名雇员。在历经里半个多小时的搜寻后，你看到一艘失事的船，上面有大约 30 个人。Yes，终于找到他们了。你正准备通过对讲机向组织报告失联船只已找到，这时你再看了一眼船上的乘客。你发现乘客都是一些带着小孩的家庭。这很奇怪，去胡子节的船上，不是应该都是一些随机选取的有胡子的成年男人吗？而不是一些带着小孩的年轻家庭。你认定这艘船不太可能是你要找的船，决定继续搜寻。果然，不久之后证明你的决定是明智的。你前面遇到的那艘船是一艘运送人们去另外一个岛上的家庭公园的船。</p>
<p>为什么要讲这个故事呢？这么说吧，如果你理解上面那个故事里 “你” 决策的原因，你就会理解抽样分布背后的基本思想。它是这样的，如果你从总体中抽取一个简单随机样本，那么它是不太可能强烈地区域于样本所处的总体的。在我们的案例中，人们正前往胡子节，他们构成了总体。一艘载有 30 个从总体中随机选取的人的船就是一个简单随机样本。</p>
<img src="/images/sdl_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>实际上，所有从奥斯陆港口前往庆典小岛的船都可以看做是一个简单随机样本。当然，每艘船都和其他船不一样，但大部分船都会包含大比例的有胡子的男人。不太可能有一艘船上都是各种年轻家庭。当然，有某些家庭参加胡子节是可能的，但是随机遇到一艘船，全部都是年轻家庭，则是非常不太可能发生的。</p>
<img src="/images/sdl_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假设你决定测量每艘船的平均胡子长度。每艘船有 30 个人。想象 5,000 个庆典参与者的平均胡子长度时 10.3 毫米，即均值是 10.3 毫米。你还知道胡子的长度在总体中服从一个钟形的分布。在一艘船上，你可能遇到胡子平均长度是 9.4 毫米，另一艘则可能是 10.8 。但是，不太可能遇到一艘船，上面的人平均胡子长度是 3.4 毫米，或者 19.2 毫米。因为这些船上的人的胡子的平均值可以看作是样本的均值，我们用 $ \bar x $ 来注记。</p>
<img src="/images/sdl_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<a id="more"></a>

<p>现在想象你正看着三艘船，概率分布可能长这样：</p>
<img src="/images/sdl_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>一艘船的均值是 9.9 ，一艘是 10.7 ，还有一艘是 10.2 。我们一共有三艘，所以每个均值的概率是 0.33 。现在想象有 17 艘船，40 艘船，100 艘船，你会发现胡子均值长度的分布会越来越接近钟形分布，并且，你会发现分布的均值接近 10.3 ，跟总体的均值一模一样。</p>
<img src="/images/sdl_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果你仔细琢磨一下，就发现这并不奇怪。你会期望，在绝大多数情况下，样本的均值和总体的均值接近。某一艘船的均值可能高一点，另一艘船的均值可能低一点。但是，当你看到许多船时，你会期望所有这些不同船的均值的均值，就等于总体的均值。</p>
<img src="/images/sdl_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，想象你的总体包含了所有的挪威男人。你知道这个总体的胡子长度均值是 1.22 毫米，并且变量服从一个钟形分布。如果你抽取一个 30 人的简单随机样本，你会发现均值接近总体均值，比如 1.34 毫米。你再抽取另一个随机样本，均值可能是 1.19 毫米，也很接近总体均值。如果你重复五次，你会得到五个不同的值，但是都很接近总体的均值。</p>
<img src="/images/sdl_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>当我们可以抽取无限多个样本时，分布将会是一个完美的钟形，均值是精确的 1.22 毫米，跟总体均值一样。我们把这种分布称为 <strong>样本均值的抽样分布 (sampling distribution of the sample mean)</strong> ，它是这样一种分布：你从总体中无限抽取样本，计算所有样本的均值。</p>
<img src="/images/sdl_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>目前为止，你应当意识到，在实际的研究中，我们不可能从某个总体中抽取无限多的样本。但是，你需要知道，如果我们能这么做，这个分布的均值将等于总体的均值，这正是我们把这个分布称为样本均值的抽样分布的原因。不要把这个和样本或者数据分布混淆在一起，这只是实际抽取的一个样本的分布，只针对实际收集的数据而言。</p>
<hr>
<h1 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h1><p>如果你从钟形分布的总体中取无限个样本，来自这个无限个样本的均值分布将会是钟形的。并且这种样本均值的分布将会和总体均值完全一样。我们将此分布称为样本均值的抽样分布。</p>
<p>在这一节中，我将讨论 <strong>中心极限定理 (central limit theorem)</strong> —— 推理统计学中，最重要的公式之一。 </p>
<img src="/images/sdl_11.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>中心极限定理表明，假设样本量足够大，样本均值 $ \bar X $ (x 的均值) 的抽样分布近似正态分布，即使这个变量在总体中并不是正态分布。这不是很神奇吗？不用理会变量在总体中是如何分布的，样本均值的抽样分布总是如此，总是近似正态分布，只要样本量足够大。作为足够大的指导，通常使用 30 或更大的样本。</p>
<img src="/images/sdl_12.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你们可以看这些总体分布可能的形状。这是当你取样本容量 n=30 时，样本均值的抽样分布图。记住，这意味着你从总体中抽取了无数个由 30 个调查对象组成的随机样本，在分布中显示所有生成的样本均值。</p>
<p>你应该意识到，在实践中，根本不可能抽取无数个样本。但是，好消息是根本不需要抽取多个样本来确定样本分布的形状。 因为如果它是正态分布，你可以通过两个参数来描述它的形状，即均值和标准差。因此，估计这两个参数就足够了。正如我之前告诉你的那样，抽样分布的均值等于总体分布的均值。我们可以这样表示，$ \mu_{\bar x} = \mu $，$ \mu $ 代表总体的均值，$ \mu_{\bar x} $ 代表样本均值的均值。 </p>
<p>想象你对挪威男人的平均胡须长度感兴趣。总体包括所有挪威男子，$ \mu $ 是总体的平均胡须长度。我们假设它是 1.22 毫米。对于样本均值的均值，如果我们从总体中抽取无数个样本，并记下每个样本中的平均胡须长度，我们就会得到这个分布的平均值，等于总体均值 1.22 。$ \bar X $ 是用来强调抽样分布中的分数是样本均值，而不是个体的分数。换句话说，总体分布的平均值是所有挪威男性的胡子长度得分的平均值。抽样分布的均值是从该人群中抽取的无限多个样本的样本平均值。</p>
<img src="/images/sdl_13.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果我们知道总体分布如何，我们可以轻松的计算出样本的标准差。抽样分布的标准差的符号化是 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ 。添加 $ \bar x $ 下标是为了表明我们正在谈论抽样分布的标准差，其中分数是样本均值，或者换句话说，$ \bar x $ 的 $ \mu $。$ \sigma $ 代表总体的标准差， n 代表样本的大小。此公式表明抽样分布的标准差受两个特征影响。首先，它受总体标准差的影响，假设 n 等于 30 ，你的总体标准差是 1 ，你的抽样分布的标准差等于 1 除于根号 30 ，等于 0.18 。如果你的总体标准差增加至 2 ，样本的标准差变成 2 除于根号 30 ，即 0.37 ，如果你的总体标准差变成 3，样本的标准差变成 0.55 ，等等。</p>
<p>所以，如果总体分布的的标准差增加，抽样分布的标准差也会增加。换句话说，总体方差越大，样本均值的方差越大。这在直觉上是合理的，对吧？如果你从人群中胡须长度差异很大的人群中抽取 30 个受试者的各种样本，你可以预期这些样本的相互之间的差异比你从几乎没有差异的总体中抽取各种样本的差异更大。你的抽样分布的标准差，也会受到样本容量的影响。再看看这个公式。假设总体标准差等于 2 。现在，如果 n=30 ，$ \sigma_{\bar x} $ 等于 2 除于根号 30 ，等于 0.37 。 如果 n=100 ，你的抽样分布的标准差将变为 2 除于根号 100 ，等于 0.2 。如果 n = 500 ，你的 $ \sigma_{\bar x} $ 变为 0.09 。</p>
<img src="/images/sdl_14.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这表明，一个更大的样本量导致抽样分布的标准差更小。这在直觉上也是合理的。如果总体中的挪威男性的平均胡子长度为 1.22 毫米，你只有两个受访者作为样本，找到一个更高的平均值并不奇怪。如果你抽取了五个样本，你的样本均值是看起来像这样。</p>
<img src="/images/sdl_15.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，想象一下你抽取了一个 1000 个受试者的样本，这个样本的均值不太可能是 5 或者 10 毫米。毕竟，长胡子的人会被完全没有胡子的人抵消。如果你抽取五组样本，样本均值可能看起来像这样。</p>
<img src="/images/sdl_16.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>它们都将非常接近总体平均值 1.22 毫米。所以你的样本容量越大，样本均值越接近总体均值，样本分布的标准差越小。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>中心极限定理告诉你：无论变量在总体中分布如何，只要样本容量至少为 30 ，样本平均值的抽样分布都近似正态分布。</li>
<li>抽样分布的均值 $ \mu_{\bar x} $ 等于总体均值 $ \mu $ ，抽样分布的标准差 $ \sigma_{\bar x} $ 等于总体分布的标准差 $ \sigma $ 除于 $ \sqrt {n} $。</li>
</ul>
<hr>
<h1 id="三种分布"><a href="#三种分布" class="headerlink" title="三种分布"></a>三种分布</h1><p>许多社会的、政治的以及宗教的团体有它们自己的神圣文字。嬉皮士，也有它们自己的 “圣经”，这是一本名叫 “On the Road” 的书。这一节中，我们对于纽约市的嬉皮士花了多少时间读这本书感兴趣。</p>
<p>假设我们知道总体，所有嬉皮士读这本书的平均时长是 943 分钟。我们还知道，总体的标准差等于 212 分钟。你从总体中做简单随机抽样抽取了 200 个受试者。这个样本中的平均阅读时长是 867 分钟，标准差 188 分钟。</p>
<p>这一节，我将介绍对于研究项目十分重要的三种分布 —— <strong>总体分布 (population distribution)</strong> ，<strong>样本分布 (sample distribution)</strong> ， <strong>抽样分布 (sampling distribution)</strong> 。我将向你展示，如果计算针对特定分数的选择性个体的概率。 </p>
<p>第一个分布，总体分布，它看起来像这样，近似钟形，均值 943 分钟，标准差 212 分钟，主体是纽约的嬉皮士们。</p>
<p>第二个分布，数据分布或者是样本分布，它是样本数据的分布，看起来像这样。它跟总体分布一样，近似钟形，均值 867 分钟，和总体均值 943 分钟相差不大。标准差 188 分钟。</p>
<img src="/images/sdl_17.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>注意，样本统计里采用罗马字母注记，而总体里采用希腊字母注记。</p>
<p>第三种分布，样本均值的抽样分布，它就像下面这样：</p>
<img src="/images/sdl_18.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>根据中心极限理论，它是正态分布的。在这个分布中，主体不是分布中的个体，而是来自纽约嬉皮士的 200 个受试者样本的一个不确定的数字。样本均值的抽样分布的均值，是这些不确定样本均值的均值。具体的数值，等于总体分布均值的数值，即 943 分钟。为了说明我们正在讨论的是抽样分布，我们添加 $ \bar x $ 下标来表明是样本均值的均值而不是个体分数的均值。抽样分布的标准差，等于总体标准差，除以 n 的平方根，即 212 ，除以 200 的平方根，得到 15 。</p>
<p>你需要记住的是，第三个分布是一个理论上的分布。我们并不实际地收集无限多的样本。那是不可能做到的，也不必做到。因为只要我们知道总体的均值和标准差，我们就能知道抽样分布长什么样。正态分布的一个大好处是，我们可以通过把原始分数变换成 z 分数，以及引入 z 表格，找出概率。</p>
<p>现在，想象你从总体中选择一个随机样本，这个嬉皮士阅读时长大于等于 1000 分钟的概率是多大呢？</p>
<p>首先，我们需要知道一个嬉皮士阅读那本书的时长等于 1000 分钟距离均值有多少个标准差。我们在总体中计算这个人的 z 分数，z 分数是 1,000 减去 943 ，除以 212 ，等于 0.27 。我们感兴趣的是这个值右边的区域。查询 z 表格，我们发现选中一个阅读时长大于等于 1,000 分钟的嬉皮士的概率是 39% 。现在，想象我们抽取 200 个嬉皮士。这个样本均值大于等于 1,000 分钟的概率是多少？千万注意，这是一个完全不同的问题。我们不是在讨论从总体中选取一个特定的人，而是在讨论基于总体中的特定样本的统计学。因此，我们不用总体分布，而是样本均值的抽样分布。通常，过程是相同的，只不过我们用的是不一样的均值和标准差。这里， z 分数计算过程如下。我们从感兴趣的均值，即 1000 ，减去抽样分布的均值，即 943 ，然后除以抽样分布的标准差，即 212 除以 200 的平方根，即 15 。因此， (1000 - 943) / 15 ，最后得到 z 分数是 3.8 。查询 z 表格，我们发现抽取一个样本的平均阅读时长均值大于等于 1,000 分钟的概率是 0.01% 。</p>
<img src="/images/sdl_19.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>决定选用哪种分布时，需要十分小心。如果你是对选择的独立个体感兴趣，应当使用总体分布；但如果你是对选择的样本感兴趣，应当使用抽样分布。在实际的研究实践中，混淆总体和抽样分布几乎不可能发生。因为你永远无从知道总体的全貌。你唯一可以确定的是你的样本长什么样。</li>
</ul>
<p>接下来，我们会学习如何在缺少总体分布信息的情况下，利用好抽样分布。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十五 | 样本和抽样</title>
    <url>/data-science/statistics-sample-and-sampling/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="样本和目标总体"><a href="#样本和目标总体" class="headerlink" title="样本和目标总体"></a>样本和目标总体</h1><blockquote>
<p>几乎所有的统计研究都基于样本。</p>
</blockquote>
<p>想象你试图知道伦敦有多少学生以嬉皮士自居，但你几乎不可能去问全部的学生这个问题。所以你决定采样，比方说 200 个调查对象，并估计有多少人把自己看做嬉皮士。</p>
<p>关于统计的一个好处是，它能基于仅仅这 200 个调查对象，即样本，帮助你得出关于伦敦所有学生的结论，即目标总体。这一节中，我将详细解释样本和目标总体。</p>
<img src="/images/sampling_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果你从目标总体约 300,000 个学生中选择 200 个调查对象作为样本，基本上你正在聚焦于总体的一个子集。如果你测量一组变量，比如性别，年龄，所在学校，等等。你可以做所有的计算，比如单一变量分析，包括众数、平均数和标准差，或者双变量分析，计算皮尔逊相关系数或者做回归分析。所有这些数字性总结都完全是基于样本，它们被称为 <strong>统计数字 (statistics)</strong> 。通常，这种总结样本数据的方法被称为 <strong>描述统计 (descriptive statistics)</strong> 。不过，在实际的研究实践中，我们经常对特定样本的总结不感兴趣 —— 我们的实际目标是对潜在的目标总体做出推断。</p>
<img src="/images/sampling_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在我们的案例中，所有 300,000 个学生都在伦敦。如果我们借由样本中得到的数据推断关于总体的结论，那我们就是在使用 <strong>推断统计学 (inferential statistics)</strong> 的方法。 统计数字以罗马字母显示。例如，$ \bar x $ 代表平均数， s 是样本的标准差。 参数则以希腊字母显示， μ 代表总体的平均值， σ 代表总体的标准差。 </p>
<img src="/images/sampling_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>想象你问这 200 个调查对象他们觉得自己有多大程度上把自己看做嬉皮士。他们可以从 0 到 10 表示自己嬉皮士的程度， 0 代表他 / 她根本不认为自己是嬉皮士，而 10 代表一个人完全将自己视为嬉皮士。</p>
<p>现在想象样本的 “嬉皮士值” 均值是 3.12 ，核心问题变成：目标总体的均值是多少？推断统计学可以帮助我们解答这类问题。</p>
<a id="more"></a>

<h1 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h1><p>推断统计学指的是基于样本数据来得出对于总体的结论的一系列方法。可以想象，为了理解推断统计学的方法，学会如何抽取样本是至关重要的。这一节中，我将把好的抽样方法和坏的抽样方法放在一起一同讨论。同时，我会讨论到你在抽样过程中可能遭遇的各种 <strong>偏差 (bias)</strong> 。</p>
<p>样本是总体的子集，此外再无其他。对于推断统计学的方法来说，并非所有的样本都合用。你需要的是 <strong>代表性样本 (representative samples)</strong> 。换言之，你需要你的样本是总体的一个微型版本。为了达到这个目的，一个不错的方法是抽取 <strong>简单随机抽样 (simple random sample)</strong> 。这意味着你确信总体中的每一个对象都有相同的机会被选中。</p>
<img src="/images/sampling_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>回到嬉皮士的例子。你决定抽取 200 个调查对象。平均的嬉皮士值是 3.12 ，总体包含伦敦所有的学生，感兴趣的参数是总体的均值，样本包含 200 个被选中的学生。</p>
<p>你将用于推断总体均值的统计数据是样本的统计均值。为了得出结论，我们希望样本是简单随机样本。如何确保这一点呢？</p>
<img src="/images/sampling_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>首先，你需要搞清楚总体是怎样的。我们已经知道，总体是全体伦敦学生。</p>
<p>第二步，得到全部主体的名单，我们称之为 <strong>抽样框 (sampling frame)</strong> 。想象伦敦有一个组织拥有所有学生的概况信息，包括他们的通信录细节。进一步的，这个组织愿意和你共享名单。你让计算机从名单中随机抽取 200 个学生。这样一来，你就得到了一个简单随机样本。</p>
<p>下一步是确定你如何触达你的 200 个调查对象。在面对面的采访中，你和调查对象在相同的房间，面对面提问。这么做到的好处是调查对象比较有可能参与，缺点是这样收集数据太昂贵了。另一个选项是通过电话采访，这么做开销小很多，但通常调查对象在电话上耐心有限，因此采访时间短暂。你还可以让调查对象填写问卷。因为他们可以在线完成调查，所以也是很便宜的选项，缺点是他们很可能不参与。</p>
<p>与此同时，你会遭遇各种形式的偏差。第一个是 <strong>覆盖偏差 (undercoverage)</strong> ，它指的是采样数据框没有囊括所有的个体。在伦敦学生的例子中，如果学生的清单不完整，就会发生这种偏差。有的学生没有机会被纳入样本。</p>
<p>还有 <strong>抽样偏差 (sampling bias)</strong> ，它指的是每个个体被纳入样本的机会不是均等的。当你的抽取做不到随机时，这种偏差就会发生。举个例子，如果你选择在街上随机接触人群，我们称为 <strong>任意抽样</strong> 或者 <strong>便利抽样 (convenience sample)</strong> 。它并非随机，因为有些人比其他人更少上街，他们被纳入样本的机会就更小。</p>
<p>其三，在你取得样本后，还有一种形式的偏差，它叫 <strong>无应答偏差 (nonresponse bias)</strong> 。某些被选中的主体可能拒绝参与实验，或者就是无法触达。还有些同意参与的调查对象只愿意回到特定的部分问题。</p>
<p>问题在于，这些不参与的情况可能不同于总体样本。无论它是覆盖偏差，抽样偏差或者无应答偏差。因为这些个人没有机会被抽样或者被抽样的机会更小，抑或这些个人拒绝回答某些问题，我们可能高估或者低估调查的目标。</p>
<p>简言之，我们的判断 (estimation) 会因某些分群的 <strong>表达不足 (under-representation)</strong> 或者 <strong>过表达 (overrepresentation)</strong> 出现偏差。</p>
<p>最后，还有 <strong>反应偏差 (response bias)</strong> 。在这个案例中，实际给定的反应是有偏差的。有可能，因为调查者问了某些前置的其他问题或者调查对象认为某些答案是社会不能接受的。有可能某个学生认为自己是个嬉皮士，但他认为调查者不喜欢嬉皮士于是就告诉调查者他不是。在我们的案例中，评估可能因为某些回应的 <strong>系统性误表达 (misrepresentations)</strong> 而出现偏差。</p>
<img src="/images/sampling_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此，在抽取样本时，你需要确保抽样是简单随机抽样，尽可能将各种形式的偏差降到最低。不过，很多情况下我们几乎不可能做到简单随机抽样。所幸，有另外两种随机抽样方式一样奏效。</p>
<p>在介绍它们之前，让我们先重温一下简单随机抽样的工作方式。如果你的总体中包含了所有的伦敦学生，你打算抽取 200 个学生的样本。你把所有学生的名字写在纸上。你把所有的纸放进箱子里，然后随机抽 200 张纸。这就是简单随机抽样。</p>
<p>第一个替代方案是 <strong>随机多阶段整群抽样 (random multi-stage cluster sample)</strong> 。它的工作方式如下：首先，你在总体中标识出大量的 <strong>整群 (cluster)</strong> ，比如，根据学生注册的不同的教育程序，每种程序用一个桶表示。把学生的纸按照注册的教育程序放入不同的桶中。接下来，你随机选几个桶，然后从这些桶中选取代表学生的纸，这样就得到了样本。多阶段整群抽样在你无法拿到很完整抽样数据框，或者简单随机抽样太昂贵时是一个很好的替代方案。</p>
<p>第二个替代方案是 <strong>分层随机抽样 (stratified random sample)</strong> 。现在，你将总体分成独立的组，这些组我们称为 <strong>层 (strata)</strong> 。例如，伦敦的各所大学，每个大学用一个盒子表示。你把学生的名字按照他们注册的大学放进不同的盒子里。接下来，你从每个盒子里随机挑出名字。所有这些名字就构成了你的样本。这种方法的好处是你可以确信样本中每一层都有足够的个体，缺点是你需要数据框，你还需要知道每个调查对象属于哪一层。</p>
<p>有一个重要的警告。大样本无法弥补糟糕的抽样步骤。如果你的样本不够随机，尽管你可以一直增加抽样数，你的样本也永远不会变得更好。假设你的样本是随机的，那大样本理论上总是更好的。不过，一旦你超过了某个临界点，样本量的增加对于总体参数评估准确度的影响就微乎其微了。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十四 | 二项分布</title>
    <url>/data-science/statistics-binomial-distribution/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<p>对于离散随机变量，有一个最重要的概率分布，它是 <strong>二项分布 (binomial distribution)</strong> 。二项分布处于二元数据。因为二元数据的情况非常多，所以二项分布使用频繁。</p>
<p>让我们从例子开始，你会在这些例子中看到两种结果。比如，参加会议是否迟到，投票赞成或者反对，噪音等级超过 80 分贝或者没有。当你收集这类现象的试验时，成功或者失败的数字服从二项分布。例如，你可以考虑每 25 个与会人员，有多少个迟到，或者投反对票的人有几个。</p>
<img src="/images/bd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>下面是你可以确定一个随机变量服从二项分布的条件：首先，每一个试验成功的概率相同；其次，试验在统计上是独立的 —— 即一个试验的结果不会影响其他试验。</p>
<img src="/images/bd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>实际上，你发现二项分布的三个要素。首先，试验现象有两种结果，并且成功概率是常量。这种实验被称为 <strong>伯努利试验验 (Bernoulli trial)</strong> 。其次，你观察试验结果 n 次。第三，你对成功的结果计数，记为 x 。这三个元素被结合成一个公式，它给出了在 n 次试验中取得特定数量成功结果的概率。公式如下：</p>
<p>$$ P (x) = \frac {n!}{x!(n - x)!} p^x (1 - p)^{n-x}, x = 0,1,2,…,n $$</p>
<p>你可以直接把 n，x 和 p 填进公式从而获得答案。</p>
<img src="/images/bd_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如公式所示，随机变量 x 只能取 0 到 n 的值。这很合理，因为你只能有有限次成功，0 ，1 ， 2 ，直到 n 。因此这个公式是一个概率质量函数，它直接给出了匹配每个可能的 x 的概率值，你不必像考虑概率密度函数那样考虑区间。</p>
<img src="/images/bd_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>感叹号不常见，它表示 <strong>阶乘法 (factorial)</strong> ，即把所有从 1 到指定的整数全部相乘的结果。例如， 4 阶乘等于 1 乘以 2 乘以 3 乘以 4 。 公式前部的这个阶乘的除法实际上是给出了无视顺序，从 n 个元素中选出 x 个元素的方法，它也被称为 <strong>二项系数 ( binomial coefficient)</strong> ，有的时候也速记为 $ C^x_n $ 。</p>
<p>现在，让我们把二项公式应用到特定的例子里吧。想象你每天通勤的路线上需要经过一座吊桥。这桥有 10% 的时间是打开的，但打开时机是随机的。那么你在一周中碰到 0 ， 1， 2 ，直到 5 天的概率是多少呢？</p>
<img src="/images/bd_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>实验有 5 次试验，遇到打开的桥的概率是 0.1 。因此，这里的二项分布的概率如下：</p>
<img src="/images/bd_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果你把 6 个概率和 x 相乘并加总，你会发现这个值等于 1 。本应如此。</p>
<a id="more"></a>

<p>让我们借助同一个例子，移到一个相关的问题，如果 5 天内最多一天遭遇打开的吊桥，这个概率怎么算呢？可以很好地利用上面的概率表，我们要找的是没遇到打开的吊桥和有一天遇到打开的吊桥的情况，两个概率之和是 0.92 。</p>
<img src="/images/bd_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>为了回答最后一个问题，我们需要利用累积的二项概率分布，即给定所有结果，低于或者等于某个成功数量的概率。方程如下：</p>
<p>$$ F (x) = P (X \leq x) = \sum_{k = 0}^{x} \frac {n!}{k!(n - k)!} p^k (1 - p)^{n - k} $$</p>
<p>这个公式跟二项概率质量函数几乎相同，除了在前面做了求和，并且把所有的 x 替换成了符号 k 。</p>
<p>现在让我们来看一下二项分布的形状。它是离散的，意味着它只会给出 0 , 1 , 2, 之类的概率。</p>
<img src="/images/bd_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有趣的是，二项分布的形状会根据参数的变化而变化。基于参考，分布可以是 <strong>右偏态 (right-skewed)</strong> 的，或者 <strong>左偏态的 (left-skewed)</strong> 的，或者是对称的。</p>
<img src="/images/bd_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这三个分布显示 20 个成功概率不同的试验。第一个成功概率是 0.1 ，第二个成功概率是 0.5 ，第三个是 0.9 。</p>
<img src="/images/bd_11.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>一般来说，成功概率更低的二项分布是右偏态的，而成功概率高的是左偏态的。通过水平对齐，你会发现中间分布的顶点低于两边的，因此它更分散。这是二项分布很有趣的一个属性。实际上，二项分布的标准差取决于 p ，均值也是。二项分布的均值就等于 p ，它的标准差等于 n 乘以 p 乘以 (1 - p)，然后求平方根。当 p 等于 0 或者 1 时，标准差等于 0 。当 p 等于 0.5 时，它的标准差达到最大。</p>
<img src="/images/bd_12.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>二项分布是一个离散概率分布，用于只有两个独立互斥结果的随机变量 —— 成功或者失败。它给出了对于随机变量的 n 个结果，其中 x 个成功的概率。也叫做试验成功的概率。</li>
<li>二项分布假定所有试验的概率 p 都是固定的，它的均值等于 n 乘以 p ，标准差等于 n 乘以 p 乘以 (1 - p)，然后求平方根。</li>
<li>二项分布根据 p 的变化可以向右或者向左偏斜，或者对称。当 p 接近 0 时是右偏态，当 p 接近 1 时是左偏态。二项分布公式如下：<br>$$ P (x) = \frac {n!}{x!(n - x)!} p^x (1 - p)^{n-x}, x = 0,1,2,…,n $$<br>速记为 $$ X \sim B (N, P) $$</li>
<li>二项分布的累积概率分布公式如下：<br>$$ F (x) = P (X \leq x) = \sum_{k = 0}^{x} \frac {n!}{k!(n - k)!} p^k (1 - p)^{n - k} $$</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十三 | 正态分布</title>
    <url>/data-science/statistics-the-normal-distribution/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="正态分布-normal-distribution-的函数形式"><a href="#正态分布-normal-distribution-的函数形式" class="headerlink" title="正态分布 (normal distribution) 的函数形式"></a>正态分布 (normal distribution) 的函数形式</h1><p>在所有的概率分布中，有一个特别出众，我们经常遇到。它就是 <strong>正态分布 (normal distribution)</strong> 。</p>
<p>在本节中，我们会学习它的重要属性。正态分布又被称为 <strong>高斯分布 (gaussian distribution)</strong> 。它是对称的，钟形，以均值 μ 和 标准差 σ 为特征。分布的最高点是均值的位置，宽度则由标准差指定。均值 μ 和 标准差 σ 被称为正态分布的 <strong>参数 (parameters)</strong> 。</p>
<img src="/images/nd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>正态分布的累积概率分布是一个 <strong>S 函数曲线 (sigmoideal shape)</strong> ，均值处于概率为 0.5 的地方，标准差决定了曲线的陡峭程度。</p>
<img src="/images/nd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>随机变量 X 有一个均值 μ ，标准差 σ 的正态分布，可以速记为：</p>
<p>$$ X \sim N (\mu, \sigma^2) $$ </p>
<p>而下面这个等式描述了完整的概率密度：</p>
<p>$$ f (x)=\frac {1}{\sqrt {2\pi}\sigma} e^{-0.5\left (\frac {x-\mu}{\sigma}\right)^2} $$ </p>
<p>这个方程之所以重要，并非因为它第一眼看起来很复杂 —— 包含了三个重要的数学常量，$ \pi $，$ e $ 和 2 的平方根，还因为它连接了统计国王和物理世界。这个方程可以描述粒子扩散的过程。如果你释放一个扩散物，比如放一块糖到茶里，茶里的糖将按照这个方程的规律扩散。不仅流体是这样，大气中的颗粒物，道路交通，社会中的信息，都遵循这个分布的规律。</p>
<a id="more"></a>

<p>同时，我们会频繁地遇见高斯分布，是因为根据 <strong>中心极限定理 (central limit theorem)</strong> ，各种独立的随机过程组合之后，就会产出这种分布。不过，让我们不要跑题。我将通过拆解的方式来解释这个方程。</p>
<p>整个方程给出了随机变量 X 的概率密度，整个函数是一个 <strong>指数函数 (exponential function)</strong> ，前面是一个常数，然后指数部分包括小 x ，即随机变量可能取得的值。观察指数部分，从 x 中减去平均数，然后除以 σ ，这实际上是在计算 z 分数。所以随机变量的值在参与到方程后续的计算之前先做了标准化。</p>
<img src="/images/nd_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在让我们聚焦到 e 之前的常数。在没有常数之前，曲线之下的面积是跟着 σ 变化的。但是通常乘以这个常量，这块面积变成了精确的 1 。这个常量的值实际上正是曲线顶部的高度，也就是 x 等于 μ 的地方。</p>
<img src="/images/nd_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>正态概率分布有一个违反直觉的属性 —— 当逼近极大或者极小的 x 时，概率接近于 0 ，但实际永远不可能是 0 。</p>
<img src="/images/nd_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这导致一个事实：随机变量的值可以往负无穷大和正无穷大无限伸展。即使这些值是极小的概率，但仍然满足所有概率之和等于 1 的规律。</p>
<img src="/images/nd_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>最终确定之前，让我们回到 μ 和 σ 这两个参数，它们决定正态分布曲线的位置和形状。下图是一个西欧男性在一周中每天上班路上花的通勤时间。平均的通勤时间是 3 分钟，标准差 6 分钟，而同一个国家的西欧女性，通勤均值更小，但是标准差更大。你会发现，曲线越宽，顶点越低。</p>
<img src="/images/nd_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>曲线还有一个属性 —— 当 x 轴的单位变化时， y 轴的单位也会发生变化。比如，你用小时而不是分钟来表示时间时，概率密度就从每分钟变成了每小时。</p>
<img src="/images/nd_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>正态分布或者说高斯概率密度函数，是对称的钟形曲线，其对应的累积概率函数是 S 形曲线。位置和形状完全由两个参数描述，均值和标准差。均值决定曲线的中点，而标准差决定曲线的宽度。曲线越宽，则顶点必定越低。因为曲线下的面积始终等于 1 。</li>
<li>对于一个均值为 63 ，标准差为 12 的变量 x ，速记如下：<br>$$ X \sim N (63, 12^2) $$<br>正态分布方程如下：<br>$$ f (x)=\frac {1}{\sqrt {2\pi} 12} e^{-0.5\left (\frac {x-63}{12}\right)^2} $$</li>
<li>这种方程不但描述了概率分布，也描述物理世界中许多过程的结果，其中的许多扩散形式十分重要。</li>
</ul>
<hr>
<h1 id="正态分布的概率计算"><a href="#正态分布的概率计算" class="headerlink" title="正态分布的概率计算"></a>正态分布的概率计算</h1><p>如果我们知道某个随机变量的概率分布，那我们就可以计算变量落在某个区间的概率。</p>
<p>这一节中吗，我将通过一个具体的例子来解释这类计算是如何进行的。</p>
<p>概率密度函数，经常被缩写为 pdf ，给出了随机变量每单位的概率。下面是一个出租车司机日常等待时间的 pdf 。在 y 轴你看到是每小时的概率， x 轴是以小时为单位的概率。现在，假设你是一个出租车司机，你想要知道一天中等待时间超过 7 小时的概率。你需要计算面积区域。基于图像，你可以粗造地估计面积。</p>
<img src="/images/pdf_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>借助累积概率函数，也可以做到这一点，并且更精确。通过 x 轴 7 个小时的位置读取对应的 y 轴上的概率，再从 1 中减去这个概率。因为你关心的是长于 7 个小时而不是短于 7 个小时的概率。</p>
<img src="/images/pdf_1_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，让我们应用此前了解到的正态分布的等式。它是一个中点位于 μ ，宽度由 σ 定义的 pdf 形状。对应的累积概率函数在下方。</p>
<img src="/images/pdf_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有趣的是，尽管曲线会随着 μ 和 σ 变化，距离中点一个 σ 的区间，对应的概率始终不变。</p>
<img src="/images/pdf_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我演示一下，假设一条曲线的均值是 20 ，标准差是 9 ，另一条曲线的均值是 30 ，标准差是 6 。对两条 pdf ，从均值减去一个标准差到均值加上一个标准差的区域，曲线之下的面积都是 0.68 。无论 μ 和 σ 分布是多少，所有的正态分布都满足这个情况。</p>
<img src="/images/pdf_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在把区间扩展到围绕均值正负两个 σ ，区间对应的概率大致是 0.95 。</p>
<img src="/images/pdf_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>再扩展到正负三个 σ ，区间对应的概率大致是 0.997 。</p>
<img src="/images/pdf_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>统计计算中经常用到一个、两个、三个 σ 区间的概率值。</p>
<img src="/images/pdf_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我通过一个练习来演示一下一个、两个、三个 σ 的规则。假设你在一周中花在通勤上的时间服从正态分布，均值 40 分钟，标准差 10 分钟。 那 95% 的状态下，你的通勤时间会落在哪个范围。是的，它在均值减两个标准差到均值加两个标准差的区间。在这里，就是从 40 分钟减去 20 分钟到 40 分钟加上 20 分钟的区间。</p>
<img src="/images/pdf_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我假定你想要知道通勤超过 50 分钟的概率，在已知平均时间是 40 分钟，标准差是 10 分钟以及一个 σ 规则的前提下，你会如何计算呢？为了解答这个问题，你需要一点创造力 —— 你知道正态分布是对称的。因此有一半的概率落在均值的一侧，继而可以知道从均值减去一个标准差到均值这个区间，概率是 0.68 的一半，即 0.34 ，于是，小于 50 分钟的概率就是 0.5 加上 0.34 ，即 0.84 。然后取补集，即 1 - 0.84 ，等于 0.16 。</p>
<img src="/images/pdf_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>基于概率密度函数，你可以计算随机变量落在给定区间的概率，通过估算曲线在那个范围下的面积。借助累积概率函数，通过读取 y 轴对应的概率值也能做到这一点，并且更精确。</li>
<li>对于一个服从正态分布的变量来说，围绕均值的区间，有一个固定的概率对应关系。</li>
</ul>
<hr>
<h1 id="标准正态分布"><a href="#标准正态分布" class="headerlink" title="标准正态分布"></a>标准正态分布</h1><p>在计算器和计算机还不得的时代，正态分布有一种非常重要的特殊形态 ——  <strong>标准正态分布 (standard normal distribution)</strong> ，也被称为 <strong>z 分布 (z-distribution)</strong> 。不过即便在今天，标准正态分布仍被高频使用，用于快速计算和呈现分析结果。</p>
<p>这一节中，我将解释标准正态分布的属性和应用。</p>
<p>尽管距离均值 1 个， 2 个， 3 个标准差的概率值很有分析的价值，仍有许多不在这些位置上的情况需要计算概率。</p>
<img src="/images/snd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>举个例子，比如距离均值 1.3 个标准差的概率。实际上，为了表示距离均值任意数量个标准差的意思，我们选择字母 z 。 这些 z 值的概率分布是一个均值为 0 ，标准差为 1 的正态分布，也被叫做为标准正态分布，或者 z 分布。</p>
<img src="/images/snd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>z 分布的累积分布常常用表格来呈现。下面这份表格给出一个正态分布的随机变量的累积概率，位置通过均值加上 z 个标准差偏移来确定。</p>
<img src="/images/snd_2_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这份表格同时展示了 z 值和关联的累积概率。</p>
<img src="/images/snd_2_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如你所见，从值 -2.00 开始，以很小的步长增长，要累积到接近 1 的地方，列表会很长。因此，我们通常采用另外一种更简洁的形式来呈现 —— 用 z 值第 1 位小数作为一条边，第 2 位小数作为另一条边。</p>
<img src="/images/snd_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>基于这样一个表格，你能够基于给定的 z 值，快速地找到与之关联的累积概率。比如，为了找到 z 值等于 1.41 的累积概率，你先选择 1.4 ， 然后选择 0.01 ，最后找到对应的概率是 0.92 。</p>
<img src="/images/snd_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>但如果我们是从一个普通的正态分布开始，该如何拿到 z 呢？首先，你需要这样考虑：对于一个随机变量 X 的某个值 x ，要把它看成均值加上 z 个标准差偏移。这个时候，你想知道 z ，可以反过来借由 x ，均值和标准差。把等式做一个调整，你发现 z 值等于随机变量的观察值与均值之差，再除以标准差。</p>
<img src="/images/snd_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>让我们把上面的变换应用到实例中。想象一群绿脚大雁每年秋天都要从波罗的海地区迁徙到欧洲的大西洋海岸。迁徙持续时间服从均值为 4 天，标准差为 1.3 天的正态分布。现在，要计算这群大雁在 6 天内到达迁徙目的地的概率。</p>
<img src="/images/snd_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>首先，你需要对 6 天做 <strong>z 变换 (z transform)</strong> ，通过 x 减去均值，然后除以标准差，得到 1.54 。下一步，在表格中查询 z 值，找到匹配的概率概率。</p>
<img src="/images/snd_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如你所见，这个 z 值匹配的是概率 0.9382 ，这就是针对前面问题的答案 —— 这群大雁在 6 天内完成迁徙的概率。</p>
<img src="/images/snd_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果是迁徙时间介于两天到五天之间，你又会怎么计算呢？下面是问题的正式描述：</p>
<img src="/images/snd_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>首先，计算小于 5 天的概率，然后计算小于 2 天的概率。然后将两个概率相减，就得到要求的范围： 2 天到 5 天。小于 5 的概率是 0.78 ，小于 2 的概率是 0.06 。从 2 到 5 的概率等于两者之差，即 0.72 。</p>
<img src="/images/snd_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，让我们休息一下。我们已经看到，可以把任意正态分布转换成标准正态分布或者说 z 分布的变量，通过减去均值再除以标准差来实现。然后，借助表格化的分布数据，我们能找到小于某个值、大于某个值或者介于两个值之间的概率。因此，如果你已经有一个概率了，你想反过来找出对应的随机变量的值，这时候要怎么做呢？</p>
<p>别担心，做法几乎相同，只需要反过来。还是用前面大雁迁徙的粒子。假设它们平均需要 4 天，标准差 1.3 天来完成迁徙。那么，你可以找出迁徙持续时间的十分位。</p>
<img src="/images/snd_12.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>持续时间的十分位意思是迁徙时间少于所有情况中的 10% 的情况，或者多于所有情况中的 90% 的情况。首先，你通过查表看到最接近概率 0.1 的 x 的值，它是 - 1.28 ，然后借助公式 $ x = μ + zσ $ ，你得到 x 的值时 2.34 天。</p>
<img src="/images/snd_13.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>最后，我想强调的是， z 变换适用于任意类型的数值数据，它会得到一个均值为 0 ，标准差为 1 的数据集，并且不包含对数据潜在分布的假定。因此，标准化数据是一个好方法，尤其是你想在不同的案例间做比较的时候。不过， z 变换并不能自动地创造出服从 z 分布并且能允许你计算概率的数据。你要得到 z 分布的数据，前提是数据本来就服从正态分布，并且你能算出均值和标准差。</p>
<img src="/images/snd_14.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h2><ul>
<li>z 变换可以应用于标准化数据，取得一个均值为 0 ，标准差为 1 的数据集，无论原始数据集是何种分布。当已知数据富服从正态分布时，可以基于 z 分数，借助对应 z 分数的累积概率表格来做概率计算。</li>
<li>对于给定的 x ，你通过从中减去均值，再除以标准差的方式来获得 z 。 z 表格提供了匹配 z 值的累积概率。这些概率指的是随机变量小于或者等于 x 的概率。相反地，对于给定的概率，你可以在表格中找出 z 值，然后计算出匹配这个值的 x 。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十二 | 随机变量的平均数和方差</title>
    <url>/data-science/statistics-mean-and-variance-of-random-variable/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="随机变量的平均数"><a href="#随机变量的平均数" class="headerlink" title="随机变量的平均数"></a>随机变量的平均数</h1><p>在了解了随机变量的概率分布之后，我们可以开始对这种变量进行计算了。</p>
<p>首先，你需要知道，<strong>总结性统计 (summary statistics)</strong> ，跟观测数据相似，都能用来捕捉分布的本质。这一节中，我们要来研究概率分布的平均数，以及我们在调整随机变量或者组合随机变量之后，平均数如何变化。</p>
<p>以下将一个随机变量的平均数以 $ μ $ 注记，它表示对许多观测值预期的平均结果，因此也被称为随机变量的 <strong>期望值 (expected value)</strong> ，以 $ E $ 注记。</p>
<p>一个离散随机变量的平均数是所有可能的值乘以概率权重之后的均值，因此它等于每个可能的值乘以概率，然后加总。对于连续随机变量，同样的规则也适用。为了应对连续性，加总的计算被替换成积分 (integral) ，概率也不像离散那样被定义为 i ，而是 x 的函数。 </p>
<p>举个例子，假设你正在一个熟悉的街区日常漫步，路上会经过三个交通灯。每等一个交通灯会使整个漫步多花 2 分钟。对于这三组交通灯的等待，你记录了等 0 个 到等 3 个的频率，下面是概率表：</p>
<img src="/images/mvorv_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你预期的等待时间计算方法如下，最后会得到 2 分 12 秒。有趣的是， 2 分 12 秒这个值实际永远不会发生。你要么不用等，要么就是等 2， 4， 6 分钟中的某个时间。</p>
<p>现在，让我们来审视一下随机变量的平均数。如果我们给随机变量 x 乘上一个系数再加上一个值， 变成 $ a + bx $ ，那么平均值会变成 $ μ_{a+bx} $ 。</p>
<a id="more"></a>

<p>现在回到我们的例子。由于你找到一条捷径，旅程节省了一分钟。但同时，交通灯变得更忙了 —— 等待时间增加到 2 分 30 秒，即增加了 25% 。你抄近路省出的时间对应方程里的 a ，等待时间增长系数 1.25 对应 b 。新的概率分布通过下面这张表格呈现。</p>
<img src="/images/mvorv_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>新的等待时间平均值变为 1 分 45 秒。</p>
<p>现在让我们来看看两个随机变量相加或者相减的时候回发生什么。结果是：两个相加或者相减的随机变量的平均值也是它们各自平均值的简单求和或者求差。这个结论甚至不要求两个变量相互独立。</p>
<img src="/images/mvorv_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>举个例子，假设你想要计算一个礼拜的等待时间的平均值，那你只需要把每天的平均值加起来就可以了：</p>
<img src="/images/mvorv_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>平均值，或者一个离散随机变量的期望值，是变量所有可能的值乘以它们的概率，然后求和。如果随机变量通过乘法或者加上常数改变，那么平均值会发生相同的变化。</li>
<li>几个随机变量的平均值加总在一起是它们平均值的总和，即便这几个变量在统计上不一定是独立的。</li>
</ul>
<hr>
<h1 id="随机变量的方差"><a href="#随机变量的方差" class="headerlink" title="随机变量的方差"></a>随机变量的方差</h1><p>在平均数之后，你需要了解的第二个总结性统计指标是随机变量的方差，即离散程度的度量。</p>
<p>这一节中，我们要来研究概率分布的方差，以及我们在调整随机变量或者组合随机变量之后，方差如何变化。</p>
<p>一个随机变量 X 的方差 var (X) 是以它与平均值的差值的平方的期望来定义的：</p>
<p>$$ var (X) = E [(X - μ)^2] $$</p>
<p>如果你想基于概率分布算出方差，它其实是变量可能的值与平均值之差的平方，然后加总或者积分。<br>连续随机变量的方差：<br>$$ \int {(X - μ)^2f (x) dx} $$<br>离散随机变量的方差：<br>$$ \sum {(x_i - μ)^2P (x_i)} $$</p>
<p>连续随机变量的方差比较复杂一些，用到了积分。离散随机变量看起来就简单一些。</p>
<p>举个例子，这个离散分布给出了一年中你可能遭遇交通事故的风险。平均风险是 0.04 ，即每 25 年一次。</p>
<img src="/images/mvorv_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>首先，你计算出事故次数和平均值之差，然后平方，乘上对应的概率，最后加总。事故风险的方差看起来接近 0.06 ，标准差 0.24 左右。</p>
<p>现在，让我们来看看，如果通过给随机变量加一个 a 或者乘以 b ，方差会发生什么变化。</p>
<img src="/images/mvorv_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>当你将两个 a 放定义方差的等式中变换时，你会发现常量 a 消失了，而因子 b 被平方了。因此，通过加或者减一个值到随机变量，它的方差不变。但通过乘以一个数 b ，它的方差会变成原始方差乘以 b 的平方。标准差，即方差的平方根，则跟随因子 b 一起变化。</p>
<p>举个例子，你是否经历过晴天人们更愿意跟你打招呼，阴天更不爱搭理你的情景呢？下面图中上方是一个阴天时你走在街上每分钟遇到的点头或者微笑次数的分布。平均每分钟 1.4 次，方差 0.84 。而图中下方是晴天时的数据，你发现大家变得更友好了，具体来说，友好的倍数是 2 。</p>
<img src="/images/mvorv_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>理论告诉我们，平均值应该变成 2 倍于 1.4 ，即 2.8 ，而方差应该变为 4 倍，即 3.36 。让我们检视一下新的分布的方差。</p>
<img src="/images/mvorv_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这个表格展示了具体的步骤。从微笑或者点头次数减去平均值得到差值，平方，乘以概率，最后加总，确实是 3.36 。</p>
<p>现在让我们来看看如果把两个随机变量相加或者相减会怎么样。对于随机变量 X 和 Y ，两者之和的方差是两者各自方差的和再加上 2 乘以 X 和 Y 之间的 <strong>协方差 (covariance)</strong> 。而两者之差的方差是两者各自方差的和再减去 2 乘以 X 和 Y 之间的协方差。</p>
<img src="/images/mvorv_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>下面这两个更完整的等式则适用于 X 和 Y 各自有因子 a 的情况。</p>
<img src="/images/mvorv_9_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这些等式适用于任意两个相加或者相减的随机变量，而且显而易见，它们要求你知道两个变量之间的协方差。然而，协方差信息通常是不可得的，因此我们这里不考虑通用的情况，而是先考虑一个更严格的案例，即变量之间不相关的情况。这样会使问题简单很多，因为两个不相关变量之间的协方差是 0 ，后面 1 项就从等式中消失了。</p>
<img src="/images/mvorv_9_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此，在不相关变量之间，相加或者相减都无关紧要了，方差总是两个方差之和。你还可以把等式泛化到任意多个随机变量之和。</p>
<img src="/images/mvorv_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>还有一个值得注意的点是，随机变量相加的标准差总是小于独立的随机变量标准差相加之和。这看起来很合理，因为随机变量结合之后，有一些变异性会被抵消。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>随机变量的方差，是这个变量所有可能的值减去它的平均值，乘以概率，然后平方，最后加总或者积分。<br>$$ 连续随机变量：\int {(X - μ)^2f (x) dx} $$<br>$$ 离散随机变量：\sum {(x_i - μ)^2P (x_i)} $$ </li>
<li>给随机变量增加常量不会改变方差，但因子会导致方差变为因子平方倍。</li>
<li>几个不相关随机变量相加或者相减的方差等于这些变量各自方差之和。标准差是方差的平方根，因此为了得到调整后的标准差，你需要先得到调整后的方差。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十一 | 概率分布</title>
    <url>/data-science/statistics-probability-distributions/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="随机变量和概率分布"><a href="#随机变量和概率分布" class="headerlink" title="随机变量和概率分布"></a>随机变量和概率分布</h1><p>随机变量的随机性其实并不像它的名字传递的那样多。这一节教程中，我将通过随机变量的可能结果和它们对应的概率来描述 <strong>概率分布 (probability distribution)</strong> 。换句话说，随机分布使随机性具体化，并且提供了一条在计算中使用随机变量的道路。当我们观察个体或者对象的时候，我们可以关注每个个体的若干个属性，这些属性就叫做 <strong>变量</strong> 。</p>
<p>现在，想象你收集了一份数据，并且决定重复实验。你能够找到相同的试验个体来测量变量，或者能找到相近的个体。不管采用哪一种，你会发现你的变量的值每次都不一样。这就是所谓的变量。举个例子，你测量一个人的身高几次，每次的结果可能会有几毫米到 1 厘米的偏离，这取决于你测量的时间在一天中的时刻，你的测量设备的精度，等等。</p>
<p>通常我们预料变量的值具有随机的变异性。如果这种概率的随机性是中肯的，则这个变量被称为 <strong>随机变量 (random variable)</strong> 。随机变量可以有一组可能的值，每个值都和概率关联。因此，如果随机变量的样本足够大，不同值的相对频率就接近概率。为了让表达更清晰，让我们用斜体的大写字母来表示随机变量，小写字母来表示它取到的值。</p>
<p>即 <strong><em>X</em></strong> 为随机变量，$ x_1, x_2, x_3, … $ 为随机变量的值。</p>
<p>随机变量有两种，一种是 <strong>离散的 (discrete)</strong> ，一种是 <strong>连续的 (continuous)</strong> 。离散随机变量可以有一组可数数量的不同值，比如 0 / 1 / 2 / 3 。实际上，如果一个随机变量只能取得有限数量的不同值，那它必定是离散的。离散随机变量的例子很多，比如一个家庭里小孩的数量。连续随机变量则可以取得无限数量的可能值。它通常是测量。为了演示无限性，假设一个身高值测出来是 3.1 米，如果换更精确的测量仪器，也许能测到 3.14 米。更精确的仪器，也许还能测到 3.145 米。换言之，通过更精确的测量，或者放大操作，无限数量的结果是可能的。年龄，温度，速度，这些都可以是连续随机变量的例子。</p>
<p>随机变量的值可以很方便地通过随机分布来呈现。随机分布的呈现形式可以是表格，图或者数学方程，并且是通过随机变量的每个取值关联的概率列表来定义的。</p>
<img src="/images/pd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>根据定义，每个随机变量都有一个概率分布，离散随机变量的概率分布叫 <strong>概率质量函数</strong> ，而连续随机变量的概率分布叫概率密度函数。至于为什么有这种区别，稍后解释。</p>
<a id="more"></a>

<p>对于离散随机变量来说，通过列出每种可能的结果，容易看出概率。假设变量 <strong><em>X</em></strong>  接收 1, 2, 3, 或者 4 。那么下面这张表就列出了每种结果的概率。分布还可以用概率直方图来描述，这跟频率表或者频率直方图的用法如出一撤。</p>
<img src="/images/pd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>对于连续随机变量，可以采用图表。下图中的概率分布并没有在 y 轴上给出概率，而给出了 <strong>概率密度 (probability density)</strong> 。为了获得概率，你需要考虑曲线某个区间下方的区域而非曲线的高度。概率就是由这块区域的面积给出的。</p>
<img src="/images/pd_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>y 轴之所以要采用密度是因为你的随机变量单位可能会改变。比如，你表示的长度由米改成厘米，这个时候密度相应改变，而区域的面积不应该变化。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>随机变量是一个由随机现象产生多种可能结果的变量。当结果有限可数时，它是离散的；当结果数量无限时，它是连续的。</li>
<li>概率分布为随机变量可取得的每个值指定概率。离散随机变量的概率分布叫概率质量函数，而连续随机变量的概率分布叫概率密度函数，它的概率值时通过概率曲线指定区间下的面积来获得的。</li>
<li>概率密度函数可以以表格、图表或者方程的形式呈现。</li>
</ul>
<hr>
<h1 id="累积概率分布"><a href="#累积概率分布" class="headerlink" title="累积概率分布"></a>累积概率分布</h1><p>你已经了解了基本的概率规则，也了解了概率分布，是时候向你介绍累积概率分布了。<br>首先看看下面这个简单的离散随机分布。你能找出 X 的值是 2 或者 3 的概率吗？</p>
<img src="/images/cpd_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>答案可以通过把 x 是 2 或者 x 是 3 的概率相加得到。因此这个值是 0.7 。</p>
<img src="/images/cpd_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>表格上列出的概率，或者说概率质量函数 x 轴上的概率，全部都是互斥。因此任意概率的并集实际上就是这些概率值之和。相似的，根据补集的规则， X 大于等于 1 的概率等于 1 减去 x 是 1 的概率，也就是 0.9 。 </p>
<img src="/images/cpd_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在让我们往下接着走。基于概率分布，我们很容易计算出小于或者等于某个值的概率。举个例子， x<br>小于或者等于 1 的概率是 0.1 。 x 小于或者等于 2 的概率是 0.1 加上 0.3 ，也就是 0.4 。</p>
<img src="/images/cpd_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这种概率被称为 <strong>累积概率 (cumulative probability)</strong> 。 全部累积概率的列表被称为 <strong>累积概率分布 (cumulative probability distribution)</strong> ，或者 <strong>累积分布函数 (cumulative distribution function)</strong> 。这个累积概率分布的概率直方图可以像下面这样：</p>
<img src="/images/cpd_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>对于概率密度函数也是如此。例如，下面这个概率密度函数，对应旁边的累积分布。</p>
<img src="/images/cpd_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有趣的部分是， y 变量从概率密度变成了概率。</p>
<img src="/images/cpd_61.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如你所见，累积概率函数从 0 开始，持续增加到最大值 1 。所有结果的概率之和等于 1 。累积分布，特别是它的图形化形式，十分便于回答两个问题。</p>
<img src="/images/cpd.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你可以在 x 轴上选择随机变量的某个值，然后在 y 轴上找到观察值的哪一部分小于或等于该值。或者相反，你可以在 y 轴上选择一个分数，然后在 x 轴上找到相应的阈值。对于这个阈值，有一个简短的叫法是 <strong>分位 (quantile)</strong> 。举个例子，对于累积概率 0.1 以下的阈值，就称为 0.1 分位。因此累积概率分布实际上展示了随机变量的分位。举个例子，你会发现，对于累积概率 0.5 ，你找到其实就是随机变量的中位数，对于累积概率 0.25 ，你找到是随机变量的四分位。</p>
<img src="/images/cpd_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>值得注意的是，对称概率分布下，中位数和平均数一致。</p>
<img src="/images/cpd_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此，对于对称分布，找到平均值的地方，累积概率也是 0.5 。 </p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>随机变量的累积概率是获取一个小于或者等于某个阈值的概率。另一方面，累积概率体现了随机变量的分位。举个例子，累积概率 0.5 代表随机变量中位数被找到的地方。</li>
<li>跟概率分布一样，累积概率分布也可以以表格、图表或者方程的形式呈现，通过从小到大计算随机变量的概率实现。</li>
<li>随机变量从 0 持续增加到 1 。在对称概率分布下，中位数和平均数一致。</li>
</ul>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之十 | 条件概率和独立性</title>
    <url>/data-science/statistics-conditional-probability-and-independence/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="联合概率和边际概率"><a href="#联合概率和边际概率" class="headerlink" title="联合概率和边际概率"></a>联合概率和边际概率</h1><blockquote>
<p>对有趣现象的计数，在日常生活中常常转换成比例，最终变为概率。利用概率估算的力量，可以更好地理解这些现象之间的关系或做出预测。 <strong>联合概率 (joint probability)</strong> 和 <strong>边际概率 (marginal probability)</strong> 是两个在这种情况下会用到的重要概率类型。在这一节教程中，我将解释联合概率和边际概率的含义，并展示它们的属性。</p>
</blockquote>
<p>想象你在沙滩上观察你的海滩同伴。你会注意到三种不同类型的活动 —— 它们是互斥的。有的休息，他们都坐在或躺在沙滩上。有的玩，这些人到处乱跑，建造沙堡或站在水中。最后，有的在游泳。此外，你还可以按性别区分。所以你观察到的每个人都是一个案例.</p>
<img src="/images/conditional_p_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在数据集中，性别和活动是变量。你最终得到以下结果的列联表。总共计了 113 人，其中有 79 人在休息，有 20 人在玩，并且他们中只有 14 人在游泳。女性和男性的数量，分别是 62 和 51 。</p>
<img src="/images/conditional_p_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这些数字实际上是每行和每列变量位于此表边缘的总和，因此被称为边际值。请注意，这与口语上 “边缘的”，即并不重要的，并不是一回事。在表中边际值代表对于单个变量的说明，没有关于任何其他变量。例如说休息的人数不考虑性别。</p>
<img src="/images/conditional_p_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，我们打开这个频率表通过将每个单元格数字除以总数 113 得到比例的表格。</p>
<img src="/images/conditional_p_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在此表中，中心块包含六个位置，它们加起来等于一。同时，每列中的比例加总到底部的边缘行中的值，每行中的比例加总到右边的边缘列中的值。并且边缘行的值加起来等于边缘列的值加起来。</p>
<a id="more"></a>

<p>你的计数可以看作随机样本，测量在海滩的人的活动和性别分布，于是你会想到把比例看作概率。在中间区域，是活动与性别的交集。例如，给定的人是男性，正在游泳。这些值称为 <strong>联合概率 (conditional probability)</strong> 。 <strong>联合概率只是各种事件的交集概率的简称</strong> 。</p>
<p>我们的每个联合概率关联的事件都与表中任何其他联合概率关联的事件互斥，因为每个人在海滩上只被放置在六个互斥事件之一。同时，联合概率形成一系列完全穷尽的事件，因为案例中不会出现其他的可能活动和性别的组合。因此，联合概率总和为一。</p>
<img src="/images/conditional_p_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在边缘的地方，你可能期望有 <strong>边际概率</strong> 。是的，这些概率仅考虑一个变量。例如，给定的人是男性，无论其活动如何，或者给定在玩，不论性别。边际概率来自联合概率的并集。例如休息的概率，玩耍的概率和游泳概率。因此，这里适用加法规则，即概率相加。</p>
<img src="/images/conditional_p_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此，如果你的原始计数不可得，但有联合概率，你始终可以计算出边际概率 —— 通过求和。相反，如果只给你边际概率，你将无法在每种情况下反推出联合概率。</p>
<img src="/images/conditional_p_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>当你在对源自一个随机样本或者试验中的现象计数时，可以把它们转换成概率。</li>
<li>如果观察多个随机变量，可以计算出这些变量的联合概率和边际概率。</li>
<li>联合概率是变量间某些结果交集的概率，而边际概率是每个变量所有结果概率的总和。</li>
<li>典型的例子里，如果变量有两个，列联表示组织数据的绝佳形式。联合概率放在中间，边际概率放在边缘。所有的联合概率加起来等于 1 ，它们在两个方向上分布加总得到一个边际概率。</li>
<li>你总是可以通过加总，基于联合概率算出边际概率；但仅有边际概率，不借助额外的假定是无法算出联合概率的。</li>
</ul>
<hr>
<h1 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h1><p>术语 <strong>条件 (condition)</strong> 意味着取决于别的东西。和日常语言中的概率上下文或多或少具有相同的含义。</p>
<p>其正式定义是：给定另外一件事已发生，这件事件发生的可能性。数学符号如下：</p>
<p>$$ P (A | B) $$ </p>
<p>即给定 B 发生或以 B 为条件，事件 A 发生。垂直线是 “给定” 的速记，或者说 “有条件” 的速记。条件概率的计算公式是：</p>
<p>$$ P (A | B) = \frac {P (A \cap B)}{P (B)} $$</p>
<p>即事件 A 和事件 B 都发生的概率除以事件 B 发生的概率。也可以用下面的文氏图来说明：</p>
<img src="/images/conditional_p_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>该图强调 A 和 B 的交集概率只能小于或等于 B 的概率。</p>
<p>让我们应用方程到一个熟悉的例子。你考虑了沙滩上的人们进行的各种活动，也可以按性别区分人们。将结果转换一张有概率的表。现在，有了这些变量，活动和性别，如何举出一个条件概率的例子？具体来说，是你知道一个结果发生的概率，然后要计算这个结果发生后，其他结果再发生的概率。让我们举一个具体的例子。你将估算一个概率 —— 该人是男性，且则该人正在休息。</p>
<p>为了算得这个概率，应用前面说到的公式，联合概率除以是男性的概率。因此， 0.3 除以 0.45 。</p>
<img src="/images/conditional_p_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在我有一个问题要问你。你能计算给定活动的性别概率吗？方法一样：</p>
<img src="/images/conditional_p_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此，根据联合概率和边际概率，您可以计算出条件概率。虽然条件概率方程很简单，但它还有更多可以挖掘。再看一下方程式，如果两边都乘以事件 B 的边际概率，你就得到了一个计算联合概率的公式。</p>
<p>这其中隐含的意思是，如果交给你一项任务：找到事件 A 和事件 B 的联合概率，如果你不知道 A 和 B 之间是否独立，你需要同时拿到 B 的概率和给定 B 发生 A 的条件概率，或者拿到 A 的概率和给定 A 发生 B 的条件概率。</p>
<h2 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h2><ul>
<li>条件概率是指给定另一件事已发生时某件事的概率。</li>
<li>表明上看不是很特别，但条件概率是很多概率估算的核心。</li>
<li>数学上，给定 B 的 A 的条件概率等于 A 和 B 的联合概率除以概率 B 。</li>
<li>条件概率的定义，也适用于不论是否独立的事件的联合概率。给定 B 的 A 的条件概率可以看成是 B 发生后，样本空间缩小到 B 时 A 发生的概率。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之九 | 概率和集合</title>
    <url>/data-science/statistics-probability-and-sets/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="集合基础-——-理论概念"><a href="#集合基础-——-理论概念" class="headerlink" title="集合基础 —— 理论概念"></a>集合基础 —— 理论概念</h1><p>在这篇教程中，我将介绍一些重要概念，它们是关于 <strong>集合 (set)</strong> ，即项的数据集。这对于理解概念以及得出概率的计算规则十分有用。同时，集合的特殊性还在于它不仅可用于概率演算，还用在逻辑学中。</p>
<p>让我们开始吧。如之前的教程中提到的，样本空间是随机现象所有结果的数据集。举个例子，抛一枚硬币两次，有四种可能的结果。事件是样本空间的子集。例如，最后一次抛硬币你得到正面朝上。</p>
<img src="/images/set_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们看到，一个样本空间可以两个或更多结果完全不同的事件。比如，抛硬币两次，0 次正面朝上，1 次正面朝上， 2 次正面朝上。它们被称为 <strong>互斥 (disjoint)</strong> 的事件。另外一个术语叫 <strong>互不相容 (mutually exclusive)</strong> 。</p>
<p>有一对特殊的互斥事件，某个事件和它的对立面 (即这个事件不发生的事件)。这种上下文中，对立的事件被称为 <strong>补集 (complement)</strong> 。比如，这里可以是没有正面朝上和其他三种情况互为补集。</p>
<img src="/images/set_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你也可以有多个事件共同填满完整的样本空间。这些事件被称为 <strong>完全穷尽 (collectively exhaustive)</strong> 事件。如果它们彼此不重叠，就是 <strong>相互独立，完全穷尽 (disjoint collectively exhaustive)</strong> 。互斥事件相关联的概率之和小于或者等于 1 ，完全穷尽事件的概率之和等于 1 。</p>
<img src="/images/set_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>直觉上很容易理解这些概念，它们可以通过 <strong>文氏图 (Venn diagrams)</strong> 来表达。文氏图通过简单的几何形状来呈现集合或者集合的部分。</p>
<a id="more"></a>

<p>这些矩形描绘同一个样本空间，在空间中，有一个事件 A ，剩下的部分都是事件 A 的补集。同一个样本空间里，还有另外一个事件 B ，和 A 不重叠。因此它们两者是互斥的。</p>
<p>如果我们把这个文氏图应用于两次抛硬币的实验，你能把四个不同的结果放进图中并且描述事件吗？</p>
<img src="/images/set_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以是这样的，只有一次正面朝上是事件 A ，有两次正面朝上是事件 B 。 A 的补集会包含两次反面朝上和两次正面朝上。</p>
<img src="/images/set_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>还用文氏图，两次抛硬币的实验也可以是这样的：</p>
<img src="/images/set_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>两个事件， A 和 B ，相互之间有重叠。 A 是事件 “第二次结果是正面朝上”， B 是事件 “只有一次正面朝上”。结果 “反面，正面” 会同时落在两个事件之内。“反面，反面” 也属于样本空间的一部分，但不落在 A 和 B 任何一个事件内。两个事件重叠的部分被称为 <strong>交集 (intersection)</strong> 。</p>
<p>事件 A 和 事件 B 的交集可以速记为:</p>
<p>$$ A \cap B $$ </p>
<hr>
<p>现在，让我们来找出两个事件交集的概率。如果两个事件是互斥的，事件很简单。交集的概率为 0 。如果两个事件并不互斥，即它们重叠，事情就稍微有点复杂。</p>
<p>假定我们正在处理的是独立事件。也就是说，例子中抛出第二个正面的事件的概率不受只抛出一个正面的事件的影响。对于独立事件 A 和 B ，它们的交集的概率是两者各自概率的乘积。</p>
<p>这里，事件 A 有两种情况，所以概率是 2 / 4 。事件 B 的情况相同，概率也是 2 / 4 。因此，最后的交集的概率等于两者概率乘积，也就是 1 / 4 。</p>
<img src="/images/set_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>样本空间中不共享任何结果的事件被称为 <strong>互斥事件</strong> 或者 <strong>互不相容</strong> 。</li>
<li>多个事件一起填满整个样本空间，则把它们称为 <strong>完全穷尽</strong> 事件。</li>
<li>如果样本空间里只有两个互斥事件构成完全穷尽，那么它们互为 <strong>补集</strong> 。</li>
<li>互斥事件的概率之和小于或者等于 1 。完全穷尽事件的概率之和等于 1 。</li>
<li>事件 A 和 B 的 <strong>交集</strong> 同时是两个事件的一个子集，这个子集包含了 A 的一部分，并且这部分也是 B 的一部分。独立事件 A 和 B 的交集是通过事件 A 的概率和事件 B 的概率乘积来计算的。对于互斥事件，按照定义，交集属性等于 0 。</li>
</ul>
<hr>
<h1 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h1><p>这一节中，我将介绍 <strong>并集 (Union)</strong> 的概念和并集的概率。并集在现实生活中会导致一个比其各个部分集合的总和具有更多新属性的实体吗？很遗憾，在概率理论中，这种魔力是不存在的。并集只是<br>需要特别注意 —— 不要将事情加倍计算。</p>
<p>还是贝壳的例子，你在海滩上随机捡三个贝壳。周围只有两种贝壳， Q 和 R 。两种类型的贝壳数量相等并且你可以认为有无数。在这种情况下，样本空间包括八个结果。整个实验的树形图如下。</p>
<img src="/images/union_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>获得任何组合的概率的八分之一。让我们设定，总共捡起一个 R 贝壳作为事件 A ，总共捡起两个 R 贝壳作为事件 B 。如果我们对事件 A 发生或事件 B 发生，或者 A 和 B 同时发生感兴趣。</p>
<img src="/images/union_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>以这种方式组合事件被称为 “并集”，速记为:</p>
<p>$$ A \cup B $$</p>
<p>要计算关于事件 A 和 B 的并集的概率，你必须求出两个事件的总和，然后减去 A 和 B 的交集。减去交集的原因是它被计数了两次。拿到一个 R 贝壳的概率 —— 事件 A ，是八分之三。<br>拿到两个 R 贝壳的概率同样也是八分之三，它们的总和是八分之六，即四分之三。</p>
<p>实际上，事件 A 和 B 不分享任何结果，即他们不相交的，则他们的交集概率为零。因此，并集的概率是四分之三。</p>
<img src="/images/union_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，考虑两个不同的事件。 事件 C ，你选择的第一个贝壳将会是 R 贝壳。事件 D ，最后一个贝壳 是 R 贝壳。显然，这两个事件不是互斥的，因为它们有重叠。事件 C 和 D 的交集包括<br>第一个贝壳是 R 贝壳，同时第三个贝壳也是 R 贝壳的情况。</p>
<img src="/images/union_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>通过将 C 的概率加到 D 的概率，再减去 C 和 D 的交集来找到 C 和 D 的并集，是四分之三。</p>
<img src="/images/union_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在挑战升级 —— 事件 A ， B ， C 和 D 的并集是？如果你把方程式机械地应用过来，事情会有些乏味，因为会有不少加法和减法的计算。</p>
<p>$$ P (A \cup B \cup C \cup D) = P (A) + P (B) + P (C) + P (D) \ - (P (A \cap B) + P (B \cap C) + P (C \cap D) + P (A \cap C) + P (A \cap D) + P (B \cap D) + P (A \cap B \cap C \cap D)) $$</p>
<img src="/images/union_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>不过，由于总的样本空间中并没有特别多的基本事件，这里有一个更简单的方法。你可以列出八个<br>基本事件，然后检查它们出现在四个组合事件中的哪一个。最后，你会发现只有一个基本事件不发生在组合事件中。从四个组合事件来看，有七个基本事件的结果是四个组合事件中的某一个的部分。因此，并集的概率是这七个基本事件之和，即八分之七。</p>
<img src="/images/union_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>多个事件的并集是这样一个事件：它包含原始事件的所有结果，并且没有重复。</li>
<li>几个事件的并集概率是各个事件的概率之和减去事件之间的交集的概率。</li>
<li>对于两个事件，等式为 $ P (A \cup B) = P (A) + P (B) - P (A \cap B) $ 。如果事件 A 和 B 互斥，则交集的概率为零。并集方程简化为 $ P (A \cup B) = P (A) + P (B) $。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之八 | 样本空间、事件和树形图</title>
    <url>/data-science/statistics-sample-space-events-tree-diagrams/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="样本空间-sample-space"><a href="#样本空间-sample-space" class="headerlink" title="样本空间 (sample space)"></a>样本空间 (sample space)</h1><p><em>海滩是一个多变的环境 —— 尤其当天气很好的时候，有许多人，需要可以做的事情和可以看的风景。这一节教程里，海滩是我们的背景。我将向你解释几个可以帮助我们找到概率的概念，以及一个可视化的辅助工具 —— <strong>树形图 (tree diagram)</strong> 。</em></p>
<p>这是一个温暖的下午，你可以来点下午茶。幸运的是，你所在的海滩上，有一个卖下午茶的摊位。不过，茶点几乎快卖完了，只剩下一种类型的冰淇淋和两瓶软饮料。</p>
<img src="/images/sample_space.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有点不走运的是，有三个人排在你前面。不过还有个好消息是，摊主只卖给每个顾客一件东西。由于你实在很渴望喝到眼前这冰爽的饮料，你不禁开始寻思，“我喝到饮料的机会有多大呢？” </p>
<img src="/images/sample_space_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>注意，你并不清楚其他顾客会做出的决定，所以他们的购买对你来说全部都是随机事件。第一个顾客可能买饮料或者冰淇淋，在这件事发生之后，第二个顾客拥有同样的选项，然后轮到第三个顾客。如果前面的两位顾客都买了饮料，那她就只剩冰淇淋可以选，否则的话，她也还有两个选项。</p>
<p>通过下面这幅树形图，你排序了所有可能的随机试验结果。看起来有 7 种可能的组合。这里所有随机现象的里列表我们称为 <strong>样本空间 (sample space)</strong> 。</p>
<a id="more"></a>

<img src="/images/sample_space_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果一个随机试验有离散的结果，比如我们的这个案例，一种描绘样本空间的便捷方式是通过树形图列出所有的可能性。就像上图中我们已经做的那样。在一个树形图中，有一些中间结果的划分，跟最终分支如出一撤。任何结果，包括结果的组合，被称为 <strong>事件 （event）__，因此， __一个事件其实就是一个样本空间的子集</strong> 。在这个特定的案例中，你关心的事件，不走运的那些 —— 没有饮料喝了，反之，还能买到饮料。 </p>
<p>任何一个随机事件都有与之关联的概率，并且小的事件可以组合成大的事件。量化这些事件的概率，可以通过实验。实验可以包含在一段足够长的时间内，观察冰淇淋和饮料的销售情况。但这里时间不够，当第一个顾客正在思考要买什么的时候，你就必须做出自己的决定了。于是你诉诸另外一种策略 —— 对样本空间里的结果做出有说服力的假设。</p>
<p>你假定每一种事件发生的机会相等 —— 每个顾客选冰淇淋和饮料的概率都是 0.5 。在这种方式中，你可以依赖通用的概率规则。概率处于 0 到 1 之间，所有可能的结果，例如，所有选项在树形图里以节点表示，它们最终的总和也等于 1 。借助它们，你可以很快得到答案。这个答案可能帮助你做出决定：是应该保持乐观，在队伍中等着轮到自己，还是应该开始考虑寻求别的方式购买饮料。</p>
<p>不过，要记得，经过所有事件都已经展开，你并不知道你对于概率的评估是否正确。虽然你收集了排在你前面的三个顾客的试验信息，但对于整个购买冰淇淋和饮料这种事情来说。你的信息极其有限，并没有办法推导出十分精确的概率估算。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul>
<li>样本空间是所有随机现象的结果的集合，而事件是样本空间的子集，它对应某一个随机变量的结果或者一组可能的结果。</li>
<li>每个事件都有概率。为了找到这些概率，你可以用到树形图。在树形图中，你可以创建样本空间，并对各种事件显式地做出假设。为了量化树形图里每个事件的概率，你可以进行实验。</li>
<li>某些时候，你可以对样本空间里的结果做出有说服力的假设，然后基于推理估计出它们的概率。</li>
<li>在任何案例中，通用的概率规则都适用于树形图。任意事件的概率都处于 0 和 1 之间，而最终所有可能的结果的概率总和等于 1 。</li>
</ul>
<hr>
<h1 id="用树形图量化概率"><a href="#用树形图量化概率" class="headerlink" title="用树形图量化概率"></a>用树形图量化概率</h1><p>当你在思考随机现象并且把注意力放在事件之间的关系以及它们在树形图中的概率时，你已经开始计算概率和评估某件事发生的可能性。</p>
<p>下面我会解释实践中树形图中的概率是如何量化的。还是上面那个例子。下面这张图显示，你假定每个顾客都有 0.5 的概率选择冰淇林或者饮料。通用概率规则适用于树形图里的每一个节点。具体来说，如果你观察图中的第一个顾客，有两个分支，每个分支 0.5 的概率。到第二个顾客，有两对分支，每对占 0.5 的概率，一对里的两个分支又各占 0.5 的概率。</p>
<p>如果这个时候轮到你了，你需要沿着一条路径，从第一个顾客的某个购买结果算到第二个顾客的某个购买结果。在树形图中，通过计算这条路径上所有概率的乘积来找出最终组合的事件的概率。</p>
<p>两个顾客之后，你还有多大的机会买到饮料呢？至少得剩一瓶饮料吧，满足这个情况的事件分支有三条，像图示中那样，总的概率是 0.75 。</p>
<img src="/images/tree_diagram.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>还有没有更快的算法呢？—— 利用所有概率的总和等于 1 这个规则。所以 1 减去 两瓶饮料都卖出去的概率会给到我们相同的答案。</p>
<p>现在我们加大难度，考虑第三个顾客了。这里有一点特殊。她在四个分支中有三个拥有两个选项，但在两瓶饮料都卖完的这个分支上，只有一个选项 —— 买冰淇淋。同时在这里，规则也需要被满足，即所有概率的总和等于 1 ，所以这个单分支的概率就等于 1 。</p>
<img src="/images/tree_diagram_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在我们回到你买到饮料的机会上。我们需要算出四条分支的概率总和，即轮到你之前最多一瓶饮料被卖掉的概率总和。每条分支的概率等于 0.5 的三次方，即 0.125 ，加起来是 0.5。</p>
<img src="/images/tree_diagram_1_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<hr>
<p>上面我们演示了利用树形图找出概率的变量，但也有必要指出一些需要注意的事情。首先是树形图可以很从容地处理小问题，对于理解有很多结果的随机现象，它并不是很适合 —— 它会变得很庞大，无助于保持概览。</p>
<img src="/images/tree_diagram_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>其次，为了实际应用树形图来量化概率，需要每个节点的概率规格。这在有的时候是很容易的，比如你假定每个选项机会均等，并且独立于前面的选择。另一方面，它也可能很困难。</p>
<p>举个例子，假如第二个顾客的购买选择会受到第一个顾客的影响怎么办呢？</p>
<img src="/images/tree_diagram_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>在树形图中，你可以创建样本空间，并对各种事件显式做出假定，包括每个事件的概率，它们在序列之中的相互独立性。</li>
<li>你可以在树形图中计算组合事件的概率。为了计算沿着一系列分支的从起点到结果的概率，所有的概率需要相乘。而为了找到某个包含很多种结果的事件的概率，所有这些结果的概率则需要相加。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之七 | 概率和随机性</title>
    <url>/data-science/statistics-probability-and-randomness/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="随机性-（randomness）"><a href="#随机性-（randomness）" class="headerlink" title="随机性 （randomness）"></a>随机性 （randomness）</h1><p>识别和理解随机性，和推断它是一样重要的技能。它们不仅在统计分析中有用，对于每天发生在我们身边的日常事物，同样有意义。这篇教程中，我将向你解释为什么人们如此不擅长应对随机性。</p>
<p>想象你在海滩上看着海浪翻滚，然后你注意到一枚美丽的贝壳，它的个头和形状明显地异于周围其它贝壳。于是你想想看附近还有有没有这种贝壳。这是一项无法预见的行动计划 —— 贝壳可能是随机分布在这个巨大的海滩上的。因此，你找到另外一枚同类贝壳的时间是不确定的，甚至你都可能找不到一枚相似的。</p>
<p>你开始思考这件事，然后你意识到随机性几乎在日常生活中无处不在。所以，无怪乎我们有丰富的词汇来描述它，比如不确定性、机会、风险、可能性。还有，变异性和不确定性的程度能够非常精细地描述随机性。</p>
<p>看看下面这组词汇：罕有、少见、有时、普通、频繁、经常。有意思的是，某件事是否随机，不仅是现象自身的特性，也很大程度上取决于我们对它的认识。假如你之前就来过这片海滩，你可能已经发现过这种贝壳，从而改变这一次的搜索策略，以便增加找到更多这种贝壳的机会。你搜索的尺度也有关系，如果在很小的区域做一个短暂的搜索，可能不是很有把握找到新贝壳，但是搜索时间延长，搜索区域扩大，找到机会就会增大。</p>
<p>尽管有这么多的词汇，以及我们在日常经验中熟记随机性的能力，我们其实一点都不擅长量化地评估随机性。一方面，我们在真实的随机数据中寻找各种 “模式”。你一定听过一个词叫 “宿命”。另一方面，我们自身又无法制造随机熟记。有一个失败尝试的案例 —— 下图中左边的通过拼接得到的贝壳随机分布的地图，实际上是分布太规则的。而右边那幅是现实的随机分布模式，看起来有更多聚集在一起的 “簇”。</p>
<img src="/images/randomness.jpg" width="68%" height="68%" style="margin: 10 auto;">

<a id="more"></a>

<p>另外一个被我们用来解释随机性的例子叫 “赌徒谬误” —— 它的错误之处在于用一系列前面发生的随机现象预测未来的随机现象。人们没有意识到的是，如果你连续掷出了四次 6 ，感觉上不太可能再第五次掷出 6 。然后，这个投掷的结果为 6 的概率之前是 六分之一，之前是，现在还是。</p>
<img src="/images/randomness_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们之所以应对随机性孱弱，原因在于我们的大脑倾向于用记忆模式的方式衡量随机性。考量到这一点，为了量化随机性、理性思考随机性并且产出现实可行的随机模式，学习正确的方法十分重要。它们帮助我们避免错误，更准确和更有效地对我们周遭的世界做出预测。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>随机性并非一个现象的内在属性，它同时取决于我们对它的知识，观察方法以及我们关注它的尺度。尽管有大量表达随机性的词汇，人类天生不擅长量化评估它。我们困于宿命论，困于对某些纯随机模式的过度解读，这些操作同时也不利于构建随机性。</p>
<hr>
<h1 id="概率-probability"><a href="#概率-probability" class="headerlink" title="概率 (probability)"></a>概率 (probability)</h1><blockquote>
<p>坚持不懈，终有所成。</p>
</blockquote>
<p>尽管已经有很多关于这个概念的箴言和引证，我想再加一句 —— “毅力战胜一切”。这一节中，我将一步步引导你学会用概率来量化随机性。</p>
<p>人类的大脑也许并不是很适合回答随机性。但幸运的是，有一个基础的机制，它的运转极大地简化了我们的生活 —— 随机性会发生变化，从事物可变、案例稀少且无法预测，到事物恒定、案例庞大且可以预测。对于这个基础，我们甚至有一个数学上的证据，它就是 <strong>大数定律</strong> 。它有赖于独立性，也就是说，某个随机现象的结果，不受之前结果的影响。</p>
<p>让我举个例子，说明大数定律在现实生活中是长什么样子。还是想象你在海滩，决定搜寻贝壳。很快，你发现了海滩一共有四种类型的贝壳，随机分布，数量相等，就像下图这样：</p>
<img src="/images/possibility.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，你需要数出一个 Q 贝壳的分数，可以通过选取操作来完成。比如，随机选 20 个贝壳，然后计算这 20 个样本里 Q 贝壳的数量。结果如下：</p>
<img src="/images/possibility_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如你所见，20 个贝壳只有 2 个 Q 贝壳。 <strong>相对频率 (relative frequency)</strong> 是十分之一。基于你的推理，这个分数本来应该是在四分之一左右。 但是，你也知道，小样本的不规则性，是随机性的本质。所以呢？“保持冷静，继续前进。”</p>
<img src="/images/possibility_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>不着急下结论，继续选取更多的贝壳，观察比例如何变化，一直演化到四分之一 —— 这种比例被称为 <strong>“累积比例 (cumulative proportion)”</strong> 。</p>
<img src="/images/possibility_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>每一次你随机选取新的贝壳时，都被看作是一次可能带来 Q、R、S、T 四种贝壳之一的机会实现。用概率的术语来说，操作的结果，也就是你拿到的贝壳的类型，被称为 <strong>事件 (event)</strong> 。选取贝壳的这个行为被称为 <strong>独立试验 (independent trial)</strong> 。整个做这么多试验的事情被称为 <strong>实验 (experiment)</strong> 。在计算相对频率的时候，因为你用贝壳总数除每一种类型的贝壳，有两个属性将始终满足：每一个类型的概率将大于等于 0 或者小于等于 1 ；所有随机现象的结果的概率总和将等于 1 。</p>
<img src="/images/possibility_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>不过，现在让我们回到现实。生活并不是海滩，当然也不会有随机分布的贝壳。在日常生活中，纯粹的独立试验并不常见。通常，在随机事件之间存在 <strong>相互依赖 (interdependent)</strong> 。尽管如此，通过简化的假定，概率经常还是可以被很好地量化。此外，你需要拿到充足数量的样本，以便大数定律能发挥作用，确保你要估计的概率接近它的实际值。</p>
<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul>
<li>概率是一种量化随机性的方法，它可以用相对频率的均值来表示。根据这个定义，概率会始终大于等于 0 ，并 IE 小于等于 1 。所有可能事件的概率总和等于 1 。</li>
<li>正式的定义用到了实验、事件和独立试验的概念。某个事件的概率是通过它出现在整个实验中的相对频率来计算的。实验包含一系列独立试验。举个例子，掷骰子是一个事件，而每次掷出是一个独立试验。</li>
<li>让大数定律发挥作用的好方法是保持冷静，持续试验，直到 <strong>累积概率 (cumulative probability)</strong> 不怎么变化为止。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之六 | 回归</title>
    <url>/data-science/statistics-regression/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="回归-——-找到-“那根线”！"><a href="#回归-——-找到-“那根线”！" class="headerlink" title="回归 —— 找到 “那根线”！"></a>回归 —— 找到 “那根线”！</h1><p>最近的一项研究表明，吃大量的巧克力可能是个好主意。</p>
<img src="/images/regression.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这个散点图展示了一个国家每个人年均消费的巧克力数量。可以看出，一年中人们吃的巧克力数量，跟这个国家每百万人口中的诺贝尔奖获得者人数，呈正相关性。</p>
<p>注意，这个散点图里的巧克力消耗量显示为自变量，而诺贝尔奖获得者人数显示为因变量。</p>
<p>散点图里分析的单位是国家。如你所见，相关性很高。实际上，这里的皮尔逊相关系数是 0.93 。这说明，多吃巧克力虽然可能令你发胖，但同时也让你变聪明。皮尔逊相关系数告诉我们，两个连续变量之间的线性相关性有多强，这种线性相关性被显示为一根直线。在我们的案例中，是这条线。</p>
<img src="/images/regression_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这就是我们所说的 <strong>回归线 (regression line)</strong> 。在本节教程中，我将告诉你如何找到回归线。重要的是要知道我们如何找到这条线，而不仅仅是因为回归线向你展示了两个变量之间的关系。 <em>找到回归线是许多统计分析的基础。</em></p>
<p>那么，我们如何找到回归线呢？想象你正在绘制散点图里每一条可能的直线。所以，你像下面这样画了许多可能的线。这是一组数量巨大的线。实际上，这几乎不可能做到。不过，暂时想象你有超能力 —— 你能做到这一点。</p>
<a id="more"></a>

<img src="/images/regression_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>接下来，你可以测量每条可能的线与每个案例之间的距离。在我们的例子，即线到每个国旗之间的距离。</p>
<p>让我给你举一个基于随机线的例子，比如，下面这个。测量日本和线的之间的垂直距离，西班牙和线之间的距离等等。直到你知道你的研究中每个案例的距离。</p>
<img src="/images/regression_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>每一个距离都被称为 __残差 (residual)__，你最终会得到正的残差，它们以线之上的案例到线之间的蓝色线段展示；以及负的残差，它们以线之下的案例到线之间的红色线段展示。</p>
<p>你为每一条可能的线测量残差。最终，我们选择一条能够 <em>使得残差的平方和最小的线</em> ，这便是我们要找的那根线。</p>
<img src="/images/regression_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>为什么是残差的平方和呢？因为正的残差和负的残差会相互抵消。</p>
<p>最佳拟合的线被称为 <strong>回归线</strong> ，分析的方法被称为 <strong>普通最小二乘回归 (ordinary least squares regression)</strong> ，这是指我们找到这条线的方式。</p>
<p>在实践中，几乎不可能绘制每一条可能的线和残差的和。幸运的是，数学家已经找到了寻找回归线的技巧。我不会解释这个把戏在这里是如何运作的，因为它相当复杂。目前为止，知道它基于残差的平方和就已经足够了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>你学到两件事：第一，你学会如何计算并寻找回归线；第二，你了解到，吃巧克力很可能有助于你通过这门课程。:D</p>
</blockquote>
<hr>
<h1 id="回归-——-描述-“那根线”"><a href="#回归-——-描述-“那根线”" class="headerlink" title="回归 —— 描述 “那根线”"></a>回归 —— 描述 “那根线”</h1><p>回归线是最好地描述两个变量之间线性关系的直线。但我们要如何描述这条线的样子呢？</p>
<p>这是一个非常重要的问题，因为通过用公式描述，我们可以很容易地把 <strong>回归的分析 (regression analysis)</strong> 传达给其他人，预测其他国家的诺贝尔奖获得者人数，以及确定不符合该模式的国家。基于此散点图中的回归线，我们可以预测：每年巧克力人均消费量为 6 公斤的国家，平均每 1000 万个人中有 11 位诺贝尔奖获得者。</p>
<img src="/images/regression_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>同样，基于同一条线，我们将预测一个每年人均巧克力消费量为 11 公斤的国家，平均每 1000 万人中 会有 25 个诺贝奖获得者。</p>
<img src="/images/regression_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>对大多数国家来说，这一预测并不完全正确。毕竟，大多数国家并不恰好在回归线上。然而，这是我们能做出的最好的预测 —— 根据我们掌握的信息。</p>
<img src="/images/regression_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有一个简单的公式，我们可以用它来描述回归线。这就是那个公式。 </p>
<p>$$\hat y = a + bx$$</p>
<p>$\hat y$ 不是 y 的实际值，但它表示 y 的预测值。例如，当 x 等于 12 时， $\hat y$ 等于 28 。 请注意，在这种情况下， y 的实际值为 33 。但是， y 的预测值是回归线上的 y 的值。这意味着，正好在回归线上所有的值是 $\hat y$ 。</p>
<p>a 就是我们所说的 <strong>截距</strong> ，它是一个常数。当 x 等于 0 时，它是 y 的预测值。换句话说，当回归线上 y 的预测值与 y 轴的相交时， x 等于 0 。在我们的案例里，它是 -5.63 。请注意，这个值没有实质性的含义。不可能每 1000 万人中有 -5.63 名诺贝尔奖获得者。它只有一个目的：描述回归线的数学性质。</p>
<p>b 就是我们所说的 <strong>回归系数 (regression coefficient)</strong> 或 <strong>斜率 （regression slope）</strong> 。 它是当 x 增加一个单位时， $\hat y$ 的变化。在我们的例子中，我们看到当 x 增加一个单位，例如，从 4 到 5， y 的预测值增加 2.80 个单位。</p>
<p>因为是一条直线，回归线的斜率是处处相等的。所以，如果我们看看当 x 从 8 增加到 9 时会发生什么， $\hat y$ 也是增加 2.80 单位。我们案例中的回归系数为 2.80 。这可以推导出下面这个 __回归方程 (regression equation)__。 </p>
<p>$$ \hat y = 5.63 + 2.80x $$</p>
<p>请看这两条回归线。它们具有相同的回归系数或 b 值。 当 x 增加一个单位时，第一条线和第二条线的 y 值增长的量是一样的。但是，这些线具有不同的截距，或一个值。毕竟，它们在不同的位置上穿过 y 轴。</p>
<img src="/images/regression_9.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这两条回归线具有不同的回归系数。当 x 增加一个单位时，第一条线上的 $\hat y$ 比第二号线上的 $\hat y$ 增加地更多。然而，这两条线的截距是相同的，因为它们在同一个点穿过 y 轴。</p>
<img src="/images/regression_10.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我已经对你说过了，我们可以用回归线来预测 y 值 —— 基于给定的 x 值。我们还可以使用回归公式进行预测。让我们用一个回归公式。 $\hat y = -5.63 + 2.80x$ 。我们可以使用公式预测 y 值。如果 x = 3.5，该怎么办？我们得到 -5.63 + (2.80 * 3.5)。 这就得出了 4.17 。 所以这里的 $\hat y = 4.17$ 。 如果 x = 10.21，该怎么办？ 然后你得到 -5.63 + (2.80 x 10.21) 。 这使得 $\hat y$ 等于 22.96 。 当我们只看回归线时，我们得到了相同的值。对于 x 值等于 3.5 时，我们得到的预测 y 值约为 4 。 对于 x 值等于 10.21 时，我们得到的 $\hat y$ 值约为 23 。 你已经可以看到，使用公式有一个巨大的优势 —— 你可以做出更精确的预测。</p>
<p>通常情况下，计算机会为你找到回归线，所以你不需要自己计算。然而，当你知道你的变量的均值和标准差，以及相应的皮尔逊系数，你可以通过两个公式计算回归方程。</p>
<p>$$b = r\left (\frac {s_y}{s_x}\right)$$<br>$$a = \bar y - b (\bar x)$$</p>
<p>第一个公式通过将皮尔逊的回归系数乘以 y 的标准差，再除以 x 的标准差。这表明了回归系数事实上是皮尔逊系数的一个不标准化的版本。当 pearson 的 r 等于 0 时，回归系数等于 0 。当皮尔逊的 r 是一个正数，回归系数也是正数，当皮尔逊系数为负时，回归系数也是负的。</p>
<img src="/images/regression_11.jpg" width="68%" height="68%" style="margin: 10 auto;">
这些是我们的研究的均值、标准差和皮尔逊系数。因此，为了找到回归系数，我们乘以 0.93 * (11.87/3.95)，结果是 2.79 。第二个公式用回归系数乘 x 的均值，之后从 y 的均值减去结果来计算截距。

<p>所以 13.17-(2.79 * 6.71) 。 这样就可以得到 -5.55 了。回归方程为 -5.55 + 2.79 x 。</p>
<p>与这一个计算机算出的回归方程的不同是由舍入误差导致的。我用汇总均值、标准差和皮尔逊系数来计算，这导致了一个不太精确的回归方程。因此，在使用这些公式时，尽量减少舍入。恭喜你成功完成了这个教程的上半部分！现在，你可以进行回归分析并计算预测值了。了解回归的基础知识是至关重要的，因为能够了解之后的推理回归过程。</p>
<p>所以多看这篇教程几次。:D</p>
<blockquote>
<p>如果自变量 x 是你看这篇教程的次数，并且因变量 y 是你掌握的回归分析的知识，当你这样做时，回归分析的回归斜率将是一个正数。</p>
</blockquote>
<p>如果你不明白上面这句话意味着什么，立即重温这篇教程吧。</p>
<hr>
<h1 id="回归-——-“那根线有多适用？”"><a href="#回归-——-“那根线有多适用？”" class="headerlink" title="回归 —— “那根线有多适用？”"></a>回归 —— “那根线有多适用？”</h1><p>在这一节，我们来研究回归线对你的数据有多适用。</p>
<p>为什么需要关注回归线的适用程度呢？因为我们希望知道回归分析预测因变量的准确性有多高。回归线适用数据的程度是用一种称为 <strong>R 方 (r-squared)</strong> 的方法来表示的。</p>
<p>想象一下，你身处一个有 99 个其他学生的班级，你刚刚参加完一场统计学的考试。你的教授手上已经拿到随机选取的 20 个学生的考试成绩。教授想要分享这 20 个学生的考试成绩，但同时不想让大家知道这些学生是谁。因此，她匿名了这些分数的主人。</p>
<img src="/images/r_squared.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是你看到的分数。因为是匿名的，你无从得知哪个学生拿到哪个分数。注意，最低分数是 0 ，最高分数是 10 。现在，想象你被要求预测你邻桌同学的分数。你怎么预测得到的分数会更靠谱呢？一个显而易见的答案是，用这 20 个分数的平均值，这个值时 6.8 。现在，继续想象教授还给了你这 20 个分数对应学生上一次统计学考试的分数，同样也是匿名的。结果如下：</p>
<img src="/images/r_squared_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在，你会如何预测你邻桌的分数呢？是的，你可以利用到回归分析了。下面是回归线和 <strong>回归方程 (regression equation)</strong> 的散点图。</p>
<img src="/images/r_squared_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你会发现，那些在之前的考试中取得高分的同学趋向于在这一次考试中也拿到高分。实际上，你可以用这条回归线和对应的回归方程对分数做出预测。当你问到你的邻桌他之前的分数，你可以用回归线预测他这一次考试最有可能的分数。</p>
<img src="/images/r_squared_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>想象上一次分数是 8.1 ，代入回归方程，得到 2.80 加 (0.59 乘以 x)，等于 7.6 。因此，这一次的分数最有可能是 7.6 。这是什么意思呢？当你只有一个变量的信息时，你做出的预测的准确性要远远低于你拥有两个相关变量信息的情况。R 方就是一个告诉你用回归线预测因变量而不是平均值这种方式有多适用的程度。</p>
<p>再回到我们的散点图。我加了一根水平线，用以表示这次考试分数的平均值。</p>
<img src="/images/r_squared_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这根线之所以是水平的，是因为平均值是一个定值 6.8 ，它不会改变。可以看到，每个观察值和回归线的残差，相比于它们到平均值的残差，总体要小得多。</p>
<img src="/images/r_squared_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这表明，回归线的预测效果明显好于平均值。</p>
<p>在我们的案例中， R 方是 0.69 。这表示使用回归线预测错误的可能性比你使用平均值要小 69% 。 R 方也经常用另外一种说法来解释 —— 它是指你的因变量的方差，多大程度上可以由自变量的方差来解释。</p>
<p>一个变量的方差告诉你各个观察值相对于平均值的离散程度。因此，在我们的案例中，这一次考试分数的方差中的 69% ，可以被前一次考试的分数预测。用可视化的方式表达这种解释，可以用到两个圆。</p>
<img src="/images/r_squared_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>左边的圆表示自变量的方差，右边的圆表示因变量的方差。重叠的部分就是 R 方，或者说 <strong>可解释方差 (explained variance)</strong> 。当重叠部分很小时， R 方很小，重叠部分很大时， R 方很大。</p>
<img src="/images/r_squared_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你需要了解一个很重要的事实 —— R 方和皮尔逊相关系数关联紧密。实际上，正如它的名字指示的， R 方就是皮尔逊相关系数的平方。因此，要计算 R 方，只要算出皮尔逊系数然后平方就行了。</p>
<p>这也说明 R 方总是一个正数。在我们的案例中，皮尔逊相关系数等于 0.83 。平方得到 R 方 0.69 。注意，如果两个变量的线性相关性是完美的，那么皮尔逊相关系数和 R 方都是 1 。如果完全线性无关，那皮尔逊相关系数和 R 方都是 0 。</p>
<p>但是，你需要记住： R 方的含义和皮尔逊相关系数很不同。皮尔逊相关系数告诉你两个变量之间是否存在正的或者负的相关性，以及这种相关性有多强。而 R 方并没有告诉你两个变量之间关联的方向。不过，它告诉你两件事，一是回归线预测相对于平均值预测优胜多少，二是因变量的方差有多少是可以被自变量的方差解释的。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之五 | 相关性</title>
    <url>/data-science/statistics-correlation/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<p>很多人喜欢吃巧克力，但多数人吃巧克力是比较谨慎的。因为吃了太多巧克力，很有可能会增加体重。在这一期的教程中，我将讨论如何使用表格和图表展示 <em>两个变量之间的关系</em> 。这有助于发现两个变量之间是否存在 <strong>相关性 (correlation)</strong> 。</p>
<h1 id="列联表-Contingency-Tables"><a href="#列联表-Contingency-Tables" class="headerlink" title="列联表 (Contingency Tables)"></a>列联表 (Contingency Tables)</h1><p>我们来进一步研究吃巧克力和体重之间的关系。</p>
<p>假设我在我们学校选择了 200 名女学生。她们身高都是一米七。这样，身高就是一个常数，不会影响体重或吃巧克力。让学生报告体重及每周巧克力消费情况。体重可以选择这样几个类别：小于 50 公斤； 50 至 69 公斤； 70 至 89 公斤和 90 公斤或以上。巧克力消费量可以选择这样几个类别：每周少于 50 克；每周 50 至 150 克；每周超过 150 克。</p>
<p>结果如下，这里看到的是 <strong>列联表</strong> 。 <strong>列联表</strong> 能够显示 <strong>两个定序或定类变量之间的关系</strong> 。 它类似于频率表，但主要区别在于 <strong>频率表始终只考虑一个变量，而列联表考虑两个变量</strong> 。</p>
<a id="more"></a>

<p>在我们的研究中，有两个变量：体重和巧克力消费量。</p>
<img src="/images/crosstab.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>该表显示我们有 33 个体重小于 50 公斤的样本 其中 27 人每周吃巧克力少于 50 克。还可以看到，每周有 90 人吃 50 至 150 克巧克力，其中 7 个体重 90 公斤及以上。</p>
<p>这种情况下，该表并不能提供两个变量之间的相关性信息，因为列和行包含不同数量的个案 —— 计算百分比可以提供更多洞察力。这种情况下，我们计算列的百分比，这意味着对于每个单元格，我们计算该单元格中的案例百分比，与相应列中的案例总数进行比较。</p>
<p>结果如示：</p>
<img src="/images/crosstab_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们也可以将这些百分比表示为比例: 45％ 则变为 0.45， 38％ 变为 0.38 。我们将这些比例称为 <strong>条件比例 (conditional proportions)</strong> —— 因为形成需要以另一个变量为前提条件。在这种情况下，该变量是巧克力消费量。</p>
<img src="/images/crosstab_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们也可以忽略巧克力消费的信息，并使用表格边缘的计数。这些都是 <strong>边际比例 (marginal proportions)</strong> 。例如， 33 除以 200 等于 0.17 。这个比例显示，研究中比例是 0.17 或 17％ 的受访者中，重量不到 50 公斤。</p>
<img src="/images/crosstab_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是什么意思呢？ 在每周吃巧克力超过 150 克的样本中， 56％ 的人体重达 90 公斤及以上；吃巧克力少于 50 克的样本中，只有 5％ 体重为 90 公斤或以上；另外，那些吃巧克力不到 50 克的人， 45％ 的人体重不到 50 公斤，而吃巧克力超过 150 克的人，只有 2％ 的体重不到 50 公斤。</p>
<img src="/images/crosstab_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这些百分比表明：吃更多巧克力的人也更容易超重，而少吃巧克力的人也更可能体重较小。换句话说，<em>百分比表明巧克力消费量与体重之间存在相关性。</em></p>
<hr>
<h1 id="散点图-Scatterplot"><a href="#散点图-Scatterplot" class="headerlink" title="散点图 (Scatterplot)"></a>散点图 (Scatterplot)</h1><ul>
<li>列联表对定类和定序变量很有用，但不适用于定量变量。<em>对于定量变量，散点图更合适。</em> 假设没有提供类别，而是让 200 名女性给出确切的体重，例如 65 或 72 公斤。假设也要求他们告知每周吃巧克力的确切重量，例如每周可以是 64 克或 99 克。现在，有比之前更精确的信息展示定量变量，巧克力消费和体重之间关系的最佳方法是使用 <strong>散点图</strong> 。</li>
</ul>
<p>制作散点图，我们绘制两条线，称之为 <strong>轴</strong> 。我们将水平轴称为 <strong>X 轴</strong> 。这里展示的是 <strong>自变量 (independent variable)</strong> ，垂直轴称为 <strong>Y 轴</strong> ，我们用它来表示 <strong>因变量 (dependent variable)</strong> 。如果因变量和自变量之间没有区别，则 Y 轴和 X 轴上的位置是一个选择问题。在我们的例子中，自变量是巧克力消耗量，因变量是体重。</p>
<p>假如我们的研究表明，最少的巧克力消耗等于每周零克，最高的量是每周 700 克。我们在 x 轴上标注这些值；同样，体重的最小值为 40 公斤，最大值为 110 公斤。</p>
<img src="/images/scatterplot.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>接着我们在此图中显示每个人，为样本中的所有人做标注，这就绘制出了一幅散点图。散点图一目了然地显示巧克力消费量与体重之间存在相关性：吃的巧克力越多，体重就越高。</p>
<img src="/images/scatterplot_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<hr>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><blockquote>
<p>大家学到了什么呢？不止于巧克力消耗量和体重的相关关系，我想大多数人已经意识到了：我们可以通过表格和图表显示 <strong>两个变量之间的关系</strong> ，<strong>当研究中的变量是定类或定序变量时，我们使用列联表；当它们是定量测量时，我们使用散点图</strong> 。</p>
</blockquote>
<hr>
<h1 id="皮尔逊积矩相关系数-Pearson’s-r"><a href="#皮尔逊积矩相关系数-Pearson’s-r" class="headerlink" title="皮尔逊积矩相关系数 (Pearson’s r)"></a>皮尔逊积矩相关系数 (Pearson’s r)</h1><p>散点图一目了然地表明两个变量之间存在很强的相关性，但 <strong>这种相关性有多强</strong> ？我们现在将要讨论最常用的相关性度量方法之一 —— <strong>皮尔逊积矩相关系数</strong> 。皮尔逊相关系数最重要的优点之一是：它用一个数字表示两个变量之间线性相关的 <strong>方向</strong> 和 <strong>强度</strong> 。</p>
<p>巧克力消费和体重之间的关系可以用这条直线来描述。因为所有案例都紧密围绕这条线，所以可以得出结论，这是一个相当强的相关性关系。</p>
<img src="/images/pearsonsr.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>另一个需要注意的点是，直线向上延伸，表明更多的巧克力消耗与更高的体重相关。因此，也可以说存在 <strong>正相关</strong> 关系。结论：这里存在一个强正向线性关系。</p>
<p>然而，变量也可以以不同的方式相关联。</p>
<img src="/images/correlation.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在上图的第一幅图中，可以看到变量 x 和 y 之间存在相当强的正向线性关系，如同巧克力消费和体重的示例一样；而在第二幅图中，存在一个相当强的负向线性相关性 —— 直线向下表示当变量 x 上升时，变量 y 下降。第三幅图也可以看到正向线性关系，但是它比之前的强度要小得多 —— 因为每个案例都远离直线。第四幅图则是一个完全负向线性相关。之所以说完全的，是因为所有案例都完全落在线上。</p>
<p>但两个变量之间的相关性不必是线性的。在第五幅图中，可以看到变量 x 和 y 之间的关系。最能代表两个变量之间关系的线并不是直线。相反，是一个 U 形线，我们称之为曲线关系。</p>
<blockquote>
<p>散点图有助于我们总体评估相关性是强还是弱，但它并没有告诉我们这种关系强度到底是多少。皮尔逊相关系数恰巧可以展示确切数字 —— 更具体地说，皮尔逊相关系可以告诉我们 <strong>两个定量变量之间线性关系的方向和精确强度</strong> 。正皮尔逊相关系数表示相关性为正，而负系数表示相关性为负。</p>
</blockquote>
<p>系数的大小表示 <strong>观测结果围绕数据假想最佳拟合直线的紧密程度</strong> 。<em>皮尔逊相关系数是始终介于 -1 和 1 之间的数字：负 1 表示完全负相关；正 1 表示完全正相关； 0 表示完全没有相关性。</em></p>
<p>那如何计算皮尔逊相关系数呢？试想巧克力消费和体重的研究不是 200 个样本，而是四个样本。</p>
<p>下面是数据矩阵和散点图：</p>
<img src="/images/pearsonr_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以看到两个变量的每个值的组合在图形中变为一个圆点。要计算皮尔逊相关系数，我们需要这个公式：</p>
<p>$$ r = \frac {\sum {Z_xZ_y}}{n - 1} $$</p>
<p>这是什么意思呢？首先将所有原始分数改为 z 分数，换句话说，标准化所有数值 —— 原因是我们希望皮尔逊相关系数是介于 -1 和 1 之间的数字 。如果不进行标准化，相关性将会以原始数据呈现。</p>
<p>首先，我们计算两个变量的均值：变量 x 的值为 162.5 ，即巧克力消耗量；变量 y 的值为 71.25 ，即体重。然后计算两个变量的标准差， x 的结果为 110.9 ， y 的结果为 18.4。再然后计算每个案例的 z 分数，从每个值中减去均值，然后除以标准差。</p>
<p>为自变量的每个值，即巧克力消耗量，因变量的每个值，即体重，进行如此计算。下一步，计算 y 值 z 分数和 x 值 z 分数的乘积。 </p>
<img src="/images/pearsonr_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>计算公式的最后一部分，将所有这些 z 分数的乘积相加，将得数除以 n 减 1。所以在我们的例子中，皮尔逊相关系数是 2.78 除以 (4 - 1) ，等于 0.93 。这是什么意思呢 —— 这意味着巧克力消费与体重之间存在强烈的正向线性关系。</p>
<blockquote>
<p>一个重要注意事项：即使关系是非线性的，也可以随时计算皮尔逊相关系数。因此，<em>在计算皮尔逊相关系数之前，要先检查散点图看变量是否存在线性相关</em> ，这一点非常重要。如果不存在，就不要计算皮尔逊相关系数，因为它就不能提供太多变量关系信息。</p>
</blockquote>
<p>例如，下面这个散点图显示 x 和 y 之间存在强烈的 <strong>曲线关系</strong> 。如果计算皮尔逊相关系数，会得到一个非常低的值，负 0.15 。这并不能说相关性较弱，只能说线性相关性较弱。</p>
<img src="/images/pearsonr_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><blockquote>
<p>计算四个样本的皮尔逊相关系数是相当容易的。但是，可以想象，当样本是 200 个时，这几乎是不可能完成的任务。幸运的是，每个统计程序都可以快速计算皮尔逊相关系数。然而，重要的是要了解皮尔逊相关系数究竟意味着什么。了解公式的含义也很重要，它可以帮你更好地理解变量的相关性，也可能会帮你决定 “每周吃多少巧克力。” :)</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之四 | Z-score</title>
    <url>/data-science/statistics-z-scores/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<blockquote>
<p>通俗解释 z-score ，即 z-score 是对某一原始分值进行转换，变成的一个标准分值，该标准分值可使得原来无法比较的数值变得可比。</p>
</blockquote>
<h1 id="Z-score"><a href="#Z-score" class="headerlink" title="Z-score"></a>Z-score</h1><p>本教程中我们还继续沿用前面教程中足球队的例子。</p>
<img src="/images/z-score.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>你在这里看到的是所谓的球员纹身占比，以纹身占身体的百分比表示。点图和标准差表明，第二队的分布比第一队的变化更大。</p>
<p>有时研究人员会问：一个特定的观测结果是常见还是特例。为了回答这个问题，研究人员会用 <strong>一个数与平均数的差再除以标准差</strong> 。这个数字就是我们所说的 z 分数。在这篇教程中，我将解释如何计算 z 分数，以及它们的用处。</p>
<p>我们先来看看第一队的分布情况。平均数是 15 ，标准差是 2.5 。为了计算 z 分数，我们使用这个公式：</p>
<p>$$ z = \frac {(x - \bar x)}{s} $$</p>
<p>这个公式不是很复杂，它告诉你如何计算感兴趣的数值。该数值与平均数之差，再除以标准差。</p>
<a id="more"></a>

<p>来看看纹身占比是 10.8％ 意味着什么。该值的 z 分数是 10.8 减去 15 再除以 2.5 等于负 1.68 。所以 z 分数是负 1.68 。你可以为所有数值进行如此计算。如果这样做，这些就是结果。</p>
<img src="/images/z-score_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>请注意，最终会得到负 z 分数和正 z 分数。负 z 分数表示低于平均数的值；正 z 分数表示高于平均数的值。因为平均数是分布的平衡点，所以负的和正的 z 分数相互抵消。换句话说，如果将所有 z 分数相加，结果为 0 。</p>
<p>好的，不过如何知道某个 z 分数是低还是高呢？</p>
<p>这取决于分布和前后关系。有一个黄金定律：如果变量的直方图是钟形的，那么 68％ 的观测值在 z 分数 -1 和 1 之间， 95％ 在 z 分数 -2 和 2 之间， 99％ 在 z 分数 -3 和 3 之间。这意味着对于这种类型的分布， z 分数大于 3 或小于 -3 ，可以被认定是特例。</p>
<img src="/images/z-score_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>但是，如果分布严重偏向右侧，如下图所示，较大的正 z 分数会更常见，因为分布的右侧有更多极值。</p>
<img src="/images/z-score_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>类似，如果分布严重偏向左侧 则较大的负 z 分数会更常见，因为分布的左侧存在更多极值。</p>
<img src="/images/z-score_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>无须考虑形状，适用于任何分布的规则。 <strong>75％ 的数据必须落在 z 分数正负 2 之内。</strong></p>
<img src="/images/z-score_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>且 <strong>89％ 的数据在 z 分数正负 3 之间。</strong> </p>
<img src="/images/z-score_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>因此， z 分数本身就在一定程度上，给出了关于观测极端程度的信息。如果要比较不同的分布， z 分数就更有用了。比如，来看一下 19.3 的体重是否常见：</p>
<img src="/images/z-score_8.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>在第 1 组中，这并不常见。 z 分数为 19.3 减去 15 再除以 2.5 ，等于 1.72 。在第 2 组中， 19.3 的 z 分数等于 19.3 减去 15 除以 8 等于 0.54 。这表明在第 2 组中， 19.3 的体重更常见。在第 2 组中， z 分数是 0.54 ，在第 1 组中，是 1.72 。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果我们将原始分数重新编码为 z 分数，就是 <strong>将变量标准化</strong> 。 <strong>标准化</strong> 意味着我们用 z 分数 替换原始度量中测量的分数，其优点是我们可以一眼看出特定分数是相对常见还是特殊。</p>
<p>因此，一个球员纹身占比是五分之一是否异常，这取决于球队或你想比对的另一组数据。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之三 | 测量集中趋势和离散程度</title>
    <url>/data-science/statistics-measures-of-central-tendency-and-dispersion/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="众数、中位数和平均数"><a href="#众数、中位数和平均数" class="headerlink" title="众数、中位数和平均数"></a>众数、中位数和平均数</h1><p>在前一篇教程中，我们学会通过图表概述分布。这同样适用于描述分布的中心位置，有三种主要方式，它们分别是：<strong>众数</strong> (mode) ，<strong>中位数</strong> (median) 和 <strong>平均数</strong> (mean) 。</p>
<p>这三个 m 通常被称为集中趋势的度量。</p>
<p>找到众数很容易，<strong>它是出现频次最高的值。</strong> 换句话说，就是最常见的结果。</p>
<p>如果测量定类或定序变量，<em>众数通常用作衡量集中趋势。</em></p>
<p>在下面这个饼图中，可以看到西班牙主要球赛中球员来自哪些大洲。</p>
<div id="echarts1106" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts1106'));
        // 指定图表的配置项和数据
        var option = {
    title : {
        text: ' 西班牙主要足球比赛中的球员国籍分布 ',
        x:'center'
    },
    tooltip : {
        trigger: 'item',
        formatter: "{a} <br/>{b} : {c} ({d}%)"
    },
    legend: {
        orient: 'vertical',
        left: 'left',
        data: [' 欧洲 ',' 北美 ',' 南美 ',' 非洲 ',' 亚洲 ']
    },
    series : [
        {
            name: ' 国籍 ',
            type: 'pie',
            radius : '55%',
            center: ['50%', '60%'],
            data:[
                {value:280, name:' 欧洲 '},
                {value:16, name:' 北美 '},
                {value:56, name:' 南美 '},
                {value:32, name:' 非洲 '},
                {value:16, name:' 亚洲 '}
            ],
            itemStyle: {
                emphasis: {
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: 'rgba (0, 0, 0, 0.5)'
                }
            }
        }
    ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>

<p>饼图使众数一目了然，是欧洲 70％ 的球员来自欧洲</p>
<p><strong><em>这里的众数是欧洲</em></strong> ，是最常出现的类别的名称，但众数不是 70％ 。这只是该特定类别的观测百分比。可能有多个众数。试想有一个足球运动员，拥有十分分裂的球迷，其中一些觉得他非常和善，而另一些则认为他非常蛮横。来给这个球员起个名，Franco Galton。</p>
<a id="more"></a>

<p>试想你选取西班牙 500 名受访者作为代表样本，询问他们对 Franco Galton 的看法，受访者可以在 0 到 10 的范围内表明他们认为他的和善程度。 0 表示非常蛮横， 10 表示非常和善。</p>
<img src="/images/two_mode.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>假设这是本研究得出的直方图形状，可以看到西班牙人分歧很大，有些人觉得 Galton 非常和善，有些人觉得他非常蛮横。正如所见，分布有 两个众数，即 3 和 8 这显然是双众数分布。</p>
<p>集中趋势的第二个衡量指标是中位数：<strong>观测值从最小到最大排序时，中位数就是观测值的中间值。</strong></p>
<p>试想你还问了七位受访者，对另一著名球员 Tomas Bayez 的看法。假设这是他的研究数据矩阵，这里的众数是 8 ，是频次最高的值。</p>
<img src="/images/median.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>要计算中位数，首先必须将所有数值从低到高排序，然后选择中间值。所以这里的中位数是 8 。如果案例是偶数而非奇数，那就稍微复杂点了。试想受访者是 8 人，他们对 Tomas Bayez 的看法。</p>
<img src="/images/median_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>数值是从低到高排列的。但是，在这种情况下，没有单个中间值。该如何解决这个问题呢？我们取两个中间数值的平均值 7 和 8 相加除以 2 等于 7.5 。因此，中位数是 7.5 。请注意，中位数将分布分为两个相等的部分。 50％ 的值低于中位数， 50％ 的值高于中位数。</p>
<p>集中趋势的第三个衡量指标，是最常用的一个，也可能是你已经非常熟悉的，就是平均数。</p>
<p>__平均数是所有观测值之和除以观测个数__。</p>
<p>$$ \bar x = \frac {\sum {x}}{n} $$</p>
<p>上面是用于计算平均值的公式。它看起来比较复杂，公式的含义是： x 横线表示变量 x 的平均数，等于 x 的总和除以样本个数，由 n 表示。</p>
<p>举个例子，借用 Tomas Bayez 的研究。公式告诉我们首先求总和， 6 加 7 ，加 7 ，加 8 ，加 8 ，加 8 ，加 9 ，等于 53 ，现在再除以 n 。样本量是 7 ，因此 53 除以 7 等于 7.6 平均数是 7.6 。</p>
<img src="/images/mean.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以将平均数视为数据的平衡点。试想我们将重量平衡放置，那么平均数就是天平中心点。其中一侧的总重量恰好等于另一侧。</p>
<img src="/images/mean_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>现在大家已经熟悉了这三个 m 。可以通过各种方式轻松计算一组数字的中间值，但报告时，该使用哪种中心趋势呢？</p>
<p><strong>这部分取决于变量的测量级别。</strong> 如果是定类测量，则无法计算中位数或平均数，因为我们无法对定类变量进行数值运算，也不能对它们进行排序。<strong>当变量是定类变量时 唯一适合的集中趋势度量是众数。</strong></p>
<p>如果是定量变量该怎么办呢？</p>
<p>试想你在家乡足球俱乐部的一个食堂里，你想计算所有在场人士的平均收入和中位收入，包括你自己，其他 5 位客人和吧员。</p>
<img src="/images/mean_and_median.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是数据矩阵，平均数约为 35,000 ，中位数恰好是 35,000 ， 它们彼此非常接近。使用哪一个来描述分布中心都无所谓。但现在，著名足球运动员 Franco Galton 走进食堂，比如他每年收入大约 7000 万 ，这时中位数略微增加到 36,000 ，然而，平均数却超过 800 万。</p>
<img src="/images/mean_and_median_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>我们说 Franco Galton 是这个分布的异常值。他的收入远高于其他所有人，他的收入对平均收入产生不成比例的影响。在这种情况下，计算中位数描述分布中心比平均数更合理。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>描述分布中心可以使用三种方法：众数，中位数和平均数。如果变量是定类的，则使用众数；如果是定量的，则使用中位数或平均数 —— 如果有异常值或分布高度偏离，使用中位数。如果不是，那就使用平均数。</p>
<hr>
<h1 id="全距、四分位距和箱线图"><a href="#全距、四分位距和箱线图" class="headerlink" title="全距、四分位距和箱线图"></a>全距、四分位距和箱线图</h1><p>你可能已经注意到了，纹身在足球运动员中越来越受欢迎。特别是所谓的纹身袖在球场上正在兴起。纹身袖，正如其名，是指满胳膊的纹身。</p>
<p>你对球员纹身占身体的比例感兴趣吗？</p>
<p>试想有两支球队，这里看到的是点图，表示两队中纹身占身体的百分比变量分布。水平线代表这个变量，原点代表每个团队中的 11 个人。</p>
<img src="/images/range.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>第一队队员纹身占比大约是 10％ 到 20％ 之间。在第二支球队中，球员的纹身占比差异很大，百分比范围是 0% 到大约 30％ 之间。因此，这个团队彼此差异很大。但是两队众数，中位数和平均数却相同。两队的众数都是 14.1 ，中位数和平均数都是 15 。<em>这表明为了充分描述分布，我们需要集中趋势度量之外的信息。</em> 这一节我将向大家展示我们还需要了解有关数据变化或离散的信息，讨论两种变异性测量，即：<strong>全距</strong> 和 <strong>四分位距</strong> ，还将讨论所谓的 <strong>箱线图</strong> —— 这是一个非常有用的图表，可以很好地呈现分布中的数值如何离散。</p>
<p>全距是最简单的变异性度量：它是 <strong>最高值和最低值之间的差值</strong> 。</p>
<img src="/images/range_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>再来看看我们的两支球队：第一队的球员中最大纹身占比是 19.3％ ， 占比最小的是 10.8％ ，范围是 19.3 减去 10.8 等于 8.5 ；第二队的球员中最大纹身占比是 27.7％ ，占比最小的是 0％ 。因此，范围是 27.7 减去 0 等于 27.7 。这清晰地显示第二队的变化范围比第一队的变化范围更大。全距是易于理解且易于计算的变异性度量。但是，在许多情况下，它并没有很好地呈现数据的变异性。 <em>原因是它只考虑了极值。。</em> 看看这两个分布，它们的范围相同，但一目了然第二个分布的变异性与第一个非常不同。</p>
<p>另一个更好的测量变异性的方法是 <strong>四分位距</strong> ，因为它省略了极值，它将分布分为四个相等的部分。因此，如果分布看起来是这样的。</p>
<img src="/images/range_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以这样切分，将得分最低的 25％ 划为一组，得分最高的 25％ 划为一组，中间的两个 25％ 再分两组。</p>
<p>这种划分分布方式称为四分位距，一共有三个 <strong>四分位</strong> ，以下称为 Q1 ， Q2 ， Q3 。</p>
<p>如你所见，第二个四分位 Q2 将分布分为两个相等的部分。毕竟， 50％ 的值低于该值， 50％ 高于该值。<br>因此 Q2 与中位数相同。 __四分位距是第三和第一个四分位之间的距离__。换句话说，四分位距是 Q3 减去 Q1 。下面让我通过纹身占比来展示计算过程。</p>
<img src="/images/range_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是第二队的分布情况。首先，寻找中位数或者换句话说 Q2 。这很简单，中间数值是 15 ；可以通过查找中位数左侧数值的中间值找到 Q1 ，是 8.7 ；可以通过相同的策略在右侧找到 Q3 是 19.3 。现在，四分位距是 Q3 减去 Q1 即 19.3 减去 8.7 等于 10.6 。四分位距的主要优点是它不受异常值的影响，因为它没有考虑低于 Q1 或高于 Q3 的观测值。然而，在研究中寻找潜在的异常值可能仍然有用。 <strong>根据经验，如果观测值低于第一个四分位 1.5 个四分位距或高于第三个四分位 1.5 个四分位距则为异常值。</strong></p>
<p>在描述中心和变异性以及检测异常值时，有一种特定类型的图非常有用，该图称为 <strong>箱线图</strong> 。</p>
<p>Q1，Q2 和 Q3 在箱形图中一目了然，最小值不是异常值，最大值不是异常值。</p>
<img src="/images/range_5.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这是基于前一个示例的箱形图。<strong>箱体</strong> 本身代表分布中心的 50％ 。换句话说，从 Q1 到 Q3 。 <strong>箱高</strong> 代表四分位距，箱内的 <strong>水平线</strong> 是中位数，换句话说，即 Q2 。箱体上面和下面的线称为 <strong>箱须</strong> 。它们包含除异常值以外的其他值，异常值用点单独标记。这里没有点，所以这个箱形图没有任何异常值。</p>
<img src="/images/range_6.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如何确定箱须的长度呢？让我们回到之前示例中的数值，我们检测到了 Q2 ， Q1 和 Q3 以及四分位距。我们知道低于 Q1 1.5 倍四分位距的或高于 Q3 1.5 倍四分位距的值是异常值。这里的四分位距是 10.6 。所以 1.5 乘以 10.6 等于 15.9 ， Q1 为 8.7 ，因此所有低于 8.7 减去 15.9 等于 -7.2 的值都是异常值。这里不存在这样的值，所以下末端没有异常值，这里的最小值是 0 。 Q3 是 19.3 ，因此，高于 19.3 加上 15.9 等于 35.2 的值都是异常值。我们也没有这么高的数值，所以上末端也没有异常值。箱须的上末端等于最大值，即 27.7 。</p>
<p>我们来看一下第一队的箱形图，如果比较两个箱形图，我们立即就能看到两个分布的变异性差别很大。</p>
<img src="/images/range_7.jpg" width="68%" height="68%" style="margin: 10 auto;">

<h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>请记住，分布的中心只能告诉你部分信息。为了了解的更完整，还要 __评估分布的变异性__。箱线图使用三个四分位数，异常值以及剔除异常值后的数据范围，以紧凑的方式显示分布的重要信息。</p>
<hr>
<h1 id="方差和标准差"><a href="#方差和标准差" class="headerlink" title="方差和标准差"></a>方差和标准差</h1><p>在足球运动员中，纹身越来越受欢迎。试想，你想知道球员纹身的身体占比。</p>
<img src="/images/tatto.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这里看到的点图表示纹身占比的分布，由两队球员纹身占身体的百分比表示。一目了然，在第一队中纹身占比的变化远小于第二队。这种变异性可以通过 <strong>全距离</strong> 或 <strong>四分位距</strong> 来测量。也可以用箱线图表示 在此可以看到相关的箱线图。在本节中，将讨论统计研究中经常使用的另外两种变异性度量，即 <strong>方差</strong> 和 <strong>标准差</strong> 。</p>
<p>与许多其他变异性度量相比，方差和标准差的巨大优势在于：<strong>它们考虑了所有变量的数值</strong> 。</p>
<p>让我们从方差开始。这是方差的公式：</p>
<p>$$ s^2 = \frac {\sum {(x - \bar x)^2}}{n - 1} $$</p>
<p>s 的平方代表方差。将每次的观测值 x 减去 x 的平均值 （x 拔），然后将所有这些值平方后相加，结果是我们所说的平方和，接下来将平方和除以样本的大小 n 减去 1 。我们现在将公式应用于纹身占比的示例，以了解它在实践中的工作原理。</p>
<img src="/images/variance.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>第一步是计算平均值，这些值的平均值等于 15 ； 第二步是从每个观测值中减去平均值。我们来取第一个值，0 从这个值中减去平均值 0 减去 15 是负 15 。我们对样本中所有的值都这样计算。算完后，我们发现有负数，也有正数。这并不奇怪，因为均值是这些数值的中间点或平衡点。事实上，均值的负差和正差相抵 ，结果的总和等于 0 。换句话说，这些值的总和等于 0 。</p>
<p>因此，我们不使用 <strong>原始差值__，而是使用 __差的平方</strong> 。</p>
<p>接下来，我们对所有这些计算值进行平方。</p>
<p>根据公式，接下来我们需要将所有这些值相加。现在得数是平方差的总和，换句话说，平方和。这个数等于 639.74 。然后将平方和除以 n 减 1 。在我们的例子中， n 是 11 ，所以 n 减去 1 等于 10 。 639.74 除以 10 等于 63.97 ，这就是方差。</p>
<p><strong>方差越大，变异性越大。这意味着方差越大，数值越离散。</strong></p>
<img src="/images/variance_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>这里显示的第一队的方差约为 6.33 ，从点图和箱线图中已经可：第 2 队中纹身占比的较大差异，也由较大的方差表示。</p>
<p>方差的一个重要缺点是：方差的度量是经过平方的变量度量。毕竟，我们平方了正差和负差，以便它们不会相互抵消。</p>
<p>有一个非常简单的方案可以解决这个问题。我们只取方差的平方根 —— 我们称之为 <strong>标准差</strong> 。标准差可以被看作观测值与平均值的平均距离。<strong>标准差越大，数据的变异性越大。</strong></p>
<p>$$ s = \sqrt {\frac {\sum {(x - \bar x)^2}}{n - 1}} $$</p>
<p>因此在我们的例子中，第一队的标准差是 6.33 的平方根，等于 2.52 。第二队的标准差是 63.97 的平方根，等于 8.0 。标准差是最常使用的离散度量。然而，在许多统计方法中，方差也起着重要作用。在本节教程中，大家了解了它们密不可分，可以轻松从一个推演出另一个。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之二 | 数据可视化</title>
    <url>/data-science/statistics-descriptive-statistics/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<blockquote>
<p>当我们向他人呈现数据时，通常需要将数据 “__总结__” 成各种图表的形式，例如频率表、饼图、条形图、散点图和直方图等。</p>
</blockquote>
<h1 id="统计案例、变量和测量级别"><a href="#统计案例、变量和测量级别" class="headerlink" title="统计案例、变量和测量级别"></a>统计案例、变量和测量级别</h1><blockquote>
<p>如果你对足球非常感兴趣，你想知道所有细节：比如某个球员有多少进球，某个球队赢了多少场比赛或者在某场足球比赛中有多少次点球。统计学知识，将帮助你成为足球或任何其他运动的真正专家。</p>
</blockquote>
<p>进球得分，赢得比赛，判罚点球，这些都可以被看作 <strong>变量</strong> 和 <strong>统计案例</strong> 。</p>
<blockquote>
<p><strong>变量</strong> 是事件或者人物的特征， <strong>统计案例</strong> 就是那个事或那个人。</p>
</blockquote>
<p>来讲得更具体一点。想象一下，你最喜欢的球队，你对足员的某些特征感兴趣：你想知道他 / 她的体重，头发颜色，年龄以及在最近的比赛中得分的总数。所有这些球员的特征都是变量，球员本身就是统计案例。</p>
<p>另一个例子，可能你对个别球员的特征不是那么感兴趣，而对他们所效力的球队特征感兴趣。例如，你可能想了解每个西班牙球队，以及它们所在的城市，他们队服的主色调是什么，以及球队去年有多少进球。这些特征也都是变量。但是，这里的统计案例不是个别球员，而是这些人所效力的球队。</p>
<p>在一项研究中，<em>案例可以是许多不同的事物。</em> 可以是个别球员和球队，也可以是公司，学校甚至是国家。</p>
<p><strong>案例的每个特征都可以成为变量</strong> —— 只要它符合一个基本的标准：即是变化的</p>
<p>这是什么意思呢？ 让我们回到示例。以球队为案例，并以团队所在的城市为变量。你关注每个西班牙球队，所以会有很多不同的城市：一支球队来自巴塞罗那，其他球队来自马德里，瓦伦西亚或塞维利亚。换句话说，城市是有变化的。</p>
<a id="more"></a>

<p>现在让我们关注另一个特征，不是城市，而是球队所在的国家。对于每一个球队而言，它们的国家都是西班牙 这些球队都是西班牙球队。这表示它们之间没有差异：没有一支球队会来自西班牙以外的其他国家。出于这个原因，这个特征不是变量，而是常量。</p>
<p>可以想象，我们可以有许多不同类型的变量代表非常不同的特征。因为这个原因，还有一些其他原因（我之后会讨论到）区分不同的 <strong>测量级别</strong> 至关重要，</p>
<p>最简单的测量是 <strong>定类测量</strong> 。<strong>定类变量由彼此不同的各种类别组成 变量之间没有顺序关系。</strong> 这意味着无法区别一个类别比另一个更好或更差，更多或更少。一个例子是球员的国籍，各种类别，例如西班牙，法国或墨西哥。彼此不同，但没有排名顺序；另一个例子是球员性别或球队所在城市。</p>
<p>第二级测量是 <strong>定序测量__：__变量的类别之间不仅存在差异，还存在顺序</strong> 。例如球赛的排名：可知谁是冠军，谁是第二，第三，等等。但是，通过查看排名，你不可能知道类别之间的差异大小 例如，你不知道第一名比第二名好多少。</p>
<p><em>定类和定序测量都可以称为分类变量。</em></p>
<p>下一级测量是 __定距测量__。在定距变量中：__我们有不同的类别和顺序，类别之间也有相似的区间__。 一个例子是球员的年龄。我们可以说，18 岁的球员与 16 岁的球员，年龄不同。另外，我们可以说这个球员年纪大些。就年龄而言，我们也可以说：18 岁球员和 16 岁球员之间的年龄差异，类似于 14 岁球员和 12 岁球员之间的年龄差异。</p>
<p>最高级的测量是 <strong>定比测量</strong> 。它类似于定序测量，但另外还有一个有意义的零点。例如球员的身高，以厘米为单位。它们在类别上存在差异，有一定的顺序，有相似的间隔，也有一个有意义的零点。身高为 0 厘米意味着没有高度。请注意，我们不能说年龄有一个有意义的零点：因为零岁并不意味着没有年龄，因此年龄是定距变量。</p>
<p>定距和定比变量就是我们所说的 <strong>定量变量</strong> ，因为类别由数值表示。</p>
<p>定量变量也可以分为 <strong>离散变量</strong> 和 <strong>连续变量</strong> 。如果某类别形成一组单独的数字，则变量是离散的。例如，球员的进球数：球员可以进一球或两球，但不能是 1.21 球。如果变量值形成区间，则变量是连续的。一个例子是玩家的高度：有人可能是 170 厘米或 171 厘米高，也可能是，比如说，170.2461 厘米高。我们没有一组单独的数字，而是一个无限的数值区域。</p>
<h2 id="区分测量级别的意义"><a href="#区分测量级别的意义" class="headerlink" title="区分测量级别的意义"></a>区分测量级别的意义</h2><p>为什么区分这些不同的测量等级如此重要。因为 __我们用来分析数据的方法，取决于变量的测量水平__。 </p>
<p>然而，在实践中， <em>区别有时会变得模糊。</em> 例如，对于许多统计分析，定距和定比测量之间的差异并不重要。此外，许多统计学家认为，如果定类测量有十分类甚至更多分类，就可以定量分析这些变量。</p>
<p>一个例子是调查问卷，问题是从 0 到 10 之间你如何评价某个球员。在形式上，这是一个定类变量，但在实践中，你可以讨巧将其视为定量变量。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>从案例，变量和这些变量的衡量水平来考虑球员，球队和比赛，可以让你对足球有更结构化的理解。</p>
<hr>
<h1 id="数据矩阵"><a href="#数据矩阵" class="headerlink" title="数据矩阵"></a>数据矩阵</h1><p>我们已经知道实施一项研究，可以根据案例和变量来考虑。接下来，我将讨论如何排布和展示你的案例和变量。</p>
<p>想象一下，你对西班牙顶级球赛 “西班牙甲级联赛” 感兴趣。你感兴趣的案例是联赛的个体球员，你关注的变量是年龄，体重，进球数量，会籍和头发颜色。</p>
<p>排布所有这些信息的最佳方式是通过 <strong>数据矩阵</strong> 。数据矩阵是所有统计研究的核心要素：它是所有案例和变量的概述。 <strong>案例显示在行中</strong> ，它的范围从 1 号球员一直到 400 号球员。</p>
<table>
<thead>
<tr>
<th>球员</th>
<th>年龄</th>
<th>体重</th>
<th>进球数</th>
<th>会籍</th>
<th>头发颜色</th>
</tr>
</thead>
<tbody><tr>
<td>球员 1</td>
<td>18</td>
<td>72.6</td>
<td>0</td>
<td>Real Zaragoza</td>
<td>金发</td>
</tr>
<tr>
<td>球员 2</td>
<td>21</td>
<td>71.4</td>
<td>0</td>
<td>Real Betis</td>
<td>黑发</td>
</tr>
<tr>
<td>球员 3</td>
<td>26</td>
<td>74.8</td>
<td>8</td>
<td>Sevilla</td>
<td>黑发</td>
</tr>
<tr>
<td>球员 4</td>
<td>22</td>
<td>76.8</td>
<td>12</td>
<td>Barcelona</td>
<td>黑发</td>
</tr>
<tr>
<td>球员 5</td>
<td>22</td>
<td>74.1</td>
<td>17</td>
<td>Valencia</td>
<td>其他</td>
</tr>
<tr>
<td>球员 6</td>
<td>27</td>
<td>78.9</td>
<td>3</td>
<td>Real Sociedad</td>
<td>其他</td>
</tr>
<tr>
<td>球员 7</td>
<td>30</td>
<td>80.3</td>
<td>2</td>
<td>Real Madrid</td>
<td>金发</td>
</tr>
<tr>
<td>球员 8</td>
<td>24</td>
<td>73.3</td>
<td>1</td>
<td>Athletic Bilbao</td>
<td>褐发</td>
</tr>
<tr>
<td>球员 9</td>
<td>23</td>
<td>76.9</td>
<td>5</td>
<td>Valencia</td>
<td>褐发</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>球员 24</td>
<td>26</td>
<td>.</td>
<td>0</td>
<td>Malaga</td>
<td>黑发</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>球员 400</td>
<td>26</td>
<td>77.2</td>
<td>0</td>
<td>Atheletic Madrid</td>
<td>其他</td>
</tr>
</tbody></table>
<p>这里没有显示名字，这意味着这里的名称是匿名的。 <strong>变量显示在列中</strong> 。我们有五个变量：年龄，体重 进球数，会籍和头发颜色。表格单元格中显示的值通常称为 <strong>观测值</strong> 。这里 80.3 表示 7 号球员的体重是 80.3 公斤，这里的八分表示三号球员已经进了八球。</p>
<p>我们看到的不是一个完整的数据矩阵，只是其中一部分。完整的矩阵无法单屏呈现，因为它有 400 行，因为我们有 400 名球员。省略号已经明确表示只取了矩阵的一部分。</p>
<p>来看看我们的数据矩阵是否包含异常值。嘿，其中的 24 号球员，我们看不到体重数值。目前，我们已经囊括了这些不完整的案例。但是，如果后续分析需要完整的数据矩阵，我们可能必须删除它们。</p>
<p>所有统计分析都需要数据矩阵。但是，你通常不会向其他人提供完整的数据矩阵。原因是数据矩阵通常很大。在我们的例子中，有 400 行，并且也没有清楚地概述数据矩阵中包含的统计信息。</p>
<p>当我们将数据矩阵中的信息呈现给其他人时，经常以表格和图形的形式进行数据摘要。想象一下，你想要概述西班牙足球比赛中关于球员头发颜色的信息。较好的方法是制作频率表。频率表显示案例中 <strong>变量数值的分布</strong> 。* 频率表就是变量的所有可能值的列表，连同每个值的观测次数。*</p>
<p>这是一个基于发色变量的示例，我们可以区分四个类别 金发，棕色，黑色和其他。</p>
<table>
<thead>
<tr>
<th>发色</th>
<th>频率</th>
<th>百分比</th>
<th>累积百分比</th>
</tr>
</thead>
<tbody><tr>
<td>金色</td>
<td>76</td>
<td>19</td>
<td>19</td>
</tr>
<tr>
<td>褐色</td>
<td>134</td>
<td>33.5</td>
<td>52.5</td>
</tr>
<tr>
<td>黑色</td>
<td>160</td>
<td>40</td>
<td>92.5</td>
</tr>
<tr>
<td>其他</td>
<td>30</td>
<td>7.5</td>
<td>100</td>
</tr>
<tr>
<td>总计</td>
<td>400</td>
<td>100</td>
<td></td>
</tr>
</tbody></table>
<p>可以看到 76 名球员是金发， 160 名球员是黑发。注意，这些值相加是 400，所以没遗漏任何头发颜色的数据。</p>
<p>我们还可以通过百分比表示相对频率。在第二列中，可以看到百分比。可以一眼看出 7.5％ 球员是其他发色， 19％ 的球员是金发。将 76 除以 400 再乘以 100 得到 19 。</p>
<p>有时，研究人员使用累积百分比。这也很容易计算，累积百分比就是每个类别的百分比之和。所以可以看到 19 加 33.5 等于 52.5 金发和棕色头发占比 52.5 。</p>
<p>在这个例子中，我们讨论了一个分类变量，头发颜色。如果处理定量变量怎么办？以体重为例，计算每个特定个体的体重百分比是没有意义的。因为那样我们最终会得到无数的类别 —— 频率表将显示：比如两个人的体重为 65.3 公斤，一个人体重 65.4 公斤，等等。这几乎没比原始数据矩阵提供额外的有用信息。</p>
<p>研究人员通常会建立新的 <strong>顺序分类</strong> 来解决这类问题。可以做成，例如，第一类包含那些小于 60 公斤的球员；第二类，体重在 60 到 69.9 公斤之间的；下一类，介于 70 和 79.9 之间的；接着介于 80 和 89.9 之间的；最后一类， 90 公斤及以上。像下面这样：</p>
<table>
<thead>
<tr>
<th>体重</th>
<th>频率</th>
<th>百分比</th>
</tr>
</thead>
<tbody><tr>
<td>&lt; 60</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<td>60-69.9</td>
<td>69</td>
<td>17.25</td>
</tr>
<tr>
<td>70-29.9</td>
<td>273</td>
<td>68.25</td>
</tr>
<tr>
<td>80-89.9</td>
<td>45</td>
<td>11.25</td>
</tr>
</tbody></table>
<blockquote>
<p>= 90 | 5 | 1.25<br>总计  | 400 | 100</p>
</blockquote>
<p>虽然这样你可能会丢失信息，但优点是可以获得更好的概述。我们说你已经 <strong>重新编码了变量</strong> 。体重变量本是定量变量，但现在变成了一个只有五个类别的定序变量。</p>
<p>将定量变量重新编码为定序变量非常容易。但是，反过来是不可能的：你无法将定序变量重新编码为定量变量。所以，你该了解 —— <strong>数据矩阵是所有统计分析的根源</strong> 。它是数据的概述。但是，如果你想将发现呈现给他人，可以使用 <strong>数据摘要</strong> 。一个非常好的总结方法是制作 <strong>频率表</strong> 。如有必要，你可以将定量变量重新编码为定序变量。</p>
<hr>
<h1 id="信息图和各种数据分布形状"><a href="#信息图和各种数据分布形状" class="headerlink" title="信息图和各种数据分布形状"></a>信息图和各种数据分布形状</h1><h2 id="定类变量"><a href="#定类变量" class="headerlink" title="定类变量"></a>定类变量</h2><p>如果想研究西班牙主要足球比赛中的球员来自哪里，下面这个频率表可能就是结果：</p>
<table>
<thead>
<tr>
<th>国籍</th>
<th>频率</th>
<th>百分比</th>
</tr>
</thead>
<tbody><tr>
<td>欧洲</td>
<td>280</td>
<td>70</td>
</tr>
<tr>
<td>北美</td>
<td>16</td>
<td>4</td>
</tr>
<tr>
<td>南美</td>
<td>56</td>
<td>14</td>
</tr>
<tr>
<td>非洲</td>
<td>32</td>
<td>8</td>
</tr>
<tr>
<td>亚洲</td>
<td>16</td>
<td>4</td>
</tr>
<tr>
<td>总计</td>
<td>400</td>
<td>100</td>
</tr>
</tbody></table>
<p>可以看到 280 名球员来自欧洲， 16 名来自北美， 56 名来自南美， 32 名来自非洲， 16 名来自亚洲。</p>
<p>我还添加了相对百分比，你可能希望通过图表展示百分比，有两种可能的方法。</p>
<div id="echarts1547" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts1547'));
        // 指定图表的配置项和数据
        var option = {
    title : {
        text: ' 西班牙主要足球比赛中的球员国籍分布 ',
        x:'center'
    },
    tooltip : {
        trigger: 'item',
        formatter: "{a} <br/>{b} : {c} ({d}%)"
    },
    legend: {
        orient: 'vertical',
        left: 'left',
        data: [' 欧洲 ',' 北美 ',' 南美 ',' 非洲 ',' 亚洲 ']
    },
    series : [
        {
            name: ' 国籍 ',
            type: 'pie',
            radius : '55%',
            center: ['50%', '60%'],
            data:[
                {value:280, name:' 欧洲 '},
                {value:16, name:' 北美 '},
                {value:56, name:' 南美 '},
                {value:32, name:' 非洲 '},
                {value:16, name:' 亚洲 '}
            ],
            itemStyle: {
                emphasis: {
                    shadowBlur: 10,
                    shadowOffsetX: 0,
                    shadowColor: 'rgba (0, 0, 0, 0.5)'
                }
            }
        }
    ]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>

<p>这里是一个 <strong>饼图</strong> 。要概述的变量类别是通过饼图 <strong>切片</strong> 展示在饼图中，切片表示每个类别的百分比，一目了然 —— 几乎四分之三的足球运动员来自欧洲。</p>
<p>另一种概述数据的方法是 <strong>柱状图</strong> ，它可以非常清楚地展示数据在各个变量类别上的分布。</p>
<div id="echarts6938" style="width: 85%;height: 400px;margin: 0 auto"></div>
<script src="https://cdn.bootcss.com/echarts/3.8.0/echarts.common.min.js"></script>
<script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('echarts6938'));
        // 指定图表的配置项和数据
        var option = {
    xAxis: {
        type: 'category',
        data: [' 欧洲 ', ' 北美 ', ' 南美 ', ' 非洲 ', ' 亚洲 ']
    },
    yAxis: {
        type: 'value'
    },
    series: [{
        label: {
            normal: {
                show: true,
                position: 'insideTop'
            }
        },
        data: [280, 16, 56, 32, 16],
        type: 'bar'
    }]
}
        // 使用刚指定的配置项和数据显示图表。
        myChart.setOption(option);
</script>

<p>柱形的高度代表每个类别观测值的百分比。</p>
<h2 id="饼图和柱状图的优劣"><a href="#饼图和柱状图的优劣" class="headerlink" title="饼图和柱状图的优劣"></a>饼图和柱状图的优劣</h2><p>两种图表都各有优，缺点。饼图的一个优点是，可以立即看出大约 75％ 的球员来自欧洲，不进行点计算就无法轻松地从柱状图中辨别出这些信息。但是，另一方面，从饼图中不容易检索每个类别的确切球员数量。例如，在柱状图中，可以轻松地看到有 50 多名球员来自南美洲。</p>
<p><strong>如果变量的类别数量增加，柱图优于饼图。</strong> 例如，想象一下，不是球员所在大洲，而是他们出生的某个具体国家。图呈现的效果将非常非常混乱。出于美学原因，你可能会在饼图中使用不同颜色，但所有这些信息使饼图不易于理解。在这种情况下，柱状图会更合理。柱状图也会包含大量信息。但它会比花里胡哨的饼图更容易理解。</p>
<h2 id="定量变量"><a href="#定量变量" class="headerlink" title="定量变量"></a>定量变量</h2><p>前面讲了定类变量，那么定量变量又要怎么处理呢？</p>
<p>一种可能性是 <strong>气泡图</strong> 。这个想法很简单，想象一下有 10 个球员身高信息，用厘米表示。</p>
<p>下面是数据矩阵。</p>
<table>
<thead>
<tr>
<th>球员</th>
<th>身高</th>
</tr>
</thead>
<tbody><tr>
<td>球员 1</td>
<td>176</td>
</tr>
<tr>
<td>球员 2</td>
<td>180</td>
</tr>
<tr>
<td>球员 3</td>
<td>165</td>
</tr>
<tr>
<td>球员 4</td>
<td>177</td>
</tr>
<tr>
<td>球员 5</td>
<td>167</td>
</tr>
<tr>
<td>球员 6</td>
<td>170</td>
</tr>
<tr>
<td>球员 7</td>
<td>175</td>
</tr>
<tr>
<td>球员 8</td>
<td>178</td>
</tr>
<tr>
<td>球员 9</td>
<td>174</td>
</tr>
<tr>
<td>球员 10</td>
<td>172</td>
</tr>
</tbody></table>
<p>首先，绘制一条水平线，并以规则的间隔标记可能的数值，如下所示。</p>
<img src="/images/singleAxis_bubble_scatter.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>接下来，对于每次观测在水平线上的数值之上标记一个点，像就这样：</p>
<img src="/images/singleAxis_bubble_scatter_2.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>可以想象，当只有若干观测结果时，气泡图很不错。但是，当样本巨大时，会变得混乱。 100 个球员的样本，看起来是这样的：</p>
<img src="/images/singleAxis_bubble_scatter_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如果有很多观测结果时，研究人员通常会使用另一种类型的图表：<strong>直方图</strong></p>
<p>这就是一例：</p>
<img src="/images/histogram.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>直方图在某种意义上类似于柱状图，它使用柱形来描绘变量可能数值的频率或相对频率。但是，有一个重要的区别： __直方图中的柱点是相互接触的__。</p>
<p>该接触表示区间比率变量的数值呈现连续标度。比如，我们对西班牙足球运动员的体重感兴趣，如果测量数值非常详细，比如 83.9 或 74.5 公斤，为每一个值绘制一个单独的柱形是没有意义的。相反，我们构建 <strong>区间</strong> 。</p>
<img src="/images/histogram_1.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p> 在此图中，有 10 个 区间，每个区间 5 公斤，第一个区间范围从 47.5 公斤到 52.5 公斤 显示 50 ，因为 50 是该区间的中间。对于创建的区间的数量，没有固定的规则。但是，重要的是区间数值必须相同，所以在此图中都是五公斤。可以一眼看出大多数球员的体重约为 75 公斤，还可以看到，重量小于 60 或大于 90 是非常罕见的。 </p>
 <img src="/images/histogram_3.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>如图所见，此直方图具有特定形状，它是钟形的，有一个 <strong>峰值</strong> 且两侧近似对称。你会经常遇到钟形分布，但并非所有直方图都是钟形。</p>
<p>直方图也可以向左或向右 <strong>倾斜</strong> 。偏斜的直方图不是对称的，因为分布的一侧比另一侧延伸得更远。</p>
<img src="/images/histogram_4.jpg" width="68%" height="68%" style="margin: 10 auto;">

<p>有的直方图向左倾斜，而有的直方图向右倾斜。向右倾斜的直方图变量是西班牙比赛中球员的年收入。与球员的平均收入相比，收入很少的球员不会很多。但是，也会有一些球员比大多数球员赚的多得多。因此，右尾更长。</p>
<p>直方图也可能有两个峰值：设想两队六到八岁球员之间的足球比赛。比赛结束后，所有的孩子和父母都去食堂喝东西。</p>
<p>你感兴趣的问题是，食堂里的人年龄如何分布。在这种情况下，年龄变量的直方图有两个峰值。毕竟，食堂里的孩子是 6 到 8 岁的孩子和他们的父母，他们最有可能在 30 到 40 岁之间。</p>
<p>因此，可能在 7 岁左右达到峰值，在 35 岁左右再达到峰值。我们说这个变量是双峰而不是单峰。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这篇教程最重要的一个内容是：通过图表概述数据是一个好主意。<strong>如果处理定类或定序变量，你应该制作饼图或柱图。如果变量是定距或者定比变量，则应绘制直方图。</strong> 永远不要忘记查看变量的形状，它是钟形且对称的吗？它是单峰，还是双峰？分布是否倾斜？ __评估分布的形状至关重要__， 因为它可能影响你之后使用的统计方法。</p>
<hr>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>极速统计教程之一 | 引言</title>
    <url>/data-science/statistics-basic-introduction/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="学习统计学的意义"><a href="#学习统计学的意义" class="headerlink" title="学习统计学的意义"></a>学习统计学的意义</h1><p>乍一看，统计学可能很吓人，但实际上，统计学并不可怕。它可以关乎很有趣的事，比如足球、潜水、巧克力，很有趣的人，比如潮人、出租车司机和婴儿。</p>
<p>至少有三个原因，让统计学至关重要。</p>
<ul>
<li>首先，我们周围有很多统计学，包括新闻，还有科学工作。</li>
<li>其次，统计学知识将帮你开展自己的研究。你该如何分析你得到的信息？该采用哪种方法？</li>
<li>第三，也是最后一点，分析数据可以帮助我们了解有趣的世界。</li>
</ul>
<h1 id="统计学的两种类型"><a href="#统计学的两种类型" class="headerlink" title="统计学的两种类型"></a>统计学的两种类型</h1><p>我们将统计学分为两种类型： <strong>描述统计学</strong> 和 <strong>推断统计学</strong> 。当我们谈论 <strong>描述统计学</strong> 时，我们指的是概述信息的方法。我们可以通过图表来概述信息，比如饼图或条线图或者诸如平均值，百分比或相关系数等数字。<strong>推断统计学</strong> 是仅根据有限数据案例，推断有关整体的结论。</p>
<h1 id="教程导览"><a href="#教程导览" class="headerlink" title="教程导览"></a>教程导览</h1><p>教程会分为七个模块。前两个模块主题是描述统计学；接下来的三个模块，将介绍之后在推断统计学中用到的方法：我们会讨论 <strong>概率</strong> ，<strong>概率分布</strong> 和 <strong>抽样分布</strong> ；在最后的两个模块中，我们将介绍推断统计学方法， <strong>如何估计置信区间</strong> 以及 <strong>如何进行假设检验</strong> 。</p>
<h1 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h1><p>不需要额外的知识，学校里学的足够了。你需要的是对方法论和数据的兴趣，以及最重要的东西 —— <strong>激情</strong> ！</p>
]]></content>
      <categories>
        <category>data-science</category>
      </categories>
      <tags>
        <tag>统计</tag>
        <tag>数据科学</tag>
      </tags>
  </entry>
  <entry>
    <title>用 “流水线” 设计拆解复杂处理流程</title>
    <url>/programming/break-down-complexity-with-pipelines/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<ul>
<li>本文的主要价值： <strong>提供一种抽象复杂逻辑，达成功能复用的思路</strong></li>
<li>关键词： <strong>语义提炼</strong> 、 <strong>动态具名</strong></li>
<li>本文约 4000 字，建议阅读时间 30 分钟。 </li>
</ul>
<hr>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在软件开发时常常遇到一种场景：随着产品功能的扩展，出现了多个具备高度相似性的功能单元。这些功能单元可能有着相似的交互逻辑，提供同类的输入数据和输出数据。并且对于用户来说，它们共同处理同一个元素。举个例子，比如一款修图 app ，它包含了一组编辑功能，每个功能都作用于一张图片，处理之后的图片还可以作为其他功能的输入。作为编辑工具，在每个功能内部，还可能都需要支持撤销和重做这样的用户操作。容易想到，这些功能间存在着许多可以进行复用设计的代码。</p>
<p>本文基于我曾经从事的一款图像处理应用开发过程中的一次代码重构的实践所做的回顾发起，期望达到记录和分享的目的。</p>
<h1 id="重构的具体背景"><a href="#重构的具体背景" class="headerlink" title="重构的具体背景"></a>重构的具体背景</h1><p>请先看下面这幅图：</p>
<p><img src="/images/image_modules.jpg" alt="重构前的图像功能模块结构"></p>
<p>图中的元素很少，但细心的读者可能留意到了：图中的 “ <strong>内存图像管理 + 效果处理</strong> ” 是一个 “ <strong>黑盒子</strong> ”。那么这个黑盒子是一件好事还是坏事呢？</p>
<p>既然我们对这种设计做了重构，那么这里重点来探讨一下它的缺点。 黑盒子的优点部分，作为思考题留给读者。</p>
<p>在具体业务场景下，我发现旧有设计的两个问题：</p>
<ul>
<li>图像处理接口粒度太大，难以复用代码； </li>
<li>黑盒子把 <strong>图像管理</strong> 和 <strong>图像效果处理</strong> 这两件事包在了一起，使得外部难以灵活的接触和使用图像。 </li>
</ul>
<a id="more"></a>

<hr>
<h1 id="重构的设计思路-——-“流水线”-概念的提炼"><a href="#重构的设计思路-——-“流水线”-概念的提炼" class="headerlink" title="重构的设计思路 —— “流水线” 概念的提炼"></a>重构的设计思路 —— “流水线” 概念的提炼</h1><p>问题一在重构时也得到了解决，但与本文要表达的设计思想关联不大，就此略过。为了解决问题二，我引入了两个概念：“ <strong>流水线</strong> ” 和 “ <strong>例程</strong> ”。相信对于从事计算机领域工作的读者来说，这两个词不会陌生。</p>
<blockquote>
<p><strong>流水线</strong> pipeline， [计] 又称管道，管线。<br><strong>例程</strong> routine, [计] 程序；日常工作；例行公事</p>
</blockquote>
<p>在具体代码实现中， Pipeline 相当于内存中的图像状态机，提供了基本的管理图像的能力，例如加入图像，删除图像，复制图像，移动图像等。 Routine 相当于各个图像功能单元中通用的事务，比如每个图像功能单元都需要在其开始运作时从某处获得一份初始图像，并在其结束运作时输出一份 <strong>最终的</strong> 图像到另一处。我们约定， Routine 中的事务会基于 Pipeline 来完成。它的含义是：每个 Routine 都会包含一组基于一个或者多个 Pipeline 的典型操作，然后再加上每个 Pipeline 的差异化操作（即后文会提到的 <strong>差异化的图像处理步骤</strong> ），共同构成一个完整的具体场景下的图像功能单元。</p>
<p>下文中我们不妨把 “__流水线__” 的释义直接替换成 “__管道__” ，因为后面用到的一些比喻性的描述我觉得用 “管道” 一词衍生出来会比用 “流水线” 更自然一些。接着我们对 “管道” 这个意象再做进一步的挖掘，可以有下面一些对应关系（表格中左侧的概念只是我的比喻，读者可自行体会，这里不会全部详细解读）</p>
<table>
<thead>
<tr>
<th>比喻</th>
<th>原对象</th>
</tr>
</thead>
<tbody><tr>
<td>“管道”</td>
<td>图像状态机</td>
</tr>
<tr>
<td>“流体”</td>
<td>图像</td>
</tr>
<tr>
<td>“节点”</td>
<td>图像状态</td>
</tr>
<tr>
<td>“流动”</td>
<td>图像状态流转</td>
</tr>
<tr>
<td>“锋面”(流体的最前端)</td>
<td>当前正在处理的图像状态</td>
</tr>
<tr>
<td>“连通性”</td>
<td>状态机内的图像以及图像状态机之间都是可串联的</td>
</tr>
</tbody></table>
<p>“流体” 是一个名词，它对应的是图像，涉及到存储模型。根据 “流体” 的特性我们推断管道里的图像存储模型应该会被设计为平行结构。</p>
<p>请读者联想一下 &lt; __化妆 / 整容 VS 软件上美化照片上的人脸__ ** &gt; 这种类比关系，再想一下两者在存储模型和工序这两个方面有什么异同？</p>
<p>回到正题，我配了五幅图来描述管道在具体实现中的五个特性：</p>
<ol>
<li><p>流体由一系列节点（即图像状态）组成。图像状态的含义构成了我们对某一个图像的本征性认知。通俗的说，图像状态能够帮助我们在特定场景下把不同的图像区分开来。举个例子，协同开发的两位开发者对于 “美颜” 和 “滤镜” 这两个步骤的认知达成了共识。于是我们就可以建立两个节点：“美颜”、“滤镜”，然后在开发过程中使用这两个节点来协作。注意到图像状态不是图像本身，图像状态的代码实现上我们可以使用一个极轻量的数据结构 —— 字符串。它体现的是 <strong>占位符思想</strong> ，而占位符的重要好处是它是 <em>可预见的（基于认知共识）、可预置的（它很轻量）、可固化的（可复用性代码的一个诉求）</em> 。 </p>
</li>
<li><p>管道通过衔接节点构成连通。在节点中有必要特别提出 “同位节点” 的描述。它指的是几个步骤在同一个图像上先后发生。在时间上有先后但在空间上始终操作同一份存储。后面会再用到这个描述。</p>
</li>
</ol>
<p><img src="/images/flow_connectivity.jpg" alt="流体和连通性"></p>
<ol start="3">
<li><p>流动的流体会有一个 <strong>最前部</strong> ，好像水流的最前端，又称 “锋面” (Waterfront) ，对应着管道中的所有图像在同一时间里只会有一个图像处于可操作的状态，这个状态代表着 <strong>图像的变化趋势</strong> 。具体到代码中的实现可能会是一组带有同步关键字的方法加上一个唯一的当前状态的指针。开发者通过引导和操刀这个趋势，把图像引向最终要呈现出来的样子。在图示中，我们有意使用了绿色代表原始的、最初的，使用红色代表成熟的、完全体的。 Pipeline 专注于做一件事，就是把图像从一种状态转化为另外一种状态。这期间可能要经历很多个节点，而 Waterfront 的意义就在于它保证了 Pipeline 的操刀者可以明确地知道这一刻只有他自己在引导图像的流向而没有别人会干扰到这件事。</p>
</li>
<li><p>流动可以是双向的（相比生产车间的 “流水线”，释义替换为 “管道” 更自然的原因是后者可以实现双向流动，对应着图像可以实现反向编辑或者说撤销到一个处理步骤之前的状态）</p>
</li>
<li><p>流体如果分流则可以出现多个 “锋面”，对应着图像的并行处理。</p>
</li>
</ol>
<p><img src="/images/waterfront_and_flow.jpg" alt="锋面和流动"></p>
<hr>
<h1 id="管道的具体实现"><a href="#管道的具体实现" class="headerlink" title="管道的具体实现"></a>管道的具体实现</h1><p>如前文所述，“流体” 即图像，做简单的封装即可。我们主要需要实现的是 “__节点__” 和 “__锋面__”， “__流动__” 和 “__连通__”。</p>
<h2 id="节点的实现方案和意义"><a href="#节点的实现方案和意义" class="headerlink" title="节点的实现方案和意义"></a>节点的实现方案和意义</h2><p>我们先来看一种典型的图像处理过程中可能会采用的代码写法:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 图像 xyz 的描述 </span></span><br><span class="line">Image xyz; </span><br><span class="line"><span class="comment">// 图像 ijk 的描述 </span></span><br><span class="line">Image ijk;</span><br><span class="line"><span class="comment">// 图像 abc 的描述 </span></span><br><span class="line">Image abc; </span><br><span class="line"> 其他图像及其描述...</span><br><span class="line"><span class="comment">// 图像的 getters：</span></span><br><span class="line">getXYZ ();</span><br><span class="line">getIJK ();</span><br><span class="line">getABC ();</span><br><span class="line"> 其他图像的 getter...</span><br></pre></td></tr></tbody></table></figure>
<p>不难发现，如上的代码无法复用，因为每一个图像的引用被赋予了非常具体的含义，同样的写法不会完全适用于另外一个图像处理场景，因为另外那个图像处理场景可能不会用到描述为 ijk 的图像，可能会用到描述是 uvw 的图像。因此采取这种写法会遇到的一个典型问题是：每新增一个图像处理场景，我们是不是需要新增若干个特定描述的图像声明？在代码层面，这无疑会造成冗余。</p>
<p>这里的图像引用，其实就是我们所说的图像管道里的某个 “节点”。要对 “节点” 实现代码复用要怎么做呢？通过分析上面的写法中代码不能复用的根源是图像引用的用途被具体定义（同时也是被具体约束），我想到，那么为什么不能把图像引用匿名化，让它的含义在具体场景到来时才被赋予呢？</p>
<p>说到这里，有的读者会想到一种数据结构 —— <code>Map</code> 。是的，没有什么奇淫巧技，只是用了映射，就能解决这个代码复用问题中的最大障碍 —— 既然无法预知我们可能需要处理什么样的图像，可能需要处理多少份图像，并且这些未知数总是易变的，那么为什么不让具体场景的使用者来 <strong>动态添加</strong> 这些图像引用，并且为它们具名呢？图像部分被复用的代码，这里只声明了一样东西，就是从图像状态表述到图像引用的映射表。它解决了一个之前的写法不具备的达成复用的前提：<strong><em>图像存取的方式是统一的，有限的，因此是可固化的。</em></strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">Map&lt;String, Image&gt; stateTagToImageMap = <span class="keyword">new</span> HashMap&lt;&gt;;</span><br></pre></td></tr></tbody></table></figure>
<p>我们用一个字符串标签来表示图像的状态。对于图像管道的使用者来说，他只需要理解每个标签的含义，通过标签来存取图像并进行处理。在这些标签中，我们再提炼出几个具有通用含义的代表，比如。 Original 代表 “<strong>最初的__” ， Processed 代表 “__加工完成的__” ，这正是前文提到的 __占位符</strong> 。容易理解，你可以声明并且预置许多 <strong>占位符</strong> 在一份可复用的代码库中，可你不会声明同样数量的图像引用到这个代码库 —— 这样很奇怪。哪怕从程序实现的角度来说，没有分配实际空间的引用并不一定会占据更多内存。在后文中列举代码范例时我们将会经常地用到 Original 和 Processed 这样的标签。</p>
<p>不妨阅读以下这段代码，这是一种使用标签来操作其对应图像的写法。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 显示两个处理步骤之后的图像 </span></span><br><span class="line">pipeline.from (tag_Original) <span class="comment">// 从原始的图像开始 </span></span><br><span class="line">        .copy_to (tag_Processed) <span class="comment">// 拷贝出一份图像，用于处理，命名标签 processed</span></span><br><span class="line">        .doProcess (tag_Processed, specificProcess_1)  <span class="comment">// 执行特定操作 1</span></span><br><span class="line">        .doProcess (tag_Processed, specificProcess_2); <span class="comment">// 执行特定操作 2</span></span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed)); <span class="comment">// 取得 processed 标签代表的图像并且展示 </span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="锋面的实现方案和意义"><a href="#锋面的实现方案和意义" class="headerlink" title="锋面的实现方案和意义"></a>锋面的实现方案和意义</h2><p>解决了节点的设计，我们再来看基于节点之上提炼出的 “锋面” 要怎么设计。容易理解， <strong>锋面</strong> 是最前面的那个节点，具有唯一性，对应具体的图像处理代码中就是 “当前正在被处理的那个图像”。当我们在设计图像管道对外提供的处理接口时约束处理动作一定只能发生在这个 “__当前的__” 图像上时，能够保证我们的 “图像流” 总是按照我们想要的方向流动，并且在这个过程中，“图像流” 是不会被篡改的。这是我们的图像编辑功能要实现撤销和重演功能的基本前提。</p>
<p>还是上面那段显示两个处理步骤之后的图像的代码，去掉处理接口的标签参数，因为我们约束了处理总是只能发生在 <strong>唯一的</strong> 、 <strong>当前的</strong> 图像上。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 显示一个处理步骤之后的图像 */</span></span><br><span class="line">pipeline.from (tag_Original)</span><br><span class="line">        .copy_to (tag_Processed)</span><br><span class="line">        .doProcess (specificProcess)</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed));</span><br></pre></td></tr></tbody></table></figure>
<p>如果要求能够回撤到第一个处理步骤之后的状态，再做第二个处理步骤，并且第二个处理步骤的参数是可以改变的。可以这么做：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/* 显示一个处理步骤之后的图像，但我们在过程中保留了第一个步骤的状态 */</span></span><br><span class="line">pipeline.from (tag_Original)</span><br><span class="line">        .copy_to (tag_specificProcess_1) <span class="comment">// 相比一步到位，这里多存储了第一个步骤的状态 </span></span><br><span class="line">        .doProcess (specificProcess_1)</span><br><span class="line">        .copy_to (tag_Processed)</span><br><span class="line">        .doProcess (specificProcess_2.setParams (params_t1))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed));</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调整第二个步骤的某些参数，重新显示图像 */</span></span><br><span class="line">pipeline.from (tag_specificProcess_1) <span class="comment">// 之前存储了第一个步骤的状态，直接从这个步骤开始 </span></span><br><span class="line">        .copy_to (tag_Processed)</span><br><span class="line">        .doProcess (specificProcess_2.setParams (params_t2))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (tag_Processed));</span><br></pre></td></tr></tbody></table></figure>
<h2 id="流动和连通性的实现方案"><a href="#流动和连通性的实现方案" class="headerlink" title="流动和连通性的实现方案"></a>流动和连通性的实现方案</h2><p>有了节点和锋面，流动和连通就有了作用的主体。对应到图像编辑功能， <strong>流动</strong> 其实就是图像从一个状态变成另外一个状态的过程。 <strong>连通</strong> 则更好理解，一个管道出来的图像可以被另外一个管道接纳，由此构成管道之间的连接。连接在一起的每一节 <strong>小管道</strong> 各司其职，灵活组合，再构成更长跨度的 <strong>大管道</strong> 或者 “__管道网络__” ，从而协同完成复杂的业务流程。</p>
<p><img src="images/construct-big-pipeline.jpg" alt="一条直线型连接小管道构成的大管道"><br><img src="images/diffluence_join_pipeline.jpg" alt="一个采用了分流策略的三个小管道构成的管道网络"></p>
<p>回归到代码，我们来看一组步骤稍多的图片处理工序如何体现出管道的流动性和连通性。刨去内部实现细节，整合或者忽略一些与管道设计思想关联不大的逻辑，以下代码在流程上已经比较接近实际生产环境了。</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">/** 主功能区，不妨将它的例程称为 Main</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 可以从这里进入各子功能处理图片再回到这里展示新的图片 </span></span><br><span class="line"><span class="comment"> * 3. 撤销到经过某个步骤处理之前的图像或者重做出之前做过但是被撤销掉的某个步骤的图像   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_Main.startFrom (image_file) -&gt; {</span><br><span class="line">    Routine_Main.pipeline.loadFrom (image_file, tag_Original) <span class="comment">// 从图片中加载初始的图像 </span></span><br><span class="line">}</span><br><span class="line">Routine_Main.showCurrent () -&gt; {</span><br><span class="line">    showImage (Routine_Main.pipeline.front (); <span class="comment">// 显示 “锋面”</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美型” 的功能区，对应的例程称为 FaceLift</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸轮廓，五官进行形状调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_FaceLift.startFrom (Routine_Main.pipeline.front ().copy ());</span><br><span class="line">Routine_FaceLift.process () {</span><br><span class="line">    Routine_FaceLift.pipeline</span><br><span class="line">         <span class="comment">// 这个过程用户无法干预，不会有 “重演”，因此我们可以直接在原稿上操作 </span></span><br><span class="line">        .from (tag_Original)</span><br><span class="line">        .doProcess (faceLift_step_1_process)</span><br><span class="line">        .doProcess (faceLift_step_2_process)</span><br><span class="line">        .doProcess (faceLift_step_3_process)</span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美型” 处理好的图像提交给主功能 </span></span><br><span class="line">Routine_Main.accept (Routine_FaceLift.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “滤镜” 的功能区，对应的例程称为 Filter</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 滤镜化处理图像 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_Filter.startFrom (Routine_Main.pipeline.front ().copy ());</span><br><span class="line">Routine_Filter.process () {</span><br><span class="line">    Routine_Filter.pipeline</span><br><span class="line">        <span class="comment">// 这个过程中用户决定要选用哪个具体的滤镜，因此每次都需要基于原稿复制一份再滤镜化 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"awful"</span>)))</span><br><span class="line">        ... <span class="comment">/// 皱眉，这个不好，换一个！</span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"notbad"</span>)))</span><br><span class="line">        ... <span class="comment">/// 托腮，这个还行，再换个试试～</span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"perfect"</span>)))</span><br><span class="line">        ... <span class="comment">/// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “滤镜” 处理好的图像提交给主功能 </span></span><br><span class="line">Routine_Main.accept (Routine_Filter.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美颜” 的功能区，对应的例程称为 SkinBeauty</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸皮肤进行色相调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像给 Main 功能 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Routine_SkinBeauty.startFrom (Routine_Main.pipeline.front ().copy ());</span><br><span class="line">Routine_SkinBeauty.process () {</span><br><span class="line">    Routine_SkinBeauty.pipeline</span><br><span class="line">        <span class="comment">// 这个过程用户可以调节一个滑竿来控制色相参数，每次都基于原稿复制一份再调色相 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_weak))</span><br><span class="line">        ... <span class="comment">/// 托腮，效果好像不明显，加强一点 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_much)))</span><br><span class="line">        ... <span class="comment">/// 皱眉，好像有点过头了，往回调一点 </span></span><br><span class="line">        .from (tag_Original).copy_to (tag_Processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_just_right)</span><br><span class="line">        ... <span class="comment">/// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美颜” 处理好的图像提交给主功能 </span></span><br><span class="line">Routine_Main.accept (Routine_SkinBeauty.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纠结一下。。</span></span><br><span class="line"><span class="comment">/// 犹豫，要不还是不美颜了吧？</span></span><br><span class="line">Routine_Main.undo ();</span><br><span class="line"><span class="comment">/// 迟疑，滤镜也不要了？</span></span><br><span class="line">Routine_Main.undo ();</span><br><span class="line"><span class="comment">/// 思考中。。。</span></span><br><span class="line"><span class="comment">//... 不行，还是都加回来吧 </span></span><br><span class="line">Routine_Main.redo ().redo ();</span><br><span class="line"><span class="comment">// 端详 5 分钟。。。完美～～～</span></span><br><span class="line">save ();</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于管道的设计思路和实现方案介绍到此，读者可以回顾一下本文一开始所提到旧有设计的第二个问题：“<strong>图像管理</strong> 和 <strong>图像效果处理</strong> 被包在一起”。那么这个问题在管道方案中是不是已经解决了呢？</p>
<p>归纳一下。</p>
<blockquote>
<p>管道的基础是图像被 <strong>无差别的管理</strong> ，被管理的每一个图像由最初将其投入管道的创建者为其定义标签。最初的创建者和后来的协同者只需要对这个标签的含义达成共识，便可以进行协作。管道的思想是模拟 <strong>流体</strong> 的运行方式来实现图像处理过程，通过 <strong>节点</strong> 的设定来分解处理步骤，通过 <strong>锋面</strong> 的操控来聚焦每个单步的操作，通过 <strong>双向的连通性</strong> 来将分治的逻辑重新串联起来完成复杂的功能。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>关于花费时间的四宗罪</title>
    <url>/thinking/the-four-sins-of-spending-time/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<blockquote>
<p>导致我们浪费时间的是我们的__认知错误__。</p>
</blockquote>
<p>你是否经历过这样的场景。邻居过来串门，喋喋不休，我们频频点头回应，哪怕当下已经心急如焚；同事开始闲聊琐碎，而我们沉浸其中，不曾意识到本该用来工作的时间正在一点一点溜走；从熟人那里收到微信，对方说：“我可以向你讨教点事情吗？”，我们爽快答应，因为抹不开面子拒绝别人？</p>
<p>斯多葛哲学家塞内卡（Seneca）曾经惊叹：哪怕最聪明的人，在保护自己的时间这件事上，都不免显得愚蠢。</p>
<blockquote>
<p>没有人会把自己的钱财送给路人，但我们中的许多人却送出了我们的生命！我们为财产和金钱所累，却罕有意识我们的时间正遭受的浪费。时间本应是我们每个人都最应吝惜的东西。</p>
</blockquote>
<p>两千多年后的今天，为什么我们还在允许时间这种宝贵的资源从我们的手中不停地溜走？</p>
<a id="more"></a>

<hr>
<h1 id="我们总以为我们有充足的时间"><a href="#我们总以为我们有充足的时间" class="headerlink" title="我们总以为我们有充足的时间"></a>我们总以为我们有充足的时间</h1><p>据说，人类现在的平均寿命已经到了 78 岁。听到这个数字你会有什么感觉？别着急作答，我们每个人用行动对这个数字做出的真实回应可能是：我好像拥有了无限的时间。是的，一辈子有这么长呢。于是乎，每天都在这里或者那里匀出二十分钟不算个事；去另一个城市开个会，去程三个小时，回程三个小时，然后再花一个小时休息安顿，然后一天就过去了，不是吗？</p>
<p>我们没有意识到是，死亡其实一直笼罩着我们所有人。要知道，寿命是一个平均值，保险公司允许你为自己买寿险，但没有任何人能为你的实际寿命做担保。更重要的是，时间其实和金钱一样，是复合的产物。当你浪费时间的时候，你浪费的不仅是眼前的这几分钟，还包括你把它们节省下来然后合理分配之后所带来的一切可能性。对，“可能性 “，这是另外一个话题，但我不需要展开讨论，你也不会没有感触。</p>
<hr>
<h1 id="我们为了做-“好人”-轻易让出时间"><a href="#我们为了做-“好人”-轻易让出时间" class="headerlink" title="我们为了做 “好人” 轻易让出时间"></a>我们为了做 “好人” 轻易让出时间</h1><p>在社交场合，似乎没有人喜欢对方说 “不”，而不愿意当 “坏人” 的我们，在内心想要拒绝的时候，选择了说 “好的”。时间浪费，只是这种委屈求全的行为所造成的一类后果，还有其他的负面影响，使得很多人其实能够意识到问题存在，并且在这种事情上自我纠结和挣扎。但是，想要摆脱这个困境，就像生孩子一样，别人是指望不上的，你只能靠自己。</p>
<p>如果我们懂得，对一件事说 “是”，通常意味着你要对另一件事说 “不”。我们就会意识到，当我们同意承担一些并不那么必要的义务时，有另外一些无辜的人也许要遭受痛苦。他们可能是我们的家人、朋友或者我们一直想要拿出时间来陪伴的人。</p>
<p>所以，当我忽略某个我不想交谈的人的电子邮件，拒绝多花一分种接听我不需要的电话销售，乃至对所有那些不符合我的意志的事情坚决说不的时候，我的心理障碍比以前小多了。</p>
<p>听起来有点卑鄙是不是？重要的是，你要想清楚什么对你来说是重要的。换一个角度，你花时间耐心接完一个电话销售在另一头给你介绍完产品，然后再拒绝并挂断。看似礼貌得体，其实你在浪费了自己时间的同时，也浪费了对方的时间。</p>
<p>在我们交付时间给别人时，可以经常提醒自己这么一个事实：每个人对于时间使用的粒度是不一样的。</p>
<hr>
<h1 id="我们对自己不够重视"><a href="#我们对自己不够重视" class="headerlink" title="我们对自己不够重视"></a>我们对自己不够重视</h1><p>我们缺少说 “不” 的信心，并且害怕伤害别人的感情。可能的原因是，我们觉得自己不配被放在我们的关注列表的前面。已逝的 Joan Rivers ，美国有史以来最有成就，最受尊敬和最有才华的喜剧演员，在七十多岁高龄时，被问到为什么她要继续工作？为什么她总是在路上？为什么她总是在寻找更多的演出？她拿着一本空日历，说出了她的恐惧：“如果我的书看起来是像这样的，那就意味着没有人想要我，我曾经尝试做的一切都没有用。没有人在乎，就等于我已经完全被遗忘了。”</p>
<p>不知道你听到这样的话是何反应。</p>
<p>我们每个人都不免有在人群中受欢迎的诉求。无论是作为销售，演讲者还是作家，我们之所以为我们的时间收费，原因之一是我们知道自己值这个价，但也要提醒自己，费用并不等于价值。关键是你要坚定信念，并且始终如一。</p>
<hr>
<h1 id="我们尚未发展出划清界限所需的力量"><a href="#我们尚未发展出划清界限所需的力量" class="headerlink" title="我们尚未发展出划清界限所需的力量"></a>我们尚未发展出划清界限所需的力量</h1><p>我花了很多时间思考自己想要什么样的生活。花在打电话或开会上的每一分钟，都本可以是我可以用在写作而实际没有用在写作上的时间。它们也是我没有花在陪伴家人这件事上的时间。我经常和我的助理说，保护我的日程表 —— 确保一天之内不要超过三件事。当我拿出日程表，看见它几乎是空白的时候，与 Joan Rivers 不同，我感觉很棒。  </p>
<p>我知道我想在哪里度过我的时光 —— 我不希望它们未经我的同意而被花掉。我知道这是值得的。</p>
<p>但是，帮助别人是另外一回事，你可以在坚持说不的原则下仍然帮助到别人。虽然无法回复收到的每一条信息，但我还是尝试回答人们有疑问的主题并撰写文章以解决这些问题。当我对请求说不的时候，我也会尽量想：“不行。但我愿意做_______来代替。”<br>以这种方式慷慨地帮助人们，同时保持对自己时间的掌控。</p>
<p>聪明的慈善家会放弃自己的超额利润，但不会放弃让他们继续赚钱的原则。将其应用到时间管理中使我获益良多。我清楚自己不是反社会型人格，我只是严肃认真地对待自己。</p>
<p>内心平静是你取得你想要的人生以及所有使美好生活成为可能的关键。所以我避免打电话，我拒绝会议要求，我不喝杯咖啡，我拒绝播客邀请，并且忽略了收到的大多数电子邮件。那些都不是我想要度过自己宝贵生命的方式，因此我不会为它们而感到内疚，但我会尽量不把这些事情强加给别人。因为并不是我的时间就比其他任何人的时间都更有价值。</p>
<p>尊重时间，从现在开始做起。</p>
<p>编译自 <a href="https://forge.medium.com/why-dont-we-know-how-to-protect-our-time-a88859deea2e">https://forge.medium.com/why-dont-we-know-how-to-protect-our-time-a88859deea2e</a> ，有删节和演绎，文章不代表译者观点。欢迎交流。</p>
]]></content>
      <categories>
        <category>thinking</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机科学教师协会 - K12 - 标准</title>
    <url>/uncategorized/csta-k12-standards/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<p>About the CSTA K-12 Computer Science Standards<br>关于 CSTA K-12 计算机科学标准</p>
<p>Computer science and the technologies it enables rest at the heart of our economy and the way we live our lives. To be well-educate citizens in a computing-intensive world and to be prepared for careers in the 21st century, our students must have a clear understanding of the principles and practices of computer science. The CSTA K–12 Computer Science Standards delineate a core set of learning objectives designed to provide the foundation for a complete computer science curriculum and its implementation at the K–12 level. To this end, the CSTA Standards:</p>
<p>计算机科学及其支持的技术是我们经济的核心，也是我们生活的方式。为了对计算机密集型世界中的公民进行良好的教育并为 21 世纪的职业做好准备，我们的学生必须对计算机科学的原理和实践有清晰的了解。 CSTA K-12 计算机科学标准描述了一组核心学习目标，旨在为完整的计算机科学课程及其在 K-12 级别的实施提供基础。为此，CSTA 标准：</p>
<p>・Introduce the fundamental concepts of computer science to all students, beginning at the elementary school level.<br>・Present computer science at the secondary school level in a way that can fulfill a computer science, math, or science graduation credit.<br>・Encourage schools to offer additional secondary-level computer science courses that will allow interested students to study facets of computer science in more depth and prepare them for entry into the work force or college.<br>・Increase the availability of rigorous computer science for all students, especially those who are members of underrepresented groups.<br>The standards have been written by educators to be coherent and comprehensible to teachers, administrators, and policy makers.<br>Levels 1A, 1B, 2, and 3A are the computer science standards for ALL students. The Level 3B standards are intended for students who wish to pursue the study of computer science in high school beyond what is required for all students (specialty or elective courses).</p>
]]></content>
  </entry>
  <entry>
    <title>聊一聊 UI 代码要怎么写 | 分治篇</title>
    <url>/programming/ui-programming-howto/</url>
    <content><![CDATA[<ul>
<li>本文的主要价值： 提供一份软件开发中分治 UI 逻辑的实践样本</li>
<li>关键词： 分治、 UOP</li>
</ul>
<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><blockquote>
<p><em>我们知道，分治策略是人们解决问题的一种基本策略。问题规模越大，内部包含的差异化的细节越多，越需要执行分治策略。</em></p>
</blockquote>
<p>所谓化整为零，化繁为简，逐个击破讲的都是分治。在计算机领域，我们要列举分治的例子，大的可以聊到七层网络模型（本质上分层也是一种分治），小的可以讲起二分算法。</p>
<p>本文基于 Android 客户端开发中经常涉及的交互逻辑编程展开，表达我对于 UI 分治在软件开发中如何实践的理解。</p>
<a id="more"></a>

<h1 id="从-MVC-说起"><a href="#从-MVC-说起" class="headerlink" title="从 MVC 说起"></a>从 MVC 说起</h1><p>经典的 <strong><a href="https://zh.wikipedia.org/wiki/MVC">MVC</a></strong> 设计模式想必各位程序猿们无人不晓。 MVC 最早存在于桌面程序中，后来由于其强大的复用性被广泛地发掘和应用于各端的开发中，还衍生出 MVP ， MVVM 等变体。如果把 MVC 的变体都算作 MVC ，可以说现如今任何一个成熟的 GUI 框架都内化了这种设计模式。放图：</p>
<p><img src="/images/MVC-vs-MVP-vs-MVVM.jpg"></p>
<p>然而我今天不是要来谈 MVC 设计模式的，因为网络上以各种姿势深入浅出 MVC 的好文章已经多的不能再多。之所以提及 MVC 模式只是想借此提醒读者， <strong>解耦</strong> 对于编程的重要性。</p>
<p>MVC 之所以看起来很简单却又如此广泛地被使用就在于它有效地解决了一个已知的，规模庞大的 <strong>耦合</strong> 问题：“你看到的”（不妨理解为 MVC 中的 View ) 和 “它代表的” (不妨理解为 MVC 中的 Model )，这两个东西永远不可能完全一致。</p>
<p>我们有时候需要用相同的表象去表示不同的真相，有时候则需要用不同的表象去表达同一个真相。而当我们尝试把两者捆绑在一起处理时，一旦映射关系发生变化，这个捆绑体便不再适用，需要重新构建。这样一来，原来的东西就都不能用了。所以我们需要一套机制来避免这种耦合，从而实现 Model 和 View 各自的复用。</p>
<blockquote>
<p><em>想要简单的理解这个问题，思考一下我们如何造字，为什么只需要造出常用的几千个汉字就能够表达一个人在生活中遇到的绝大部分事物？又为什么同一个字词在不同的场景下可以表达不同的含义？</em></p>
</blockquote>
<p>MVC 正是通过解耦 Model 和 View ，使得大量的 UI 可以被标准化，进而被重复利用。而这个问题之所以规模巨大，是因为只要一个计算机程序是给人类用的，就一定会涉及到人机交互，也就是我们常说的 UI 。</p>
<p>在解决了耦合问题并实现复用时， MVC 引入了 <strong>Controller</strong> ，我们的 UI 怎么写将围绕 Controller 展开。</p>
<hr>
<h1 id="UI-写在何处"><a href="#UI-写在何处" class="headerlink" title="UI 写在何处"></a>UI 写在何处</h1><p>在现今我们用到的主流应用框架中，你很难找到针对 GUI 编程部分只提供手写原生代码来实现界面的个例 — 它们无一例外地会引入基于某一种或者某几种标记语言的界面编程机制。其中最常见的是 xml 及其变体。</p>
<p>使用标记语言设计 UI 的最大好处在于它们可以被方便地转换为可视化的编辑界面，这样的话可以允许程序员以所见即所得的方式直观地进行界面设计，即 <strong>可视化编程</strong> 。提到可视化编程，桌面端的开发框架中大家最耳熟能详的想必包括微软的 .NET 。之所以特别提及 .NET ，是因为我认为微软在可视化编程技术和可视化集成开发环境方面的贡献至今仍是值得称道的。作为编程的初学者，我当年曾一度被 VisualStudio 的强大惊艳到。</p>
<p>在 GUI 编程方面摸爬滚打过几年，我先后使用过 MFC ， Windows Forms ， Qt 等框架开发桌面端的用户界面，目前从事的是 Android 客户端开发。从这些使用过的开发框架的用户界面部分的组件，我发现一个共同点： UI 都是一定程度上独立的。</p>
<p>首先，在设计阶段，通过使用单独的资源文件夹或者 .xml ， .qml ， .ui ，又或者是 C# 分部类，界面部分的生成逻辑是被隔离开的。然后，在使用阶段，界面部分的元素通过约定的方式查找或者引用，并且建立响应逻辑。这样的运行方式，使得 UI 和其他程序逻辑被天然地划分开，能够让程序员把 UI 的代码编写从整体的编程活动中独立出来，从而便于维护和协作。</p>
<h2 id="UI-编程的两个阶段"><a href="#UI-编程的两个阶段" class="headerlink" title="UI 编程的两个阶段"></a>UI 编程的两个阶段</h2><p>不妨把 UI 设计和 UI 使用的这两个阶段称为 <strong>UI 编程的两个阶段</strong> 。我在后文会介绍到 <strong>UOP</strong> 和从 UI 快速切入别人的代码结构进行修改的策略，都是基于 UI 实现所具备的这种独立性。从这里开始，相关话题我会以 Android 平台的客户端界面设计为例展开。</p>
<p>Android 的 UI 可以通过 xml 设计，运行时由系统加载和创建出界面，也可以通过代码直接创建。相对来说，前者的使用方式比较普遍，以下描述会基于采用前者方式的前提。在 UI 编程的第二个阶段， Android 通过 findViewById 的方式将 UI 元素从被隔离的区域 (xml) 中找出来，准确的说，是通过预先定义好的 id 将第二阶段所关心的 UI 元素从被隔离的区域 (xml) 中找出来，为它在控制器逻辑中建立一个引用，然后围绕这些 UI 元素编写交互逻辑。</p>
<p>到目前为止，我所说的是大家都已经知道的事实，而这一节要聊的关于 UI 写在何处 —— 跟我们已知的这些事实有什么关联呢？一些有过 Android 开发经验的同学想一想 <em>RoboGuice</em> 、 <em>ButterKnife</em> 以及官方的 <em>Android Data Binding</em> 为何会存在？也许会对这个问题有自己的答案。</p>
<h2 id="负担过重的-Controller"><a href="#负担过重的-Controller" class="headerlink" title="负担过重的 Controller"></a>负担过重的 Controller</h2><p>在我看来，在编程框架内置的 MVC 模型中，单一的 Controller 一直负荷了过重的工作，因为通常的情况是许多的 Model 和 View 都仅仅通过某个唯一的 Controller 建立关联，与此同时我们忽略了一个重要的事实：单一的 Controller 通常不仅要服务于 UI ，往往还需要承载多个不同角度不同层级的业务逻辑。</p>
<p>面对这个问题，我们能做些什么呢？有的读者可能已经想到了 MVVM 模式。首先，要肯定一下 MVVM 是一个可以考虑的选项。在我看来， ViewModel 本质上就是将 Controller 中与特定 UI 密切相关的逻辑集中在一起。不过呢，我会倾向于认为 MVVM 是 MVC 的一个变体， ViewModel 是我们在实现 Controller 时所采取的一种策略：这种策略叫做分治。那么为什么 MVVM 只是可以考虑的选项而不是根本的解决方案呢？我的解释是：因为 <strong>分治</strong> 这件事，太依赖于具体情况了。没有一种框架可以告诉我们应当如何拆分一整个复杂的控制器逻辑，如你所见，它们顶多帮你把 UI 隔离到另外的空间，让你的代码不至于一上来就看着一团乱麻。而我们在编程的时候，还可能会不断地把 UI 找出来，重新加入我们的控制器，并为它们书写冗长的交互代码。有的时候这些交互的复杂程度是已经具备一定约束规则的 ViewModel 所无法预见和适应的。</p>
<p>其实，无论 MVC 还是 MVVM，其实都是可行的方案，但是我们不能太拘泥于形式，不能规定 View 和 Model 必须以这样或者那样的方式建立关联。在具体的场景中，需要视逻辑的复杂度对控制器中的 UI 部分进行拆分。控制器中可以拆分的逻辑当然并不局限于 UI 部分，不过它与本文无关这里不特别说明。所有分治的 UI 控制器中的 UI 虽然是由原来的那个控制器统一创建的，但是在使用时却可以由各分治控制器自行把握。</p>
<p>这里提供一个参考思路：在实际的开发实践中，我做过的控制器拆分通常是以可复用的组件作为目标，根据模块分工，代码规模等情况综合考虑的。</p>
<hr>
<h1 id="UOP——-分治-UI-控制逻辑的利器"><a href="#UOP——-分治-UI-控制逻辑的利器" class="headerlink" title="UOP—— 分治 UI 控制逻辑的利器"></a>UOP—— 分治 UI 控制逻辑的利器</h1><p>接着第 2 节文末提出的思路，笔者在本文的最后一节要来重点分享一下在实践 UI 控制逻辑分治这件事时的一种十分有效的编程方式： __UOP__。</p>
<p>面向 UI 编程。你无法在 wikipedia 上找到这个词条。因为它是杜撰的。实际上，我将要说的 “面向 UI 编程” 应该是面向切面编程（<a href="https://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-oriented programming</a>）的一种，只不过切面聚焦在 User Interface 上。</p>
<p>在展开 <strong>UOP</strong> 之前，让我们先回到 Controller 这个概念，在我们熟知的框架内化的 MVC 模式中，原先的那个 Controller 角色必定是已经提供 UI 的访问途径了，比如 Android 框架的控制器 Activity ，它提供了 findViewById 。而分治出去的 Controller （同时也是我们自己创建的 Controller ）要如何取得 UI 呢？一些同学可能会想到，使用 setter。是的，我们完全可以这么实现。不过这里要提供另外一种思路 —— <strong>“UI 包装器”</strong> ，我给它取了一个代码名，叫 <code>UIWrapper</code> 。我们将通过这个 <strong>“UI 包装器”</strong> 来说明 UOP 是什么，以及我们为什么使用 UOP 。</p>
<p>一个 Android 上的 UI 包装器可以是如下的实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIWrapper</span> </span>{</span><br><span class="line">        <span class="comment">/** 布局资源 id 到根视图的索引 */</span></span><br><span class="line">        <span class="keyword">protected</span> SparseArray&lt;View&gt; mLayoutIdToRootViewIndex = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">        <span class="comment">/** 视图 ID 到子视图的索引 */</span></span><br><span class="line">        <span class="keyword">protected</span> SparseArray&lt;View&gt; mIdToSubViewIndex = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UIWrapper</span><span class="params">()</span> </span>{}</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置 UI 元素 </span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> otherWrapper 给定的 UI 元素包装器 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">setUi</span><span class="params">(UIWrapper otherWrapper)</span> </span>{</span><br><span class="line">            mLayoutIdToRootViewIndex = otherWrapper.mLayoutIdToRootViewIndex.clone ();</span><br><span class="line">            mIdToSubViewIndex = otherWrapper.mIdToSubViewIndex.clone ();</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 包装 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 指定的视图资源 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> view 指定的视图资源 ID 对应的视图 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">wrapUi</span><span class="params">(<span class="keyword">int</span> viewId, View view)</span> </span>{</span><br><span class="line">            <span class="keyword">return</span> wrapUi (viewId, view, <span class="keyword">false</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 包装 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 指定的视图资源 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> view 指定的视图资源 ID 对应的视图 </span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> treatAsViewGroup 以 ViewGroup 方式处理包装的 View</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UIWrapper <span class="title">wrapUi</span><span class="params">(<span class="keyword">int</span> viewId, View view, <span class="keyword">boolean</span> treatAsViewGroup)</span> </span>{</span><br><span class="line">            <span class="keyword">if</span> (viewId &gt;= <span class="number">0</span> &amp;&amp; view != <span class="keyword">null</span>) {</span><br><span class="line">                mIdToSubViewIndex.put (viewId, view);</span><br><span class="line">                <span class="keyword">if</span> (treatAsViewGroup) {</span><br><span class="line">                    mLayoutIdToRootViewIndex.put (viewId, view);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 根据 view id 查找 UI 元素 </span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> viewId 目标视图的 id</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> view</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> View <span class="title">findViewById</span><span class="params">(<span class="keyword">int</span> viewId)</span> </span>{</span><br><span class="line">            View view = mIdToSubViewIndex.get (viewId);</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (view == <span class="keyword">null</span>) {</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; mLayoutIdToRootViewIndex.size (); index++) {</span><br><span class="line">                    View layout = mLayoutIdToRootViewIndex.valueAt (index);</span><br><span class="line">                    <span class="keyword">if</span> (layout != <span class="keyword">null</span>) {</span><br><span class="line">                        view = layout.findViewById (viewId);</span><br><span class="line">                    }</span><br><span class="line">    </span><br><span class="line">                    <span class="keyword">if</span> (view != <span class="keyword">null</span>) {</span><br><span class="line">                        mIdToSubViewIndex.put (viewId, view);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">return</span> view;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">UIWrapper 这个类很简单，它的功能概括成一句话就是动态扩容地持有一组 View 的匿名引用，并且具备通过 viewId 来检索 View 的能力。（以动态扩容地持有匿名引用的方式来实现代码复用，是一个简单却极其有效的实用技巧，在我的另外一篇文章 __用 “管道” 设计拆分复杂处理流程__ 中也有提到，感兴趣的读者可以移步一阅。）</span><br><span class="line"></span><br><span class="line">UIWrapper 在具体场景中是以继承或者依赖的方式被使用的，如果我们的分治 UI 控制器本身没有基类，可以直接继承自 UIWrapper ；如果已经有了继承结构，可以引入 UIWrapper 作为成员，进而间接引入目标 UI ，比如 Fragment 就适用这种情况。题外话，说到 Fragment，读者会不会意识到它其实就是框架本身提供的一种分治策略的具体实现呢？</span><br><span class="line"></span><br><span class="line"> 对于以继承方式使用 UI 包装器的方式，我们不妨设计下面这样一个基类 AbsUIController ，也就是前文我们说的要分治的 UI 控制器。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 分治的 UI 控制器基类 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbsUIController</span> <span class="keyword">extends</span> <span class="title">UIWrapper</span> </span>{</span><br><span class="line">        <span class="comment">// 生产环境中这个抽象层级中除了构造方法外还有一些实际的基础功能，</span></span><br><span class="line">        <span class="comment">// 但是与本文重点无关，此处略过 </span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbsUIController</span><span class="params">(<span class="meta">@NonNull</span> Activity activity)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            wrapUi (<span class="number">0</span>, activity.getWindow ().getDecorView (), <span class="keyword">true</span>);</span><br><span class="line">        }</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AbsUIController</span><span class="params">(<span class="meta">@NonNull</span> Activity activity, UIWrapper ui)</span> </span>{</span><br><span class="line">            <span class="keyword">super</span>();</span><br><span class="line">            setUi (ui);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>再基于基类的 UI 控制器，我举一个在生产环境中实现的 UI 控制器为例，它的功能是为所有由它管理的 UI 元素提供独占可见状态的显示和隐藏过程处理的可复用的工具类。通俗的说，就是处理几个 View 同一时间只显示其中一个的情况。以下是简化的代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MonoDisplayController</span> <span class="keyword">extends</span> <span class="title">AbsUIController</span> </span>{</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 独占展示空间显示给定视图 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view 要显示的视图 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monoDisplay</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>{ ... }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 隐藏由当前包装器管理的全部视图 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> delayBeforeStart 开始隐藏前的延时 </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 整个隐藏过程完成的总耗时，以毫秒计 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">hideAll</span><span class="params">(<span class="keyword">long</span> delayBeforeStart)</span> </span>{ ... }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>读者是否可以想到这样的一个简单的 UI 控制器可以用在哪里呢？不妨先看一下 MonoDisplayController 这个类的用例的代码片段:</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 将可见性互斥的 UI 元素包在同一个 MonoDisplayController 里，包含可下载图标，下载进度等 </span></span><br><span class="line"><span class="comment">// 注意，生产环境中的 UI 元素数量可能很多，都要求互斥显示，这时复用代码更能体现优势 </span></span><br><span class="line">viewHolder.monoDisplaysOnDownloadStatus = <span class="keyword">new</span> MonoDisplayController (getActivity ());</span><br><span class="line">viewHolder.monoDisplaysOnDownloadStatus</span><br><span class="line">        .wrapUi (R.id.iv_download_available, viewHolder.ivDownloadAvailable)</span><br><span class="line">        .wrapUi (R.id.download_progress_view, viewHolder.downloadProgressView)</span><br><span class="line">        .wrapUi (...)</span><br><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="comment">// 根据下载状态互斥展示不同的 UI 元素 </span></span><br><span class="line"><span class="keyword">switch</span> (entity.getDownloadStatus ()) {</span><br><span class="line"><span class="comment">// 正在下载 </span></span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_DOWNLOADING:</span><br><span class="line">    viewHolder.monoDisplaysOnDownloadStatus.monoDisplay (viewHolder.progressView);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"><span class="comment">// 下载暂停，删除，未下载 </span></span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_PAUSE:</span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_DELETED:</span><br><span class="line"><span class="keyword">case</span> DOWNLOAD_STATUS_UN_DOWNLOAD:</span><br><span class="line">    viewHolder.monoDisplaysOnDownloadStatus.monoDisplay (viewHolder.downloadAvailableView);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>限于篇幅没有奉上无关的代码。我相信如果读者有过用许多 if , else 分支来协调多个 View 的可见性这种编码经验的话，应该会认同这样一个控制器是能够有效减少代码量和避免错误的。</p>
<p>讲到这里， UOP 的实例已经在代码中完整给出。读者请重点留意一下 <code>UIWrapper#wrapUi (int viewId, View view)</code> 这个方法，它体现了 UOP 最核心的思维方式： UI 是第一度的逻辑出发点。<strong>首先搞清楚我们要跟哪些 UI 打交道，然后才是要在这些 UI 上做些什么事情。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">.wrapUi (R.id.iv_download_available, viewHolder.ivDownloadAvailable)</span><br><span class="line">.wrapUi (R.id.download_progress_view, viewHolder.downloadProgressView)</span><br></pre></td></tr></tbody></table></figure>
<p>解释完 UOP 是什么，最后再来解释一下为什么 UOP 是分治 UI 的利器。前面说过 UOP 其实是 AOP 中的一种，而我认为 AOP 其实是贯彻第一性原理的一种思维方式：聚焦任务在同一维度的事物构成的某一条线索上。UI 是程序代码中被最直观呈现的东西，以软件用户的角色观察，UI 可能就是他可以感知的全部，这是一条最自然的线索。而对于程序员来说，这个认知其实也是完全适用的。</p>
<p>如果上面的描述不好理解，我再举一个维护代码的例子，程序员朋友可能就会有共鸣了。</p>
<blockquote>
<p><em>假定有程序员甲开发了一款软件，他很熟悉这款软件的代码。还有程序员乙从未接触过这款软件的代码。有一，乙在甲不能提供帮助的情况下，（比方说甲请假了）接受了一个任务：他要在短时间内调整一处 UI 。对于乙来说，最快的做法是先去阅读代码吗？恐怕不是。然而，现实场景中，在对代码一无所知的情况下，要我们基于别人的代码增改功能，这并不少见。倘若时间有限，无法阅读太多的代码，那么抓住目标的特点，从代码中找到线索，利用线索切入，则是快速搞定任务的靠谱思路。这其实只是专注于任务本身的结果，而并非什么独特的解题技巧。对于 UI 来说，不论是框架内化的设计模式，还是它本身最直观的外在呈现，往往都天然地提供了一条独立于常规代码之外的 线索。</em></p>
</blockquote>
<p>使用 UOP ，本质上是在分治 UI 控制逻辑的同时，仍然保持对关注点的聚焦。虽然 UI 被分出来了，但事还是那些事，并没有因为设立了一个分管的去处，就多出了额外的东西。同时，又因为分管，被分出来的这些事，作为一个可单独运行的逻辑，自身变得更加纯粹了，更容易被复用。当然，它带来的最重要的好处是：维护这件事变得更容易了。</p>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>UI</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之十 | 可选型</title>
    <url>/programming/swiftswift-optionals/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="处理缺失的数据"><a href="#处理缺失的数据" class="headerlink" title="处理缺失的数据"></a>处理缺失的数据</h1><p>我们已经会使用 <code>Int</code> 这样的类型来存储像 5 这样的数值。不过，当你想要存储用户年龄这样的属性，并且你还不知道该用户的年龄时你该怎么做呢？</p>
<p>你可能会说，“我可以暂时存成 0”，但这样一来你就会混淆新生儿和你不知道年龄的用户。你应该用一个特殊的数字，比如 1000 或者 -1 来代表 “未知”，这两个数字都不可能是年龄，但你能记得住这些特殊数字的含义吗？</p>
<p>Swift 的解决方案称为 <em>optional</em> ，即可选型。你可以基于任意类型创建可选型。一个可选型整数可以有诸如 1 或者 1000 这样的数字，也可能没有任何值，即值可以缺失， Swift 里表示缺失是用 <code>nil</code> 。</p>
<p>为了把一个类型变成可选型，只需要在类型后面加一个问号。举个例子，我们可以这样把一个整数变成可选型：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age: <span class="type">Int?</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<p>这个可选型现在并不保有任何整数，但是如果之后我们知道了年龄值，我们可以给它重新赋值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">age = <span class="number">38</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="解包可选型"><a href="#解包可选型" class="headerlink" title="解包可选型"></a>解包可选型</h1><p>可选型字符串可能包含一个 “Hello” 或者 <code>nil</code> 。</p>
<p>考虑这样一个可选字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name: <span class="type">String?</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure>
<p>当我们调用 <code>name.count</code> 时会发生什么呢？一个真的字符串有 <code>count</code> 属性，它存储字符串的字符数量。但它是 <code>nil</code> 时，并没有 <code>count</code> 属性。</p>
<p>因此，试图直接使用 <code>name.count</code> 是不安全的， Swift 也不允许。取而代之的是，我们必须先检查可选型里面有些什么，这个过程被称为 <em>解包</em> 。</p>
<p>解包可选型的一种常见做法是采用 <code>if let</code> 语法，它是一种有条件的解包。如果可选型里有值，你就可以使用它，如果没有则条件失败。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> unwrapped = name {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(unwrapped.count) letters"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Missing name."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果 <code>name</code> 持有一个字符串，这个字符串会被放进一个叫 <code>unwrapped</code> 的常规字符串，然后我们就可以读取它的 <code>count</code><br>属性。另一种情况，如果 <code>name</code> 是 nil， 那么 <code>else</code> 中的代码将被执行。</p>
<hr>
<h1 id="用-guard-解包可选型"><a href="#用-guard-解包可选型" class="headerlink" title="用 guard 解包可选型"></a>用 guard 解包可选型</h1><p><code>if let</code> 的一个替代方案是 <code>guard let</code> ，后者也可以用来解包可选型。 <code>guard let</code> 会为你解包，但是当它发现可选型里是 <code>nil</code> 时会期望你退出它所处的函数，循环或者条件。</p>
<p>因此， <code>if let</code> 和 <code>guard let</code> 的主要区别在于 <code>guard let</code> 之后可选型还可以继续使用。</p>
<p>让我们尝试一下 <code>greet ()</code> 函数。它将接收一个可选字符串作为唯一的参数，当它解包发现这个参数是 <code>nil</code> 时会打印消息并且退出函数。因为可选型 <code>unwrapped</code> 在 <code>guard let</code> 的语句块结束之后作用，我们可以在函数最后打印这个解包后的字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="keyword">_</span> name: String?)</span></span> {</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> unwrapped = name <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"You didn't provide a name!"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  }</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(unwrapped)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过使用 <code>guard let</code> ，你可以在函数的前面解决可选型的解包问题，在这之后的代码就可以愉快地使用解包后的值而不必担心出错了。</p>
<hr>
<h1 id="强制解包"><a href="#强制解包" class="headerlink" title="强制解包"></a>强制解包</h1><p>可选型代表可能存在也可能不存在的数据，而某些时候你是 <em>确切</em> 知道一个可选型的值并不是 <code>nil</code> 。在这种情况下， Swift 允许你强制解包这个可选型：通过把一个可选型转换为非可选型的方式。</p>
<p>举个例子，下面你试图将一个字符串转换成 <code>Int</code> ，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"5"</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码中 <code>num</code> 其实是一个可选型 <code>Int</code> 。因为你有可能尝试转换一个不是数字的字符串导致转换失败。</p>
<p>尽管 Swift 不确定转换能否成功，你自己是知道你的结果是否可以安全地执行强制解包。这个强制解包是通过在 <code>Int (str)</code> 之后添加 <code>!</code> 来完成的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)!</span><br></pre></td></tr></tbody></table></figure>
<p>通过强制解包， Swift 将立刻解包 <code>num</code> ，把它变成一个常规的 <code>Int</code> 而不是 <code>Int?</code> 。但是假如你是错的，比方说 <code>str</code> 是某个不能转换成数字的字符串，那么你的代码将崩溃。</p>
<p>强制解包的操作符常常被戏称为崩溃操作符。因此，只有当你确信强制解包是安全的你才能这么做。</p>
<hr>
<h1 id="隐式解包可选型"><a href="#隐式解包可选型" class="headerlink" title="隐式解包可选型"></a>隐式解包可选型</h1><p>像常规可选型一样，隐式解包可选型可能包含一个值也可能包含 <code>nil</code> 。不过，跟常规可选型不一样的是，隐式解包可选型时不需要再解包，你可以把它们当做非可选型一样使用。</p>
<p>隐式解包可选型是通过类型名之后添加感叹号来声明的，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age: <span class="type">Int!</span> = <span class="literal">nil</span></span><br></pre></td></tr></tbody></table></figure>
<p>由于它们表现起来就像已经被解包过的样子，你并不需要 <code>if let</code> 或者 <code>guard let</code> 这样的代码来测试它们。不过，当你试图使用它们而它们实际上没有值时，即它们的值是 <code>nil</code> 时，你的代码将崩溃。</p>
<p>隐式解包可选型存在的意义在于，有些情况某个变量一开始时是 <code>nil</code> ，但当你需要用到它之前它总会有值。如果你可以确信这一点，那么采用隐式解包可选型可以省去一直写 <code>if let</code> 的麻烦。</p>
<p>值得一提的是，如果条件允许采用常规可选型，安全起见最好总是采用常规可选型。</p>
<hr>
<h1 id="空合运算符"><a href="#空合运算符" class="headerlink" title="空合运算符"></a>空合运算符</h1><p>空合运算符解包一个可选型，如果可选型包含值则返回这个值，如果可选型不包含值，即可选型的值是 <code>nil</code> ，那么返回某个默认值。两种情况，返回值都不再是可选型：它要么是可选型里包含的有效值，要么是一个备选的默认值。</p>
<p>下面是一个接收整数作为唯一参数并且返回可选型字符串的函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">username</span><span class="params">(<span class="keyword">for</span> id: Int)</span></span> -&gt; <span class="type">String?</span> {</span><br><span class="line">  <span class="keyword">if</span> id == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Taylor Swift"</span></span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果我们以 ID 15 来调用这个函数，我们将得到 <code>nil</code> 。通过空合运算符，我们可以提供一个叫 “Anonymous” 的默认值，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> user = username (<span class="keyword">for</span>: <span class="number">15</span>) ?? <span class="string">"Anonymous"</span></span><br></pre></td></tr></tbody></table></figure>
<p>它将检查 <code>username ()</code> 函数返回的值：如果是一个字符串，它将被解包并放入 <code>user</code> ，如果是 <code>nil</code> ，则使用 “Anonymous” 替代。</p>
<hr>
<h1 id="可选链"><a href="#可选链" class="headerlink" title="可选链"></a>可选链</h1><p>在使用可选型时， Swift 为我们提供了一种快捷方式：假如你试图访问形如 <code>a.b.c</code> 这样的代码并且 <code>b</code> 是可选型，你可以在 <code>b</code> 后面写一个问号来启用 <em>可选链</em> ： <code>a.b?.c</code> 。</p>
<p>当代码运行时， Swift 会检查 <code>b</code> 是否有值，如果它是 <code>nil</code> ，那么这行代码剩下的部分将被忽略。Swift 会立即返回 <code>nil</code> 。但是如果 <code>b</code> 有值，它将被解包，代码执行将继续。</p>
<p>下面是一个名字的数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> names = [<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>我们将使用数组的 <code>first</code> 属性，如果数组里第一个名字有值的话返回这个名字，如果数组为空则返回 <code>nil</code> 。在结果之上，我们调用 <code>uppercased ()</code> 把它变成一个全大写的字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> beatle = names.first?.uppercased ()</span><br></pre></td></tr></tbody></table></figure>
<p>上面的问号就是可选链。如果 <code>first</code> 返回 <code>nil</code> ，那么 Swift 就不会尝试将它转换成全大写，它会将 <code>beatle</code> 立即设置为 <code>nil</code> 。</p>
<hr>
<h1 id="可选型-try"><a href="#可选型-try" class="headerlink" title="可选型 try"></a>可选型 try</h1><p>让我们回忆一下可能抛出错误的函数那一节的知识，看下面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PasswordError</span>: <span class="title">Error</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> obvious</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword</span><span class="params">(<span class="keyword">_</span> password: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> {</span><br><span class="line">  <span class="keyword">if</span> password == <span class="string">"password"</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">PasswordError</span>.obvious</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  <span class="keyword">try</span> checkPassword (<span class="string">"password"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"That password is good!"</span>)</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"You can't use that password."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过 <code>do</code> ， <code>try</code> 和 <code>catch</code> ，我们得以运行可能抛出错误的函数，并且优雅地处理错误。</p>
<p>上面的 <code>try</code> 写法其实有另外两种选择，这两种选项都能加深你对可选型和强制解包的理解。</p>
<p>第一个是 <code>try?</code> ，它将可能抛出错误的函数转换成返回可选型的函数。如果函数抛出错误，那你就会得到 <code>nil</code> 作为函数的执行结果，否则你会得到将返回值包装之后的可选型。</p>
<p>尝试使用 <code>try?</code> 来执行 <code>checkPassword ()</code> ，像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> result = <span class="keyword">try</span>? checkPassword (<span class="string">"password"</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Result was \(result)"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"D'oh."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>另外一种选择是 <code>try!</code> ，当你确信函数一定不会失败时你可以采用它。如果函数实际抛出了错误，你的代码将崩溃。</p>
<p>使用 <code>try!</code> 来重写前面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>! checkPassword (<span class="string">"sekrit"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"OK!"</span>)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="失败构造器"><a href="#失败构造器" class="headerlink" title="失败构造器"></a>失败构造器</h1><p>当我们说到强制解包的时候，我用了下面的代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"5"</span></span><br><span class="line"><span class="keyword">let</span> num = <span class="type">Int</span>(str)</span><br></pre></td></tr></tbody></table></figure>
<p>它将一个字符串转换成一个整数，但由于你可以传入任意字符串，你得到的实际上是一个可选型整数。</p>
<p>这里用到一种叫做 <em>失败构造器</em> 的东西：它是一种可能成功也可能失败的构造器。你在结构体或者类里面用 <code>init?()</code> 来实现失败构造器。如果某些东西出错，它将返回 <code>nil</code> 。因此这种构造器返回的是某种类型的可选型，你用之前需要解包。</p>
<p>举个例子，我们现在要求 <code>Person</code> 结构体必须通过一个 9 字符的 ID 字符串来构造。只要不是 9 个字符，都会返回 <code>nil</code> 。</p>
<p>Swift 代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>?(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">if</span> id.<span class="built_in">count</span> == <span class="number">9</span> {</span><br><span class="line">      <span class="keyword">self</span>.id = id</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><p>Swift 知道每个变量的类型，但有的时候你知道的信息比 Swift 更多。举个例子，这里有三个类：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>{ }</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fish</span>: <span class="title">Animal</span> </span>{ }</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>: <span class="title">Animal</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Woof!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们创建几个 <code>Fish</code> 和几个 <code>Dog</code> ，然后把它们放进一个数组，像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = [<span class="type">Fish</span>(), <span class="type">Dog</span>(), <span class="type">Fish</span>(), <span class="type">Dog</span>()]</span><br></pre></td></tr></tbody></table></figure>
<p>Swift 知道 <code>Fish</code> 和 <code>Dog</code> 都继承自 <code>Animal</code> 类，因此它通过类型推断将 <code>pets</code> 创建为一个 <code>Animal</code> 类型的数组。</p>
<p>如果我们想遍历 <code>pets</code> 数组，让所有的狗发出叫声，我们需要执行一次类型转换： Swift 将检查每个 pet 是否 <code>Dog</code> 对象，以便我们调用 <code>makeNoise ()</code> 方法。</p>
<p>这里用到了一个关键字 <code>as?</code> ，它将返回一个可选型：类型转换失败时返回 <code>nil</code> ，成功则返回转换后的类型。</p>
<p>Swift 代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> pet <span class="keyword">in</span> pets {</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">let</span> dog = pet <span class="keyword">as</span>? <span class="type">Dog</span> {</span><br><span class="line">    dog.makeNoise ()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>可选型让我们可以用一种清晰无歧义的方式表示值缺失的情况。 </li>
<li>Swift 不允许不经解包就使用可选型，解包可以用 <code>if let</code> 或者 <code>guard let</code> 。 </li>
<li>你可以用感叹号强制解包可选型，不过如果解出来的是 <code>nil</code> ，你的代码将会崩溃。 </li>
<li>隐式解包可选型没有做常规可选型的安全性检查。 </li>
<li>你可以使用空合运算符解包一个可选型，以便可选型里没有值时提供一个默认值。 </li>
<li>可选链用于操作可选型，如果可选型的值是空的，后续代码将被忽略。 </li>
<li>你可以使用 <code>try?</code> 将一个可能抛出错误的函数转换成一个可选型的返回值，或者使用 <code>try!</code> 在抛出错误时崩溃。 </li>
<li>如果你需要在输入不合理时让构造过程失败，可以使用 <code>init?()</code> 来创建失败构造器。 </li>
<li>你可以使用类型转换将一个类型转换为另一个类型。 </li>
</ol>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之九 | 协议</title>
    <url>/programming/swiftswift-protocol/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><p>协议是一种描述某个类型必须有某些属性和方法的方式。你告知 Swift 某个类型将使用某个协议，这个过程称为协议适配或者协议遵循。</p>
<p>举个例子，我们可以写一个函数接收 <code>id</code> 属性，但我们并不精确地关心用的是哪一种数据类型。让我们从 <code>Identifiable</code> 协议开始，这个协议要求所有遵循协议的类型必须有一个 <code>id</code> 字符串属性，并且这个字符串可读写。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> { <span class="keyword">get</span> <span class="keyword">set</span> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们无法创建协议的实例，因为协议只是一种描述，它本身并非一种类型。但是我们可以创建遵循它的结构体。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后，我们还可以写一个 <code>displayID ()</code> 函数，它接收 <code>Identifiable</code> 对象：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">displayID</span><span class="params">(thing: Identifiable)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"My ID is \(thing.id)"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<hr>
<h1 id="协议继承"><a href="#协议继承" class="headerlink" title="协议继承"></a>协议继承</h1><p>一个协议可以继承另一个协议，这个过程称为协议继承。跟类不一样的是，你可以同一时间继承多个协议。</p>
<p>接下来我们将定义三个协议： <code>Payable</code> 要求遵循它的类型实现 <code>calculateWages ()</code> 方法， <code>NeedsTraining</code> 要求遵循它的类型实现 <code>study ()</code> 方法，而 <code>HasVacation</code> 要求遵循它的类型实现 <code>takeVacation ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Payable</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">calculateWages</span><span class="params">()</span></span> -&gt; <span class="type">Int</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">NeedsTraining</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">study</span><span class="params">()</span></span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">HasVacation</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">takeVacation</span><span class="params">(days: Int)</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们可以创建一个 <code>Employee</code> 协议，将上面的三个协议合并在一起。我们还不打算添加额外的东西，因此简单地写一对花括号就行：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Employee</span>: <span class="title">Payable</span>, <span class="title">NeedsTraining</span>, <span class="title">HasVacation</span> </span>{ }</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们就可以创建遵循这个单一协议的类型，而不是分别遵循三个协议的类型。</p>
<hr>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><p>扩展使得你可以为已经存在的类型添加方法，实现它们设计时没有做的事情。</p>
<p>举个例子，我们可以为 <code>Int</code> 类型添加一个扩展方法 <code>squared ()</code> ，用来返回当前数的平方。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">squared</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> * <span class="keyword">self</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>尝试一下。创建一个整数，你会发现现在这个整数有了 <code>squared ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">8</span></span><br><span class="line">number.squared ()</span><br></pre></td></tr></tbody></table></figure>
<p>Swift 不允许你通过扩展添加存储属性，但可以用扩展添加计算属性。举个例子，我们给整数添加一个 <code>isEven</code> 的计算属性，这个属性返回当前数值是否为偶数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> isEven: <span class="type">Bool</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span> % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="协议扩展"><a href="#协议扩展" class="headerlink" title="协议扩展"></a>协议扩展</h1><p>协议可以描述某个类型应当有某种方法，但并没有提供方法的代码。扩展实现有具体代码的方法，但一次只能作用于一个数据类型，你没办法同时给多个类型添加相同的代码。</p>
<p>协议扩展同时解决了这两个问题：它们就像常规扩展一样，差异只在于你并不是只扩展一个特定的类型，比如 <code>Int</code> ，你扩展是的一个协议，因而所有遵循这个协议的类型都会发生改变。</p>
<p>举个例子，下面有一个包含了一些名字的数组和一个同样包含了一些名字的集合：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pythons = [<span class="string">"Eric"</span>, <span class="string">"Graham"</span>, <span class="string">"John"</span>, <span class="string">"Michael"</span>, <span class="string">"Terry"</span>, <span class="string">"Terry"</span>]</span><br><span class="line"><span class="keyword">let</span> beatles = <span class="type">Set</span>([<span class="string">"John"</span>, <span class="string">"Paul"</span>, <span class="string">"George"</span>, <span class="string">"Ringo"</span>])</span><br></pre></td></tr></tbody></table></figure>
<p>Swift 的数组和集合都遵循一个叫 <code>Collection</code> 的协议，因此我们可以给 <code>Collection</code> 协议扩展一个叫 <code>summarize ()</code> 的方法，这个方法逐一打印 <code>Collection</code> 里的元素。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Collection</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">summarize</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"There are \(count) of us:"</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> <span class="keyword">self</span> {</span><br><span class="line">      <span class="built_in">print</span>(name)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>Array</code> 和 <code>Set</code> 都将获得这个方法。让我们来尝试一下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">pythons.summarize ()</span><br><span class="line">beatles.summarize ()</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="面向协议编程"><a href="#面向协议编程" class="headerlink" title="面向协议编程"></a>面向协议编程</h1><p>协议扩展可以为我们自己的协议方法提供默认实现。这使得类型遵循协议变得更加容易，并且允许我们 “面向协议编程”—— 这是一种利用协议和协议扩展来加工代码的方式。</p>
<p>首先，我们这里有一个叫 <code>Identifiable</code> 的协议，它要求所有遵循协议的类型都有一个叫 <code>id</code> 的属性和叫一个叫 <code>identify ()</code> 的方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span> { <span class="keyword">get</span> <span class="keyword">set</span> }</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>虽然我们可以让每个遵循这个协议的类型书写它们自己的 <code>identify ()</code> 方法，但协议扩展允许我们可以提供一个默认实现：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"My ID is \(id)."</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在当我们再声明一个遵循 <code>Identifiable</code> 协议的类型时，它会自动获得 <code>identify ()</code> 方法的实现：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> paul = <span class="type">User</span>(id: <span class="string">"Paul"</span>)</span><br><span class="line">paul.identify ()</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>协议描述了一个遵循它的类型应该拥有的属性和方法，但并不提供那些方法的实现。 </li>
<li>你可以基于协议创建协议，这一点跟类相似。 </li>
<li>扩展允许你为类型添加方法和计算属性。 </li>
<li>协议扩展是为协议添加方法和计算属性。 </li>
<li>面向协议编程是这样一种实践：它把程序架构按照一系列协议来设计，然后利用协议扩展来提供默认实现。 </li>
</ol>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之八 | 类</title>
    <url>/programming/swiftswift-classes/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="创建你自己的类"><a href="#创建你自己的类" class="headerlink" title="创建你自己的类"></a>创建你自己的类</h1><p>Swift 的类也能让你创建带有属性和方法的新类型，这一点和结构体很相似，但是它们之间有五个显著的区别。下面让我一一为你说明。</p>
<p>类和结构体的第一个区别是类没有逐一成员构造器。这意味着只要你的类里有属性，你就必须自行创建构造器。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>创建类的实例跟创建结构体的实例方式一样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> poppy = <span class="type">Dog</span>(name: <span class="string">"Poppy"</span>, breed: <span class="string">"Poodle"</span>)</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<hr>
<h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><p>类和结构体的第二个区别是类可以继承已经存在的类。新的类继承了原始类所有的属性和方法。</p>
<p>这个过程被称为 <em>类继承</em> 或者 <em>子类化</em> ， 被继承的类称为 “父类” 或者 “超类”， 而新的类称为 “子类” 。</p>
<p>下面是一个 <code>Dog</code> 类：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在让我们基于 <code>Dog</code> 来创建一个新的类 <code>Poodle</code> 。默认情况下，它会继承 <code>Dog</code> 的所有属性以及构造器。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不过，我们也可以为 <code>Poodle</code> 创建自己的构造器。我们知道这个类的 <code>breed</code> 属性总是 “Poodle”，因此我们可以创建一个只有 <code>name</code> 属性的构造器。并且，我们可以在 <code>Poodle</code> 的构造器里直接调用 <code>Dog</code> 的构造器，以便发生和 <code>Dog</code> 相同的构造过程。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, breed: <span class="string">"Poodle"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>出于安全性考虑， Swift 会要求你总是在子类里调用 <code>super.init ()</code> ，以防止类在构造时来自父类的一些重要工作被遗漏。</p>
<hr>
<h1 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h1><p>子类可以将父类的方法替换为自己的实现，这个过程被称为 <em>重写</em> 。 让我们给 <code>Dog</code> 类添加一个 <code>makeNoise ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Woof!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果你创建一个 <code>Poodle</code> 类继承自 <code>Dog</code> ，它会继承 <code>makeNoise ()</code> 方法。 “Woof!”:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">}</span><br><span class="line"><span class="keyword">let</span> poppy = <span class="type">Poodle</span>()</span><br><span class="line">poppy.makeNoise ()</span><br></pre></td></tr></tbody></table></figure>
<p>方法重写使得我们可以为 <code>Poodle</code> 类重新实现 <code>makeNoise ()</code> 。</p>
<p>Swift 要求我们在重写方法时用 <code>override func</code> 而不是 <code>func</code> ，这个限定防止你在自己不知情的情况下偶然重写方法。另外，试图重写一个父类中并不存在的方法，你会遭遇错误。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poodle</span>: <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">makeNoise</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Yip!"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过这个修改， <code>poppy.makeNoise ()</code> 将打印出 “Yip!”，而不是 “Woof!”。</p>
<hr>
<h1 id="Final-类"><a href="#Final-类" class="headerlink" title="Final 类"></a>Final 类</h1><p>尽管类继承十分有用，并且苹果的平台在许多地方要求你大量使用它，有的时候你会希望阻止其他开发者基于你的类构建新的类。</p>
<p>Swift 给了我们 <code>final</code> 关键字用于实现这种意图：当你把一个类声明为 <code>final</code> 时，将没有类能够继承它。这意味着没有人能通过重写方法来改变这个类的行为。</p>
<p>只需要把 <code>final</code> 关键字放在类前面，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> breed: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, breed: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.breed = breed</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="复制对象"><a href="#复制对象" class="headerlink" title="复制对象"></a>复制对象</h1><p>类和结构体的第三个区别是它们被复制的方式。当你复制一个结构体时，原始对象和复制体是不一样的两个东西，改变其中一个并不会改变另外一个。当你复制一个 <em>类</em> 时，原始对象和复制体都指向相同的东西，所以改变其中一个也会改变另一个。</p>
<p>举个例子，有一个简单的 <code>Singer</code> 类，它有一个带有默认值的 <code>name</code> 属性：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当我们创建一个这个类的实例并且打印它的 <code>name</code> 时，我们会得到 “Taylor Swift” ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singer = <span class="type">Singer</span>()</span><br><span class="line"><span class="built_in">print</span>(singer.name)</span><br></pre></td></tr></tbody></table></figure>
<p>当我们基于第一个实例创建第二实例并且改变第二个实例的 <code>name</code> 时：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> singerCopy = singer</span><br><span class="line">singerCopy.name = <span class="string">"Justin Bieber"</span></span><br></pre></td></tr></tbody></table></figure>
<p>由于类的工作机制， <code>singer</code> 和 <code>singerCopy</code> 指向内存里的同一个对象。所以当我们打印 <code>singer</code> 的 <code>name</code> 时，我们也会得 “Justin Bieber”：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(singer.name)</span><br></pre></td></tr></tbody></table></figure>
<p>另一方面，假如 <code>Singer</code> 是一个结构体，那第二次我们还将得到 “Taylor Swift” ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="析构器"><a href="#析构器" class="headerlink" title="析构器"></a>析构器</h1><p>类和结构体的第四个区别是类有 <em>析构器</em> ，它是一个类的实例被销毁时执行的代码。</p>
<p>这里有一个 <code>Person</code> 类，它有一个 <code>name</code> 属性，一个简单的构造器，以及一个打印信息的 <code>printGreeting ()</code> 方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"John Doe"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name) is alive!"</span>)</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">printGreeting</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Hello, I'm \(name)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们将利用循环创建几个 <code>Person</code> 类的实例，每次循环流转的时候，一个新的 <code>Person</code> 都会被创建，之后被销毁：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">3</span> {</span><br><span class="line">  <span class="keyword">let</span> person = <span class="type">Person</span>()</span><br><span class="line">  person.printGreeting ()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>来到我们的析构器。每当 <code>Person</code> 实例被销毁时，它的析构器都会被执行。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">deinit</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(name) is no more!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h1><p>类和结构体的最后一个区别是它们处理常量的方式。如果你有一个常量结构体，它有一个变量属性，那么这个变量属性是无法修改的。</p>
<p>但是，如果它是一个常量类，也有一个变量属性，那么这个变量属性是可以被修改的。基于这个区别，类的方法在改变属性时，并不需要 <code>mutating</code> 关键字，而结构体则需要。</p>
<p>这个区别意味着你可以修改类中的任何变量属性，即便类的实例本身被声明为常量。以下代码完全合法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> taylor = <span class="type">Singer</span>()</span><br><span class="line">taylor.name = <span class="string">"Ed Sheeran"</span></span><br><span class="line"><span class="built_in">print</span>(taylor.name)</span><br></pre></td></tr></tbody></table></figure>
<p>如果你不想属性被修改，那么你必须直接将属性声明为常量。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singer</span> </span>{</span><br><span class="line">  <span class="keyword">let</span> name = <span class="string">"Taylor Swift"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>类和结构体很相似，它们都允许你创建自己的属性和方法。 </li>
<li>一个类可以继承自另一个类，它会获得父类的所有属性和方法。谈到类层次结构的时候，我们经常说一个类基于另一个类，也就是一个类继承自另一个类。 </li>
<li>你可以用 <code>final</code> 关键字来标记一个类，这样可以阻止它被继承。 </li>
<li>方法重写使得一个子类可以用全新的实现来替代父类中的实现。 </li>
<li>当两个变量指向同一个实例时，它们指代的对象在内存中占用同一块区域，改变其中一个也会改变另一个。 </li>
<li>类可以有析构器，它们是类的实例被销毁时执行的代码。 </li>
<li>类不像结构体那样受常量的强制约束。如果类的一个属性被声明为变量，那么无论类的实例是否以变量的方式创建，这个属性都可以被修改。 </li>
</ol>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之七 | 结构体</title>
    <url>/programming/swiftswift-structs/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="创建你自己的结构体"><a href="#创建你自己的结构体" class="headerlink" title="创建你自己的结构体"></a>创建你自己的结构体</h1><p>Swift 允许你用两种方式创建自己的类型。其中一种最常见的叫做结构体，即 <code>struct</code> 。Struct 可以拥有自己的变量、常量以及函数，而你可以在任意时候创建和使用它们。</p>
<p>让我们以一个简单的例子开始：创建一个 <code>Sport</code> 结构体，它有一个叫 <code>name</code> 的字符串变量。在结构体中，这种变量被称为 <em>属性</em> 。因此，这是一个拥有一个属性的结构体。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>类型定义完成，现在让我们来创建和使用它的实例：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tennis = <span class="type">Sport</span>(name: <span class="string">"Tennis"</span>)</span><br><span class="line"><span class="built_in">print</span>(tennis.name)</span><br></pre></td></tr></tbody></table></figure>
<p><code>name</code> 和 <code>tennis</code> 都是变量，因而我们可以像常规变量那样修改它们：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">tennis.name = <span class="string">"Lawn tennis"</span></span><br></pre></td></tr></tbody></table></figure>
<p>属性可以像常规变量那样拥有默认值，并且依赖 Swift 的类型推断。</p>
<a id="more"></a>

<hr>
<h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><p>我们刚刚创建了 <code>Sport</code> 结构体：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>它有一个叫 <em>name</em> 的属性，存储 <code>String</code> 类型。这种属性叫做 <em>存储</em> 属性，因为 Swift 还有另外一种属性，它叫 <em>计算</em> 属性。这是一种通过运行代码来获得值的属性。</p>
<p>让我们为 <code>Sport</code> 结构体再增加一个存储属性，然后是一个计算属性。代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sport</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> isOlympicSport: <span class="type">Bool</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> olympicStatus: <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">if</span> isOlympicSport {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"\(name) 是一项奥林匹克运动。"</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"\(name) 不是一项奥林匹克运动。"</span></span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如你所见， <code>olympicStatus</code> 看起来像一个常规的 <code>String</code> ，但它其实是依据其他的属性返回不同的值。</p>
<p>让我们来创建一个 <code>Sport</code> 实例：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> chessBoxing = <span class="type">Sport</span>(name: <span class="string">"Chessboxing"</span>, isOlympicSport: <span class="literal">false</span>)</span><br><span class="line"><span class="built_in">print</span>(chessBoxing.olympicStatus)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="属性观察者"><a href="#属性观察者" class="headerlink" title="属性观察者"></a>属性观察者</h1><p>属性观察者允许我们可以在属性变化前后运行代码。让我们来写一个名叫 <code>Progress</code> 的结构体，这个结构体追踪一个任务以及它完成的百分比：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Progress</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> task: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> amount: <span class="type">Int</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在，创建这个结构体的实例，随着时间的推移调整它的进度：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> progress = <span class="type">Progress</span>(task: <span class="string">" 加载数据 &amp; quot;</span>, amount: <span class="number">0</span>)</span><br><span class="line">progress.amount = <span class="number">30</span></span><br><span class="line">progress.amount = <span class="number">80</span></span><br><span class="line">progress.amount = <span class="number">100</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们期望 Swift 在每一次 <code>amount</code> 改变的时候都打印信息，这里可以用到一个叫 <code>didSet</code> 属性观察者。它可以用于每一次 <code>amount</code> 改变之后运行代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Progress</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> task: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> amount: <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">didSet</span> {</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">"\(task) 已完成 \(amount)%。"</span>)</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你还可以用到叫 <code>willSet</code> 的属性观察者。它是在属性改变之前作用，相对来说更不常用。</p>
<hr>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>Struct 的内部可以拥有函数，它们在必要时可以使用结构体的属性。这种函数被称为 <em>方法</em> ，关键字也是 <code>func</code> 。</p>
<p>现在我们通过一个叫 <code>City</code> 的结构体来演示。它有一个 <code>population</code> 属性，用于存储城市里的人口。此外，它还有一个 <code>collectTaxes ()</code> 方法，这个方法返回人口数乘以 1000。 由于方法是属于 <code>City</code> 的，它可以读取当前城市的 <code>population</code> 属性。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">City</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> population: <span class="type">Int</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">collectTaxes</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">    <span class="keyword">return</span> population * <span class="number">1000</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>基于结构体调用方法的代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> xiamen = <span class="type">City</span>(population: <span class="number">4_110_000</span>)</span><br><span class="line">xiamen.collectTaxes ()</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="可变方法"><a href="#可变方法" class="headerlink" title="可变方法"></a>可变方法</h1><p>如果一个结构体拥有一个变量属性，但是这个结构体的实例是以常量的方式创建的，那么在实例中，这个变量属性是不能修改的。这是因为结构体本身已经是常量了，所以它的所有属性也是常量。</p>
<p>这里面有一个问题， Swift 无从得知你将以常量还是变量的方式使用结构体。所以安全起见， Swift 的默认策略是：不允许你在方法里修改属性，除非你显式地要求这一点。</p>
<p>当你想要改变属性值时，需要在方法前使用 <code>mutating</code> 关键字，就像这样：</p>
 <figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAnonymous</span><span class="params">()</span></span> {</span><br><span class="line">    name = <span class="string">"Anonymous"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于这个方法改变了属性值，所以 Swift 只会允许这个方法在变量型的 <code>Person</code> 实例上调用。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>(name: <span class="string">"Ed"</span>)</span><br><span class="line">person.makeAnonymous ()</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="String-的属性和方法"><a href="#String-的属性和方法" class="headerlink" title="String 的属性和方法"></a>String 的属性和方法</h1><p>目前为止我们已经大量地使用了字符串。你发现了吗？其实 <code>String</code> 类型是一个结构体类型。它有许多属性和方法，用于查询和维护字符串本身。</p>
<p>首先，我们创建一个测试字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> string = <span class="string">"Do or do not, there is no try."</span></span><br></pre></td></tr></tbody></table></figure>
<p>你可以用 <code>count</code> 属性来读取这个字符串里的字符数量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.<span class="built_in">count</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>字符串有一个 <code>hasPrefix ()</code> 方法，可以用来检测字符串是否以特定字符开头：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.hasPrefix (<span class="string">"Do"</span>))</span><br></pre></td></tr></tbody></table></figure>
<p>你还可以用 <code>uppercased ()</code> 方法把一个字符串转换成全大写的版本：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.uppercased ())</span><br></pre></td></tr></tbody></table></figure>
<p>你甚至可以让 Swift 将字符串中的字母重新排序成一个数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(string.sorted ())</span><br></pre></td></tr></tbody></table></figure>
<p>String 类型有大量的属性和方法。 你可以利用 Xcode 的代码补全，用 <code>string.</code> 调取这些选项看一看它们都有些什么能力。</p>
<hr>
<h1 id="数组的属性和方法"><a href="#数组的属性和方法" class="headerlink" title="数组的属性和方法"></a>数组的属性和方法</h1><p>数组同样也是结构体，这意味着它们也有可以用来查询和操作数组的属性和方法。</p>
<p>从一个简单的数组开始：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> toys = [<span class="string">"Woody"</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>你可以用 <code>count</code> 属性来读取数组的元素个数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(toys.<span class="built_in">count</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>如果你需要增加一个元素，可以使用 <code>append ()</code> 方法，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">toys.append (<span class="string">"Buzz"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>你可以用 <code>firstIndex ()</code> 方法来定位元素在数组里的位置，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">toys.firstIndex (of: <span class="string">"Buzz"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码会返回 1 ，因为数组位置从 0 开始计数。</p>
<p>跟字符串一样，你可以让 Swift 以字母表顺序给数组的元素重新排序。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(toys.sorted ())</span><br></pre></td></tr></tbody></table></figure>
<p>最后，如果你想要移除数组里的一个元素，可以使用 <code>remove ()</code> 方法，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">toys.remove (at: <span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>数组类型也有大量的属性和方法。 你可以利用 Xcode 的代码补全，用 <code>toys.</code> 调取这些选项看一看它们都有些什么能力。</p>
<hr>
<h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p>构造器是一种可以用来支持不同方式创建结构体的特殊方法。所有的结构体都有一个默认的构造器，这个构造器被称为 <em>逐一成员构造器</em> ，它要求你为结构体的每一个属性都提供一个值。</p>
<p>让我们来声明一个 <code>User</code> 结构体，它有一个属性：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当我们创建这个结构体的实例时，我们需要提供一个 <code>username</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="type">User</span>(username: <span class="string">"Paul"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>当然，我们也可以创建自己的构造器用以替换默认的。举个例子，我们可能希望所有的新用户默认都叫 “Anonymous” ，并且会打印一条信息，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> username: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    username = <span class="string">"Anonymous"</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 创建新用户！"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你并不需要在构造器前面写 <code>func</code> 关键字，但你必须确保构造器结束前所有的属性都被赋值。</p>
<p>现在让我们来用上这个没有参数的构造器，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="type">User</span>()</span><br><span class="line">user.username = <span class="string">"Paul"</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="引用当前实例"><a href="#引用当前实例" class="headerlink" title="引用当前实例"></a>引用当前实例</h1><p>方法的内部，有一个特殊的常量叫 <code>self</code> ，它指向当前正在使用的结构体实例。当你在构造器中遇到参数名和属性名相同的情况时，这个 <code>self</code> 会很有用。</p>
<p>举个例子，如果你声明一个 <code>Person</code> 的结构体，它有一个 <code>name</code> 属性，并且你尝试写一个接收名为 <code>name</code> 参数的构造器，那么 <code>self</code> 可以帮助你区分属性和参数。 <code>self.name</code> 指代属性，而 <code>name</code> 指代参数。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(name) was born!"</span>)</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="懒加载属性"><a href="#懒加载属性" class="headerlink" title="懒加载属性"></a>懒加载属性</h1><p>作为一种性能优化手段， Swift 允许你在用到的时候才真正创建属性。举个例子，这里有一个叫 <code>FamilyTree</code> 的结构体，它做的工作很容易描述。但理论上为一个人创建族谱可能会是一个很耗时的过程：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FamilyTree</span> </span>{</span><br><span class="line">  <span class="keyword">init</span>() {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 创建族谱！"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以在 <code>Person</code> 结构体内将 <code>FamilyTree</code> 作为一个属性来使用，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> familyTree = <span class="type">FamilyTree</span>()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ed = <span class="type">Person</span>(name: <span class="string">"Ed"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>假如某些情况我们并不需要用到某个人的族谱信息呢？我们可以在 <code>familyTree</code> 属性前添加 <code>lazy</code> 关键字， Swift 将会在 <code>familyTree</code> 属性第一次被访问的时候才执行创建代码：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> familyTree = <span class="type">FamilyTree</span>()</span><br></pre></td></tr></tbody></table></figure>
<p>因此，如果你想要看到 “创建族谱！” 这条信息被打印，你至少需要访问 <code>familyTree</code> 属性一次：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">ed.familyTree</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="静态属性和方法"><a href="#静态属性和方法" class="headerlink" title="静态属性和方法"></a>静态属性和方法</h1><p>目前为止我们认识的所有属性和方法都是属于独立的结构体实例，这意味着假如我们有一个叫 <code>Student</code> 的结构体，我们可以创建几个 student 实例，每个实例都有各自的属性和方法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ed = <span class="type">Student</span>(name: <span class="string">"Ed"</span>)</span><br><span class="line"><span class="keyword">let</span> taylor = <span class="type">Student</span>(name: <span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>你可以要求 Swift 在不同的结构体实例之间共享属性和方法，这些属性和方法被称为静态属性和静态方法，实现的方式是添加 <em>static</em> 声明。</p>
<p>现在，让我们给 <code>Student</code> 结构体添加一个静态属性，用以存放班级学生的总数。每当我们创建一个新的 student 实例时，我们将这个属性的数值加 1 ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> </span>{</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> classSize = <span class="number">0</span></span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="type">Student</span>.classSize += <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>classSize</code> 属性是属于结构体本身而非结构体的实例，因此我们需要用 <code>Student.classSize</code> 来访问它：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="type">Student</span>.classSize)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>访问控制使得我们可以限制哪些代码能够访问属性和方法。这个机制在你想要保护属性免于被直接读取的时候很有用，举个例子：</p>
<p>我们仍然创建一个 <code>Person</code> 结构体，它有一个 <code>id</code> 属性，用来存放社保 ID：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ed = <span class="type">Person</span>(id: <span class="string">"12345"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>一旦 person 实例被创建，我们希望它的 <code>id</code> 是私有的。私有的意思是你不能从结构体外部读取它，像 <code>ed.id</code> 这样的代码会变得不合法。</p>
<p>要做到这一点，你需要用到 <code>private</code> 关键字，像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这么写之后，只有 <code>Person</code> 内部的方法才能读取 <code>id</code> 属性。举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> </span>{</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">init</span>(id: <span class="type">String</span>) {</span><br><span class="line">    <span class="keyword">self</span>.id = id</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">identify</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="string">" 我的社保 ID 是 \(id)"</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>还有一个常见的选项是 <code>public</code> ，它使得所有的其他代码都能够访问到目标属性或者方法。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们一起来总结一下。</p>
<ol>
<li>你可以创建自己的结构体类型，它们有自己的属性和方法。 </li>
<li>你学习了存储属性，以及每一次通过临时计算得到值的计算属性。 </li>
<li>当你希望在方法中修改属性时，需要把方法标记成 <code>mutating</code> 。 </li>
<li>构造器是创建结构体时的特殊方法。默认情况下，你会得到一个逐一成员构造器。不过，如果你想要自行实现构造器的话，需要确保所有的属性都被赋值。 </li>
<li>你可以在方法中用 <code>self</code> 常量来引用当前正在使用的结构体实例。 </li>
<li><code>lazy</code> 关键字告诉 Swift 你希望属性在第一次访问时才被创建。 </li>
<li>可以利用 <code>static</code> 关键字在结构体的所有实例间共享属性和方法。 </li>
<li>访问控制使得我们可以限制哪些代码能够访问属性和方法。 </li>
</ol>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之六 | 闭包</title>
    <url>/programming/swiftswift-closures/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="创建基本的闭包"><a href="#创建基本的闭包" class="headerlink" title="创建基本的闭包"></a>创建基本的闭包</h1><p>Swift 允许我们像字符串和整数一样使用函数。具体来说，你可以创建一个函数然后把它赋给一个变量，利用那个变量来调用函数。你甚至可以把函数作为参数传给另一个函数。</p>
<p>函数的这种用法被称为 <em>闭包</em> 。虽然工作机制差不多，写法上是有一些小差异的。</p>
<p>还是以打印信息为例：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我要去开车 &amp; quot;</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码实际上创建了一个匿名的函数，并将这个函数赋给了 <code>driving</code> 。之后你就可以把 <code>driving ()</code> 当作一个常规的函数来用，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">driving ()</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<hr>
<h1 id="在闭包中接收参数"><a href="#在闭包中接收参数" class="headerlink" title="在闭包中接收参数"></a>在闭包中接收参数</h1><p>当你创建闭包的时候，它们并没有名字，也没有提供书写参数的地方。但这并不意味着它们不能接收参数，只不过它们接收参数的方式稍有不同：这些参数是被写在花括号里面的。</p>
<p>为了让一个闭包接收参数，你需要在花括号之后把这些参数列出来，然后跟上一个 <code>in</code> 关键字。这样就告诉 Swift ，闭包的主体是从哪里开始的。</p>
<p>举个例子，我们来创建一个闭包，接收一个叫 <code>place</code> 的字符串作为唯一的参数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我要开车去 \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>函数和闭包的一个区别是运行闭包的时候你不会用到参数标签。因此，调用 <code>driving ()</code> 的时候，我们是这样写的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">driving (<span class="string">" 北京 &amp; quot;</span>)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="从闭包中返回值"><a href="#从闭包中返回值" class="headerlink" title="从闭包中返回值"></a>从闭包中返回值</h1><p>闭包也能返回值，写法和闭包的参数类似：写在闭包内部， <code>in</code> 关键字前面。</p>
<p>还是以 <code>driving ()</code> 闭包为例， 让它返回一个字符串。原来的函数是这样的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我要开车去  \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>改成返回字符串而不是直接打印那个字符串，需要 <code>in</code> 之前添加 <code>-&gt; String</code> ，然后像常规函数那样用到 <code>return</code> 关键字:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> drivingWithReturn = { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">" 我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们运行这个闭包并且打印出它的返回值：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = drivingWithReturn (<span class="string">" 北京 &amp; quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(message)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="闭包作为参数"><a href="#闭包作为参数" class="headerlink" title="闭包作为参数"></a>闭包作为参数</h1><p>既然闭包可以像字符串和整数一样使用，你就可以将它们传入函数。闭包作为参数的语法乍一看一看挺伤脑筋的，让我们慢慢来。</p>
<p>首先，还是基本的 <code>driving ()</code> 闭包。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> driving = {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果我们打算把这个闭包传入一个函数，以便函数内部可以运行这个闭包。我们需要把函数的参数类型指定为 <code>() -&gt; Void</code> 。它的意思是 “不接收参数，并且返回 <code>Void</code> ”。在 Swift 中， <code>Void</code> 是什么也没有的意思。</p>
<p>好了，让我们来写一个 <code>travel ()</code> 函数，接收不同类型的 traveling 动作， 并且在动作前后分别打印信息：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我准备出发了。"</span>)</span><br><span class="line">  action ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在可以用上 <code>driving</code> 闭包了，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel (action: driving)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="拖尾闭包语法"><a href="#拖尾闭包语法" class="headerlink" title="拖尾闭包语法"></a>拖尾闭包语法</h1><p>如果一个函数的最后一个参数是闭包， Swift 允许你采用一种被称为 <em>“拖尾闭包语法”</em> 的方式来调用这个闭包。你可以把闭包传入函数之后的花括号里，而不必像传入参数那样。</p>
<p>又用到我们的 <code>travel ()</code> 函数了。它接收一个 <code>action</code> 闭包。闭包在两个 <code>print ()</code> 调用之间执行:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">()</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我准备出发了。"</span>)</span><br><span class="line">  action ()</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于函数的最后一个参数是闭包，我们可以用拖尾闭包语法来调用 <code>travel ()</code> 函数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel () {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>实际上，由于函数没有别的参数了，我们还可以将圆括号完全移除：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我正在开车。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>拖尾闭包语法在 Swift 中非常常见，所以你要适应它。</p>
<hr>
<h1 id="使用接收参数的闭包作为函数的参数"><a href="#使用接收参数的闭包作为函数的参数" class="headerlink" title="使用接收参数的闭包作为函数的参数"></a>使用接收参数的闭包作为函数的参数</h1><p>接下来要说到的闭包用法会有点复杂：当你把闭包作为函数参数时，闭包本身也接收参数。</p>
<p>前面我们用 <code>() -&gt; Void</code> 来表示 “不接收参数，并且什么也不返回”，但实际上你可以在 <code>()</code> 里填上你任何想要闭包接收的参数类型。</p>
<p>再次用到 <code>travel ()</code> 函数。函数只接收一个闭包作为参数，但这次闭包会接收一个字符串参数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我准备出发了。"</span>)</span><br><span class="line">  action (<span class="string">" 北京 &amp; quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在，当我们采用拖尾闭包语法调用 <code>travel ()</code> 时，我们的闭包代码会要求接收一个字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) <span class="keyword">in</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我准备开车去 \(place)。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="使用有返回值的闭包作为函数的参数"><a href="#使用有返回值的闭包作为函数的参数" class="headerlink" title="使用有返回值的闭包作为函数的参数"></a>使用有返回值的闭包作为函数的参数</h1><p>我们之前用 <code>() -&gt; Void</code> 来表示 “不接收参数，并且什么也不返回”。你可以把 <code>Void</code> 替换成任意的类型从而让闭包可以返回值。</p>
<p>还是 <code>travel ()</code> 函数，这次闭包会返回一个字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我准备出发了。"</span>)</span><br><span class="line">  <span class="keyword">let</span> description = action (<span class="string">" 北京 &amp; quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(description)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我到达目的地了 &amp; quot;</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>仍然用拖尾闭包语法来调用 <code>travel ()</code> ，闭包要求接收一个字符串并且返回一个字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">" 我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="速记参数名"><a href="#速记参数名" class="headerlink" title="速记参数名"></a>速记参数名</h1><p>前面我们了构建 <code>travel ()</code> 函数。它接收一个闭包作为参数，这个闭包本身接收一个参数并且返回一个字符串，它在两个 <code>print ()</code> 调用之间运行。</p>
<p>代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我准备出发了。"</span>)</span><br><span class="line">  <span class="keyword">let</span> description = action (<span class="string">" 北京 &amp; quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(description)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我到达目的地了。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以像这样调用 <code>travel ()</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { (place: <span class="type">String</span>) -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">" 我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>不过， Swift 知道提供给闭包的参数必须是一个字符串，所以调用的代码可以简写成这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { place -&gt; <span class="type">String</span> <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">" 我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Swfit 也知道闭包必须返回一个字符串，于是进一步简写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { place <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">" 我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于这里的闭包只有一行代码，这行代码肯定是返回值的那行代码，因此 Swift 允许我们把 <code>return</code> 关键字也移除：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel { place <span class="keyword">in</span></span><br><span class="line">  <span class="string">" 我要开车去 \(place)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后， Swift 还提供一种速记语法，让你可以把代码变得更短。我们可以让 Swift 为闭包的参数自动提供一个名字，而不必自行写下 <code>place in</code> 。这些自动生成的名字以 $ 开头，然后跟着一个从 0 开始的整数，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="string">" 我要开车去 \($0)。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="有多个参数的闭包"><a href="#有多个参数的闭包" class="headerlink" title="有多个参数的闭包"></a>有多个参数的闭包</h1><p>让我们把闭包这个概念一次讲透吧。接下来举一个接收两个参数的闭包的例子。</p>
<p>将 <code>travel ()</code> 函数改造一下，不仅接收旅行目的地，也接收速度。闭包的类型会变成 <code>(String, Int) -&gt; String</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">(action: <span class="params">(String, Int)</span></span></span> -&gt; <span class="type">String</span>) {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 我准备出发了。)</span></span><br><span class="line"><span class="string">  let description = action ("</span> 北京 &lt; span class="string"&gt;", 60)</span><br><span class="line"><span class="string">  print (description)</span></span><br><span class="line"><span class="string">  print ("</span> 我到达目的地了。<span class="string">")</span></span><br><span class="line"><span class="string">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>再一次用速记闭包参数名来调用函数。由于这次闭包有两个参数了，于是自动参数名分别是 <code>$0</code> 和 <code>$1</code> ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">travel {</span><br><span class="line">  <span class="string">" 我要开车去 \($0)，时速 \($1) 公里每小时。"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>有些人可能不喜欢用速记参数名，因为它们的语义不是很清晰。你可以根据自己的喜好来决定是否采用它们。不过了解一下这个语法还是必要的，这样读到别人的代码时就不会感到困惑。</p>
<hr>
<h1 id="从函数中返回闭包"><a href="#从函数中返回闭包" class="headerlink" title="从函数中返回闭包"></a>从函数中返回闭包</h1><p>就如同你可以把闭包传入函数那样，你也可以从函数中返回闭包。</p>
<p>返回闭包的语法看起来有点绕，因为用了两次 <code>-&gt;</code> ：第一次用于指定函数的返回值，第二次用于指定闭包的返回值。</p>
<p>又又又要把 <code>travel ()</code> 函数拉出来了。这次它不接收参数，但返回一个闭包。这个返回的闭包在用的时候必须传入一个字符串，但闭包本身没有返回值。</p>
<p>Swift 代码长这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 我要动身去 \($0)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>接下来我们通过调用 <code>travel ()</code> 拿到闭包，然后作为函数来调用：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = travel ()</span><br><span class="line">result (<span class="string">" 北京 &amp; quot;</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>留意下面的代码，它是直接调用 <code>travel ()</code> 的返回值。这个写法虽然在语法上完全没问题，但是可读性较差，建议尽量不要这样写。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result2 = travel ()(<span class="string">" 北京 &amp; quot;</span>)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="捕获变量"><a href="#捕获变量" class="headerlink" title="捕获变量"></a>捕获变量</h1><p>如果你想要使用闭包之外的对象， Swift 会为你 “捕捉” 它们，并把它们和闭包一同存储，以便外部作用域已经失效的情况下闭包内部还可以使用它们。</p>
<p>最后一次用到 <code>travel ()</code> 函数，它返回一个闭包，这个闭包接收字符串作为唯一的参数并且什么也不返回：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 我准备去 \($0)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用 <code>travel ()</code> 拿到闭包，然后自由使用：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = travel ()</span><br><span class="line">result (<span class="string">" 北京 &amp; quot;</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>闭包捕获变量可以发生在什么情况下呢？举个例子，当 <code>travel ()</code> 函数内创建了一个变量，这个变量需要在闭包里面用到，那么这个变量就会被闭包捕获。比如，我们想知道闭包被调用的次数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">travel</span><span class="params">()</span></span> -&gt; (<span class="type">String</span>) -&gt; <span class="type">Void</span> {</span><br><span class="line">  <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 第 \(counter) 次，我将前往 \($0)"</span>)</span><br><span class="line">    counter += <span class="number">1</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>尽管 <code>counter</code> 变量是在 <code>travel ()</code> 里被创建的，它被闭包捕获，因而会在闭包内部存续。</p>
<p>当我们多次调用 <code>result (" 北京 ")</code> ，计数器会持续增加：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">result (<span class="string">" 北京 &amp; quot;</span>)</span><br><span class="line">result (<span class="string">" 北京 &amp; quot;</span>)</span><br><span class="line">result (<span class="string">" 北京 &amp; quot;</span>)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>你可以把闭包赋值给变量，之后再用变量名来调用闭包。 </li>
<li>闭包和常规函数一样可以接收参数和返回值。 </li>
<li>你可以将闭包作为参数传入函数，并且这些闭包也可以有自己的参数和返回值。 </li>
<li>如果函数的最后一个参数是闭包，你可以使用拖尾闭包语法。 </li>
<li>Swift 为拖尾闭包语法自动生成了 <code>$0</code> 和 <code>$1</code> 这样的速记闭包参数名，但不是所有人都习惯这种速记法。 </li>
<li>如果你在闭包中使用了外部变量，这些变量将被闭包 “捕捉” 以便后续引用。 </li>
</ol>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之五 | 函数</title>
    <url>/programming/swiftswift-functions/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="书写函数"><a href="#书写函数" class="headerlink" title="书写函数"></a>书写函数</h1><p>函数让我们可以重用代码。这句话的具体含义是，我们写一次函数，在多个地方使用。书写重复的代码，通常来说不是一种好的实践，而函数帮助我们避免重复代码。</p>
<p>用一个简单的例子开始吧。假设我们要为 app 的用户提供帮助信息，这个动作在 app 里的多个地方都会用到。因此，把打印帮助信息这个逻辑写成一个函数就是个好主意。</p>
<p>Swift 的函数以 <code>func</code> 关键字开始，然后跟着函数名，然后是一对圆括号，最后是一对花括号。当函数被运行时，花括号里的代码会被执行。</p>
<p>一个 <code>printHelp ()</code> 函数长这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printHelp</span><span class="params">()</span></span> {</span><br><span class="line">  <span class="keyword">let</span> message = <span class="string">"""</span></span><br><span class="line"><span class="string">  欢迎来到我的 App!</span></span><br><span class="line"><span class="string">  在一个图片的目录下运行这个 App，</span></span><br><span class="line"><span class="string">  它会把所有的图片缩放成缩略图。</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="built_in">print</span>(message)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们用 <code>printHelp ()</code> 来运行它。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">printHelp ()</span><br></pre></td></tr></tbody></table></figure>
<p>运行一个函数又被称为 * 调用 * 一个函数。</p>
<a id="more"></a>

<hr>
<h1 id="接收参数"><a href="#接收参数" class="headerlink" title="接收参数"></a>接收参数</h1><p>函数在你调用它们的时候可以被定制，这使得它们的能力更加强大。 Swift 允许你发送值给函数，这些值可以在函数内部使用，从而改变函数的行为。其实之前我们已经见过函数的这个特性：我们把整数和字符串传递给 <code>print ()</code> 函数，就像下面这样。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Hello, world!"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>这些被传入函数的值被称为 * 参数 * 。</p>
<p>为了使你的函数可以接收参数，你需要给参数起个名字，然后加一个冒号，最后再告诉 Swift 这个参数的数据类型。这些都是放在函数名之后的圆括号里面。</p>
<p>举个例子，我们可以写一个函数，打印任意数字的平方。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(number: Int)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(number * number)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码告知 Swift 我们期望接收一个 <code>Int</code> 类型，并且名字叫 <code>number</code> 。这个名字不仅用于函数内部指代参数，也用于运行函数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">square (number: <span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h1><p>函数不仅可以接收数据（通过参数），也可以返回数据。为了返回数据，在函数的参数列表之后写一个短横线加一个向右的尖括号，然后提供一个数据类型。这个语法告诉 Swift 函数将返回一个指定类型的数据。</p>
<p>在函数内，我们用 <code>return</code> 关键字来返回数据。这个时候函数会立即结束，并返回数据，函数内的其他代码都不再执行。</p>
<p>我们可以重写 <code>square ()</code> 函数，返回平方数而不是直接打印它：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">  <span class="keyword">return</span> number * number</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们可以通过运行这个函数，拿到返回值并且打印出来：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = square (number: <span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></tbody></table></figure>
<p>如果你需要返回多个值，可以使用元组作为返回值的类型。</p>
<hr>
<h1 id="参数标签"><a href="#参数标签" class="headerlink" title="参数标签"></a>参数标签</h1><p>前面的 <code>square ()</code> 函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(number: Int)</span></span> -&gt; <span class="type">Int</span> {</span><br><span class="line">  <span class="keyword">return</span> number * number</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>参数名是 <code>number</code> ，我们通过在函数里使用 <code>number</code> 来引用这个参数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = square (number: <span class="number">8</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>Swift 允许我们给参数起两个名字：一个供调用时使用，一个在函数内部使用。书写的时候把两个名字都写上，用空格分隔。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello</span><span class="params">(to name: String)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(name)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里的参数名是 <code>to name</code> ，在外部调用时用 <code>to</code> ，而内部指代时用 <code>name</code> 。这种方式让参数在函数内部有一个合理的名称，同时在调用时阅读起来也是自然的。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">sayHello (to: <span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="省略参数标签"><a href="#省略参数标签" class="headerlink" title="省略参数标签"></a>省略参数标签</h1><p>你可能已经注意到我们在使用 <code>print ()</code> 函数时并没有传入任何参数标签。我们会写作 <code>print ("Hello")</code> ，而不是 <code>print (message:"Hello")</code> 。</p>
<p>通过使用下划线 <code>_</code> 作为外部参数标签，你可以在自己的函数里实现一样的效果，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="keyword">_</span> person: String)</span></span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello, \(person)!"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样写的话，调用 <code>greet ()</code> 函数时，你就不必传入参数标签了：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">greet (<span class="string">"Taylor"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>为了使代码阅读起来更自然，通常我们是需要给参数起一个外部标签名的。举个例子，如果我说设置闹钟 5（ <code>setAlarm (5)</code> ）不写标签的话很难理解这代表什么意思：是要设置一个 5 点钟生效的闹钟呢？还是要激活第 5 个预先设好的闹钟？而像打印这件事，在打印后面直接跟上要打印的内容，本身就是一个清晰的表达，所以可以省略掉参数标签。</p>
<hr>
<h1 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h1><p><code>print ()</code> 函数打印文本到屏幕，并且不论你传什么内容给它，它都会在最后添加一个换行。所以多次调用 <code>print ()</code> 的话，那些文本是不会显示在同一行的。</p>
<p>但是你可以改变 <code>print ()</code> 函数的这个行为：你可以用其他符号，例如空格来取代换行。不过多数情况下，大家都想要换行，因此 <code>print ()</code> 有一个叫 <code>terminator</code> 的参数，它的默认值是换行符。</p>
<p>通过在参数后面加上一个 <code>=</code> 然后写上一个值，你可以为你自己的函数提供默认参数。 举个例子，我们写一个 <code>greet ()</code> 函数，默认友好问候：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">greet</span><span class="params">(<span class="keyword">_</span> person: String, nicely: Bool = <span class="literal">true</span>)</span></span> {</span><br><span class="line">  <span class="keyword">if</span> nicely == <span class="literal">true</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 你好， \(person)!"</span>)</span><br><span class="line">  } <span class="keyword">else</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 不是吧，又是 \(person) 你小子。"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在 <code>greet ()</code> 函数就有两种调用方式了：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">greet (<span class="string">"Taylor"</span>)</span><br><span class="line">greet (<span class="string">"Taylor"</span>, nicely: <span class="literal">false</span>)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h1><p>有一些函数是 <em>可变</em> 的，可变是指函数可以接收任意多个同类型的参数。例如， <code>print ()</code> 函数实际上就是可变的：如果你传入多个参数，它们会被以空格相连打印在同一行。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"Haters"</span>, <span class="string">"gonna"</span>, <span class="string">"hate"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>你可以通过在参数类型之后添加 <code>...</code> ，将一个参数声明成可变参数。因此，一个 <code>Int</code> 参数代表一个整数，而 <code>Int...</code> 则代表 0 个或者更多整数，理论上不限个数。</p>
<p>在函数内部， Swift 会将这些整数转成一个整数的数组，以方便你遍历它们。</p>
<p>让我们用 <code>square ()</code> 函数来尝试一下吧：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(numbers: Int...)</span></span> {</span><br><span class="line">  <span class="keyword">for</span> number <span class="keyword">in</span> numbers {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"\(number) 的平方等于 \(number * number)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们可以用逗号分隔一组数字，把它们全部传入 <code>square ()</code> 函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">square (numbers: <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="书写会抛出错误的函数"><a href="#书写会抛出错误的函数" class="headerlink" title="书写会抛出错误的函数"></a>书写会抛出错误的函数</h1><p>有的时候函数会运行失败，因为不合理的输入或者函数内部的错误。 Swift 允许我们从函数中抛出错误。实现的方法是在返回值前写一个 <code>throws</code> ，然后在函数出错时使用 <code>throw</code> 关键字抛出错误。</p>
<p>首先我们需要定义一个 <code>enum</code> ，用于描述我们可能抛出的错误。这些错误必须基于 Swift 已经存在的 <code>Error</code> 类型。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">PasswordError</span>: <span class="title">Error</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> obvious</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们来实现一个函数 <code>checkPassword ()</code> ，这个函数检测传入的密码是否合理，当密码过于简单时，我们抛出一个错误提醒用户。具体来说，当密码被设置成 “password” 时，执行 <code>throw PasswordError.obvious</code> 。</p>
<p>Swift 代码如下：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkPassword</span><span class="params">(<span class="keyword">_</span> password: String)</span></span> <span class="keyword">throws</span> -&gt; <span class="type">Bool</span> {</span><br><span class="line">  <span class="keyword">if</span> password == <span class="string">"password"</span> {</span><br><span class="line">    <span class="keyword">throw</span> <span class="type">PasswordError</span>.obvious</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="运行可能会抛出错误的函数"><a href="#运行可能会抛出错误的函数" class="headerlink" title="运行可能会抛出错误的函数"></a>运行可能会抛出错误的函数</h1><p>Swift 并不期望你在程序运行时遭遇错误，因此它不会让你直接运行可能抛出错误的函数。</p>
<p>你需要用到三个关键字来运行会抛出错误的函数： <code>do</code> 开启一段可能会遭遇问题的代码， <code>try</code> 放在每一个可能抛出错误的函数前面，最后的 <code>catch</code> 让你可以优雅地处理错误。</p>
<p>如果 <code>do</code> 语句块里有任何错误抛出，代码执行会直接跳到 <code>catch</code> 语句块。让我们用一个可以触发 <code>checkPassword ()</code> 抛出错误的密码来调用这个函数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> {</span><br><span class="line">  <span class="keyword">try</span> checkPassword (<span class="string">"password"</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 这个密码很棒！"</span>)</span><br><span class="line">} <span class="keyword">catch</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 你不能用这个密码。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当这段代码运行时，“你不能用这个密码。” 会被打印。但” 这个密码很棒！“则不会被打印。这个是由于错误的抛出导致那个打印无法被运行到。</p>
<hr>
<h1 id="inout-参数"><a href="#inout-参数" class="headerlink" title="inout 参数"></a>inout 参数</h1><p>所有传入 Swift 函数的参数默认都是 <em>常量</em> ，所以你无法更改它们。假如你就是想要在函数内改变这些参数呢？可以用 <code>inout</code> 修饰它们，所有在函数内对它们做出的改变都会影响到它们在函数外的原始值。</p>
<p>举个例子，如果你想要让一个数翻倍。比如，直接改变那个数，而不是返回一个新的数。你可以像下面这样写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doubleInPlace</span><span class="params">(number: <span class="keyword">inout</span> Int)</span></span> {</span><br><span class="line">  number *= <span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了使用这个可以修改参数的函数，首先要求传入的参数本身不能是常量，因为如果参数本来是常量，即使用 <code>inout</code> 修饰，也无法被修改。其次，在传入函数时，还要用一个 <code>&amp;</code> 符号，放在参数名前面。它是参数以 <code>inout</code> 方式使用的显式标识。</p>
<p>在代码中，是这么书写的：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> myNum = <span class="number">10</span> </span><br><span class="line">doubleInPlace (number: &amp;myNum)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>函数通过避免重复来帮助我们复用代码。 </li>
<li>函数可以接收参数，你需要告诉 Swift 每个参数的类型。 </li>
<li>函数可以返回值，同样需要指定返回值的类型。如果你想返回多个值，可以使用元组。 </li>
<li>你可以给参数取不同的外部名和内部名，并且可以完全省略外部名。 </li>
<li>参数可以有默认值，以便你用更少的代码指定常见的特定值。 </li>
<li>可变参数可以接收零到多个特定的参数， Swift 会把它们转成数组。 </li>
<li>函数可以抛出错误，但是调用这种函数的时候需要用 <code>try</code> 关键字并且用 <code>catch</code> 来处理错误。 </li>
<li>你可以用 <code>inout</code> 标记可以在函数内部改变的参数，不过通常来说最好还是返回一个新值。 </li>
</ol>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之四 | 循环</title>
    <url>/programming/swiftswift-looping/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="For-循环"><a href="#For-循环" class="headerlink" title="For 循环"></a>For 循环</h1><p>Swift 有很多种书写循环的方式，它们底层的机制是相同的：重复执行某段代码直到某个条件不再满足。</p>
<p>最常见的循环是 <code>for</code> 循环：它在数组和范围上循环，每次拉出一个值然后把它赋予一个常量。</p>
<p>举个例子，这里是一个数字的范围：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">1</span>...<span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们可以用一个 <code>for</code> 循环打印里面的每一个值，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">count</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 数字是 \(number)"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>数组的操作方式也一样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> albums = [<span class="string">"Red"</span>, <span class="string">"1989"</span>, <span class="string">"Reputation"</span>]</span><br><span class="line"><span class="keyword">for</span> album <span class="keyword">in</span> albums {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(album) 在 Apple Music 上有售卖。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果你不需要用到 <code>for</code> 循环提供给你的常量，你可以用下划线替代，这样 Swift 就会忽略这个你没有用到的值：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="keyword">_</span> <span class="keyword">in</span> <span class="number">1</span>...<span class="number">5</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Zzz..."</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<hr>
<h1 id="While-循环"><a href="#While-循环" class="headerlink" title="While 循环"></a>While 循环</h1><p>第二种书写循环的方式是使用 <code>while</code> ：给定一个检查的条件，循环运行代码直到条件不成立。</p>
<p>举个例子，我们可以使用 <code>while</code> 循环来模拟一个躲猫猫游戏：从 1 开始数数，数到的数会打印出来。数完 20 个数之后打印 “准备好了没？我来啦！”</p>
<p>Swift 代码长这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> number &lt;= <span class="number">20</span> {</span><br><span class="line">  <span class="built_in">print</span>(number)</span><br><span class="line">  number += <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">" 准备好了没？我来啦！"</span>)</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="Repeat-循环"><a href="#Repeat-循环" class="headerlink" title="Repeat 循环"></a>Repeat 循环</h1><p>第三种循环的写法不常用，它是 <code>repeat</code> 循环。除了把条件检查放在后面，它基本上跟 <code>while</code> 循环是一样的。</p>
<p>因此，我们可以用 <code>repeat</code> 循环重写我们的躲猫猫游戏：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">1</span></span><br><span class="line"><span class="keyword">repeat</span> {</span><br><span class="line">  <span class="built_in">print</span>(number)</span><br><span class="line">  number += <span class="number">1</span></span><br><span class="line">} <span class="keyword">while</span> number &lt;= <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">" 准备好了没？我来啦！"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>因为检查的条件是放在后面，所以 <code>repeat</code> 循环里的代码至少会被执行一次。而 <code>while</code> 循环则是在首次运行前就会检查条件。</p>
<p>举个例子， 下面代码里的 <code>print ()</code> 函数永远都不会被运行，因为 <code>false</code> 永远是 false ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">false</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 这是 false"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Xcode 会警告我们上面代码中的 <code>print ()</code> 代码永远都不会被执行。</p>
<p>而在下面这个代码里， <code>print ()</code> 函数则至少运行一次，因为 <code>repeat</code> 只有在条件检查没有通过时才会停止执行：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">repeat</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 这是 false"</span>)</span><br><span class="line">} <span class="keyword">while</span> <span class="literal">false</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="退出循环"><a href="#退出循环" class="headerlink" title="退出循环"></a>退出循环</h1><p>你可以使用 <code>break</code> 关键字来终止循环。让我们以一个常规的 <code>while</code> 循环为例 —— 火箭发射倒计时：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countDown = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> countDown &gt;= <span class="number">0</span> {</span><br><span class="line">  <span class="built_in">print</span>(countDown)</span><br><span class="line">  countDown -= <span class="number">1</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">" 发射！"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>想象一下，宇航员感觉这个倒计时过程很无聊，决定跳过后面的数，直接发射：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> countDown &gt;= <span class="number">0</span> {</span><br><span class="line">  <span class="built_in">print</span>(countDown)</span><br><span class="line">  <span class="keyword">if</span> countDown == <span class="number">4</span> {</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">" 好无聊啊，让我们直接发射吧！"</span>)</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  countDown -= <span class="number">1</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>通过这次改动，只要 <code>countDown</code> 达到 4 ，那么宇航员的消息就会被打印，剩余的计数将会被忽略。</p>
<hr>
<h1 id="退出多重循环"><a href="#退出多重循环" class="headerlink" title="退出多重循环"></a>退出多重循环</h1><p>把循环放在另一个循环里，叫做 <em>嵌套</em> 循环。有的时候，你会有这种需求：同时跳出内部的循环和外部的循环。</p>
<p>举个例子， 我们可以用嵌套循环实现一个从 1 到 10 的乘法表：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">    <span class="keyword">let</span> product = i * j</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"\(i) * \(j) 等于 \(product)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果想退出循环，我们需要做两件事。首先，给外层循环加一个标签，像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">outerLoop: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">    <span class="keyword">let</span> product = i * j</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"\(i) * \(j) 等于 \(product)"</span>)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后，在内层循环里添加条件，在条件满足时用 <code>break outerLoop</code> 同时退出内外层循环：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">outerLoop: <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">    <span class="keyword">let</span> product = i * j</span><br><span class="line">    <span class="built_in">print</span> (<span class="string">"\(i) * \(j) 等于 \(product)"</span>)</span><br><span class="line">    <span class="keyword">if</span> product == <span class="number">50</span> {</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">" 这是一个靶心。"</span>)</span><br><span class="line">      <span class="keyword">break</span> outerLoop</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果只使用 <code>break</code> ，就只能退出内层循环，外层循环会继续运行。</p>
<hr>
<h1 id="跳过循环项"><a href="#跳过循环项" class="headerlink" title="跳过循环项"></a>跳过循环项</h1><p>如你所见， <code>break</code> 关键字可以用于退出循环。 但是假如你想要跳过当前项然后继续执行下一次循环，你可以使用 <code>continue</code> 关键字。</p>
<p>让我们写一个从 1 到 10 的循环，然后利用 Swift 的取余操作符来跳过所有的奇数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> {</span><br><span class="line">  <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">1</span> {</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h1><p>通常来说，我们用 <code>while</code> 循环来实现无限循环：它指的是那种不会自动停止的循环，或者说只有我们想要它停止时才停止的循环。你的智能手机里的 App 都用到了无限循环，因为它们一旦开始运行，就会持续运行，不断地接收输入事件，做出响应。</p>
<p>最简单的无限循环是用 <code>true</code> 作为条件。 <code>true</code> 使得循环可以无限重复地执行。 ** 警告：** 如果你采用 <code>while true</code> 来实现循环，确保你在循环内会有一个条件检查以退出这个无限循环。</p>
<p>举个例子， 我们用 <code>while true</code> 来模拟约翰・凯奇的《4’33”》这首歌。这首歌真的很奇葩，因为整个首歌的 4 分 33 秒都是沉默，没声。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" "</span>)</span><br><span class="line">  counter += <span class="number">1</span></span><br><span class="line">  <span class="keyword">if</span> counter == <span class="number">273</span> {</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ol>
<li>循环可以重复执行某段代码，直到条件不再满足。 </li>
<li>最常见的循环是 <code>for</code> 循环，它内部会计数一个临时的常量来记录循环的次数。 </li>
<li>如果你用不上这个 <code>for</code> 循环给到你的常量，可以使用下划线来告知 Swift 忽略它。 </li>
<li>对于 <code>while</code> 循环，你需要显式地提供一个条件检查来决定循环是否执行。 </li>
<li>尽管和 <code>while</code> 循环很像， <code>repeat</code> 循环至少会执行一次循环体里的代码。 </li>
<li>你可以用 <code>break</code> 结束循环，但是在嵌套循环里， <code>break</code> 之后还要再加上标签才能跳出特定的外层循环。 </li>
<li>你可以用 <code>continue</code> 来跳过循环中特定的项。 </li>
<li>无限循环只有在你要求它停止时才会结束。如果你用了 <code>while true</code> 来实现无限循环，确保你有一个条件检查用于终止循环！ </li>
</ol>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之三 | 操作符与条件</title>
    <url>/programming/swiftswift-operators-and-conditions/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h1><p>到目前为止，你已经了解了 Swift 的所有基本类型，现在让我们利用操作符把它们放在一起来使用。操作符指的是那些看起来像数学符号的玩意，比如 <code>+</code> 和 <code>-</code> 。 Swift 中有大量的操作符。</p>
<p>下面有一些测试用的变量（这里特指数学里的变量，不局限于 Swift 的 <code>var</code> ）：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstScore = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> secondScore = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<p>让我们用 <code>+</code> 和 <code>-</code> 把它们相加或者相减：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> total = firstScore + secondScore</span><br><span class="line"><span class="keyword">let</span> difference = firstScore - secondScore</span><br></pre></td></tr></tbody></table></figure>
<p>我们还可以用 <code>*</code> 和 <code>/</code> 来执行乘法和除法：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> product = firstScore * secondScore</span><br><span class="line"><span class="keyword">let</span> divided = firstScore /secondScore</span><br></pre></td></tr></tbody></table></figure>
<p>Swift 有一个用于计算除法的余数的特殊操作符： <code>%</code> 。它可以计算一个数 <code>A</code> 用若干个数 <code>B</code> 填充后，剩余的空间。</p>
<p>举个例子，如果我们把 <code>secondScore</code> 设置为 4 ，那么当我们做 <code>13 % secondScore</code> 这个操作时，我们会得到 1 ，因为 4 可以填充 13 三次，余数为 1 ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> remainder = <span class="number">13</span> % secondScore</span><br></pre></td></tr></tbody></table></figure>
<a id="more"></a>

<hr>
<h1 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h1><p>Swift 支持 “操作符重载”，这是一种简明的说法，具体指的是操作符的行为可以根据它使用时的具体情境来决定。举个例子， <code>+</code> 可以用来相加整数，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> meaningOfLife = <span class="number">42</span></span><br><span class="line"><span class="keyword">let</span> doubleMeaning = <span class="number">42</span> + <span class="number">42</span></span><br></pre></td></tr></tbody></table></figure>
<p>同时， <code>+</code> 也可以用来连接字符串，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fakers = <span class="string">"Fakers gonna "</span></span><br><span class="line"><span class="keyword">let</span> action = fakers + <span class="string">"fake"</span></span><br></pre></td></tr></tbody></table></figure>
<p>你甚至还可以使用 <code>+</code> 来连接数组，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstHalf = [<span class="string">"John"</span>, <span class="string">"Paul"</span>]</span><br><span class="line"><span class="keyword">let</span> secondHalf = [<span class="string">"George"</span>, <span class="string">"Ringo"</span>]</span><br><span class="line"><span class="keyword">let</span> beatles = firstHalf + secondHalf</span><br></pre></td></tr></tbody></table></figure>
<p>记住， Swift 是一门类型安全的语言。这意味着它不允许你混用类型。举个例子，你不能把一个整数加到一个字符串上，因为这么做没有意义。</p>
<hr>
<h1 id="复合赋值操作符"><a href="#复合赋值操作符" class="headerlink" title="复合赋值操作符"></a>复合赋值操作符</h1><p>Swift 提供了一些把操作符和赋值组合起来的速记操作符，以便你可以用一次操作同时完成计算和赋值。它们看起来很像你已经认识的那些操作符，比如 <code>+</code> ，<code>-</code> ，<code>*</code> ，和 <code>/</code> ，不过需要在尾部再加上一个 <code>=</code> ，以表示把计算结果赋给操作数。</p>
<p>举个例子，如果有人考试考了 95 分，但是需要罚去 5 分，你可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">95</span></span><br><span class="line">score -= <span class="number">5</span></span><br></pre></td></tr></tbody></table></figure>
<p>类似地，你可以利用 += 来拼接字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> quote = <span class="string">"The rain in Spain falls mainly on the "</span></span><br><span class="line">quote += <span class="string">"Spaniards"</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h1><p>Swift 提供了几个比较操作符，这些符号的工作方式跟你在数学中使用它们的方式很相似。</p>
<p>先来两个测试用的变量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstScore = <span class="number">6</span></span><br><span class="line"><span class="keyword">let</span> secondScore = <span class="number">4</span></span><br></pre></td></tr></tbody></table></figure>
<p>有两个可以用来检查相等的操作符。 <code>==</code> （发音 “等于”）检查两个值是否相等，而 <code>!=</code> （发音 “不等于”）则检查两个值是否不相等：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">firstScore == secondScore</span><br><span class="line">firstScore != secondScore</span><br></pre></td></tr></tbody></table></figure>
<p>还有四个用来检查两个值哪一个比较大，哪一个比较小或者相等的操作符。就跟数学里的符号一样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">firstScore &lt; secondScore</span><br><span class="line">firstScore &gt;= secondScore</span><br></pre></td></tr></tbody></table></figure>
<p>上面的这些操作符用在字符串上也是可以的，因为字符串都有一个自然的字母顺序。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"Taylor"</span> &lt;= <span class="string">"Swift"</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h1><p>你现在应该已经意识到你可以使用 <code>if</code> 语句来书写一些条件了。当你给到 Swift 一个条件时，如果条件成立， Swift 会运行你在 <code>if</code> 语句块里写的代码。</p>
<p>尝试一下。 你可以用上 Swift 最基础的函数，它叫做 <code>print ()</code> ：你提供一些文本给它，它将这些文本打印出来。</p>
<p>让我们用条件来检测二十一点扑克游戏的赢家：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstCard = <span class="number">11</span></span><br><span class="line"><span class="keyword">let</span> secondCard = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> firstCard + secondCard == <span class="number">21</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"21 点！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>花括号 <code>{</code> 和 <code>}</code> 之间的代码，在条件成立时会被执行。如果条件不成立时你想执行另外的代码，可以使用 <code>else</code> 语句：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> firstCard + secondCard == <span class="number">21</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"21 点！"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 普通点数。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你还可以使用 <code>else if</code> 来串联多个条件：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> firstCard + secondCard == <span class="number">2</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Aces，好手气！"</span>)</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> firstCard + secondCard == <span class="number">21</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"21 点！"</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 普通点数。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="组合条件"><a href="#组合条件" class="headerlink" title="组合条件"></a>组合条件</h1><p>Swift 提供两种操作符，以便我们把条件组合在一起，它们是 <code>&amp;&amp;</code>（发音 “与”）和 <code>||</code> （发音 “或”）。</p>
<p>举个例子，为了检查两个人的年龄是否都超过某个值，我们可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> age1 = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> age2 = <span class="number">21</span></span><br><span class="line"><span class="keyword">if</span> age1 &gt; <span class="number">18</span> &amp;&amp; age2 &gt; <span class="number">18</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 两个人都超过 18 岁。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的 <code>print ()</code> 调用只有当两个年龄都大于 18 时才会被执行，而给到的两个年龄并不满足都大于 18 。实际上， Swift 并不会真的把两个条件都检查一遍，它不需要检查 <code>age2</code> 是否大于 18 ，因为当它发现 <code>age1</code> 大于 18 这个条件已经不成立时，就不会再继续检查后面的条件。</p>
<p>与 <code>&amp;&amp;</code> 不同的是，只要有任意一个条件通过测试， <code>||</code> 检查就会被认定为通过。 举个例子，下面的代码在任一年龄大于 18 时就会打印一条消息：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> age1 &gt; <span class="number">18</span> || age2 &gt; <span class="number">18</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 有一个人超过 18 岁。"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>你可以在一个检查中使用多次 <code>&amp;&amp;</code> 和 <code>||</code> ，但是切记不要把条件写得太过复杂，因为那样很难阅读！</p>
<hr>
<h1 id="三元操作符"><a href="#三元操作符" class="headerlink" title="三元操作符"></a>三元操作符</h1><p>Swift 还提供一种不常用的操作符，叫做三元操作符。它的名字源自它可以一次协同三个操作数工作的特点。首先，它会先检查第一个数里指定的条件是否满足，如果满足则返回第二个数，否则返回第三个数。</p>
<p>三元操作符是把 <code>true</code> 和 <code>false</code> 两种情况一次性考虑进去的符号，它包含问号和冒号两个部分，因此阅读起来更麻烦一些。下面是一些例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> firstCard = <span class="number">11</span></span><br><span class="line"><span class="keyword">let</span> secondCard = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(firstCard == secondCard ? <span class="string">" 牌是一样的 &amp; quot;</span> : <span class="string">" 牌不一样 &amp; quot;</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>上面的代码检查两张牌是否一样，如果一样则打印 “牌是一样的”，否则打印 “牌不一样”。我们也可以换成常规的条件语句来达到一样的检测效果：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> firstCard == secondCard {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 牌是一样的 &amp; quot;</span>)</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 牌不一样 &amp; quot;</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h1><p>如果你需要用到多个 <code>if</code> 和 <code>else if</code> ，那你可以使用另一种结构：<code>switch case</code>，它会让你的代码看起来更清晰。采用 <code>switch</code> 语句，你只需要写一次条件，然后列出所有可能的结果，并针对所有的结果编写对应的处理代码。</p>
<p>让我们来尝试一下，下面是一个值为 <code>sunny</code> 字符串的名叫 <code>weather</code> 的常量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> weather = <span class="string">"sunny"</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们可以使用 <code>switch</code> 语句块来打印下面四种消息中的一种：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> weather {</span><br><span class="line"><span class="keyword">case</span> <span class="string">"rain"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 记得带伞 &amp; quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"snow"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 记得保暖 &amp; quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sunny"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 记得戴墨镜 &amp; quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 天气不错！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>最后一条 case 是 <code>default</code> ，它是不能省略的，因为 Swift 需要确保你覆盖了所有可能的 case ，即不能有遗漏的情况。所以只要天气不是 <code>rain</code> ， <code>snow</code> ，或者 <code>sunny</code> ， 默认的情况的 case 就会被运行。</p>
<p>Swift 只会运行某一个 case 里的代码。如果你希望继续执行下一个 case 的代码，你需要用到 <code>fallthrough</code> 关键字，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> weather {</span><br><span class="line"><span class="keyword">case</span> <span class="string">"rain"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 记得带伞 &amp; quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"snow"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 记得保暖 &amp; quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="string">"sunny"</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 记得戴墨镜 &amp; quot;</span>)</span><br><span class="line">  <span class="keyword">fallthrough</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 天气不错！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="范围操作符"><a href="#范围操作符" class="headerlink" title="范围操作符"></a>范围操作符</h1><p>Swift 提供了两种方式给我们创建范围： 它们是 <code>..&lt;</code> 和 <code>...</code> 操作符。半开放范围操作符 <code>..&lt;</code> ，创建的范围不包含右边的值。而闭合范围操作符 <code>...</code> ，创建的范围包含右边的值。</p>
<p>范围 <code>1..&lt;5</code> 包含数字 1 ，2 ，3 和 4 ， 而范围 <code>1...5</code> 包含数字 1 ，2 ，3 ，4 和 5 。</p>
<p>对于 switch 语句块来说，范围非常有用。因为你可以把它们用于你的每条 case 。举个例子，假设我们根据某人的考试成绩打印不同的消息：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> score = <span class="number">85</span></span><br><span class="line"><span class="keyword">switch</span> score {</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>..&lt;<span class="number">50</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 你需要加把劲了。"</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">50</span>..&lt;<span class="number">85</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 做的不错。"</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">" 你真棒！"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如前面提到的，这里必须有一个 <code>default case</code> 来确保所有的可能都被覆盖到。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ul>
<li>Swift 提供了用于算术和比较的操作符，它们的工作机制就像我们在数学中所熟知的那样。 </li>
<li>有一些算术操作符的复合变体，它们可以一次性完成算术和赋值两个操作，比如 <code>+=</code> ，<code>-=</code> ，等等。 </li>
<li>你可以使用 <code>if</code> ， <code>else</code> 和 <code>else if</code> 语句，基于条件判定的结果来运行不同的代码。 </li>
<li>Swift 提供一个三元操作符，把 <code>true</code> 和 <code>false</code> 两种条件检查和语句块组合在一起。尽管有的时候会看到大家在使用它们，我个人不建议你使用这个操作符。 </li>
<li>如果你基于同一个值做多种条件判定，那么你可以使用 switch 语句，这么做会使代码更清晰。 </li>
<li>我们可以用 <code>..&lt;</code> 或者 <code>...</code> 来创建范围，具体用哪一个取决于要不要包含后面那个值，即范围是否闭合。 </li>
</ul>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之二 | 复合类型</title>
    <url>/programming/swiftswift-complex-types/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组是用于存储一组值的合集。举个例子，红、绿、蓝是三基色，你可以对它们进行调和从而产生新颜色。因此颜色就可以用一个包含了红、绿、蓝三个值的数组来存储。</p>
<p>代码上，我们这么书写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> red = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">let</span> green = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">let</span> blue = <span class="number">1.0</span></span><br><span class="line"><span class="keyword">let</span> color = [red, green, blue]</span><br></pre></td></tr></tbody></table></figure>
<p>上面的最后一行代码创建了一个数组：它以方括号开始和结束，里面的元素通过逗号分隔。</p>
<p>你可以通过书写数组名加上内部包含一个数字的方括号来读取数组里的元素。注意：这个数字代表元素在数组里的位置，几乎在所有的计算机编程语言中，这个位置都是从 <code>0</code> 开始的。所以，如果你想读取蓝色，可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">color [<span class="number">2</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>小心：如果你尝试读取一个不存在的值， Swift 将会崩溃。例如，试图读取 <code>color [5]</code> 就不是一个好主意。</p>
<p>另外还要注意的是，如果你想使用类型注解，数组是通过方括号加里面的类型来表示的： <code>[String]</code> ，<code>[Int]</code> ，<code>[Double]</code> 和 <code>[Bool]</code> 。</p>
<a id="more"></a>

<hr>
<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><p>集合跟数组类似，也是存储一组值的合集。但它们有两个区别：集合中的元素是随机存放的，而数组中的元素是顺序存放的。集合中不允许有两个相同的元素，即任何一个元素只能出现一次。数组则没有这个限制。</p>
<p>你可以直接利用数组来创建一个集合，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors = <span class="type">Set</span>([<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>])</span><br></pre></td></tr></tbody></table></figure>
<p>当你在 Playground 中查看 colors 中的元素时，你看到的元素的顺序可能跟你创建 colors 时填写的顺序不同。实际上，这个顺序并非真的是每次都随机生成，只不过很有可能跟你给的顺序不同。</p>
<p>Swift 内部自有算法来生成这个顺序，但不保证跟你创建集合时传入的顺序一致。所以，通过位置来读取数组中的元素那种方式，对于读取集合中的元素是不适用的。</p>
<p>如果你试图往集合中插入一个已经存在的元素，重复的这个元素会被忽略。举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> colors2 = <span class="type">Set</span>([<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"red"</span>, <span class="string">"blue"</span>])</span><br></pre></td></tr></tbody></table></figure>
<p>最后的 <code>colors2</code> 只会包含 <code>red</code> ，<code>green</code> 和 <code>blue</code> 各一个。</p>
<hr>
<h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>元组允许你通过一个值来存储几个值。 听起来跟数组很像，但元组有所不同：你不能往元组中添加或者删除元素 —— 元组的长度是固定的。你不能改变元组中元素的类型 —— 元组创建时内部的元素类型必须是一致的。</p>
<p>你可以通过位置或者名称来访问元组中的元素。但是 Swift 不允许你访问不存在的位置或者名称。</p>
<p>元组的创建方式是把一组值放进圆括号中，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = (first: <span class="string">"Taylor"</span>, last: <span class="string">"Swift"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>你可以通过从 0 之类的位置信息来访问元组的元素：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">name.<span class="number">0</span></span><br></pre></td></tr></tbody></table></figure>
<p>或者你也可以通过名称来访问元组的元素：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">name.first</span><br></pre></td></tr></tbody></table></figure>
<p>在元组创建之后，你可以改变其中元素的值，但是不能改变它们的类型。因此，如果你尝试把 name 改成 (first: “韩梅梅”，age: 25) ，将会遭遇错误。</p>
<hr>
<h1 id="数组-vs-集合-vs-元组"><a href="#数组-vs-集合-vs-元组" class="headerlink" title="数组 vs 集合 vs 元组"></a>数组 vs 集合 vs 元组</h1><p>数组，集合和元组第一眼看上去很相似，但它们的用途是有区别的。为了帮助你更好地选择，这里有一些规则供参考：</p>
<p>如果你需要存放的元素是关联在一起被使用的，它们的个数固定，顺序或者名称也相对固定，那么你应当使用元组。举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> address = (门牌号: <span class="number">666</span>, 街道: <span class="string">" 朝阳区某街道 &amp; quot;</span>, 城市: <span class="string">" 北京 &amp; quot;</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>如果你需要一个合集，其中的元素必须是唯一的，或者你可能需要快速地检验合集里有没有包含某个元素，那么你应当使用集合。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> shoppingList = <span class="type">Set</span>([<span class="string">" 苹果 &amp; quot;</span>, <span class="string">" 肉 &amp; quot;</span>, <span class="string">" 牛奶 &amp; quot;</span>])</span><br></pre></td></tr></tbody></table></figure>
<p>如果你需要一个合集，其中的元素允许重复，或者合集中元素的顺序对你来说很重要，那么你应当使用数组。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pingpongScores = [<span class="string">"11-7"</span>, <span class="string">"8-11"</span>, <span class="string">"11-9"</span>, <span class="string">"8-11"</span>, <span class="string">"11-5"</span>, <span class="string">"13-11"</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>三种类型中，数组是最常用的。</p>
<hr>
<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典也是用于存储一组值的合集。但跟数组用整数的位置来访问元素的方式不同的是，在字典里你可以用任何你想要的类型来充当访问标识。</p>
<p>当然，最常见的存储字典的访问标识是字符串。举个例子，我们可以创建一个基于运动员的名字来访问运动员的身高的字典：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> top3NBAHeights = [</span><br><span class="line">  <span class="string">" 马努特 波尔 &amp; quot;</span>: <span class="number">2.31</span>,</span><br><span class="line">  <span class="string">" 姚明 &amp; quot;</span>: <span class="number">2.28</span>,</span><br><span class="line">  <span class="string">" 里克 施密茨 &amp; quot;</span>: <span class="number">2.23</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>就像数组一样，字典也以方括号开始和结束，里面的元素通过逗号分隔。此外，为了把一个值（例如 2.28）存放到对应的标识（例如 “姚明”）下面，你还得用到一个冒号。</p>
<p>这些访问标识被称为 “键”，相对应的是 “值”。我们用键来读取值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">top3NBAHeights [<span class="string">" 姚明 &amp; quot;</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>注意：如果你想使用类型注解，数组是通过方括号加里面的键值对类型来表示的，键值对又通过冒号分隔。举个例子， <code>[String: Double]</code> 或者 <code>[String: String]</code> 。</p>
<h2 id="字典默认值"><a href="#字典默认值" class="headerlink" title="字典默认值"></a>字典默认值</h2><p>如果你试图通过一个不存在于字典中的键读取字典中的值时， Swift 会返回给你一个 nil 。它代表没有东西。当然，这可能就是你想要 Swift 在找不到目标时返回给你的结果。不过，我们还有另外一种选择：当给定的键对应的值不存在时，我们可以指定一个默认的值返回给访问者。</p>
<p>为了演示这种操作，我们先创建一个包含了两个人最喜欢的冰淇淋的字典：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> favoriteIceCream = [</span><br><span class="line">  <span class="string">" 小明 &amp; quot;</span>: <span class="string">" 巧克力 &amp; quot;</span>,</span><br><span class="line">  <span class="string">" 小红 &amp; quot;</span>: <span class="string">" 香草 &amp; quot;</span></span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以像这样读取小明最喜欢的冰淇淋：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">favoriteIceCream [<span class="string">" 小明 &amp; quot;</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>但是当我们试图读取小华最喜欢的冰淇淋时，我们会得到一个 nil ，这代表 Swift 没有在字典里找到对应 “小华” 这个键的值。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">favoriteIceCream [<span class="string">" 小华 &amp; quot;</span>]</span><br></pre></td></tr></tbody></table></figure>
<p>这种情况下，我们可以通过指定一个默认值，比如说 “未知”，来解决这个问题。这样做之后， 当 Swift 没有从字典中找到小华最喜欢的冰淇淋时，我们得到的不再是一个 nil ，而是一个 “未知” 字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">favoriteIceCream [<span class="string">" 小华 &amp; quot;</span>, <span class="keyword">default</span>: <span class="string">" 未知 &amp; quot;</span>]</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="创建空的合集"><a href="#创建空的合集" class="headerlink" title="创建空的合集"></a>创建空的合集</h1><p>数组，集合和字典都属于合集，因为它们都是把分散的值收集起来放在一处的结构。</p>
<p>如果你想要创建一个空的合集，只需要写上类型名，然后加上一组圆括号。举个例子，创建一个键和值的类型都是 <code>String</code> 的字典，我们可以这样书写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> teams = [<span class="type">String</span>: <span class="type">String</span>]()</span><br></pre></td></tr></tbody></table></figure>
<p>之后添加元素，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">teams [<span class="string">" 小红 &amp; quot;</span>] = <span class="string">" 红色 &amp; quot;</span></span><br></pre></td></tr></tbody></table></figure>
<p>类似的，你可以像这样创建一个 <code>Int</code> 类型的空数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> results = [<span class="type">Int</span>]()</span><br></pre></td></tr></tbody></table></figure>
<p>创建集合是一个例外，方式稍有不同：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> words = <span class="type">Set</span>&lt;<span class="type">String</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> numbers = <span class="type">Set</span>&lt;<span class="type">Int</span>&gt;()</span><br></pre></td></tr></tbody></table></figure>
<p>这是因为 Swift 只为字典和数组提供了特殊的语法，其他类型都必须使用尖括号来声明类型信息，就像集合那样。</p>
<p>当然，也可以不使用特殊语法，通过和集合类似的标准方式创建字典和数组：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scores = <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Int</span>&gt;()</span><br><span class="line"><span class="keyword">var</span> results = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;()</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举，通常简称 <code>enums</code> ，是一种定义一组高度关联的值的方式。它使得这组关联的值使用起来更方便。为什么这么说呢？</p>
<p>想象一下，如果你想要写一些代码表示正在做的某件事情的结果，成功或者失败，你选择了使用字符串来表示这个结果：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result = <span class="string">"failure"</span></span><br></pre></td></tr></tbody></table></figure>
<p>不过，有人不小心写错了或者采用了不同的拼写，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result2 = <span class="string">"failed"</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="string">"fail"</span></span><br></pre></td></tr></tbody></table></figure>
<p>上面几行表示失败的字符串都各不相同，所以它们代表不一样的东西，无法让你基于失败这一结果的代码被正确执行。</p>
<p>而有了枚举，我们可以定义一个叫做 <code>Result</code> 的类型，它既可以是 <code>success</code> ，也可以是 <code>failure</code> ，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> success</span><br><span class="line">  <span class="keyword">case</span> failure</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在，当我们再想要表示结果时，只需要从两个值中选择一个：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> result4 = <span class="type">Result</span>.failure</span><br></pre></td></tr></tbody></table></figure>
<p>这样做的好处是可以避免书写不一致字符串导致跟预期不匹配的情况发生。</p>
<h2 id="枚举关联值"><a href="#枚举关联值" class="headerlink" title="枚举关联值"></a>枚举关联值</h2><p>除了可以存储简单的值，枚举还可以存储附属于每个 <code>case</code> 的关联值。这个特性使得你可以为枚举附加额外的数据，从而让它们传达更多细微的信息。</p>
<p>举个例子，我们可以定义一个枚举，它存放了各种各样的活动类型：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Activity</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> bored</span><br><span class="line">  <span class="keyword">case</span> running</span><br><span class="line">  <span class="keyword">case</span> talking</span><br><span class="line">  <span class="keyword">case</span> singing</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的枚举类型存储的信息，可以让我们知道有人在讲话，但我们不知道讲话的内容，或者可以让我们知道有人在跑步，但我们不知道他们将跑去哪里。</p>
<p>通过枚举的关联值，我们添加额外的细节：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Activity</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> bored</span><br><span class="line">  <span class="keyword">case</span> running (destination: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> talking (topic: <span class="type">String</span>)</span><br><span class="line">  <span class="keyword">case</span> singing (volume: <span class="type">Int</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们有了更精确的信息。我们可以说某人正在谈论足球：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> talking = <span class="type">Activity</span>.talking (topic: <span class="string">"football"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="枚举原始值"><a href="#枚举原始值" class="headerlink" title="枚举原始值"></a>枚举原始值</h2><p>有的时候你可能想给枚举赋予一些原始值从而让它们可以表达某种含义。这么做可以让你动态地创建枚举，并且以不一样的方式来使用它们。</p>
<p>举个例子，你可以创建一个名叫 <code>Planet</code> 的枚举，然后让它的每条 case 存储一个整数：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> mercury</span><br><span class="line">  <span class="keyword">case</span> venus</span><br><span class="line">  <span class="keyword">case</span> earth</span><br><span class="line">  <span class="keyword">case</span> mars</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Swift 会为这些 case 自动分配一个数字，同样的，是从 0 开始。你可以利用这些数字创建枚举的 case 。举个例子， <code>earth</code> 会被分配到数字 2 ，于是你可以这么创建一个 <code>earth</code> 的 case ：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> earth = <span class="type">Planet</span>(rawValue: <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>如果你自行指定了一个或者几个 case 的原始值， Swift 可能会自动为剩下的 case 生成原始值，只要这些值是可以被 Swift 推断的。比如把地球算作第 2 颗行星来考虑可能不太自然（因为我们一般说它是九大行星中的第 3 颗)，于是你可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Planet</span>: <span class="title">Int</span> </span>{</span><br><span class="line">  <span class="keyword">case</span> mercury = <span class="number">1</span></span><br><span class="line">  <span class="keyword">case</span> venus</span><br><span class="line">  <span class="keyword">case</span> earth</span><br><span class="line">  <span class="keyword">case</span> mars</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这样一来 Swift 就会给 <code>mercury</code> 分配数字 1 ，后面的数字基于前面的往上加， <code>earth</code> 就变成第 3 颗行星了。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ul>
<li>数组，集合，元组和字典让你可以通过单一对象存储一组值。它们实现这一点的方式各有不同，所以你需要根据具体场景来决定采用哪一种结构。</li>
<li>数组按顺序存储数据，你可以往里面添加或者删除元素，并通过位置来读取。</li>
<li>集合不按顺序存储数据，所以你不能通过位置来访问，但它提供了元素不重复的特性。</li>
<li>元组长度固定，你可以给里面的每个元素取名。这样就既可以通过位置，也可以通过名字来读取。</li>
<li>字典根据键来存储数据，因此读取元素时要用到键。</li>
<li>枚举是一种分组关联值的方法，帮你避免拼写错误。</li>
<li>你可以为枚举的每条 <code>case</code> 设置原始值，同时还可以为它们附加关联值来提供额外的信息。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>极速 Swift 教程之一 | 简单类型</title>
    <url>/programming/swiftswift-simple-types/</url>
    <content><![CDATA[<p>欢迎关注微信公众号「Swift 花园」</p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>当你启动 Xcode 时，它会询问你想要做的事情，选择 “Get Started with a Playground” 。 Playground 是一个可以供你输入 Swift 代码并立即看到结果的沙盒环境。</p>
<p>默认的， Xcode 将提供一个 iOS 编程环境的空白 Playground, 点击 Next，然后再点击 Create ，将 Playground 保存到你的系统桌面。</p>
<p>在本文中，我将向你介绍 “变量”，它们是你用来存储程序数据的地方。之所以被称为 “变量”，是因为它们可变，即你可以自由地改变它们的值。</p>
<p>我们将从在 Playground 中的第一行代码开始了解 “变量”，它是一行创建了一个名称为 “str” ， 值为 “Hello, playground” 的字符串变量的代码。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"Hello, playground"</span></span><br></pre></td></tr></tbody></table></figure>
<p>这行代码创建了一个名为 <code>str</code> 的新变量，并给它赋值为 “Hello, playground” 。在 Playground 右侧的输出区域你可以看到 “Hello, playground” – 这是 Xcode 在展示我们刚刚给 <code>str</code> 设置的值。</p>
<p>既然 str 是一个变量，我们就可以改变它:</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line">str = <span class="string">"Goodbye"</span></span><br></pre></td></tr></tbody></table></figure>
<p>第二次的时候，你不需要再写一次 <code>var</code> ，因为这个变量在前面已经被创建过了 – 我们只需要改变它。</p>
<a id="more"></a>

<hr>
<h1 id="字符串和整型"><a href="#字符串和整型" class="headerlink" title="字符串和整型"></a>字符串和整型</h1><p>Swift 是一门类型安全的编程语言，类型安全特指的含义包括：每一个变量都必须有一个特定的 “类型”。 Xcode 为我们创建的 str 变量拥有一个由字母组合 “Hello, playground” 组成的字符串，所以 Swift 为这个变量赋予了 <code>String</code> 类型。</p>
<p>换句话说，如果我们想存储一个人的年龄，那我们可能需要创建这样一个变量：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">38</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个变量拥有一个整数， 所以 Swift 赋予它 <code>Int</code> 类型 –  <code>Int</code> 是 “integer” 的简写。如果你的数比较大，Swift 允许使用下划线作为千位分隔符。这些分隔符不会改变数字代表的绝对数值，它们只是让数字阅读起来更方便。</p>
<p>例如：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> population = <span class="number">8_000_000</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>String</code> 和 <code>Int</code> 是不同的类型，不能混用。因此，你可以把 <code>str</code> 的值改成 “Goodbye”，但你不能把它改成 <code>38</code> ，因为 <code>38</code> 是一个 <code>Int</code> 类型，不是一个 <code>String</code> 类型。</p>
<hr>
<h1 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h1><p>标准的 Swift 字符串使用双引号表示，但在双引号之间你不能换行。如果你想要表示多行的字符串，需要使用将双引号首尾的引号个数由一个改成三个，就像下面这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str1 = <span class="string">""" </span></span><br><span class="line"><span class="string"> 这个字符串 </span></span><br><span class="line"><span class="string"> 跨越了 </span></span><br><span class="line"><span class="string"> 多行 </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure>
<p>Swift 对于书写这些引号有着特别的规定：开始的三个引号和结束的三个引号都必须独占一行，但它们占的那两行都不会算进最终的字符串里。假如你只是想利用多行字符串来使代码看起来更整洁，你可以通过在每行的行尾添加一个 \ 来确保换行不会进入最终的字符串，就像这样：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str2 = <span class="string">"""</span></span><br><span class="line"><span class="string"> 这个字符串 \</span></span><br><span class="line"><span class="string"> 看起来跨越了多行， \</span></span><br><span class="line"><span class="string"> 实际上没有 </span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="双精度浮点型和布尔型"><a href="#双精度浮点型和布尔型" class="headerlink" title="双精度浮点型和布尔型"></a>双精度浮点型和布尔型</h1><p>Swift 中还有两种基础的数据类型，它们是双精度浮点数类型和布尔类型，你将会经常用到它们。 <code>Double</code> 被用来代表 “双精度浮点数”，这是表示诸如 38.1 , 或者 3.141592654 这样的小数的一种高级的说法。每当你通过一个分数创建一个变量时， Swift 都会自动赋予这个变量 <code>Double</code> 类型。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pi = <span class="number">3.141</span></span><br></pre></td></tr></tbody></table></figure>
<p>双精度浮点数有别于整数，也不能混用。至于布尔类型则更简单一些：它们只有 <code>true</code> 和 <code>false</code> 两种值，所以当你用 <code>true</code> 或者 <code>false</code> 创建一个变量时， Swift 会自动赋予这个变量布尔类型。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> awesome = <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h1 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h1><p>你已经在前面学到了如何在代码中直接输入字符串的值，不过 Swift 还提供了一种被称为 “字符串插值” 的特性。这个特性允许你在字符串值里插入变量，从而动态地给一个 <code>String</code> 类型的变量赋值。在字符串内部，你可以放置任意类型，任意数量的变量。要放置这些变量，你需要以一个反斜杠开始，即 \，然后跟上用圆括号包起来的变量名。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> score = <span class="number">85</span> </span><br><span class="line"><span class="keyword">var</span> str = <span class="string">" 你的分数是 \(score)"</span></span><br></pre></td></tr></tbody></table></figure>
<p>你将会在 Playground 的输出区域里看到，上面的操作会把 <code>str</code> 变量的值设置为 “你的分数是 85”。</p>
<p>多尝试几次，通过字符串插值组合出任何你想要的字符串。</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> results = <span class="string">" 测试结果如下： \(str)"</span></span><br></pre></td></tr></tbody></table></figure>
<p>在之后你还会学到，字符串插值不仅可以用来放置变量，还可以用来运行代码。</p>
<hr>
<h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>前面提到变量之所以被称为变量是因为你可以随着时间的推移改变它们，这一点非常有用。不过，有些时候你只需要设置一次值然后就不再改变了，这种情况下我们使用常量。对应给变量用的 <code>var</code> 关键字，常量用 <code>let</code> 关键字表示。 <code>let</code> 关键字用来声明常量，常量的值只能被设置一次，并且无法被修改。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> taylor = <span class="string">"swift"</span></span><br></pre></td></tr></tbody></table></figure>
<p>如果你尝试改变常量的值， Xcode 会拒绝运行你的代码。这是一种安全机制，以防止你失手改变一些本来不应该被改变的东西。在书写 Swift 代码的时候，除非你明确想要改变，你应当尽量使用 <code>let</code> 关键字。实际上，如果你用了 <code>var</code> 声明变量但之后都没有再对它进行改变， Xcode 将会发出警告。</p>
<hr>
<h1 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h1><p>Swift 基于变量和常量在创建时被赋予的值为它们分配了一个类型。因此，当你书写如下的代码时， Swift 知道这里面包含了一个字符串：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"Hello, playground"</span></span><br></pre></td></tr></tbody></table></figure>
<p>它将把 <code>str</code> 当作一个 <code>String</code> 类型，因此之后你就不能再给它赋值一个整数值或者布尔值。这个过程被称为 ** 类型推断 **。 Swift 能够基于你创建一个东西的方式来推断它的类型。  如果你想显式地声明数据的类型而不是依赖 Swift 的类型推断，你可以这么写：</p>
<figure class="highlight swift"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> album: <span class="type">String</span> = <span class="string">"Reputation"</span> </span><br><span class="line"><span class="keyword">let</span> year: <span class="type">Int</span> = <span class="number">1989</span> </span><br><span class="line"><span class="keyword">let</span> height: <span class="type">Double</span> = <span class="number">1.78</span> </span><br><span class="line"><span class="keyword">let</span> <span class="keyword">is</span>: <span class="type">Bool</span> = <span class="literal">true</span></span><br></pre></td></tr></tbody></table></figure>
<p>留心布尔类型的缩写名是 <code>Bool</code> ，同样地，整数类型也是采用缩写的 <code>Int</code> 。</p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>让我们来总结一下。</p>
<ul>
<li>我们使用 <code>var</code> 来创建变量，使用 <code>let</code> 来创建常量。如无必要使用变量，应当尽可能地使用常量。 </li>
<li><code>String</code> 类型通常以双引号来开始和结束。如果你想要字符串能够跨越多行，则需要把引号替换为三个。 </li>
<li><code>Int</code> 类型存储整数，<code>Double</code> 存储小数，而 <code>Bool</code> 则存储 <code>true</code> 或者 <code>false</code>。 </li>
<li>字符串插值允许你通过在字符串内部放置其他的变量和常量的方式来创建新的字符串。 </li>
<li>Swift 通过类型推断来给变量或者常量分配类型，不过你也可以显式地提供类型。 </li>
</ul>
<hr>
]]></content>
      <categories>
        <category>programming</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Tech | Meteor rain - Randomly outside, but neatly inside 🔥🔥🔥</title>
    <url>/unity-portfolio/tfaces-game-match-hero-progress-daily-20191221/</url>
    <content><![CDATA[<p>Our team recently researched the special effects of “Flame Rain” and found many other developers’ solutions from the Internet. They were not very satisfactory for us, mainly because they could not meet the requirements of randomness and precise control at the same time. Finally, we decided to develop a component by ourselves.</p>
<p>We make use of the “machine gun” component which we develop previously. Machine guns can aim at targets and emit particle effects. The related API and prefabs support multiple targets, bullet prefabs, and the gun body can be rotated.</p>
<p>Our idea is to use many “machine guns” to build a “cloud”. This “cloud” can cause a regional “ball rain” attack on the ground.<br>Of course, this cloud is virtual, and it is not necessary to use render in the scene, it is only used to deploy machine guns. The machine gun is also invisible.</p>
<p>Here is the demo scene we used to verify the bullet cloud function during development:</p>
<p><img src="/images/bullet_cloud.png" width="68%" height="68%" style="margin: 10 auto;"></p>
<p>Because the bullet cloud is usually invisible in the actual scene, you can deploy a bullet cloud anywhere. However, considering the time of flight of the particles, you need to decide the height of the cloud yourself. We implemented it as a well-encapsulated component. You can configure it with any number of raindrops to hit the target precisely (of course, there can be multiple targets), the amount of hit you want to happend on each target, which bullets you want to use. And, there are many other bullets which looks like randomly drop, but actually they are configured by us.</p>
<p>When deploying the bullet cloud to your own scene, you need to pay attention to check the particle effects used as bullets, so you can ensure that there is no layer which can collide with your target.</p>
<p>We applied the previously implemented particles of various projectiles as cloud bullets, which triggered explosions based on physical collisions. At the same time, we determine whether a certain rain process of the bullet cloud is completed based on the collision. This API is necessary for the design of the skill system. Because we need to know when the skills we have released are over.</p>
<p>Of course, if you want to use purely mathematical methods to determine whether the bullet hits the target, this part needs to be implemented by yourself. Our bullet cloud can’t do that yet.</p>
<p>Using this bullet cloud to achieve the effect of “Flame Rain”, we are quite satisfied, because it has achieved both randomly effect and accuratly control on the damage. Because many of our game’s skill look randomly, but their damage amount is fixed.</p>
<p>The implementation logic is still quite complicated, try it:</p>
<figure class="highlight csharp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EnsurePreciseHitDrop</span>(<span class="params"><span class="keyword">int</span> _preciseHitCount = <span class="number">-1</span></span>)</span></span><br><span class="line"><span class="function"></span>        {</span><br><span class="line">            PreciseHitCount = _preciseHitCount == <span class="number">-1</span> ? preciseHitCountPreset : _preciseHitCount;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (PreciseHitCount &gt; <span class="number">0</span> &amp;&amp; Targets != <span class="literal">null</span> &amp;&amp; Targets.Length &gt; <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                PreciseHitDrop = <span class="keyword">new</span> Aimer[PreciseHitCount];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (PreciseHitCount == <span class="number">1</span>)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (Targets.Length == <span class="number">1</span>)</span><br><span class="line">                    {</span><br><span class="line">                        PreciseHitDrop[<span class="number">0</span>] = CenterDrop;</span><br><span class="line">                        preciseDropMaxIndexInAllDrop = <span class="number">0</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    {</span><br><span class="line">                        Vector3 target = Targets[Random.Range(<span class="number">0</span>, Targets.Length)];</span><br><span class="line"></span><br><span class="line">                        PreciseHitDrop[<span class="number">0</span>] = AllDrop[<span class="number">1</span>];</span><br><span class="line">                        PreciseHitDrop[<span class="number">0</span>].transform.position = DropMoveToAimAtTarget(target);</span><br><span class="line"></span><br><span class="line">                        preciseDropMaxIndexInAllDrop = <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (PreciseHitCount &gt; <span class="number">1</span> &amp;&amp; PreciseHitCount &lt;= DropCount)</span><br><span class="line">                {</span><br><span class="line">                    <span class="keyword">if</span> (Targets.Length == <span class="number">1</span>)</span><br><span class="line">                    {</span><br><span class="line">                        PreciseHitDrop[<span class="number">0</span>] = CenterDrop;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; PreciseHitCount; i++)</span><br><span class="line">                        {</span><br><span class="line">                            PreciseHitDrop[i] = AllDrop[i];</span><br><span class="line">                            PreciseHitDrop[i].transform.position = CenterDrop.transform.position;</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        preciseDropMaxIndexInAllDrop = PreciseHitCount - <span class="number">1</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (Targets.Length &gt; <span class="number">1</span>)</span><br><span class="line">                    {</span><br><span class="line">                        <span class="keyword">int</span> targetCount = Targets.Length;</span><br><span class="line">                        <span class="keyword">if</span> (EquallyAssignPreciseHit)</span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">int</span> quota = PreciseHitCount / targetCount;</span><br><span class="line">                            <span class="keyword">int</span> remain = PreciseHitCount % targetCount;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">int</span> allDropIndex = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">int</span> preciseDropIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> targetIndex = <span class="number">0</span>; targetIndex &lt; targetCount; targetIndex++)</span><br><span class="line">                            {</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; quota; i++)</span><br><span class="line">                                {</span><br><span class="line">                                    PreciseHitDrop[preciseDropIndex] = AllDrop[allDropIndex];</span><br><span class="line">                                    PreciseHitDrop[preciseDropIndex].transform.position</span><br><span class="line">                                        = DropMoveToAimAtTarget(Targets[targetIndex]);</span><br><span class="line"></span><br><span class="line">                                    allDropIndex++;</span><br><span class="line">                                    preciseDropIndex++;</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (remain &gt; <span class="number">0</span>)</span><br><span class="line">                            {</span><br><span class="line">                                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; remain; j++)</span><br><span class="line">                                {</span><br><span class="line">                                    Vector3 target = Targets[Random.Range(<span class="number">0</span>, Targets.Length)];</span><br><span class="line"></span><br><span class="line">                                    PreciseHitDrop[preciseDropIndex] = AllDrop[allDropIndex];</span><br><span class="line">                                    PreciseHitDrop[preciseDropIndex].transform.position</span><br><span class="line">                                        = DropMoveToAimAtTarget(target);</span><br><span class="line"></span><br><span class="line">                                    allDropIndex++;</span><br><span class="line">                                    preciseDropIndex++;</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        {</span><br><span class="line">                            <span class="keyword">int</span> allDropIndex = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">int</span> preciseDropIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PreciseHitCount; i++)</span><br><span class="line">                            {</span><br><span class="line">                                Vector3 target = Targets[Random.Range(<span class="number">0</span>, Targets.Length)];</span><br><span class="line"></span><br><span class="line">                                PreciseHitDrop[preciseDropIndex] = AllDrop[allDropIndex];</span><br><span class="line">                                PreciseHitDrop[preciseDropIndex].transform.position</span><br><span class="line">                                    = DropMoveToAimAtTarget(target);</span><br><span class="line"></span><br><span class="line">                                allDropIndex++;</span><br><span class="line">                                preciseDropIndex++;</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        preciseDropMaxIndexInAllDrop = PreciseHitCount;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                {</span><br><span class="line">                    preciseDropMaxIndexInAllDrop = DropCount - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> System.InvalidOperationException(<span class="string">"Precise hit count exceed total drop count."</span>);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>]]></content>
      <categories>
        <category>unity-portfolio</category>
      </categories>
      <tags>
        <tag>programming</tag>
        <tag>unity</tag>
        <tag>portfolio</tag>
      </tags>
  </entry>
</search>
