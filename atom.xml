<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>The Infinite Game</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://theinfinitegame.tech/"/>
  <updated>2020-03-21T06:05:12.496Z</updated>
  <id>https://theinfinitegame.tech/</id>
  
  <author>
    <name>猫克杯</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Unity Tech | How to implement a ‘sacrifice’ skill - take bullets for companion 🐺🐺🐺</title>
    <link href="https://theinfinitegame.tech/unity-portfolio/tfaces-game-match-hero-progress-daily-20200310/"/>
    <id>https://theinfinitegame.tech/unity-portfolio/tfaces-game-match-hero-progress-daily-20200310/</id>
    <published>2020-03-21T02:22:05.000Z</published>
    <updated>2020-03-21T06:05:12.496Z</updated>
    
    <content type="html"><![CDATA[<p>In our latest game development, I implemented an interesting action: “jumping block”.</p><p>The team used this skill on the white wolf guard.  The specific skill is called “sacrifice”. 🤨</p><blockquote><p>Whenever the wolf leader around him receives deadly ballistic damage, the heroic white wolf guard will take a deep leap and block this damage for his boss.</p></blockquote><p>Here is the video demonstration:</p><video src="https://www.youtube.com/watch?v=LCN8_GVhync" type="video/mp4" controls="controls" width="100%" height="100%"></video><p>And here is the schematic diagram:</p><img src="/images/ward fellow by take a bullet for them.png" width="68%" height="68%" style="margin: 10 auto;"><p>The realization of the jumping block is very interesting 🤪. It is a combination of mathematics and physics.</p><p>Let’s skip the unimportant part and look directly at the most critical code:</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> A callback invoked when we find a particle(i.e. our bullet) is flying toward something</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="collisionInstance"&gt;</span>a manager contains information about the particle<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="estimatedArrival"&gt;</span>estimated time of flight<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">OnParticleHeadingToTarget</span>(<span class="params">ParticleCollisionInstance collisionInstance, <span class="keyword">float</span> estimatedArrival</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Check if the bullet is flying toward our fellow</span></span><br><span class="line">    <span class="keyword">if</span> (collisionInstance != <span class="literal">null</span> &amp;&amp; collisionInstance.HeadingTarget == wolfFellow.gameObject)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Calculate which point should I jump in order to take the bullet for my fellow</span></span><br><span class="line">        jumpSpot = collisionInstance.EvaluateNecessaryArrival(<span class="number">4f</span>, <span class="keyword">out</span> <span class="keyword">float</span> time);</span><br><span class="line">        <span class="comment">// of course, you should look at the bullet when you try to take it.</span></span><br><span class="line">        lookSpot = collisionInstance.gameObject.transform.position;</span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> Every creature has its react time when something happens</span></span><br><span class="line">        <span class="keyword">float</span> reactTime = (_dollAction <span class="keyword">as</span> WolfDollAction).WardJumpToApexDuration;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reactTime &lt;= time)</span><br><span class="line">        {</span><br><span class="line">            Invoke(<span class="keyword">nameof</span>(WardFellow), time - reactTime);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Ward fellow, for wolf guard, warding is implemented by jump to take bullet for fellow</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WardFellow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    WolfDollAction wolfAction = _dollAction <span class="keyword">as</span> WolfDollAction;</span><br><span class="line"></span><br><span class="line">    wolfAction.TriggerJumpWard(wolfFellow, jumpSpot, lookSpot);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>the mathematical part, <code>EvaluateNecessaryArrival</code>：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> Evaluate necessary arrival which we must pass through</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="distanceToHeadingTarget"&gt;</span>distance for the arrival to the target<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;param name="estimatedTime"&gt;</span>out parameter, a estimated time by when we arrive<span class="doctag">&lt;/param&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span>the vector of the must-pass arrival<span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Vector3 <span class="title">EvaluateNecessaryArrival</span>(<span class="params"><span class="keyword">float</span> distanceToHeadingTarget, <span class="keyword">out</span> <span class="keyword">float</span> estimatedTime</span>)</span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Target</span></span><br><span class="line">    <span class="keyword">var</span> heading = HeadingTargetSpot - transform.position;</span><br><span class="line">    <span class="comment">// Distance</span></span><br><span class="line">    <span class="keyword">var</span> currentDistance = heading.magnitude;</span><br><span class="line">    <span class="comment">// Direction</span></span><br><span class="line">    <span class="keyword">var</span> direction = heading / currentDistance;</span><br><span class="line"></span><br><span class="line">    Vector3 arrival = HeadingTargetSpot + direction * -distanceToHeadingTarget;</span><br><span class="line">    estimatedTime = (currentDistance - distanceToHeadingTarget) / MainFlyingParticleVelocity.magnitude;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arrival;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>It’s not that difficult, right? 🙊  Hoping you enjoy this skill. 😬</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;In our latest game development, I implemented an interesting action: “jumping block”.&lt;/p&gt;
&lt;p&gt;The team used this skill on the white wolf g
      
    
    </summary>
    
    
      <category term="unity-portfolio" scheme="https://theinfinitegame.tech/categories/unity-portfolio/"/>
    
    
      <category term="programming" scheme="https://theinfinitegame.tech/tags/programming/"/>
    
      <category term="unity" scheme="https://theinfinitegame.tech/tags/unity/"/>
    
      <category term="portfolio" scheme="https://theinfinitegame.tech/tags/portfolio/"/>
    
  </entry>
  
  <entry>
    <title>用 “流水线” 设计拆解复杂处理流程</title>
    <link href="https://theinfinitegame.tech/development/programming-use-pipeline-to-tackle-complexity/"/>
    <id>https://theinfinitegame.tech/development/programming-use-pipeline-to-tackle-complexity/</id>
    <published>2020-03-17T03:32:12.000Z</published>
    <updated>2020-03-17T12:43:54.896Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>建议横屏阅读代码</p></blockquote><ul><li>本文的主要价值：提供一种抽象复杂逻辑，达成功能复用的思路</li><li>关键词：语义提炼、动态具名</li><li>本文约 4000 字，建议阅读时间 12 分钟。</li></ul><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在软件开发中，我们常常会遇到一种场景：随着产品功能的扩展，出现了多个具备高度相似性的功能单元。作为功能单元，它们可能有着相似的交互逻辑，提供同类的输入数据和输出数据。并且，对于用户来说，它们都在处理同一个的东西。</p><p>举个例子，比如一款修图 app ，它包含了一组编辑功能，每个功能都作用于一张图片，处理之后的图片，还可以作为其他功能的输入。作为编辑工具，在每个功能内部，可能还需要支持撤销和重做这样的用户操作。我们容易想到的是，这些功能间存在着许多可以进行复用设计的代码。</p><p>本文基于一次回顾发起，出于记录和分享的目的：一次代码重构，一款之前我参与开发的图像处理应用。</p><hr><h1 id="重构的具体背景"><a href="#重构的具体背景" class="headerlink" title="重构的具体背景"></a>重构的具体背景</h1><p>请看下面这幅图：</p><p><img src="/images/black_box.png" alt="某个图像功能模块的结构图"></p><p>元素不多，让我解释一下。图中的 “<strong>内存图像管理 + 效果处理</strong>” 是一个 “<strong>黑盒子</strong>”。“逻辑黑盒” 有的时候是好事，有的时候是坏事。那这里的黑盒子算好事还是坏事呢？ 既然对这种设计做了重构，多半是有痛点了。这里，我们重点探讨一下它的负面效应。 </p><p>在具体业务场景下，这个黑盒子有两个问题：</p><ul><li>图像处理接口粒度太大，难以复用代码；</li><li>图像 <strong>管理</strong> 和图像 <strong>效果处理</strong> 被绑定在一起。使得外部难以灵活的接触和使用图像。强调一下，管理和效果处理是两件事。前者是站在用户的角度，后者是站在服务提供者的角度。更高层应用逻辑的开发者，对于更底层支撑 API 的开发者来说，也是用户。</li></ul><h1 id="“管道”-概念的提炼"><a href="#“管道”-概念的提炼" class="headerlink" title="“管道” 概念的提炼"></a>“管道” 概念的提炼</h1><p>黑盒子的两个问题在重构时都得到了解决，但第一个问题与本文要分享的设计思想关联不大，不做展开。</p><p>为了说明我们是如何解决第二个问题的，这里先引入两个概念：“<strong>流水线</strong>” 和 “<strong>例程</strong>”。相信对于从事编程类工作的读者来说，这两个词不会陌生。</p><blockquote><p><strong>流水线</strong>  pipeline，[计] 又称管道，管线。<br><strong>例程</strong>  routine，[计] 程序；日常工作；例行公事</p></blockquote><p>在我们的案例中，<code>Pipeline</code> 相当于内存中的图像状态机，提供了基本的图像管理功能，例如加入图像，删除图像，复制图像，移动图像，等等。<code>Routine</code> 相当于各个图像功能单元中的通用事务，比如说，对于每个图像功能单元，都需要在其开始运作时从某处获得一份初始的图像，并在其结束运作时输出一份 <strong><em>最终的</em></strong> 图像到另一处。我们还约定，<code>Routine</code> 中的事务会基于 <code>Pipeline</code> 来完成。可以具体解释成这样：每个 <code>Routine</code> 都会包含一组典型的图像处理动作，这些处理动作借助一个或者多个 <code>Pipeline</code> 的通用操作，以及每个 <code>Pipeline</code> 的差异化操作来完成（后面会具体说明这个 <strong><em>差异化的图像处理步骤</em></strong>）。</p><p>从这里开始，我们不妨把 “<strong>流水线</strong>” 的叫法直接替换成 “<strong>管道</strong>”，因为后面会用到一些比喻性的描述，我个人它们觉得基于 “管道” 一词衍生出来，会比用 “流水线” 来得更自然。接下来，我们对 “管道” 这个意象再做进一步的挖掘，可以设计出下面这些对应关系（表格中左侧的概念只是一种比喻，读者可自行体会，这里不会详细解读）</p><div class="table-container"><table><thead><tr><th>比喻</th><th>原对象 </th></tr></thead><tbody><tr><td>“管道”</td><td>图像状态机</td></tr><tr><td>“流体”</td><td>图像</td></tr><tr><td>“节点”</td><td>图像状态</td></tr><tr><td>“流动”</td><td>图像状态流转</td></tr><tr><td>“锋面”(流体的最前端)</td><td>当前正在处理的图像状态</td></tr><tr><td>“连通性”</td><td>状态机内的图像以及图像状态机之间都是可串联的</td></tr></tbody></table></div><p>“流体” 是一个名词，它对应的是图像，涉及到存储模型。根据 “流体” 的特性，我们可以想象，或者说推断，管道里的图像存储模型应该会被设计为平行结构。</p><p>请读者联想一个类比， &lt;__化妆 / 整容  VS  软件上美化照片上的人脸__&gt; ，再思考一下，两者在存储模型和工序这两个方面有什么异同？ </p><p>回到正题，我配了五幅图来描述管道在具体实现中的五个特性：</p><ol><li>“流体” 由一系列 “节点” 组成。“节点”，即图像的状态，它的含义构成了我们对某一个图像的本征性认知。通俗地讲，图像状态能够帮助我们在特定的场景下把不同的图像区分开来。举个例子，有协同开发的两位程序员，对于 “美颜” 和 “滤镜” 这两个步骤的认知达成了共识。于是，我们就可以建立两个节点：“美颜”、“滤镜”，然后在开发过程中使用这两个节点来 <em>协作</em> 。注意，图像状态不是图像本身。对于图像状态的代码实现，我们可以使用一个极轻量的数据结构 —— 字符串。它体现的是 <strong>占位符思想</strong>，而我想要强调占位符的三个重要好处：它们是 <strong>可预见的</strong>（基于认知共识）、<strong>可预置的</strong>（很轻量）、<strong>可固化的</strong>（可复用代码的一个内在要求）。</li></ol><p><img src="/images/nodes.png" alt="节点及同位节点"></p><ol><li>“管道” 通过衔接 “节点” 构成 “连通”。在 “节点” 中，有必要特别介绍的是 “同位节点”。它指的是：几个步骤在 <strong>同一个图像</strong> 上先后发生。在时间上有先后，但在空间上始终操作同一份存储。我后面会再用到这个描述。</li></ol><p><img src="/images/connectivity.png" alt="连通性"></p><ol><li><p>“流动” 的 “流体” 会有一个 <strong>最前部</strong> ，就好像水流的最前端，又称为 “锋面” (Waterfront)，对应着这样一个事实：“管道” 中所有的图像，在同一时间里，只会有 <strong>唯一的</strong> 图像处于 <strong>可操作</strong> 的状态，这个状态代表着 <strong>图像的变化趋势</strong> 。具体到代码实现，可能会是一组带有 <em> 同步关键字 </em> 的方法，加上一个唯一的指向当前状态的指针。我们通过 <strong>引导</strong> 和 <strong>操刀</strong> 这个趋势，把图像 “引向” 最终要呈现出来的样子。在图示中，我有意使用了绿色代表原始的、最初的，使用红色代表成熟的、完全体的。<code>Pipeline</code> 专注于做一件事：把图像从一种状态转化为另外一种状态。这期间，可能要经历多个 “节点”，而 “锋面” 的意义就在于，它保证了一件事。那就是 <code>Pipeline</code> 的操刀者可以确信，这一刻只有他自己在引导图像的 “流向”，没有人会干扰到他。</p><p><img src="/images/waterfront.png" alt="锋面"></p></li><li><p>“流动” 可以是双向的（相比生产车间的 “流水线”，“管道” 之所以更贴切，在于后者可以实现双向的流动，对应到图像，相当于实现反向编辑，或者说撤销到一个处理步骤之前的状态）</p></li><li><p>“流体” 如果 “分流”，则可以出现多个 “锋面”，对应着图像的 <strong>并行处理</strong> 。</p><p><img src="/images/shunt.png" alt="分流"></p></li></ol><h1 id="“管道”-的具体实现"><a href="#“管道”-的具体实现" class="headerlink" title="“管道” 的具体实现"></a>“管道” 的具体实现</h1><p>如前所述，“流体” 其实就是图像，简单封装即可。我们主要实现的是 “<strong>节点</strong>”、“<strong>锋面</strong>”、 “<strong>流动</strong>” 和 “<strong>连通</strong>”。</p><h2 id="节点的实现方案和意义"><a href="#节点的实现方案和意义" class="headerlink" title="节点的实现方案和意义"></a>节点的实现方案和意义</h2><p>我们先来看一种典型的图像处理过程中可能会采用的写法，代码为 swift 实现：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 图像 xyz</span></span><br><span class="line"><span class="keyword">var</span> xyz: <span class="type">MyImage</span></span><br><span class="line"><span class="comment">// 图像 ijk</span></span><br><span class="line"><span class="keyword">var</span> ijk: <span class="type">MyImage</span></span><br><span class="line"><span class="comment">// 图像 abc </span></span><br><span class="line"><span class="keyword">var</span> abc: <span class="type">MyImage</span></span><br></pre></td></tr></tbody></table></figure><p>当然，现代编程语言的语法特性，可以让你省去写各种 getter/setter 的样板代码，从而节省代码量。但这不是重点，重点在于 —— 上述这种代码无法复用。因为每一个图像的引用都被赋予了 <strong>具体</strong> 的含义：同样的写法不太可能完全地适用于另外一个图像处理场景。比如说，另外那个图像处理场景很可能不会用到描述为 ijk 的图像，可能会用到描述是 uvw 的图像。因此，采取这种写法会遇到的一个典型问题是：每新增一个图像处理场景，我们都需要新增若干个特定描述的图像声明。在编码层面，这无疑是一项繁冗的工作。</p><p>上面说的图像引用，其实正是我们的图像 “管道” 里的某个 “节点”。思考一个问题，如果要对 “节点” 实现代码复用，你会怎么做？稍微提示一下，关键在于 “<strong>具体</strong>” 这两个字。</p><p>是的，如果我们能想到，上面的写法中代码之所以不能复用，根源在于图像引用的用途已经被 <strong>具体定义</strong>（同时也是被具体 <strong>约束</strong>），那么我们就更有可能往这样一个方向思考问题的解决方案：能不能把图像引用 “去具体化” ，让它的含义在具体场景到来时才被赋予呢？</p><p>讲到这一层，有些读者可能已经想到一种数据结构 —— 字典。是的，没有什么奇淫巧技，只用字典，就能实现 “去具体化”，解决这个代码复用问题中的最大障碍 —— 既然无法预知我们可能需要处理什么样的图像，可能需要处理多少份图像，并且这些未知数总是易变的，那为什么不让具体场景的使用者来 <strong>动态添加</strong> 这些图像引用，并且为它们具名呢？图像部分被复用的代码，这里只声明了一样东西，就是从图像状态表述到图像引用的映射表。它提供了一个之前的写法不具备的特点，而这个特点是达成复用的必要前提：图像存取的方式是 <strong>统一的</strong>，<strong>有限的</strong>，从而是 <strong>可固化的</strong>。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> stateTagToImageMap = [<span class="type">String</span>:<span class="type">MyImage</span>]()</span><br></pre></td></tr></tbody></table></figure><p>我们用一个 <strong>字符串标签</strong> 来表示图像的状态。对于图像 “管道” 的使用者来说，他只需要理解每个标签的含义，通过标签来存取图像并进行处理。在这些标签中，我们再提炼出几个具有通用含义的代表性标签：比如，<code>original</code> 代表 “<strong>最初的</strong>”，<code>processed</code> 代表 “<strong>加工完成的</strong>”，这正是前文提到的 <strong>占位符</strong> 。容易理解，在一份可复用的代码库中，你可以声明并且预置许多 <strong>占位符</strong> 。但你不会在这个代码库里声明同样数量的图像引用 —— 这样很奇怪对吧？哪怕从程序实现的角度来说，没有分配实际空间的引用并不一定会占据更多的内存。在后面列举的代码范例中，我们将会经常地用到 <code>original</code> 和 <code>processed</code> 这样的标签。</p><p>不妨阅读下面这段代码，这就是一种使用标签来操作对应图像的写法。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示两个处理步骤之后的图像 </span></span><br><span class="line">pipeline.from (.original) <span class="comment">// 从原始的图像开始 </span></span><br><span class="line">        .copyTo (.processed) <span class="comment">// 拷贝出一份图像用于处理，对应标签 processed</span></span><br><span class="line">        .doProcess (tag: .processed, specificProcess1)  <span class="comment">// 在 processed 上执行处理 1</span></span><br><span class="line">        .doProcess (tag: .processed, specificProcess2) <span class="comment">// 在 processed 上执行处理 2</span></span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed)) <span class="comment">// 取得 processed 标签代表的图像并且展示 </span></span><br></pre></td></tr></tbody></table></figure><h2 id="锋面的实现方案和意义"><a href="#锋面的实现方案和意义" class="headerlink" title="锋面的实现方案和意义"></a>锋面的实现方案和意义</h2><p>解决了 “节点” 的设计，我们再来看基于 “节点” 提炼出来的 “锋面” 要怎么设计。容易理解，“<strong>锋面</strong>” 是最前面的那个 “节点” ，具有 <strong>唯一性</strong>，对应具体的图像处理代码中就是 “当前正在被处理的那个图像”。在设计图像管道对外提供的处理 API 时，我们约定处理动作一定只能发生在这个 “<strong>当前的</strong>” 图像上，这样就能够保证我们的 “图像流” 总是按照我们想要的方向流动，并且在这个过程中，“图像流” 是不会被篡改的。这也是我们的图像编辑功能要实现撤销和重做功能的基本前提。</p><p>还是上面那段代码，现在可以去掉实际处理步骤的标签参数。因为我们约束了处理只能发生在 <strong>唯一的</strong>、<strong>当前的</strong> 图像上。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示一个处理步骤之后的图像 </span></span><br><span class="line">pipeline.from (.original) <span class="comment">// 从原始的图像开始 </span></span><br><span class="line">        .copyTo (.processed) <span class="comment">// 拷贝出一份图像用于处理，对应标签 processed</span></span><br><span class="line">        .doProcess (specificProcess1) <span class="comment">// 隐含了在 processed 上执行处理 1</span></span><br><span class="line">        .doProcess (specificProcess2) <span class="comment">// 隐含了在 processed 上执行处理 2</span></span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed)) <span class="comment">// 取得 processed 标签代表的图像并且展示 </span></span><br></pre></td></tr></tbody></table></figure><p>如果要求能够回撤到第一个处理步骤之后的状态，再做第二个处理步骤，并且第二个处理步骤的参数是可以改变的。可以这么做：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示一个处理步骤之后的图像，但我们在过程中保留了第一个步骤的状态 </span></span><br><span class="line">pipeline.from (.original)</span><br><span class="line">        .copyTo (<span class="string">"specificProcess1"</span>) <span class="comment">// 相比一步到位，这里多存储了第一个步骤的状态 </span></span><br><span class="line">        .doProcess (specificProcess1)</span><br><span class="line">        .copyTo (.processed)</span><br><span class="line">        .doProcess (specificProcess2.setParams (params1))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整第二个步骤的某些参数，重新显示图像 </span></span><br><span class="line">pipeline.from (<span class="string">"specificProcess1"</span>) <span class="comment">// 之前存储了第一个步骤的状态，直接从这个步骤开始 </span></span><br><span class="line">        .copyTo (.processed)</span><br><span class="line">        .doProcess (specificProcess2.setParams (params2))</span><br><span class="line"></span><br><span class="line">showImage (pipeline.fetch (.processed))</span><br></pre></td></tr></tbody></table></figure><h2 id="流动和连通性的实现方案"><a href="#流动和连通性的实现方案" class="headerlink" title="流动和连通性的实现方案"></a>流动和连通性的实现方案</h2><p>有了 “节点” 和 “锋面”，“流动” 和 “连通” 就有了作用的主体。对应到图像编辑功能，“<strong>流动</strong>” 其实就是图像从一个状态变成另外一个状态的过程。“<strong>连通</strong>” 则更好理解，一个管道出来的图像可以被另外一个管道接纳，由此构成管道之间的连接。连接在一起的每一节 “<strong>小管道</strong>” 各司其职，灵活组合，再构成更长跨度的 “<strong>大管道</strong>” 或者 “<strong>管道网络</strong>”，从而协同完成复杂的业务流程。</p><p>回归到代码，我们来看一组步骤稍多的图片处理工序，看它是如何体现出管道的 “流动性” 和 “连通性”。刨去内部的实现细节，整合或者忽略一些与管道设计思想关联不大的逻辑，以下代码在流程上算是比较接近实际生产环境了。虽然采用的是伪代码，相信读者可以看懂。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 主功能区，不妨将它的例程称为 Main</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 可以从这里进入各子功能处理图片再回到这里展示新的图片 </span></span><br><span class="line"><span class="comment"> * 3. 撤销到经过某个步骤处理之前的图像或者重做出之前做过但是被撤销掉的某个步骤的图像   </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineMain</span>.startFrom (imageFile) {</span><br><span class="line">    <span class="type">RoutineMain</span>.pipeline.loadFrom (imageFile, .original) <span class="comment">// 从图片中加载初始的图像 </span></span><br><span class="line">}</span><br><span class="line"><span class="type">RoutineMain</span>.showCurrent () {</span><br><span class="line">    showImage (<span class="type">RoutineMain</span>.pipeline.front () <span class="comment">// 显示 “锋面”</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美型” 的功能区，对应的例程称为 FaceLift</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸轮廓，五官进行形状调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineFaceLift</span>.startFrom (<span class="type">RoutineMain</span>.pipeline.front ().copy ())</span><br><span class="line"><span class="type">RoutineFaceLift</span>.process () {</span><br><span class="line">    <span class="type">RoutineFaceLift</span>.pipeline</span><br><span class="line">         <span class="comment">// 这个过程用户无法干预，不会有 “重做”，因此我们可以直接在原稿上操作 </span></span><br><span class="line">        .from (.original)</span><br><span class="line">        .doProcess (faceLift_step_1_process)</span><br><span class="line">        .doProcess (faceLift_step_2_process)</span><br><span class="line">        .doProcess (faceLift_step_3_process)</span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美型” 处理好的图像提交给主功能 </span></span><br><span class="line"><span class="type">RoutineMain</span>.accept (<span class="type">RoutineFaceLift</span>.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “滤镜” 的功能区，对应的例程称为 Filter</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 滤镜化处理图像 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像到主功能区 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineFilter</span>.startFrom (<span class="type">RoutineMain</span>.pipeline.front ().copy ());</span><br><span class="line"><span class="type">RoutineFilter</span>.process () {</span><br><span class="line">    <span class="type">RoutineFilter</span>.pipeline</span><br><span class="line">        <span class="comment">// 这个过程中用户决定要选用哪个具体的滤镜，因此每次都需要基于原稿复制一份再滤镜化 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"awful"</span>)))</span><br><span class="line">        ... <span class="comment">// 皱眉，这个不好，换一个！</span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"notbad"</span>)))</span><br><span class="line">        ... <span class="comment">// 托腮，这个还行，再换个试试～</span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (filterProcess (pickFilter (<span class="string">"perfect"</span>)))</span><br><span class="line">        ... <span class="comment">// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “滤镜” 处理好的图像提交给主功能 </span></span><br><span class="line"><span class="type">RoutineMain</span>.accept (<span class="type">RoutineFilter</span>.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 进入到一个叫 “美颜 ” 的功能区，对应的例程称为 SkinBeauty</span></span><br><span class="line"><span class="comment"> * 基本功能：</span></span><br><span class="line"><span class="comment"> * 1. 展示图像 </span></span><br><span class="line"><span class="comment"> * 2. 针对图像中的人脸皮肤进行色相调整 </span></span><br><span class="line"><span class="comment"> * 3. 输出处理后的图像给 Main 功能 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">RoutineSkinBeauty</span>.startFrom (<span class="type">RoutineMain</span>.pipeline.front ().copy ());</span><br><span class="line"><span class="type">RoutineSkinBeauty</span>.process () {</span><br><span class="line">    <span class="type">RoutineSkinBeauty</span>.pipeline</span><br><span class="line">        <span class="comment">// 这个过程用户可以调节一个滑竿来控制色相参数，每次都基于原稿复制一份再调色相 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_weak))</span><br><span class="line">        ... <span class="comment">// 托腮，效果好像不明显，加强一点 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_too_much)))</span><br><span class="line">        ... <span class="comment">// 皱眉，好像有点过头了，往回调一点 </span></span><br><span class="line">        .from (.original).copyTo (.processed)</span><br><span class="line">        .doProcess (skinBeautyProcess (level_just_right)</span><br><span class="line">        ... <span class="comment">// 完美～</span></span><br><span class="line">        ...</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 把子功能 “美颜” 处理好的图像提交给主功能 </span></span><br><span class="line"><span class="type">RoutineMain</span>.accept (<span class="type">RoutineSkinBeauty</span>.commit ())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 纠结一下。。</span></span><br><span class="line"><span class="comment">// 犹豫，要不还是不美颜了吧？</span></span><br><span class="line"><span class="type">RoutineMain</span>.undo ();</span><br><span class="line"><span class="comment">// 迟疑，滤镜也不要了？</span></span><br><span class="line"><span class="type">RoutineMain</span>.undo ();</span><br><span class="line"><span class="comment">// 思考中。。。</span></span><br><span class="line"><span class="comment">//... 不行，还是都加回来吧 </span></span><br><span class="line"><span class="type">RoutineMain</span>.redo ().redo ();</span><br><span class="line"><span class="comment">// 端详 5 分钟。。。完美～</span></span><br><span class="line">save (); <span class="comment">// 收工，准备发朋友圈 </span></span><br></pre></td></tr></tbody></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>关于 “管道” 的设计思路和实现方案介绍到此。我们可以回顾一下，本文开始所提到 “黑盒子” 设计的第二个问题：“图像 <strong><em>管理</em></strong>  和图像 <strong><em>效果处理</em></strong>  被绑定在一起。”，在管道方案中是不是已经解决了呢？</p><blockquote><p>“管道” 设计的基石是 <strong>无差别地管理图像</strong> ，被管理的每一个图像，由最初将其投入管道的创建者为其定义标签。最初的创建者和后来的协同者，只需要对这个标签的含义达成 <strong>共识</strong> 便可以进行协作。“管道” 的思想是模拟 “<strong>流体</strong>” 的运行方式来实现图像处理过程，通过 “<strong>节点</strong>” 的设定来 <strong>分解</strong> 处理步骤，通过 “<strong>锋面</strong>” 的操控来 <strong>聚焦</strong> 每个单步的操作，通过 <strong>连通性</strong> 来将 <strong>分治</strong> 的逻辑重新 <strong>串联</strong> 起来完成复杂的功能。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;建议横屏阅读代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;本文的主要价值：提供一种抽象复杂逻辑，达成功能复用的思路&lt;/li&gt;
&lt;li&gt;关键词：语义提炼、动态具名&lt;/li&gt;
&lt;li&gt;本文约 4000 字，建议阅读时间 12 分钟。&lt;/l
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
      <category term="programming" scheme="https://theinfinitegame.tech/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>SwiftUI 笔记 | MVVM In SwiftUI</title>
    <link href="https://theinfinitegame.tech/development/note-swiftui-mvvm/"/>
    <id>https://theinfinitegame.tech/development/note-swiftui-mvvm/</id>
    <published>2020-03-02T02:51:18.000Z</published>
    <updated>2020-03-02T06:40:55.145Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>译自 <a href="https://augmentedcode.io/2020/01/05/mvvm-in-swiftui/" target="_blank" rel="noopener">MVVM in SwiftUI</a></p></blockquote><p>让我们用 MVVM (model-view-view model) 来构建一个应用，其中的每个 SwiftUI 视图都有自己的 model 。这会是一个拥有两个视图的 app : 一个电影列表以及一个用于添加电影的表单。新增的电影存在在 <code>MovieStore</code> ，它由两个 view models 共享。我们将通过 environment 来共享 MovieStore ，也就说，当我们需要时，会从 environment 中读取。</p><h2 id="用-Movie-和-MovieStore-来表示数据"><a href="#用-Movie-和-MovieStore-来表示数据" class="headerlink" title="用 Movie 和 MovieStore 来表示数据"></a>用 Movie 和 MovieStore 来表示数据</h2><p>Movie 是一个很小的结构体，只存储了标题和评分。标题和评分都是可变的，因为我们需要在 AddMovieView 里更新它们。这个结构体也遵循 <code>Identifiable</code> 协议，因为我们将用 List 视图来展示所有的电影。List 需要能够标识内容中的每一项，而遵循这个协议是最简单的方式。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Movie</span>: <span class="title">Equatable</span>, <span class="title">Identifiable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id = <span class="type">UUID</span>()</span><br><span class="line">    <span class="keyword">var</span> fullTitle: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> givenRating: <span class="type">Rating</span> = .notSeen</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Movie</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Rating</span>: <span class="title">Int</span>, <span class="title">CaseIterable</span> </span>{</span><br><span class="line">        <span class="keyword">case</span> notSeen, terrible, poor, decent, good, excellent</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>MovieStore 也很简单，不过实际的 app 会包含更多的逻辑：持久化，删除等等。我们用 <code>Published</code> 属性包装器来为订阅者自动提供发布。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MovieStore</span> </span>{</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> allMovies = [<span class="type">Movie</span>]()</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(<span class="number">_</span> movie: Movie)</span></span> {</span><br><span class="line">        allMovies.append (movie)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了将共享的 <code>MovieStore</code> 插入环境，我们需要使用自定义的 EnvironmentKey 。自定义 key 仅仅只是一个遵循  <code>EnvironmentKey</code> 协议的自定义 key 。我们需要提供类型和默认值。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MovieStoreKey</span>: <span class="title">EnvironmentKey</span> </span>{</span><br><span class="line">    <span class="keyword">typealias</span> <span class="type">Value</span> = <span class="type">MovieStore</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">var</span> defaultValue = <span class="type">MovieStore</span>()</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">EnvironmentValues</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> movieStore: <span class="type">MovieStore</span> {</span><br><span class="line">        <span class="keyword">get</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>[<span class="type">MovieStoreKey</span>]</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">set</span> {</span><br><span class="line">            <span class="keyword">self</span>[<span class="type">MovieStoreKey</span>] = newValue</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如果我们不插入自己的 <code>MovieStore</code> 实例到 environment ，那就会使用 defaultValue 默认值。典型情况下，我们会在视图体系之外初始化这个特定实例。</p><h2 id="SceneDelegate-和-MovieScene-呈现"><a href="#SceneDelegate-和-MovieScene-呈现" class="headerlink" title="SceneDelegate 和 MovieScene 呈现"></a>SceneDelegate 和 MovieScene 呈现</h2><p>MovieStore 作为依赖项，在构造函数被传给 view model 。我们将使用存储在 SceneDelegate 的实例。再次申明，在实际的 app 中，这种依赖项很可能是处于一个独立的容器或者别的类似的东西。 MovieListView 是我们要呈现的第一个视图，因此我们会初始化 view model ， view ，并且插入 MovieStore 实例到 environment ，以便后续使用。 (movieStore keypath 是通过 EnvironmentValues 的 extension 来定义的)。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SceneDelegate</span>: <span class="title">UIResponder</span>, <span class="title">UIWindowSceneDelegate</span> </span>{</span><br><span class="line">    <span class="keyword">var</span> window: <span class="type">UIWindow?</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> movieStore = <span class="type">MovieStore</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">scene</span><span class="params">(<span class="number">_</span> scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions)</span></span> {</span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">MovieListView</span>.<span class="type">ViewModel</span>(movieStore: movieStore)</span><br><span class="line">        <span class="keyword">let</span> contentView = <span class="type">MovieListView</span>(viewModel: viewModel).environment (\.movieStore, movieStore)</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> windowScene = scene <span class="keyword">as</span>? <span class="type">UIWindowScene</span> <span class="keyword">else</span> { <span class="keyword">return</span> }</span><br><span class="line">        <span class="keyword">let</span> window = <span class="type">UIWindow</span>(windowScene: windowScene)</span><br><span class="line">        window.rootViewController = <span class="type">UIHostingController</span>(rootView: contentView)</span><br><span class="line">        <span class="keyword">self</span>.window = window</span><br><span class="line">        window.makeKeyAndVisible ()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="MovieListView-和对应的-ViewModel"><a href="#MovieListView-和对应的-ViewModel" class="headerlink" title="MovieListView 和对应的 ViewModel"></a>MovieListView 和对应的 ViewModel</h2><p>在 SwiftUI 中，view model 遵循 <code>ObservableObject</code> 协议，使用 @Published 属性包装器。 ObservableObject 的默认实现提供了 <code>objectWillChange</code> publisher 。 @Published 属性包装器能在属性将要改变时自动发射这个 publisher 。在 MovieListView 中，我们用 @ObservedObject 属性包装器声明 view model 属性。这会使得该视图订阅 objectWillChange publisher ，并且在 objectWillChange 发动时自动刷新视图。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MovieListView</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">let</span> movieStore: <span class="type">MovieStore</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> cancellables = [<span class="type">AnyCancellable</span>]()</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">init</span>(movieStore: <span class="type">MovieStore</span>) {</span><br><span class="line">            <span class="keyword">self</span>.movieStore = movieStore</span><br><span class="line">            cancellables.append (movieStore.$allMovies.assign (to: \.movies, on: <span class="keyword">self</span>))</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> movies = [<span class="type">Movie</span>]()</span><br><span class="line">        @<span class="type">Published</span> <span class="keyword">var</span> isPresentingAddMovie = <span class="literal">false</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MovieListView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">Environment</span>(\.<span class="keyword">self</span>) <span class="keyword">var</span> environment</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">ViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">NavigationView</span> {</span><br><span class="line">            <span class="type">List</span>(<span class="keyword">self</span>.viewModel.movies) { movie <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(movie.fullTitle)</span><br><span class="line">            }.navigationBarTitle (<span class="string">"Movies"</span>)</span><br><span class="line">                .navigationBarItems (trailing: navigationBarTrailingItem)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> navigationBarTrailingItem: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: {</span><br><span class="line">            <span class="keyword">self</span>.viewModel.isPresentingAddMovie = <span class="literal">true</span></span><br><span class="line">        }, label: {</span><br><span class="line">            <span class="type">Image</span>(systemName: <span class="string">"plus"</span>).frame (minWidth: <span class="number">32</span>, minHeight: <span class="number">32</span>)</span><br><span class="line">        }).sheet (isPresented: <span class="keyword">self</span>.$viewModel.isPresentingAddMovie) {</span><br><span class="line">            <span class="keyword">self</span>.makeAddMovieView ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">makeAddMovieView</span><span class="params">()</span></span> -&gt; <span class="type">AddMovieView</span> {</span><br><span class="line">        <span class="keyword">let</span> movieStore = environment [<span class="type">MovieStoreKey</span>]</span><br><span class="line">        <span class="keyword">let</span> viewModel = <span class="type">AddMovieView</span>.<span class="type">ViewModel</span>(movieStore: movieStore)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">AddMovieView</span>(viewModel: viewModel)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你会注意到，MovieStore 时用了两份，一份在 view model 中，一份放在环境中。</p><p><code>AddMovieView</code> 和它的 view model 是在用户点击导航栏上的加号按钮时被创建的。环境属性包装器可以被用于获取整个环境或者借助特定键获取某个值。在这个案例中我们访问了整个环境对象，然后在需要的时候借助 MovieStoreKey 访问 MovieStore 。或者你也可以使用 @Environment (.movieStore) var movieStore 来代替。</p><h2 id="AddMovieView-和对应的-ViewModel"><a href="#AddMovieView-和对应的-ViewModel" class="headerlink" title="AddMovieView 和对应的 ViewModel"></a>AddMovieView 和对应的 ViewModel</h2><p><code>AddMovieView</code> 的 view model 是随着 MovieStore 一同被初始化的，它内部呈现了一个 Movie 实例。 Published 属性包装器和 MovieListView 的 view model 里的用法相似。 内部的 movie 对象是一个私有的属性， TextField 和 Picker 都采用双向 Binding 。 Binding 是一种 view 和 model 间的双向连接方式。另外，还有一个 <code>canSave</code> 属性，它是用来控制导航栏上的保存按钮是否启用。保持按钮只有在标题有填充的时才启用。</p><p>简单复习一下视图更新的流程：TextField 或者 Picker 会利用 Binding 来更新私有属性 <code>newMovie</code> 。 因为 newMovie 属性使用了 @Published 属性包装器，它会发射 ObservableObject 的 objectWillChange publisher 。 SwiftUI 自动订阅 objectWillChange ，因为 view model 的属性用了 @ObservedObject 。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">AddMovieView</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">let</span> movieStore: <span class="type">MovieStore</span></span><br><span class="line">         </span><br><span class="line">        <span class="keyword">init</span>(movieStore: <span class="type">MovieStore</span>) {</span><br><span class="line">            <span class="keyword">self</span>.movieStore = movieStore</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        @<span class="type">Published</span> <span class="keyword">private</span> <span class="keyword">var</span> newMovie = <span class="type">Movie</span>(fullTitle: <span class="string">""</span>)</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">lazy</span> <span class="keyword">var</span> title = <span class="type">Binding</span>&lt;<span class="type">String</span>&gt;(<span class="keyword">get</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.fullTitle</span><br><span class="line">        }, <span class="keyword">set</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.fullTitle = $<span class="number">0</span></span><br><span class="line">        })</span><br><span class="line">         </span><br><span class="line">        <span class="built_in">lazy</span> <span class="keyword">var</span> rating = <span class="type">Binding</span>&lt;<span class="type">Movie</span>.<span class="type">Rating</span>&gt;(<span class="keyword">get</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.givenRating</span><br><span class="line">        }, <span class="keyword">set</span>: {</span><br><span class="line">            <span class="keyword">self</span>.newMovie.givenRating = $<span class="number">0</span></span><br><span class="line">        })</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">var</span> canSave: <span class="type">Bool</span> {</span><br><span class="line">            <span class="keyword">return</span> !newMovie.fullTitle.isEmpty</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">save</span><span class="params">()</span></span> {</span><br><span class="line">            movieStore.add (newMovie)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AddMovieView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">Environment</span>(\.presentationMode) <span class="keyword">private</span> <span class="keyword">var</span> presentationMode</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">ViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">NavigationView</span> {</span><br><span class="line">            <span class="type">Form</span> {</span><br><span class="line">                titleSection</span><br><span class="line">                ratingSection</span><br><span class="line">            }.navigationBarTitle (<span class="string">"Add Movie"</span>, displayMode: .inline)</span><br><span class="line">                .navigationBarItems (leading: leadingBarItem, trailing: trailingBarItem)</span><br><span class="line">                .navigationViewStyle (<span class="type">StackNavigationViewStyle</span>())</span><br><span class="line">             </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> titleSection: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Section</span>() {</span><br><span class="line">            <span class="type">TextField</span>(<span class="string">"Title"</span>, text: viewModel.title)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ratingSection: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Section</span>() {</span><br><span class="line">            <span class="type">Picker</span>(<span class="type">LocalizedStringKey</span>(<span class="string">"Rating"</span>), selection: viewModel.rating) {</span><br><span class="line">                <span class="type">ForEach</span>(<span class="type">Movie</span>.<span class="type">Rating</span>.allCases, id: \.rawValue) {</span><br><span class="line">                    <span class="type">Text</span>($<span class="number">0</span>.localizedName).tag ($<span class="number">0</span>)</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> leadingBarItem: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: { <span class="keyword">self</span>.presentationMode.wrappedValue.dismiss () }, label: {</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Cancel"</span>)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> trailingBarItem: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">Button</span>(action: {</span><br><span class="line">            <span class="keyword">self</span>.viewModel.save ()</span><br><span class="line">            <span class="keyword">self</span>.presentationMode.wrappedValue.dismiss ()</span><br><span class="line">        }, label: {</span><br><span class="line">            <span class="type">Text</span>(<span class="string">"Save"</span>).disabled (!<span class="keyword">self</span>.viewModel.canSave)</span><br><span class="line">        })</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们创建了一个只有两个视图的简单 app 。两个视图都有各自的 view model ，并且都依赖 MovieStore 。一个 view model 中触发了 MovieStore 的改变，这些改变会被另一个 view model 观察到。另外，我们还了解了 SwiftUI 的 environment 以及如何从 view model 中触发 view 更新。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;译自 &lt;a href=&quot;https://augmentedcode.io/2020/01/05/mvvm-in-swiftui/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MVVM in SwiftUI&lt;/a&gt;&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
      <category term="swiftui" scheme="https://theinfinitegame.tech/tags/swiftui/"/>
    
  </entry>
  
  <entry>
    <title>note-swiftui-dynamic-user-notification-on-apple-watch</title>
    <link href="https://theinfinitegame.tech/uncategorized/note-swiftui-dynamic-user-notification-on-apple-watch/"/>
    <id>https://theinfinitegame.tech/uncategorized/note-swiftui-dynamic-user-notification-on-apple-watch/</id>
    <published>2020-03-01T09:08:42.112Z</published>
    <updated>2020-03-02T02:52:09.193Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: SwiftUI 应用 | 浇水提醒 app<br>top: false<br>date: 2020-03-01 17:08:42<br>tags:</p><ul><li>watchOS</li><li>development</li><li>swiftui<br>categories: development<br>description:</li></ul><hr><h1 id="用-SwiftUI-在-Apple-Watch-上构建动态通知"><a href="#用-SwiftUI-在-Apple-Watch-上构建动态通知" class="headerlink" title="用 SwiftUI 在 Apple Watch 上构建动态通知"></a>用 SwiftUI 在 Apple Watch 上构建动态通知</h1><blockquote><p>译自 <a href="https://augmentedcode.io/2020/02/02/dynamic-user-notification-on-apple-watch-with-swiftui/" target="_blank" rel="noopener">Dynamic user notification on Apple Watch with SwiftUI</a><br>源码地址：<a href="https://github.com/laevandus/WaterMyPlants" target="_blank" rel="noopener">WaterMyPlants</a></p></blockquote><p>集成了推送或者本地通知的 app 可以定制 apple watch 上的通知。本文是关于如何在 apple watch 上实现动态通知的笔记。样例工程实现一个提醒给植物浇水的功能。我们会聚焦在添加通知视图，省略从 iOS app 发送通知的步骤。</p><h2 id="为-Apple-Watch-添加富文本通知添加构建目标"><a href="#为-Apple-Watch-添加富文本通知添加构建目标" class="headerlink" title="为 Apple Watch 添加富文本通知添加构建目标"></a>为 Apple Watch 添加富文本通知添加构建目标</h2><p>如果工程里没有 App Watch app ，你需要添加它。在 Xcode 中，我们新增一个构建目标，并配置成包含通知场景。打开 New -&gt; Target:</p><p><img src="/images/watch_app_target.png" width="80%" height="80%" style="margin: 10 auto;"></p><p>确保 User Interface 选择，并且 “Include Notification Scene” 选中。我们将会把它嵌入当前的 iOS app ，所以 “Embed in Companion App” 要选择当前 app 。值得一提的是，从 iOS 13 和 WatchOS 6 开始，Apple Watch app 已经可以独立存在了。</p><p><img src="/images/watch_app_target_2.png" width="80%" height="80%" style="margin: 10 auto;"></p><p>点击完成，Xcode 会询问激活新的 scheme ，点击激活，它会自动选择新建的目标，所以我们可以直接开始写代码了。先检查工程，会发现 Xcode 加了两个目标：watch app 和 extension。App 包含了 storyboard ，而 extension 包含了所有的代码。 storyboard 是提供基于 <code>WKHostingController</code> 的子类的 HostingController 演示用的场景。这个类负责承载你的 Apple Watch app 的 SwiftUI 视图。另外，还有两个场景，分别是静态和动态通知。我们对动态通知感兴趣，在 storyboard 里可以看见动态视图是由 <code>NotificationController</code> 提供的，它是 <code>WKUserNotificationHostingController</code> 的子类，承载通知的 SwiftUI 视图。这里就是我们给通知提供自定义界面的地方。如果通知的分类和 storyboard 里预先定义的匹配，就会选择动态通知视图。</p><h2 id="解析通知的-payload-并设置动态通知视图"><a href="#解析通知的-payload-并设置动态通知视图" class="headerlink" title="解析通知的 payload 并设置动态通知视图"></a>解析通知的 payload 并设置动态通知视图</h2><p>NotificationController 的职责是消费用户通知的 payload ，并生成 SwiftUI 视图来展示它们。用户通知是从 <code>didReceive</code> 函数接收的，我们需要释放信息，用于视图。在本地测试的时候，我们可以把测试数据写在 <code>PushNotificationPayload.apns</code> 文件里。因为我们要展示的是关于植物的信息，所有我们添加一个植物对象到文件中。同时，我们还需要把通知分类修改成某个有含义的字符串。确保你设置新的分类时正确更新 storyboard 。</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">{</span><br><span class="line">    <span class="attr">"aps"</span>: {</span><br><span class="line">        <span class="attr">"alert"</span>: {</span><br><span class="line">            <span class="attr">"body"</span>: <span class="string">"Test message"</span>,</span><br><span class="line">            <span class="attr">"title"</span>: <span class="string">"Optional title"</span>,</span><br><span class="line">            <span class="attr">"subtitle"</span>: <span class="string">"Optional subtitle"</span></span><br><span class="line">        },</span><br><span class="line">        <span class="attr">"category"</span>: <span class="string">"WATERING_REMINDER"</span>,</span><br><span class="line">        <span class="attr">"thread-id"</span>: <span class="string">"plantid123"</span></span><br><span class="line">    },</span><br><span class="line">     </span><br><span class="line">    <span class="attr">"plant"</span>: {</span><br><span class="line">        <span class="attr">"id"</span>: <span class="string">"plantid123"</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"Aloe"</span>,</span><br><span class="line">        <span class="attr">"lastDate"</span>: <span class="number">1579937802</span>,</span><br><span class="line">        <span class="attr">"nextDate"</span>: <span class="number">1580515200</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/watch_app_target_3.png" width="50%" height="50%" style="margin: 10 auto;"></p><p>当我们访问 <code>UNNotification.request.content.userInfo</code> 拿到植物的信息时，我们可以用 <code>Decodable</code> 和 <code>JSONDecoder</code> 将代表植物的字典转换成值类型。 <code>JSONDecoder</code> 接收 <code>JSON</code> 数据，所以我们先用 <code>JSONSerialization</code> 包装数据，然后把包装的结果传给 <code>JSONDecoder</code> 。 或者我们也可以手动从 <code>userInfo</code> 字典里读取所有的值，然后创建出植物类型。留意，我们需要用 view model 来提供数据给 SwiftUI ，而不是直接使用 <code>Plant</code> 类型。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span>: <span class="title">Decodable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastDate: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> nextDate: <span class="type">Date</span></span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span> {</span><br><span class="line">        <span class="keyword">let</span> plantInfo = notification.request.content.userInfo [<span class="string">"plant"</span>] <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">Any</span>]</span><br><span class="line">        <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.data (withJSONObject: plantInfo, options: [])</span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        decoder.dateDecodingStrategy = .secondsSince1970</span><br><span class="line">        <span class="keyword">let</span> plant = <span class="keyword">try</span> decoder.decode (<span class="type">Plant</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">        viewModel = <span class="type">NotificationViewModel</span>(plant: plant)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> <span class="keyword">let</span> nsError <span class="keyword">as</span> <span class="type">NSError</span> {</span><br><span class="line">        <span class="built_in">print</span>(nsError.localizedDescription)</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>另外，我们想要添加三个用户可以执行的动作：标记植物已经浇水，推后提醒，或者安排明天再提醒。这些动作是用 <code>UNNotificationAction</code> 实例表示。当用户点击任意其中一个时，<code>UNUserNotificationCenter</code> 的委托方法会被调用，并且带有该动作的 <code>identifier</code> 。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> doneTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Done"</span>, comment: <span class="string">"Done button title in notification."</span>)</span><br><span class="line"><span class="keyword">let</span> laterTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Later"</span>, comment: <span class="string">"Later button title in notification."</span>)</span><br><span class="line"><span class="keyword">let</span> tomorrowTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Tomorrow"</span>, comment: <span class="string">"Tomorrow button title in notification."</span>)</span><br><span class="line">notificationActions = [</span><br><span class="line">    <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_done"</span>, title: doneTitle, options: []),</span><br><span class="line">    <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_later"</span>, title: laterTitle, options: []),</span><br><span class="line">    <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_tomorrow"</span>, title: tomorrowTitle, options: [])</span><br><span class="line">]</span><br></pre></td></tr></tbody></table></figure><p><code>NotificationController</code> 的完整实现如下：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NotificationController</span>: <span class="title">WKUserNotificationHostingController</span>&lt;<span class="title">NotificationView</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> viewModel: <span class="type">NotificationViewModel?</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> body: <span class="type">NotificationView</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NotificationView</span>(viewModel: viewModel!)</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">didReceive</span><span class="params">(<span class="number">_</span> notification: UNNotification)</span></span> {</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="keyword">let</span> plantInfo = notification.request.content.userInfo [<span class="string">"plant"</span>] <span class="keyword">as</span>! [<span class="type">String</span>: <span class="type">Any</span>]</span><br><span class="line">            <span class="keyword">let</span> data = <span class="keyword">try</span> <span class="type">JSONSerialization</span>.data (withJSONObject: plantInfo, options: [])</span><br><span class="line">            <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">            decoder.dateDecodingStrategy = .secondsSince1970</span><br><span class="line">            <span class="keyword">let</span> plant = <span class="keyword">try</span> decoder.decode (<span class="type">Plant</span>.<span class="keyword">self</span>, from: data)</span><br><span class="line">            viewModel = <span class="type">NotificationViewModel</span>(plant: plant)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> <span class="keyword">let</span> nsError <span class="keyword">as</span> <span class="type">NSError</span> {</span><br><span class="line">            <span class="built_in">print</span>(nsError.localizedDescription)</span><br><span class="line">        }</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">let</span> doneTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Done"</span>, comment: <span class="string">"Done button title in notification."</span>)</span><br><span class="line">        <span class="keyword">let</span> laterTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Later"</span>, comment: <span class="string">"Later button title in notification."</span>)</span><br><span class="line">        <span class="keyword">let</span> tomorrowTitle = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationAction_Tomorrow"</span>, comment: <span class="string">"Tomorrow button title in notification."</span>)</span><br><span class="line">        notificationActions = [</span><br><span class="line">            <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_done"</span>, title: doneTitle, options: []),</span><br><span class="line">            <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_later"</span>, title: laterTitle, options: []),</span><br><span class="line">            <span class="type">UNNotificationAction</span>(identifier: <span class="string">"water_tomorrow"</span>, title: tomorrowTitle, options: [])</span><br><span class="line">        ]</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="呈现通知的-NotificationView"><a href="#呈现通知的-NotificationView" class="headerlink" title="呈现通知的 NotificationView"></a>呈现通知的 NotificationView</h2><p>上面提到 view model <code>NotificationViewModel</code> 为 NotificationView 提供文本，它主要处理日期的格式化字符。 </p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotificationViewModel</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> plant: <span class="type">Plant</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(plant: <span class="type">Plant</span>) {</span><br><span class="line">        <span class="keyword">self</span>.plant = plant</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> plant.name</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> subtitle: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSLocalizedString</span>(<span class="string">"NotificationView_Subtitle"</span>, comment: <span class="string">"Notification suggestion text"</span>)</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        formatter.dateFormat = <span class="type">DateFormatter</span>.dateFormat (fromTemplate: <span class="string">"dMMMM"</span>, options: <span class="number">0</span>, locale: .current)</span><br><span class="line">        <span class="keyword">return</span> formatter</span><br><span class="line">    }()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> lastWatering: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> format = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationView_LastWatering"</span>, comment: <span class="string">"Last watering date."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: format, dateFormatter.string (from: plant.lastDate))</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> nextWatering: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> format = <span class="type">NSLocalizedString</span>(<span class="string">"NotificationView_NextWatering"</span>, comment: <span class="string">"Next watering date."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: format, dateFormatter.string (from: plant.nextDate))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>SwiftUI 视图很简单，4 个文本。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NotificationView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> viewModel: <span class="type">NotificationViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">Text</span>(viewModel.title).font (.title)</span><br><span class="line">            <span class="type">Text</span>(viewModel.subtitle).font (.subheadline)</span><br><span class="line">            <span class="type">Divider</span>()</span><br><span class="line">            <span class="type">Text</span>(viewModel.lastWatering).font (.body).multilineTextAlignment (.center)</span><br><span class="line">            <span class="type">Text</span>(viewModel.nextWatering).font (.body).multilineTextAlignment (.center)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/watch_notification_1.png" width="30%" height="30%" style="margin: 10 auto;"></p><p><img src="/images/watch_notification_2.png" width="30%" height="30%" style="margin: 10 auto;"></p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>我们往一个 iOS app 中添加了 watch app ，实现一个通知分类的动态通知视图。我们学习了如何解析通知数据，添加动作按钮。下一步是在 companion iOS app 里基于按钮的 identifier 处理对应通知动作。</p><hr><h1 id="拉取和显示数据"><a href="#拉取和显示数据" class="headerlink" title="拉取和显示数据"></a>拉取和显示数据</h1><p> 这一节的主题是从 compasion iOS app 的 CoreData 存储中获取数据，需要借助 WatchConnectivity framework 。</p><h2 id="iOS-和-WatchOS-app-之间的-session"><a href="#iOS-和-WatchOS-app-之间的-session" class="headerlink" title="iOS 和 WatchOS app 之间的 session"></a>iOS 和 WatchOS app 之间的 session</h2><p> iOS app 用 CoreData 来存储植物列表，记录了每株植物上一次和下一次浇水的日期。在这里，没有 web 服务，所有的东西都存在设备上。那么如何把持久化存储中的数据拿给 WatchOS app 使用呢？</p><p>我们会用到 WatchConnectivity framework 来做 iOS 和 WatchOS app 之间的交互。连接是在 iOS 和 WatchOS app 上都激活 <code>WCSession</code> 来实现的。因此，第一步是添加一个管理 <code>WCSession</code> 的类到 iOS 工程，我们不妨称它为 WatchConnectivityProvider (稍后也会添加一个相似的类到 WatchOS app)。它的主要职能是建立 <code>WCSession</code> ，处理 <code>WCSessionDelegate</code> ，其中包含从 CoreData 存储拉取数据。因此，有一个叫 <code>NSPersistentContainer</code> 的参数会提供对 <code>CoreData</code> 栈的访问 (借由访问 performBackgroundTask 函数)。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchConnectivityProvider</span>: <span class="title">NSObject</span>, <span class="title">WCSessionDelegate</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> persistentContainer: <span class="type">NSPersistentContainer</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> session: <span class="type">WCSession</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(session: <span class="type">WCSession</span> = .<span class="keyword">default</span>, persistentContainer: <span class="type">NSPersistentContainer</span>) {</span><br><span class="line">        <span class="keyword">self</span>.persistentContainer = persistentContainer</span><br><span class="line">        <span class="keyword">self</span>.session = session</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>()</span><br><span class="line">        session.delegate = <span class="keyword">self</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><code>WCSession</code> 是通过调用 activate () 来激活，激活过程是异步的。激活的响应通过 <code>session (_:activationDidCompleteWith:error:)</code> 委托访问返回。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">connect</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">guard</span> <span class="type">WCSession</span>.isSupported () <span class="keyword">else</span> {</span><br><span class="line">        os_log (.debug, log: .watch, <span class="string">"watch session is not supported"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"activating watch session"</span>)</span><br><span class="line">    session.activate ()</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, </span></span></span><br><span class="line"><span class="function"><span class="params">             activationDidCompleteWith activationState: WCSessionActivationState, </span></span></span><br><span class="line"><span class="function"><span class="params">             error: Error?)</span></span> {</span><br><span class="line">    os_log (.debug, </span><br><span class="line">               log: .watch, </span><br><span class="line">               <span class="string">"did finish activating session % lu (error: % s)"</span>, </span><br><span class="line">               activationState == .activated, </span><br><span class="line">               error?.localizedDescription ?? <span class="string">"none"</span>) </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 watchOS extension target 那边，我们会添加相似的代码，不过名字不一样，叫 “PhoneConnectivityProvider” 。当两个类都创建完成后，我们需要初始化并调用 connect ，分别在 <code>SceneDelegate</code> (iOS) 和 <code>ExtensionDelegate</code> (watchOS) 中完成。注意，在 iOS app 这边，我们需要实现两个委托方面，不过目前我们简单打印就可以了。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sessionDidBecomeInactive</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> {</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"session became inactive"</span>)</span><br><span class="line">}</span><br><span class="line">     </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sessionDidDeactivate</span><span class="params">(<span class="number">_</span> session: WCSession)</span></span> {</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"session deactivated"</span>)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了测试 session ，我们需要先编译并运行，然后在编译运行 watchOS app 。如果一切工作正常， Xcode 调试窗口会打印出消息： “did finish activating session 1 (error: none)”. 这表明 session 已经建立并且正在运行，我们可以两个 app 间发送消息了。</p><h2 id="Fetching-plants-from-iOS-app"><a href="#Fetching-plants-from-iOS-app" class="headerlink" title="Fetching plants from iOS app"></a>Fetching plants from iOS app</h2><p>因为 iOS 和 watchOS app 之间的通信依赖字典，所以第一步是定义一组两个 app 共享使用的 key 。这样可以减少误拼写的风险，所以我们可以添加新文件，并且同时包含到 iOS app target 和 watchOS extension target 中去。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WatchCommunication</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> requestKey = <span class="string">"request"</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> responseKey = <span class="string">"response"</span></span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">Content</span>: <span class="title">String</span> </span>{</span><br><span class="line">        <span class="keyword">case</span> allPlants</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二步是在 <code>PhoneConnectivityProvider</code> (watchOS app extension target) 中实现一个 <code>refreshAllPlants (completionHandler)</code> 函数，用来发送消息给 iOS app ，并且等待植物数据的数组返回。 <code>WCSession</code> 有一个叫  <code>sendMessage (_:replyHandler:errorHandler:)</code> 的函数，我们可以用它来发送一个字典给 iOS app ，然后等待 reply handler 。我们会用 WatchCommunication.requestKey 和 WatchCommunication.Content.allPlants 枚举的 rawValue 来构建消息。这种模式便于后续扩展，你只要添加更到 case 到枚举就可以了。在 reply handler 中，我们期望得到一个字典的数组，描述所有的植物。让我们先看一眼完整的实现，然后再讨论字典是如何被转换成 <code>Plant</code> 值类型的。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">refreshAllPlants</span><span class="params">(withCompletionHandler completionHandler: @escaping <span class="params">([Plant]?)</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">    <span class="keyword">guard</span> session.activationState == .activated <span class="keyword">else</span> {</span><br><span class="line">        os_log (.debug, log: .phone, <span class="string">"session is not active"</span>)</span><br><span class="line">        completionHandler (<span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">let</span> message = [<span class="type">WatchCommunication</span>.requestKey: <span class="type">WatchCommunication</span>.<span class="type">Content</span>.allPlants.rawValue]</span><br><span class="line">    session.sendMessage (message, replyHandler: { (payload) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> plantDictionaries = payload [<span class="type">WatchCommunication</span>.requestKey] <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]]</span><br><span class="line">        os_log (.debug, log: .phone, <span class="string">"received % lu plants"</span>, plantDictionaries?.<span class="built_in">count</span> ?? <span class="number">0</span>)</span><br><span class="line">             </span><br><span class="line">        <span class="keyword">let</span> decoder = <span class="type">JSONDecoder</span>()</span><br><span class="line">        decoder.dateDecodingStrategy = .secondsSince1970</span><br><span class="line">        <span class="keyword">let</span> plants = plantDictionaries?.compactMap ({ <span class="type">Plant</span>(dictionary: $<span class="number">0</span>, decoder: decoder) })</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.async {</span><br><span class="line">            completionHandler (plants)</span><br><span class="line">        }</span><br><span class="line">    }, errorHandler: { error <span class="keyword">in</span></span><br><span class="line">        os_log (.debug, log: .phone, <span class="string">"sending message failed: % s"</span>, error.localizedDescription)</span><br><span class="line">    })</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>iOS app 上处理 CoreData 和 Plant 类型的是一个 NSManagedObject 子类的对象。watchOS app extension 定义了它自己的 <code>Plant</code> 值类型，因为它并没有 CoreData 栈。为了将字典转换成值类型，我们可以使用 “Storing struct in UserDefault” 中描述的方法，只需要额外配置 <code>JSONDecoder</code> 使用的 <code>dateDecodingStrategy</code>  为 <code>secondsSince1970</code> 。理由是我们希望以自 1970 年之后的秒数来存储日期。转换字典到值类型的过程用到了 <code>JSONSerialization</code> ，它只支持 <code>NSString</code> ， <code>NSNumber</code> ， <code>NSArray</code> ， <code>NSDictionary</code> ， 或者 <code>NSNull</code> 。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Plant value type in WatchOS app extension</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Plant</span>: <span class="title">Identifiable</span>, <span class="title">Decodable</span>, <span class="title">DictionaryDecodable</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">let</span> lastWateringDate: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> nextWateringDate: <span class="type">Date</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">// Plant class in iOS app</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Plant</span>: <span class="title">NSManagedObject</span>, <span class="title">Identifiable</span> </span>{</span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> id: <span class="type">String</span></span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">     </span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> lastWateringDate: <span class="type">Date</span></span><br><span class="line">    <span class="meta">@NSManaged</span> <span class="keyword">var</span> nextWateringDate: <span class="type">Date</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第三步是在 iOS app 端处理消息，并且提供数据给 watchOS app 。我们需要做的是实现 session 的委托，从 CoreData 栈中获取字典数据。 先看下完整实现，然后逐一拆解。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">session</span><span class="params">(<span class="number">_</span> session: WCSession, didReceiveMessage message: [String: <span class="keyword">Any</span>], replyHandler: @escaping <span class="params">([String: <span class="keyword">Any</span>])</span></span></span> -&gt; <span class="type">Void</span>) {</span><br><span class="line">    os_log (.debug, log: .watch, <span class="string">"did receive message: % s"</span>, message [<span class="type">WatchCommunication</span>.requestKey] <span class="keyword">as</span>? <span class="type">String</span> ?? <span class="string">"unknown"</span>)</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> contentString = message [<span class="type">WatchCommunication</span>.requestKey] <span class="keyword">as</span>? <span class="type">String</span> , <span class="keyword">let</span> content = <span class="type">WatchCommunication</span>.<span class="type">Content</span>(rawValue: contentString) <span class="keyword">else</span> {</span><br><span class="line">        replyHandler ([:])</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">switch</span> content {</span><br><span class="line">    <span class="keyword">case</span> .allPlants:</span><br><span class="line">        persistentContainer.performBackgroundTask { (managedObjectContext) <span class="keyword">in</span>            </span><br><span class="line">            <span class="keyword">let</span> all = <span class="type">Plant</span>.allPlantsDictionaryRepresentation () <span class="keyword">as</span>! [[<span class="type">String</span>: <span class="type">Any</span>]]</span><br><span class="line">            <span class="comment">// Replace Date with Double</span></span><br><span class="line">            <span class="keyword">let</span> converted = all.<span class="built_in">map</span> { (plantDictionary) -&gt; [<span class="type">String</span>: <span class="type">Any</span>] <span class="keyword">in</span></span><br><span class="line">                plantDictionary.mapValues { (value) -&gt; <span class="type">Any</span> <span class="keyword">in</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> date = value <span class="keyword">as</span>? <span class="type">Date</span> {</span><br><span class="line">                        <span class="keyword">return</span> date.timeIntervalSince1970</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">else</span> {</span><br><span class="line">                        <span class="keyword">return</span> value</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }                </span><br><span class="line">            <span class="keyword">let</span> response = [<span class="type">WatchCommunication</span>.responseKey: converted]</span><br><span class="line">            replyHandler (response)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第一步是查看接收到的字典，看看 watchOS app 请求的是哪些内容。然后我们访问持久化存储，获取表示 Plant 的字典，把其他的日期转换成 1970 年后秒数的形式 (以便 watchOS app 能够在字典上使用 <code>JSONSerialization</code>)，然后把数据发送回 watchOS app 。注意，从 CoreData 中获取字典形式的 Plant 很容易：我们首先是请求 <code>NSDictionary</code> 类型的数据，并且将结果类型属性设置为 <code>.dictionaryResultType</code> 。对于各庞大的模型，我们可能还会用到属性集合 (propertiesToFetch) 。不过目前，所有的属性都被添加到字典中了。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Plant</span> </span>{</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> entityName = <span class="string">"Plant"</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">makeDictionaryRequest</span><span class="params">()</span></span> -&gt; <span class="type">NSFetchRequest</span>&lt;<span class="type">NSDictionary</span>&gt; {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NSFetchRequest</span>&lt;<span class="type">NSDictionary</span>&gt;(entityName: entityName)</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">allPlantsDictionaryRepresentation</span><span class="params">()</span></span> -&gt; [<span class="type">NSDictionary</span>] {</span><br><span class="line">        <span class="keyword">let</span> request = makeDictionaryRequest ()</span><br><span class="line">        request.resultType = .dictionaryResultType</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">try</span> request.execute ()</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> <span class="keyword">let</span> nsError <span class="keyword">as</span> <span class="type">NSError</span> {</span><br><span class="line">            os_log (.debug, log: .plants, <span class="string">"failed fetching all plants with error % s % s"</span>, nsError, nsError.userInfo)</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="用-SwiftUI-在-watchOS-app-中构建-UI"><a href="#用-SwiftUI-在-watchOS-app-中构建-UI" class="headerlink" title="用 SwiftUI 在 watchOS app 中构建 UI"></a>用 SwiftUI 在 watchOS app 中构建 UI</h2><p>Xcode 中 watchOS app 的模板是借助 storyboard 初始化 <code>HostingController</code>， 这个控制器负责提供初始的 SwiftUI 视图。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HostingController</span>: <span class="title">WKHostingController</span>&lt;<span class="title">PlantListView</span>&gt; </span>{</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> connectivityProvider: <span class="type">PhoneConnectivityProvider</span> = {</span><br><span class="line">        <span class="keyword">let</span> provider = <span class="type">PhoneConnectivityProvider</span>()</span><br><span class="line">        provider.connect ()</span><br><span class="line">        <span class="keyword">return</span> provider</span><br><span class="line">    }()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">lazy</span> <span class="keyword">var</span> listViewModel = <span class="type">PlantListViewModel</span>(connectivityProvider: connectivityProvider)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">var</span> body: <span class="type">PlantListView</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="type">PlantListView</span>(viewModel: listViewModel)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>PlantListView</code> 是一个显示植物列表的简单视图，它用 <code>PhoneConnectivityProvider</code> 的 <code>refreshAllPlants (withCompletionHandler:)</code> 来处理刷新植物的逻辑。 SwiftUI 视图会在 view model 改变时自动更新。这是因为 view model 的 <code>plants</code> 属性使用了 <code>@Published</code> 属性包装器，而 view model 本身是 <code>ObservableObject</code> ，这是 SwiftUI 视图中为 view model 采用的属性包装器 (更多信息可以阅读 refreshing SwiftUI view in MVVM in SwiftUI) 。注意，这里的 view model 是 SwiftUI 视图显现时刷新内容的。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PlantListViewModel</span>: <span class="title">ObservableObject</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> connectivityProvider: <span class="type">PhoneConnectivityProvider</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">init</span>(plants: [<span class="type">Plant</span>] = [], connectivityProvider: <span class="type">PhoneConnectivityProvider</span>) {</span><br><span class="line">        <span class="keyword">self</span>.plants = plants</span><br><span class="line">        <span class="keyword">self</span>.connectivityProvider = connectivityProvider</span><br><span class="line">        refresh ()</span><br><span class="line">    }</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">private</span>(<span class="keyword">set</span>) <span class="keyword">var</span> plants: [<span class="type">Plant</span>]</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">refresh</span><span class="params">()</span></span> {</span><br><span class="line">        connectivityProvider.refreshAllPlants { [<span class="keyword">weak</span> <span class="keyword">self</span>] (plants) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">guard</span> <span class="keyword">let</span> plants = plants <span class="keyword">else</span> { <span class="keyword">return</span> }</span><br><span class="line">            <span class="keyword">self</span>?.plants = plants</span><br><span class="line">        }</span><br><span class="line">    }    </span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlantListView</span>: <span class="title">View</span> </span>{</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> viewModel: <span class="type">PlantListViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span> {</span><br><span class="line">            <span class="type">List</span>(<span class="keyword">self</span>.viewModel.plants) { plant <span class="keyword">in</span></span><br><span class="line">                <span class="type">PlantCell</span>(viewModel: <span class="type">PlantCellViewModel</span>(plant: plant))</span><br><span class="line">            }</span><br><span class="line">        }.onAppear {</span><br><span class="line">            <span class="keyword">self</span>.viewModel.refresh ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>PlantListView</code> 用 <code>PlantCell</code> 来显示独立的视图。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlantCell</span>: <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> viewModel: <span class="type">PlantCellViewModel</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> {</span><br><span class="line">        <span class="type">VStack</span>(spacing: <span class="number">4</span>) {</span><br><span class="line">            <span class="type">Text</span>(viewModel.title).font (.headline).multilineTextAlignment (.center)</span><br><span class="line">            <span class="type">Text</span>(viewModel.subtitle).font (.footnote).multilineTextAlignment (.center)</span><br><span class="line">        }.padding (<span class="number">8</span>)</span><br><span class="line">            .frame (minWidth: <span class="number">0</span>, maxWidth: .greatestFiniteMagnitude)</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PlantCellViewModel</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> plant: <span class="type">Plant</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">return</span> plant.name</span><br><span class="line">    }</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> formatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        formatter.dateFormat = <span class="type">DateFormatter</span>.dateFormat (fromTemplate: <span class="string">"dMMMM"</span>, options: <span class="number">0</span>, locale: .current)</span><br><span class="line">        <span class="keyword">return</span> formatter</span><br><span class="line">    }()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">var</span> subtitle: <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> format = <span class="type">NSLocalizedString</span>(<span class="string">"PlantCellView_NextWatering"</span>, comment: <span class="string">"Next watering date."</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="type">String</span>(format: format, <span class="type">Self</span>.dateFormatter.string (from: plant.nextWateringDate))</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>我们在 iOS 和 watchOS app 上都添加 <code>WCSessions</code> ，实现相关的委托方法以处理 session 和接收到的消息。然后，我们定义一个简单的通信模式，并在 watchOS app 端实现刷新植物的方法，在 iOS 端实现 CoreData 集成。当数据访问创建完成后，我们在 watchOS app 上用 SwiftUI 视图显示植物的列表。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: SwiftUI 应用 | 浇水提醒 app&lt;br&gt;top: false&lt;br&gt;date: 2020-03-01 17:08:42&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;watchOS&lt;/li&gt;
&lt;li&gt;development&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>大纲 | SwiftUI 教程</title>
    <link href="https://theinfinitegame.tech/uncategorized/outline-swiftui-tutorials/"/>
    <id>https://theinfinitegame.tech/uncategorized/outline-swiftui-tutorials/</id>
    <published>2020-02-27T02:25:01.000Z</published>
    <updated>2020-03-01T08:01:41.893Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://developer.apple.com/tutorials/swiftui/creating-and-combining-views" target="_blank" rel="noopener">源</a></p><h1 id="第一章-基础"><a href="#第一章-基础" class="headerlink" title="第一章 基础"></a>第一章 基础</h1><h2 id="创建和绑定视图"><a href="#创建和绑定视图" class="headerlink" title="创建和绑定视图"></a>创建和绑定视图</h2><h3 id="1-创建项目和探索-Canvas"><a href="#1-创建项目和探索-Canvas" class="headerlink" title="1 创建项目和探索 Canvas"></a>1 <strong>创建项目和探索 Canvas</strong></h3><p>要点：</p><ol><li>创建项目时 User Interface 选择 “SwiftUI”</li><li>基础扩展：演示 Xcode 界面布局，菜单</li><li>SwiftUI 文件的两部分：描述视图内容和布局的主结构体，预览</li><li>显示隐藏 Canvas 面板快捷键</li><li>演示实时预览 （改变 body 里的代码） SwiftUI 开发体验的核心卖点之一<br>进阶资源：声明式 UI 、Flutter 和 SwiftUI 的比较，拖尾闭包语法</li></ol><h3 id="2-自定义文本视图"><a href="#2-自定义文本视图" class="headerlink" title="2 自定义文本视图"></a>2 自定义文本视图</h3><p>要点：</p><ol><li>演示从预览中的检视 UI 元素，顺便提一下 modifier ，演示 Font modifier</li><li>代码和视图的关系：source of truth (真理之源)</li><li>演示预览、检视器和代码的自动同步</li></ol><h3 id="3-通过堆叠组合视图"><a href="#3-通过堆叠组合视图" class="headerlink" title="3 通过堆叠组合视图"></a>3 通过堆叠组合视图</h3><p>要点</p><ol><li>body 属性只返回一个视图<br>进阶资源：关于 body 属性的文章</li><li>介绍三类 stacks ，HStack, VStack，ZStack</li><li>介绍 Xcode 的结构化编辑：嵌套、检视、提取等。通用的 ” 右键菜单 “ ，SwiftUI 专有的 Cmd + 点击<br>进阶资源：Flutter</li><li>演示 embed in vstack</li><li>演示添加控件： + 按钮，快捷键</li><li>演示两层 Stack 嵌套，演示 Spacer 的使用。<br>进阶资源：Spacer 的特性</li><li>演示 padding<br>进阶资源：padding 的各种版本</li></ol><h3 id="4-创建自定义图像视图"><a href="#4-创建自定义图像视图" class="headerlink" title="4 创建自定义图像视图"></a>4 创建自定义图像视图</h3><p>要点</p><ol><li>简介 image view ，常见图片相关概念：mask，边缘 (border)，投影 (drop shadow)</li><li>基础扩展： 添加资源到 asset catalog</li><li>演示创建新的 SwiftUI 文件，CircleImage</li><li>演示 Image () 构造器，演示 clipShaper modifier, Circle mask<br>进阶：mask 遮蔽</li><li>演示 overlay， shadow</li></ol><h3 id="5-让-UIKit-和-SwiftUI-一起工作"><a href="#5-让-UIKit-和-SwiftUI-一起工作" class="headerlink" title="5 让 UIKit 和 SwiftUI 一起工作"></a>5 让 UIKit 和 SwiftUI 一起工作</h3><ol><li>如何在 SwiftUI 中使用 UIKit 里的视图？关键词：wrap, UIViewRepresentable 协议<br>进阶资源：wrap，协议</li><li>[学习曲线] 跳过，后续再来说明。<br>MapKit 相关知识点</li></ol><h3 id="6-构成视图-Compose-Views-——-需要练习"><a href="#6-构成视图-Compose-Views-——-需要练习" class="headerlink" title="6 构成视图 (Compose Views) —— (需要练习)"></a>6 构成视图 (Compose Views) —— (需要练习)</h3><p>要点：</p><ol><li>选择容器 —— stacks，文字、图像、Spacer、自定义视图</li><li>调整视图 —— modifier，属性</li><li>打开源链接，演示样例 app 界面变化过程。</li></ol><p>检查理解的测验。</p><hr><h2 id="构建-List-和导航"><a href="#构建-List-和导航" class="headerlink" title="构建 List 和导航"></a>构建 List 和导航</h2><h3 id="1-了解样本数据"><a href="#1-了解样本数据" class="headerlink" title="1 了解样本数据"></a>1 了解样本数据</h3><p>要点：</p><ol><li>理解 Model ，粗浅理解为数据，相对于视图<br>进阶资源：MVC 设计模式，结构体和类的区别，数据格式，json</li><li>带一些新的关键字，协议</li><li>进阶扩展：为什么要用扩展 Landmark 的 image 属性</li><li>json 数据格式</li></ol><h3 id="2-创建-“行”-视图"><a href="#2-创建-“行”-视图" class="headerlink" title="2 创建 “行” 视图"></a>2 创建 “行” 视图</h3><p>要点</p><ol><li>创建新 SwiftUI 文件，起名 LandmarkRow.swift</li><li>进阶扩展：存储属性和计算属性</li><li>介绍 Image resizable modifier</li></ol><h3 id="3-自定义预览"><a href="#3-自定义预览" class="headerlink" title="3 自定义预览"></a>3 自定义预览</h3><p>要点</p><ol><li>previewLayout<br>进阶资源：previewDevice</li></ol><h3 id="4-创建列表"><a href="#4-创建列表" class="headerlink" title="4 创建列表"></a>4 创建列表</h3><p>要点</p><ol><li>List 的元素可以是动态的、静态的或者混合的<br>进阶资源：SwiftUI 的 List</li><li>使用 List<br>进阶资源：</li></ol><h3 id="5-创建动态列表"><a href="#5-创建动态列表" class="headerlink" title="5 创建动态列表"></a>5 创建动态列表</h3><p>要点</p><ol><li>List 接收 <code>identifiable</code> 的数据<br>进阶资源：Swift keypath 语法，SwiftUI 的 List、ForEach<br>进阶资源：闭包、拖尾闭包语法</li><li>Identifiable 协议：id 属性的约定</li></ol><h3 id="6-在-List-之间建立导航"><a href="#6-在-List-之间建立导航" class="headerlink" title="6 在 List 之间建立导航"></a>6 在 List 之间建立导航</h3><p>要点</p><ol><li>NavigationView<br>进阶资源：SwiftUI 给视图 “赋能” 的方式</li><li>标题、导航按钮<br>进阶资源：标准化 UI</li><li>NavigationLink</li></ol><h3 id="7-数据传递"><a href="#7-数据传递" class="headerlink" title="7 数据传递"></a>7 <strong>数据传递</strong></h3><p>要点</p><ol><li>演示改动</li></ol><h3 id="8-生成动态预览"><a href="#8-生成动态预览" class="headerlink" title="8 生成动态预览"></a>8 生成动态预览</h3><p>要点</p><ol><li>演示实现方式<br>进阶：对移动开发的意义</li></ol><hr><h2 id="处理用户输入"><a href="#处理用户输入" class="headerlink" title="处理用户输入"></a>处理用户输入</h2><h3 id="1-标记最爱的地标"><a href="#1-标记最爱的地标" class="headerlink" title="1. 标记最爱的地标"></a>1. 标记最爱的地标</h3><p>要点</p><ol><li>添加一个图标：系统图标、缩放、着色<br>进阶：SF Symbols，着色</li></ol><h3 id="2-过滤列表视图"><a href="#2-过滤列表视图" class="headerlink" title="2 过滤列表视图"></a>2 过滤列表视图</h3><p>要点</p><ol><li>@State 属性</li></ol><h3 id="3-添加控件以触发-State"><a href="#3-添加控件以触发-State" class="headerlink" title="3 添加控件以触发 State"></a>3 添加控件以触发 State</h3><p>要点</p><ol><li>绑定：$ 语法</li></ol><h3 id="4-用-Observable-Object-存储"><a href="#4-用-Observable-Object-存储" class="headerlink" title="4 用 Observable Object 存储"></a>4 用 Observable Object 存储</h3><p>要点</p><ol><li>ObservableObject 协议</li><li>@Published 属性</li></ol><h3 id="5-在视图中接收模型对象"><a href="#5-在视图中接收模型对象" class="headerlink" title="5 在视图中接收模型对象"></a>5 在视图中接收模型对象</h3><p>要点：</p><ol><li>环境变量: EnvironmentOjbect 属性声明，environmentObject 传入</li><li>where 语句</li></ol><h3 id="6-为每个地标创建按钮"><a href="#6-为每个地标创建按钮" class="headerlink" title="6 为每个地标创建按钮"></a>6 为每个地标创建按钮</h3><p>要点：演示</p><hr><h1 id="第二章-绘制和动画"><a href="#第二章-绘制和动画" class="headerlink" title="第二章 绘制和动画"></a>第二章 绘制和动画</h1><hr><h1 id="第三章-App-设计和布局"><a href="#第三章-App-设计和布局" class="headerlink" title="第三章 App 设计和布局"></a>第三章 App 设计和布局</h1><h1 id="构成复杂界面"><a href="#构成复杂界面" class="headerlink" title="构成复杂界面"></a>构成复杂界面</h1><h2 id="1-Home-视图"><a href="#1-Home-视图" class="headerlink" title="1 Home 视图"></a>1 Home 视图</h2><p>要点</p><p>Home 界面<br>   进阶：心智模式：干扰和专注，简单和复杂 （通知）</p><h2 id="2-分类列表"><a href="#2-分类列表" class="headerlink" title="2 分类列表"></a>2 分类列表</h2><p>要点</p><ol><li>分类 =&gt; 建立层级 （“抽屉”、容器）=&gt; 寻找</li><li>用字典将地标分组</li><li>重温 List、ForEach、keypath 的用法</li></ol><h2 id="3-增加地标分类的内容"><a href="#3-增加地标分类的内容" class="headerlink" title="3 增加地标分类的内容"></a>3 增加地标分类的内容</h2><p>要点</p><ol><li>重温 Stack</li><li>ScrollView (.horizontal), ForEach</li></ol><h2 id="4-构成-Home-视图"><a href="#4-构成-Home-视图" class="headerlink" title="4 构成 Home 视图"></a>4 构成 Home 视图</h2><p>要点</p><ol><li>改造 CategoryRow</li><li>listRowInsets、EdgeInsets</li></ol><h2 id="5-添加导航"><a href="#5-添加导航" class="headerlink" title="5 添加导航"></a>5 添加导航</h2><p>要点</p><ol><li>重温 NavigationLink</li><li>Image .renderingMode , Text .foregroundColor</li><li>重温 @State， 重点: sheet<br>进阶：alert, 内建的环境变量 .presentationMode</li><li>导航栏按钮 navigationBarItems</li></ol><hr><h2 id="和-UI-控件合作"><a href="#和-UI-控件合作" class="headerlink" title="和 UI 控件合作"></a>和 UI 控件合作</h2><h3 id="1-显示用户资料"><a href="#1-显示用户资料" class="headerlink" title="1 显示用户资料"></a>1 显示用户资料</h3><h3 id="2-编辑模式"><a href="#2-编辑模式" class="headerlink" title="2 编辑模式"></a>2 编辑模式</h3><p>要点</p><ol><li>editMode</li><li>条件视图，wrappedValue</li></ol><h3 id="3-定义资料编辑器"><a href="#3-定义资料编辑器" class="headerlink" title="3 定义资料编辑器"></a>3 定义资料编辑器</h3><p>要点</p><ol><li>Divider</li><li>Toggle</li><li>Picker</li><li>DatePicker</li></ol><h3 id="4-延后编辑的生效"><a href="#4-延后编辑的生效" class="headerlink" title="4 延后编辑的生效"></a>4 延后编辑的生效</h3><p>要点</p><ol><li>编辑草稿</li><li>可取消的编辑</li><li>onAppear, onDisappear</li></ol><hr><h1 id="第四章-Framework-集成"><a href="#第四章-Framework-集成" class="headerlink" title="第四章 Framework 集成"></a>第四章 Framework 集成</h1><h2 id="与-UIKit-对接"><a href="#与-UIKit-对接" class="headerlink" title="与 UIKit 对接"></a>与 UIKit 对接</h2><h3 id="1-创建视图来表示-UIPageViewController"><a href="#1-创建视图来表示-UIPageViewController" class="headerlink" title="1 创建视图来表示 UIPageViewController"></a>1 创建视图来表示 UIPageViewController</h3><p>要点</p><ol><li>UIViewControllerRepresentable, #makeUIViewController, #updateUIViewController<br>进阶资源：回调</li><li>用 SwiftUI 的 view 来构建 UIPageViewController 中的 controller</li><li>map</li></ol><h3 id="2-创建-ViewController-的数据源"><a href="#2-创建-ViewController-的数据源" class="headerlink" title="2 创建 ViewController 的数据源"></a>2 创建 ViewController 的数据源</h3><p>要点</p><ol><li>使用 Coordinator, UIPageViewControllerDataSource</li></ol><h3 id="3-用-SwiftUI-中的视图状态跟踪-Page"><a href="#3-用-SwiftUI-中的视图状态跟踪-Page" class="headerlink" title="3 用 SwiftUI 中的视图状态跟踪 Page"></a>3 用 SwiftUI 中的视图状态跟踪 Page</h3><p>要点</p><ol><li>@State, @Binding 的传递</li><li>UIPageViewControllerDelegate</li></ol><h3 id="4-添加一个自定义页面控制"><a href="#4-添加一个自定义页面控制" class="headerlink" title="4 添加一个自定义页面控制"></a>4 添加一个自定义页面控制</h3><p>要点</p><ol><li>UIViewRepresentable</li><li>UIPageControl, UIControl<br>进阶资源：“控件”</li><li><strong>target-action pattern</strong> , <strong>*delegate</strong>， <strong>#selector</strong></li><li><strong>@objc 关键字 </strong></li><li>可选进阶：起名字，一个名字在多个层次中使用<br>PageControl, UIPageControl</li><li>可选进阶：PageViewController 和 PageControl 之间如何联动</li></ol><hr><h2 id="创建-watchOS-App"><a href="#创建-watchOS-App" class="headerlink" title="创建 watchOS App"></a>创建 watchOS App</h2><h3 id="1-添加-watchOS-目标"><a href="#1-添加-watchOS-目标" class="headerlink" title="1 添加 watchOS 目标"></a>1 添加 watchOS 目标</h3><p>要点</p><ol><li>激活 watch app 的 scheme</li><li>Supports Running Without iOS App Installation<br>进阶内容：watchOS 6.0, watch app 和 iOS app 的关系</li></ol><h3 id="2-在目标间共享文件"><a href="#2-在目标间共享文件" class="headerlink" title="2 在目标间共享文件"></a>2 在目标间共享文件</h3><p>要点</p><ol><li>文件 inspector, Target membership 段</li><li>watchkit app 和 watchkit extension 的区别<br>进阶内容：watch app 的结构</li></ol><h3 id="3-创建细节视图"><a href="#3-创建细节视图" class="headerlink" title="3 创建细节视图"></a>3 创建细节视图</h3><p>要点</p><ol><li>适配不同尺寸的屏幕</li><li><strong>where 语句 </strong></li><li>scaleToFill, scaleToFit</li></ol><h3 id="4-添加-watchOS-的地图视图"><a href="#4-添加-watchOS-的地图视图" class="headerlink" title="4 添加 watchOS 的地图视图"></a>4 添加 watchOS 的地图视图</h3><p>要点</p><ol><li>WKInterfaceObjectRepresentable<br>进阶：为什么不能像复用 CircleImage 那样直接复用 iOS 里写好的地图视图？SwiftUI 的定位（learn once, apply everywhere）</li><li>添加到 detail 界面</li></ol><h3 id="5-创建跨平台的列表视图"><a href="#5-创建跨平台的列表视图" class="headerlink" title="5 创建跨平台的列表视图"></a>5 创建跨平台的列表视图</h3><p>要点</p><ol><li><strong> 泛型 </strong>，<strong> 类型推断 </strong></li><li>对应修改 iOS scheme 的 Home 视图，LandmarkList 的初始化，重温拖尾闭包。</li><li>LandmarkList 预览怎么解决？ #if, #else, #endif, typealias</li></ol><h3 id="6-在-watch-app-中）添加-Landmarks-List"><a href="#6-在-watch-app-中）添加-Landmarks-List" class="headerlink" title="6 (在 watch app 中）添加 Landmarks List"></a>6 (在 watch app 中）添加 Landmarks List</h3><p>要点</p><ol><li>切换 scheme</li><li>思考题：watch app 为什么没有 Home ?</li></ol><h3 id="7-创建自定义的通知接口"><a href="#7-创建自定义的通知接口" class="headerlink" title="7 创建自定义的通知接口"></a>7 创建自定义的通知接口</h3><p>要点</p><ol><li><strong> 如何正确地使用通知？</strong></li><li>构建通知视图：swift 的 init 模式</li><li>通知控制：WKUserNotificationHostingController, #didReceive, </li><li>UNNotification</li><li>通知配置：Notification Category, apns 文件模拟远程通知</li><li>切换到 Notification scheme</li></ol><hr><h2 id="创建-macOS-app"><a href="#创建-macOS-app" class="headerlink" title="创建 macOS app"></a>创建 macOS app</h2><h3 id="1-创建-macOS-目标"><a href="#1-创建-macOS-目标" class="headerlink" title="1 创建 macOS 目标"></a>1 创建 macOS 目标</h3><p>要点</p><ol><li>Deployment Target<br>进阶资源：<strong> 软件兼容（向前兼容）</strong>，<strong> 版本号 </strong></li></ol><h3 id="2-共享数据和-Assets"><a href="#2-共享数据和-Assets" class="headerlink" title="2 共享数据和 Assets"></a>2 共享数据和 Assets</h3><p>要点</p><ol><li>Membership</li></ol><h3 id="3-Row-视图"><a href="#3-Row-视图" class="headerlink" title="3 Row 视图"></a>3 Row 视图</h3><h3 id="4-组装视图"><a href="#4-组装视图" class="headerlink" title="4 组装视图"></a>4 组装视图</h3><p>要点</p><ol><li>List (selection: Binding<set<selectionvalue>)</set<selectionvalue></li></ol><h3 id="5-过滤器视图"><a href="#5-过滤器视图" class="headerlink" title="5 过滤器视图"></a>5 过滤器视图</h3><p>要点</p><ol><li>相同控件在不同平台上的外观</li><li>preview 中样例的 .constant 用法</li><li>数组相加</li><li>通用规范：复杂条件，注意使用括号</li></ol><h3 id="6-组合列表和过滤器视图"><a href="#6-组合列表和过滤器视图" class="headerlink" title="6 组合列表和过滤器视图"></a>6 组合列表和过滤器视图</h3><h3 id="7-复用-CircleImage"><a href="#7-复用-CircleImage" class="headerlink" title="7 复用 CircleImage"></a>7 复用 CircleImage</h3><p>要点</p><ol><li>属性默认值</li></ol><h3 id="8-macOS-上的地图视图"><a href="#8-macOS-上的地图视图" class="headerlink" title="8 macOS 上的地图视图"></a>8 macOS 上的地图视图</h3><p>要点</p><ol><li>善用 extension 分治代码</li></ol><h3 id="9-构建细节视图"><a href="#9-构建细节视图" class="headerlink" title="9 构建细节视图"></a>9 构建细节视图</h3><h3 id="10-Master-Detail-视图"><a href="#10-Master-Detail-视图" class="headerlink" title="10 Master Detail 视图"></a>10 Master Detail 视图</h3><p>要点</p><ol><li>mac (iPad) 上的应用布局，NavigationView</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://developer.apple.com/tutorials/swiftui/creating-and-combining-views&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;源&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;第一章
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>计算方法 03 | 科学哲学</title>
    <link href="https://theinfinitegame.tech/social-science/quantitative-method-philosophy-of-science/"/>
    <id>https://theinfinitegame.tech/social-science/quantitative-method-philosophy-of-science/</id>
    <published>2020-02-26T10:13:30.000Z</published>
    <updated>2020-02-26T12:42:35.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="认识论-Epistemology"><a href="#认识论-Epistemology" class="headerlink" title="认识论 (Epistemology)"></a>认识论 (Epistemology)</h1><p>在把假说 - 演绎法作为获取世界知识的最佳途径之前。第一个问题是：现实的本性？什么是现实？什么存在？因此，我们首先要问，获得的知识到底是关于什么的知识。解决这类问题的哲学领域叫做 <strong>本体论 (ontology)</strong> —— 对存在的研究。第二个问题涉及获取知识的方法。假设的确有一个现实：原则上是可知的，那么我们能获取哪些现实的知识？怎么获取？哲学领域中考虑这类问题的叫 <strong>认识论 (epistemology)</strong> —— 认识的研究或理论。</p><p>我们从后一个问题开始讲。假设有一个可知的现实，我们如何来获取知识。有很多不同的认识论观点，我们这里讨论两个最重要的观点。</p><p>第一个是 <strong>理性主义 (rationalism)</strong> 。理性主义者认为知识通过理性获得，用我们大脑的逻辑和理性思维能力，可以推断世界的真理，而无需借助经验。</p><p>哲学家柏拉图和笛卡尔结合了理性主义和其他观点，认为至少某些自然结构的抽象概念是天生的，是我们与生俱来的。就是说，我们的大脑能轻易理解这些概念，因为我们已经知道了，只要用推理回忆或辨识即可。</p><p><strong>经验主义 (Empiricism)</strong> 反对这一观点，经验主义者认为感官经验才是最主要方式。一些绝对经验主义者甚至认为，这是获取世界知识的唯一方式。</p><p>亚里士多德被认为是第一个经验主义者，他认为关于自然的基本真理来自感官经验。我们可以通过演绎推理获取更多知识，但观察是所有知识的基础。亚里士多德不相信天赋观念 (innate ideas) 。其实，他创造了 “白板” 这个词，指出每个人生下来就是一块白板。我们的知识并不是预先确定的，大脑可以接受任何概念。</p><p>当然，亚里士多德不是激进的经验主义者。他不反对理性思维加入进来，他也不反对用一些抽象的、不能直接观察的概念。</p><p>我觉得伽利略算是温和的经验主义者。他很注重观察法和实验法，但他也极度依赖逻辑推理。伽利略有句名言 “自然之书以数学语言写就”。他完全不排斥运用思想实验，也在他的假说中引入不可观测的性质。</p><img src="/images/sci-phil_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>后来的经验主义者如培根，尤其是休谟和逻辑实证主义者，都是绝对经验主义者，坚信只有感官经验才能获得世界的真知。他们认为建立在无法被直接观测的共相上的论断没有意义。</p><p>现代的经验主义就是范弗拉森的建构经验主义。它强调感官经验在归纳法和演绎法中都有作用，但它也允许理论术语存在，对应不能直接观测的实体。建构经验主义的目标是提出实证上恰当的解释，只要它表述的世界与观测到的一致，即可被接受。建构经验主义者会说因为存在不可观测的性质，真假无法判断。这承认了知识是暂时的，因为未来总存在发现新的反例的可能。</p><hr><h1 id="本体论-Ontology"><a href="#本体论-Ontology" class="headerlink" title="本体论 (Ontology)"></a>本体论 (Ontology)</h1><p>我们来说说本体论 (ontology) 即现实的本质是什么。</p><p>有很多对立的观点。在深入各种哲学观点之前，我先来解释这些观点里两个主要区别。第一点，现实是否独立存在于人类思想之外。当我们感知世间万物，它们真的脱离我们而真实存在吗？或者只是我们思想构建的心理表征，只能说存在于我们的思想。第二点是关于本体状态的殊相 (particular) 和共相 (universal)。殊相是指具体实例或能观察到属性的事件；共相或者说不可观察的性质，就是指那些无法直接观察到的普遍性质。</p><p>我们来举个例子，爱是我们无法直接观察到的普遍性质，但能通过行为表达或具现。因此当我家猫爬上我的膝盖打个小盹，这就是爱这个共相的具体实例。重力是另一个不可观察的共相，重力可用具体实例来表现。例如，当我打翻猫食盆，它就会掉在地上。</p><p>我们来看一下不同的本体论观点，看看他们对殊相和共相问题，以及对现实是外部存在还是仅存于思想内的看法。</p><p>唯心主义 (Idealism) 哲学观认为我们感知的现实完全存在于脑内。在我们精神世界感知到之前，外部物质世界的存在与我们无关。现实其实是精神世界的映射，重力和爱是存在的，但仅在我们的思想里，与之相关的具体实例也是如此。唯心主义者会说：猫睡在我膝上，以及碗掉在地上，这都是你想出来的。</p><p>对唯心主义而言，共相或不可观察的性质，它们是否真的在外部独立存在无关紧要。因为他们认为殊相和共相都是存在的，但都是精神世界的映射。</p><p>和唯心主义相对的是唯物主义 (Materialism) 。唯物主义认为思想世界外有独立存在的世界，唯物主义还认为一切由独立的物质世界构成。这就是说一切都是实物相互作用的结果，包括我们的意识、情绪和思想，这些是我们大脑和物质世界相互作用的副产品。</p><p>和唯心主义刚好相反，这是物质对精神。唯物主义只关注世界的物质组成，和唯心主义类似，它并不关心如何区分殊相和共相。</p><p>现实主义 (Realism) 又有所不同，就像唯物主义者，现实主义者坚持外部现实世界独立于人类思想存在，但现实主义者还坚持，像爱和重力这种共相是真实的，其存在形式取决于现实主义的类型。柏拉图式的现实主义认为像重力、爱这种共相，真的存在但我们观察不到，其位于一个独立的抽象位面。科学现实主义则更温和，它认为把共相用于现象观察能得到坚实可靠的主张。</p><p>在科学现实主义中，像爱和重力这种共相，和可观察的殊相位于同样的本体状态。之所以能假设不可测性的存在，是因为其对构造成功的科学主张有用且经常很必需。</p><p>最后是唯名论 (名义主义，Nominalism) 。这个观点在共相方面与现实主义完全对立，它承认现实独立于人类思想存在，但否认共相的存在。唯名论认为没有重力或爱这回事儿，只有掉落的物品以及经常在你膝盖打呼噜的猫。根据唯名论，我们用重力和爱这些术语，只因为能帮助理解世界，但共相不是真实存在的。</p><hr><h1 id="方法-Approaches"><a href="#方法-Approaches" class="headerlink" title="方法 (Approaches)"></a>方法 (Approaches)</h1><p>至今为止我讲到的科学方法的发展，主要在自然科学领域。物理学 physics、天文学 astronomy、生物学 biology，但在 19 世纪下半叶， <strong>社会科学 (social sciences)</strong> 开始登上历史舞台。</p><p>这段时期，人们又重拾了现实主义的本体论观点，即假设物质世界是真实的，我们感知的是外部世界，是独立于我们思想存在的。</p><p>认识论的观点越来越实证主义 (positivistic) ，这意味着科学家认为我们可以通过观察和实验来获取有关世界本质的知识。这种现实实证观点大多应用于自然现象方面，但随着社会科学发展并成为独特的科学领域，问题来了：现实主义观点是否适用于社会学和心理学现象呢？</p><p>根据 <strong>客观主义 (objectivism)</strong> 的观点，现实主义本体论立场确实适用于心理学和社会学现象，比如智力和社会凝聚力是外部的、独立的性质，是独立于我们的心理表征的。</p><p>客观主义可以建构主义 (constructivism) 做对比。</p><img src="/images/sci-phil_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>根据建构主义，社会现象的本质取决于所涉及的社会角色。这意味着现实不是独立和外在的，而被认为是基于观察者和情境的心理建构。比如，快乐或女性气质这些属性不是外在的，不是永恒的，也不能被客观定义。要如何看待这些属性以及它们的意义，取决于观察者的文化背景、社会族群及特定的历史时期。那么，如果心理现实和社会现实是建构的、主观的、难以捉摸的，我们如何了解它呢？怎样的认识论立场适合建构主义的本体论立场？</p><p>事实上，有一组互相联系的观念，统称为 <strong>解释主义 (interpretivism)</strong> 。解释主义的观点都假设研究者关于社会现象的经历或观察，可能与这些社会现象亲历者的经历大相径庭。所以重点应该放在参与者的角度来解读现象。</p><p>我想讲的三个解释主义观点是 <strong>解释学 (hermeneutics)</strong> 、 <strong>现象学 (phenomenology)</strong> 和 <strong>诠释社会学 (verstehen)</strong> ，它们在如何获得心理学和社会现实的理解上有些微差别。</p><p>先来看看解释学。这个术语来自神学，是关于解读经文。解释学旨在通过解读人们在社会情境下的行为 来解释社会现象。研究者需要将情境纳入考量，并试着理解人们如何看待这世界，以此来理解他们的行为。</p><p>现象学与解释学密切相关。它的首要前提是人不是无生命的对象，他们会思考和感知周遭的世界，而这会影响他们的行为。为了理解他们的行为，就需要调查他们给自己所经历的现象赋予的意义。这意味着调查人们如何从自身的角度探究世界。要切身了解他人对自己经历的理解，研究者需要尽可能地消除自己先入为主的观念。</p><p>诠释社会学是第三种解释主义观点，它与解释学和现象学有紧密联系。诠释社会学主要与社会学家马克斯・韦伯 (Max Weber) 相关。诠释社会学是指对社会现象的移情理解。研究者需要站在研究对象的立场，来解读他们如何看待世界，只有这样研究者才能解释他们的行为。比如，如果欧洲研究者想在一个与世隔绝的亚马逊部落中探究快乐。他们需要站在部落的角度，考虑到部落的社会情境。对部落来说，或许集体比个人更重要，这可能意味着快乐被认为是一种集体属性，甚至根本不适用于个人。现在，为了理解这种完全不同的世界观，研究者需要将自己沉浸在他们研究的人或族群的文化中。</p><p>当然，建构解释主义的观点存在一些问题。首先，有分层解读的问题 —— 研究者的解读；研究对象的解读；而将发现放进一个框架或关联一个理论时，又进行了解读。每多一层解读，就增大了误解的机会。第二个更严重的问题是结果缺乏可比性。在我们的例子中，快乐是主观的，在不同的文化中意义不同。我们不能就这么进行比较。这意味着我们永远无法提出普适解释或理论，而仅仅适用于特定人群或特定时段。第三个问题是参考系的不同。如果参考系与研究者相去甚远，研究者就很难站在研究对象的立场上，从而甚至难以发现社会情境中的相关方面。</p><p>建构 - 解释主义的观点常与科学的定性方法有关。换言之，观察是通过非结构化访谈或参与性观察进行的，而研究者是他们中的一份子。数据来源于一个或少数几个研究对象，通过解读文本或录制的素材对数据进行定性分析。反之，客观 - 实证观点于定量研究方法相关。得到的观察结果可以被计数或测量，所以多个研究对象的数据可以整合在一起，选取的研究对象代表更大的人群，或许可以支持一个普适解释。而且数据用量化统计手段来分析。</p><p>尽管定性方法通常与建构主义的科学观点相关，而定量方法与客观主义观点相关，这并不是限制我们仅使用定性或定量方法的理由。两种方法都各有优劣。对有些研究问题来说，定性方法更好；其他情况下 定量方法可能更合适。事实上，将两种方法互补结合在一起的方法，越来越受到欢迎。</p><hr><h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>当然最后，科学的总体目标是获得知识，但可以分为更多具体的目标，区分目标的方式有获取知识的类型以及获取知识的目的。</p><p><strong>普遍性研究 (universalistic research)</strong> 试图提供能广泛使用的解释。</p><p>例如，假设玩暴力电脑游戏会导致攻击行为。这与具体游戏或特定玩家没有关系，因为我们假定的是玩暴力游戏和攻击性间的相关性，这适用于任何暴力游戏，如 GTA 、使命召唤等等；我们还假设相关性适用于男性和女性，任何年龄、任何文化背景的人。</p><p>普遍性研究致力描述或解释的现象，能用于所有人、所有群体或社会。</p><p>科学方法也能用于特殊性研究。特殊性研究致力描述或解释发生在特定环境下的现象，或者涉及特定群体。</p><p>例如，在荷兰将法定饮酒年龄从 16 岁升至 18 岁后，我们能调查荷兰青年酒精中毒住院人数的变化。关键是在特定的时间、地点、群体内调查影响的大小。不要指望在不同国家或十年里再次改变饮酒年龄会有同样结果。所以研究目的既可以是普遍性的，也可以是特殊性的。说得简短些就是：可获得普遍性或特定的知识。</p><p><strong>基础研究 (fundamental research)</strong> 和 <strong>应用研究 (applied research)</strong> 间关系很近，重叠度很高。</p><p>应用研究为了直接解决问题，其开发和应用知识是为了提高人类福祉。假设我们想帮助抑郁人群，我们认为抑郁是孤独造成的。我们就可以建立一个项目，目的是减少孤独感以降低抑郁程度。我们让孤独抑郁的人去养只猫，来观察是否真的由于不再孤独降低了抑郁程度。</p><p>基础研究相较于应用研究旨在获取知识，就是为了增进了解。基础研究的唯一目的是加深了解身边的世界，不需要能立即应用和接解决问题。例如，调查孤独和抑郁间的相关性，用大规模调查来看是否越感觉孤独的人越抑郁，反之亦然。这里是为了揭示孤独和抑郁间的相关性。也许我们想看看是否男性女性都有这种相关性，不同文化和年龄也有这种相关性。但注意，我们不关心如何治疗抑郁，这里的目的更多的是了解相关性，不是帮助抑郁人群。</p><p>大多数基础研究是普遍性研究，但有时候基础研究也会是特殊性研究。例如，在非常特定的情形下的研究。好比我们调查玩暴力游戏和攻击行为的相关性，就在阿姆斯特丹特定的初犯少年犯群体中，他们都来自权贵阶级。在玩暴力游戏和攻击行为相关性方面，这个非常特定的问题群体能提供有趣的新见解。注意，我们不观察该群体如何改造或不再犯罪。</p><p>应用研究常是特殊性研究，旨在特定环境、特定群体中解决问题，但它也可以是普遍性的研究。以养猫来减少抑郁的研究为例，我们可以扩展这项应用研究，比较照顾友善易交流的猫和拒绝接触的猫的人群。这会更有针对性地帮助找到何种治疗有效，但这也加入了普遍性元素，我们还可以调查它对孤独的意义。仅仅有个活物存在就够了吗？还是需要有互动？很多时候，应用研究的结果会产生新的见解，这些见解会和介入或治疗相关，但它们也会提供基础的知识。</p><p>因此，两种研究类型会互相增强。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;认识论-Epistemology&quot;&gt;&lt;a href=&quot;#认识论-Epistemology&quot; class=&quot;headerlink&quot; title=&quot;认识论 (Epistemology)&quot;&gt;&lt;/a&gt;认识论 (Epistemology)&lt;/h1&gt;&lt;p&gt;在把假说 - 演绎法
      
    
    </summary>
    
    
      <category term="social-science" scheme="https://theinfinitegame.tech/categories/social-science/"/>
    
    
      <category term="计量方法" scheme="https://theinfinitegame.tech/tags/%E8%AE%A1%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    
      <category term="社会科学" scheme="https://theinfinitegame.tech/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>iOS 笔记 | 地图 API</title>
    <link href="https://theinfinitegame.tech/development/note-ios-map-api/"/>
    <id>https://theinfinitegame.tech/development/note-ios-map-api/</id>
    <published>2020-02-26T05:22:08.000Z</published>
    <updated>2020-02-26T12:27:09.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CLLocationManager-CLLocationManagerDelegate"><a href="#CLLocationManager-CLLocationManagerDelegate" class="headerlink" title="CLLocationManager, CLLocationManagerDelegate"></a>CLLocationManager, CLLocationManagerDelegate</h1><p>监控目标区域，进入、离开，Beacon 相关</p><h2 id="MKMapView-MKCoordinateRegion-MKMapItem"><a href="#MKMapView-MKCoordinateRegion-MKMapItem" class="headerlink" title="MKMapView, MKCoordinateRegion, MKMapItem,"></a>MKMapView, MKCoordinateRegion, MKMapItem,</h2><ul><li>坐标 CLLocationCoordinate2D （CoreLocation）</li><li>MKMapItem</li><li>罗盘按钮 MKCompassButton</li></ul><ul><li>用 Array:compactMap 获取一个可选型集合到非可选型且不包含 nil 的映射集合。</li></ul><h2 id="KVO-Compliant-KVO-兼容"><a href="#KVO-Compliant-KVO-兼容" class="headerlink" title="KVO Compliant (KVO 兼容)"></a>KVO Compliant (KVO 兼容)</h2><p>KVO is key-value observing.</p><h2 id="MKLocalSearch-查找附近，MKLocalSearchCompleter"><a href="#MKLocalSearch-查找附近，MKLocalSearchCompleter" class="headerlink" title="MKLocalSearch 查找附近，MKLocalSearchCompleter"></a>MKLocalSearch 查找附近，MKLocalSearchCompleter</h2><h2 id="UISearchResultsUpdating"><a href="#UISearchResultsUpdating" class="headerlink" title="UISearchResultsUpdating"></a>UISearchResultsUpdating</h2><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">updateSearchResults (<span class="keyword">for</span> searchController: <span class="type">UISearchController</span>)</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CLLocationManager-CLLocationManagerDelegate&quot;&gt;&lt;a href=&quot;#CLLocationManager-CLLocationManagerDelegate&quot; class=&quot;headerlink&quot; title=&quot;CLLoca
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
      <category term="iOS" scheme="https://theinfinitegame.tech/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>watchOS 学习笔记 | 最小可行 Complication</title>
    <link href="https://theinfinitegame.tech/development/note-watchos-minimum-viable-complication/"/>
    <id>https://theinfinitegame.tech/development/note-watchos-minimum-viable-complication/</id>
    <published>2020-02-20T06:43:35.000Z</published>
    <updated>2020-02-22T05:30:26.785Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>要做一个 watch app，逻辑上，你会先想到从主 UI 开始。毕竟，notfication 和 complication 是可选的。人们说到 app ，通常指的就是主 UI 。</p><p>但是，如果要做一个在表盘用于浏览空气质量指数的 watch app ，你会先想到 complication 。 watchOS 设计的三大准则之一是 <strong>glanceable</strong> ，意味着用户能在扫一眼手表，以尽快的方式看到想要的信息，理想的时间最多几秒钟。 complication 可以让看到这些信息，比从 app 启动栏访问主 UI 快得多。</p><p>不同于 iOS ，watchOS 的应用并不要求主 UI 一定得是最常用的使用方式 —— 如果用例使得通知和 complication 更合理的话。主 UI 可以充当用户想要查看更具体信息或者特定的动作时的 “回退” 方案。</p></blockquote><p>那么，为什么我们不跳过 view controller ，直接尝试构建一个 complication 呢？</p><p>以下是 Kuba 构建的一个简单的 MVP 版本的 watch app ，只有一个 complication (支持 1~2 种变体)。这个 app 没有 UI ，主试图只有一个黑盒子，一行 WKInterface* 对象相关的代码都没有。</p><p>这个没有 UI 的 watch app 的用途是获取空气质量的信息（PM10，PM2.5，$ NO_2 $ 等)，每个小时更新一次，但足够用了。</p><p><img src="/images/minimum-complication-watch-app.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>下面先了解一些基础知识。</p><hr><h1 id="Complication-时间线"><a href="#Complication-时间线" class="headerlink" title="Complication 时间线"></a>Complication 时间线</h1><p>管理 complications 的 API 单独从 WatchKit 分离出来，位于 ClockKit 中，以 <code>CLK</code> 前缀标识。</p><p>有一些 complication 在你抬腕时就是可见的。当手表的屏幕亮起，你希望立即看到渲染的 complication widget ，它显示的数据当下就必须是最新的 —— 用户很可能只看了它一秒钟不到，因此没有时间在这个时候启动网络请求。</p><p>Apple 也不可能采用 7 天 24 小时的方式让应用在后台运行扩展 —— 电池撑不住。</p><p>所以工作方式实际上是这样的：你的应用指定一个 <strong>complication data source</strong>  (<code>CLKComplicationDataSource</code>) ，然后每当它接收到新的数据时 (无论运行在前台或者后台)，它告诉 <strong>complication server</strong> (<code>CLKComplicationServer</code>) 通过数据源刷新数据。数据源返回一个 <strong>timeline</strong> 数据 (一个 <code>CLKComplicationTimelineEntry</code> 的对象) —— timeline 告诉 watchOS complication 在给定时间点到下一个时间点之前应该显示什么数字、文本、图标或者它们的组合。系统缓存这份数据。并且在正确的时间点自动更新显示的内容 —— 你的 app 只有在需要返回 timeline 时才会被唤起，但实际上也可以做到不需要唤起。你可以预先准备一整天的内容，只要你的数据足够提前。</p><p>下图是一个经典的天气 app 的例子，点标记 timeline 实体，上面的线显示每个实体被展示的时长。</p><p><img src="/images/timeline1.png" width="68%" height="68%" style="margin: 10 auto;"></p><p>而这个是日历 app 的 complication ：</p><p><img src="/images/timeline2.png" width="68%" height="68%" style="margin: 10 auto;"></p><p>取决于 app 类型，你需要的数据可能是未来的，过去的，两者都有，或者只需要当前状态。</p><p>在 Kuba 的案例中，他用的是过去的数据 —— 因为 PM10 这种数据不可能精确预测，它受到很多因素影响，某些是人为的 (比如烧煤取暖这类日常活动)</p><h1 id="Time-Travel"><a href="#Time-Travel" class="headerlink" title="Time Travel"></a>Time Travel</h1><p>Timeline 的设计还用到 watchOS 的另外一个特性，叫做 <strong>“Time Travel”</strong> ，它使得你可以在表盘上向前或者向后滚动时间，并更新 complication —— 这使得你可以看到诸如一场比赛中比分变化的过程，或者一只股票在一天中股价变化的过程。</p><p>watchOS 5 中这个特性被完全移除了，这意味着现在没办法看过去时间点的数据了。所以在实践中，实现处理过去数据这部分的 complication API 没有意义。</p><p>未来的数据仍然有价值 —— 虽然没有办法直接滚动操作了，但是 time travel 还可以工作，只不过是单方向固定节奏了。</p><p>有趣的是，这部分无用的 API 尚未被废弃，这意味着未来有回归的可能。</p><h1 id="Comlication-家族"><a href="#Comlication-家族" class="headerlink" title="Comlication 家族"></a>Comlication 家族</h1><p>在 watchOS 5 中你可以选择多达 26 种样式的表盘。不同的表盘可以适应不同数量和形状的 complications 。这些形状或者 complication 空间的变体被称为 <strong>complication famlilies</strong> ，目前有 10-11 种 families 可用：</p><ul><li>Modular Small, 用于所有的经典模块化表盘，也可用于 Siri 表盘的角落</li><li>Modular Large, 只能用在模块化表盘中间唯一的位置</li><li>Circular Small, 用于一些不同的表盘 (e.g. Activity)</li><li>Utilitarian Small (有 “flat” 变体) 和 Utilitarian Large, 用于占据表盘一半以上空间，展示一条水平的内容 (它有一个模式，容易跟 Circular Small 混淆)</li><li>Extra Large, 只用在 X-Large 表盘上</li><li>Graphic Corner, Graphic Circular, Graphic Bezel 和 Graphic Rectangular, 只用在 Apple Watch 4 系列的 Infograph 表盘</li></ul><p>你可以支持其中任意多你想要的家族子集，当然，理想情况下一个好的 app 是支持所有这些家族，因为不同的人偏好不同的表盘。</p><p>项目中为了让事情简单一些，我们只添加了对 Modular Small 和 Circular Small 的支持（覆盖了 11 中表盘，如果没算错的话）。</p><h1 id="内容模板"><a href="#内容模板" class="headerlink" title="内容模板"></a>内容模板</h1><p>由于资源的限制，你无法在 complication 空间随意绘制东西，你只能使用预定义的模板。模板限定了它们可以包含的内容类型和排布方式。你唯一的选择是选择一种模块，适配给定的空间，放入文本，图标或者值。</p><p>举个例子， Circular Small 家族有 6 种可用的模块：</p><p>.ringImage, 中间一个图标，然后一个围绕它的环，其他环的哪些部分被填充可以由你指定<br>.ringText, 中间是文本，然后一个围绕它的环 (实际中，文本通常是 1 到 3 位数字)<br>.simpleImage, 就是个简单的图标<br>.simpleText, 就是个标签<br>.stackImage, 上面一个小图标，下面是短的标签<br>.stackText, 两行短文本</p><p>大部分模块都只有极其有限的空间用于展示内容，有的时候你需要绞尽脑汁想如何利用给定的空间。如果实在想不出来，那么放弃对特定 complication 家族的支持也是可以的。</p><p>你的 app 会一些不同的状态 —— 例如，有或者没有数据，空或者非空数据列表，有或者没有进行中的活动等等。所以根据状态来选用不同的模块是可以的（比如，某些状态用数字，某些状态用图标）。每当你构建 timeline 时，你可以创建全新的模板对象并且用它们填充内容，所以只要你开心，甚至可以每次采用随机模板。</p><h1 id="文本和图像-providers"><a href="#文本和图像-providers" class="headerlink" title="文本和图像 providers"></a>文本和图像 providers</h1><p>为了渲染不同类型内容的灵活性， timeline 数据并非简单地以 <code>String</code> 或者 <code>UIImage</code> 对象的形式返回，而是借助某种可用的 <strong>provide</strong> 对象封装。这些 provider 使得你的内容可以更加动态，根据时间和上下文变化。</p><p>对于文本，最简单的选项是 <code>CLKSimpleTextProvider</code> ，你可以指定单一的字符串以及一个可选的简短版本，如果空间无法容纳完整字符串，则选取简短版本。</p><p>作为替代方案，有几种时间相关内容的 provider 可供选择：</p><ul><li><code>CLKDateTextProvider</code> 输出日期 (日 / 月)</li><li><code>CLKTimeTextProvider</code> 输出特定时间 (小时 / 分钟)</li><li><code>CLKTimeIntervalTextProvider</code> 输出时间范围 (from-to)</li><li><code>CLKRelativeDateTextProvider</code> 输出自某个时间开始或者到某个时间结束 (例如 “2 小时后”)</li></ul><p>上面最后一种会随着时间的流逝自动更新，你只需要配置一次目标时间戳，而不用每小时或者更频繁地手动更新，例如 “5 小时后”，“4 小时后” 等等。</p><p>对于图像，你通常用 <code>CLKImageProvider</code> 。它让你指定一个模板图像（被渲染为单色）和一个颜色。多少情况下，这个颜色会被忽略，因为大部分表盘都是以用户选定的单一颜色渲染所有的 complications 。有一个叫 <code>CLKFullColorImageProvider</code> 的模块可以以全彩的方式渲染图像，但只在新的 Infograph 表盘才用到。</p><p>模拟 Infograph 表盘上的 complications 还用到一些 <code>CLKGaugeProvider</code> —— 它们是用于配置新表盘角落里的彩色弧线。</p><hr><p>出发！</p><p>首先，创建工程，使用模板 “watchOS &gt; iOS App with WatchKit App” ，确保 “Include Complication” checkbox 勾选。</p><p>工程将包含 3 个 targets：</p><ul><li>SmogWatch, 它是 iOS app (这个案例里我们基本不碰这部分)</li><li>SmogWatch WatchKit App, UI 部分，只包含了 storyboard, (包括主 UI 和可能的 notification 场景) 以及 asset catalog 。</li><li>SmogWatch WatchKit Extension, 包含所有的 WatchKit 代码</li></ul><p>在导航栏中选择 “SmogWatch WatchKit App” 目标运行。</p><p><img src="/images/sim-new-app.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><h1 id="设计模板"><a href="#设计模板" class="headerlink" title="设计模板"></a>设计模板</h1><p>如上文所提，为了让事情更简单，我们只是实现 Modular Small 和 Circular Small complication 家族。不过默认情况下所有的 complication 家族都是启用的，所以你需要禁用掉其他的。</p><p>打开 “SmogWatch WatchKit Extension” target 的配置页，在 “General” tab 你会看见一个可以触发 complication 家族的列表：</p><p><img src="/images/enabled-complications.png" width="68%" height="68%" style="margin: 10 auto;"></p><p>接下来，要确定每个 complication 家族要采用什么模板。在 <a href="https://developer.apple.com/documentation/clockkit" target="_blank" rel="noopener">CloudKit 文档</a> 中，找到 Modular Small 家族。在它的页面上，你会看到 7 种可用的模板类以及它们的效果截屏。</p><p>在我们的案例中，我们主要显示小数字，所以下面几种选项可能是合理的：</p><ul><li>显示数字，例如 “75” - 可读性没问题，但是第一眼看数字代表什么不明显</li><li>以一个圆来显示数字 - 弧应该怎么算，没有上限怎么办？</li><li>以上面是图标，下面是数字的方式显示</li><li>以两行文本显示</li></ul><p>最后，我选择了像下面这样的样式：</p><p><img src="/images/modular-small.png" width="10%" height="10%" style="margin: 10 auto;"></p><p>这个方案解决了展示 app 是什么的类型，同时也支持解释不同类型参数的问题，缺陷是使得字体更小了，尤其是 3 个数字的情况。尽管仍然可读，但是 Circular Small 版本肯定效果不好。因此，对于 Circular Small ，选项相似，也选择了两行文本的版本。</p><p><img src="/images/circular-small.png" width="7%" height="7%" style="margin: 10 auto;"></p><p>上面这个可读性差很多，但是 Circular Small 是非常通用的 complication 家族，因此基本上对所有使用者都是一个挑战。Apple 自己的 complications ，比如世界时钟，日出、日落，看起来也没有好多少。我们这里可以放弃 “PM” ，但这样一来又搞不清 app 是干什么用的，所以折中，把 “PM10” 缩短为 “PM” 。有可能上面用图标效果会更好，读者可以尝试一下。</p><hr><h1 id="实现-Complication-数据源"><a href="#实现-Complication-数据源" class="headerlink" title="实现 Complication 数据源"></a>实现 Complication 数据源</h1><p>现在，打开样板代码 <code>ComplicationController</code> 类，这里已经数据源协议所有要求的方法了，一些是空实现，但其中大多数我们并不需要。</p><p>注意，所有的方法都是通过一个 handler callback 返回数据的。这使得你可以通过某些异步的方式加载要求的数据 —— 理论上，你是可以按需在用到时再加载这些数据，但实际上我们绝不应该这么做。 </p><p>所有的方法都传入一个 CLKComplication 对象作为参数，它让你知道系统现在正为哪一种 complication 向你询问数据，这个对象只有一个字段叫 family ，这意味着在一个 Modular 表盘上，你无法区分同族的两个 complication 实例，但是不同族的可以。</p><p>因此，这个信息绝对是必须的 —— 不仅因为不同家族外观看起来不一样，也是为了让编译器匹配你返回的模板类型。</p><p><code>CLKComplicationDataSource</code> 协议里只有 <code>getSupportedTimeTravelDirections</code> 和 <code>getCurrentTimelineEntry</code> 两个方法是必须得实现的，但我们会先从一个可选的方法开始讲。</p><h1 id="样例模板"><a href="#样例模板" class="headerlink" title="样例模板"></a>样例模板</h1><p>我们要看的第一个方法是 <code>getLocalizableSampleTemplate</code> ，在文件的底部 —— 你有可能会需要在把 complication 添加到表盘之前先实现这个方法。</p><p>这个方法让你返回一个 complication 的 “样例” 外观，它是当用户在表盘配置视图中设置 complication 时用到的。这里应当展示一些随机数据，表现你的 complication 一般情况下的外观，就像你在应用的网站或者应用商店上放的截图那样的东西。</p><p>在这个方法中，我们需要返回一个 <code>CLKComplicationTemplate</code> 对象 —— 在实际的 timeline 中，我们也会返回一样的东西。不过这里不指定时间戳。对于两种 complication 家族，我们都用标准的 <code>CLKSimpleTextProvider</code> 来封装返回的文本。 在样例模板里，我们用 “50” 来代替真实值。</p><p>下面是代码：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLocalizableSampleTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTemplate?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"50"</span>)</span><br><span class="line">        handler (template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"50"</span>)</span><br><span class="line">        handler (template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>记得总是返回匹配给定 complication 家族的模板。不幸的是，好像没有可以在编译期检查这个过程的机制。</p><p>这里，我们为两种家族都选用了 “stack text” 模板，因此都有 <code>line1TextProvider</code> 和 <code>line2TextProvider</code> 属性。如果你选择另外的配置的话，可能的属性有 <code>imageProvider</code> ， <code>headerTextProvider</code> ， <code>ringStyle</code> 等等。</p><p>如果系统向我们请求其他我们不支持的 complication 类别的话，我们在默认 case 抛出断言 —— 但这不应该发生，因为我们已经禁用所有其他类型的 complication 。用 <code>preconditionFailure</code> 触发崩溃是为了确保自己不忘掉一些东西，最终版本其实应该返回 nil 更安全。</p><p>之所以先说这部分，是因为无论你在这个模板返回了什么，它都会被系统缓存。如果你改变了代码再次运行，你不会看到任何效果 —— 你需要从模拟器中删除 app ，重新安装以便更新版本。</p><p>现在，当你运行 app ，你可以编辑表盘（通过用力按压 MacBook 的 touchpad ，或者在菜单 Hardware &gt; Touch Pressure），选择一个 complication 空间，并且选择你的 complication ：</p><p><img src="/images/watch-face-editing-1.png" width="25%" height="25%" style="margin: 10 auto;"></p><p>注意，默认你的 app 名是 app target 的完整名，这会有点长。为了把它改成更可读的，打开 WatchKit app target 的 <code>Info.plist</code> (注意，是 app 而不是 extension 的) 然后把 “Bundle display name” 改成 “SmogWatch” 。</p><p>当你退出编辑模式并返回表盘，你会看到你放置 complication 的地方有一个空白的空间 —— 别急，我们接下来就着手处理这块。</p><h1 id="getSupportedTimeTravelDirections"><a href="#getSupportedTimeTravelDirections" class="headerlink" title="getSupportedTimeTravelDirections"></a>getSupportedTimeTravelDirections</h1><p>这个方法告知系统你的 app 在过去、未来、两个方向或者只有当前时刻拥有数据。因为之前提到过去的数据已经不再使用了，所以只有返回 <code>.forward</code> 或者空列表是有意义的。由于我们并不需要预测未来的空气质量，所以我们只需要返回一个空的列表：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getSupportedTimeTravelDirections</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimeTravelDirections)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    handler ([])</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里返回的东西决定了系统是否会调用 <code>getTimelineStartDate</code> ， <code>getTimelineEndDate</code> ， <code>getTimelineEntries (for:before:limit:withHandler:)</code> 和 <code>getTimelineEntries (for:after:limit:withHandler:)</code> 这些方法，以询问你 timeline 在两个方向上延展的长度，时点。如果我们返回 <code>[]</code> ，那么系统只会询问当前时点。</p><p>不过这些方法都是可选的，所以如果你都不实现它们， watchOS 会假定当前时点没有什么有趣的东西。</p><h1 id="getCurrentTimelineEntry"><a href="#getCurrentTimelineEntry" class="headerlink" title="getCurrentTimelineEntry"></a>getCurrentTimelineEntry</h1><p>这是整个协议核心的代码，它是我们返回最新数据点的地方。</p><p>timeline 数据是以一个或者多个 <code>CLKComplicationTimelineEntry</code> 对象返回的。一个 timeline 实体其实就是一个时间戳加上一个或者多个指派的数据 provider ，里面填充着你需要的数据。实体借由时间戳验证。</p><p>目前我们还没有实际拥有数据，不过别担心 —— 我们可以先返回一个静态数值，比如 75 ，就像样例模板中的做法一样。我们使用当前时间作为时间戳，因为根据前面方法返回的设定，我们不会被询问任何在当前时点之前的时段数据。</p><p>下面是 <code>getCurrentTimelineEntry</code> 的初始版本:</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentTimelineEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimelineEntry?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> entry: <span class="type">CLKComplicationTimelineEntry</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"75"</span>)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: <span class="type">Date</span>(), complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"75"</span>)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: <span class="type">Date</span>(), complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    handler (entry)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>当你添加了以上两个方法，编译运行你的 app 到模拟器。你应该会在 complication 里看到我们配置的模板和数值：</p><p><img src="/images/watch-complication-75.png" width="25%" height="25%" style="margin: 10 auto;"></p><p>如果你还是没有看到效果，那可能是因为系统缓存了之前编译版本的状态。为了强制加载 complication ，你可以进入编辑模式，切到不同的 complication ，退出编辑模式。 然后再进入编辑模式，切回你的 complication 。</p><h1 id="可选的方法"><a href="#可选的方法" class="headerlink" title="可选的方法"></a>可选的方法</h1><p>在数据源协议中还有一些其他的协议，但针对我们的用途，我们只需要用到 <code>getTimelineEntries (for:after:limit:withHandler:)</code> 。这个方法询问我们早前传入的 timeline 时点之后的时点。当我们写的 app 需要提前了解某个时点时，会用到这个方法。例如，天气预报，日历事件，todo list 上预定的任务等。不过，大部分 app 只需要显示当前实体就够了。</p><p>我们在这个 app 中使用这个 API 的作用是，我们很可能需要在时点过去之后将未来版本的数据标记为过时。如果你查看的是 6 个小时前的空气质量，它很可能是没什么价值的，因为当前的空气很有可能已经发生显著的变化。在 Krakow ，这种变化可能发生在 2 个小时内。例如，起风或者风停了。所以，我们可能在几小时后自动隐藏掉当前数值，借助添加一个几小时后的 “重置” 数据来实现。如果我们成功地在每个小时更新了数据，那么备选的第二个时点的数据永远不会被展示，但是如果有些东西出错了，那么当时间变化足够长，会在时点到来时借助这个 API 来更新数据。</p><p>我认为 watchOS 之前应该也是这么干的，至少在 Time Travel 功能里是这么做的 —— 文档里也提到了。不过这本该是 <code>getTimelineStartDate</code> 和 <code>getTimelineEndDate</code> 方法存在的意义 —— 但是由于这两个 API 不起作用 (Time Travel)，所以实现它们也没意义。 </p><hr><h1 id="从网络上获取真实数据"><a href="#从网络上获取真实数据" class="headerlink" title="从网络上获取真实数据"></a>从网络上获取真实数据</h1><p>对于第一个版本，我们用使用 Małopolska 地区空气监控系统的公共数据 (仅限波兰) 。</p><p>前端通过一个挺复杂的 POST 请求，发送到 URL <a href="http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz" target="_blank" rel="noopener">http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz</a> ，然后解析返回的 Json 数据。</p><p>这个主题并不是跟 watchOS 特定相关，它是特定于 web API —— 所以这里不详细描述，下面是拉取和解析数据的完整代码：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">DataURL</span> = <span class="string">"http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KrakowPiosDataLoader</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> dateFormatter: <span class="type">DateFormatter</span> = {</span><br><span class="line">        <span class="keyword">let</span> d = <span class="type">DateFormatter</span>()</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 不确定下面是否必须，安全起见 </span></span><br><span class="line">        <span class="comment">//see https://developer.apple.com/library/archive/qa/qa1480/</span></span><br><span class="line">        d.locale = <span class="type">Locale</span>(identifier: <span class="string">"en_US_POSIX"</span>)</span><br><span class="line"> </span><br><span class="line">        d.dateFormat = <span class="string">"dd.MM.yyyy"</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 确保我们用的是 CET 时区 —— 比如说你是在莫斯科 </span></span><br><span class="line">        <span class="comment">// 你在 2 月 19 号午夜之后请求 19.02.2019 （这时候在波兰还是 2 月 18 号）</span></span><br><span class="line">        <span class="comment">// 你将拿不到数据 </span></span><br><span class="line">        d.timeZone = <span class="type">TimeZone</span>(identifier: <span class="string">"Europe/Warsaw"</span>)!</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    }()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> dataStore = <span class="type">DataStore</span>()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">let</span> session: <span class="type">URLSession</span> = {</span><br><span class="line">        <span class="keyword">let</span> config = <span class="type">URLSessionConfiguration</span>.ephemeral</span><br><span class="line">        config.timeoutIntervalForResource = <span class="number">10.0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">URLSession</span>(configuration: config)</span><br><span class="line">    }()</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">queryString</span><span class="params">()</span></span> -&gt; <span class="type">String</span> {</span><br><span class="line">        <span class="keyword">let</span> query: [<span class="type">String</span>: <span class="type">Any</span>] = [</span><br><span class="line">            <span class="string">"measType"</span>: <span class="string">"Auto"</span>,</span><br><span class="line">            <span class="string">"viewType"</span>: <span class="string">"Parameter"</span>,</span><br><span class="line">            <span class="string">"dateRange"</span>: <span class="string">"Day"</span>,</span><br><span class="line">            <span class="string">"date"</span>: dateFormatter.string (from: <span class="type">Date</span>()),</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//hardcoded ID for PM10 on a specific station</span></span><br><span class="line">            <span class="comment">//we'll make it configurable later</span></span><br><span class="line">            <span class="string">"viewTypeEntityId"</span>: <span class="string">"pm10"</span>,</span><br><span class="line">            <span class="string">"channels"</span>: [<span class="number">148</span>]</span><br><span class="line">        ]</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> jsonData = <span class="keyword">try</span>! <span class="type">JSONSerialization</span>.data (withJSONObject: query, options: [])</span><br><span class="line">        <span class="keyword">let</span> json = <span class="type">String</span>(data: jsonData, encoding: .utf8)!</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//don't ask me, that's what the API expects</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"query=\(json)"</span></span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(<span class="number">_</span> completion: @escaping <span class="params">(Bool)</span></span></span> -&gt; ()) {</span><br><span class="line">        <span class="keyword">var</span> request = <span class="type">URLRequest</span>(url: <span class="type">URL</span>(string: <span class="type">DataURL</span>)!)</span><br><span class="line">        request.httpBody = queryString ().data (using: .utf8)!</span><br><span class="line">        request.httpMethod = <span class="string">"POST"</span></span><br><span class="line"> </span><br><span class="line">        <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: sending request to %@ with %@ ..."</span>,</span><br><span class="line">            <span class="type">DataURL</span>, queryString ())</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">let</span> task = session.dataTask (with: request) { (data, response, error) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">var</span> success = <span class="literal">false</span></span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> error = error {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: received error: %@"</span>, <span class="string">"\(error)"</span>)</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: received response: %@"</span>,</span><br><span class="line">                    data != <span class="literal">nil</span> ? <span class="string">"\(data!.count) bytes"</span> : <span class="string">"(nil)"</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> data = data {</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> obj = <span class="keyword">try</span>? <span class="type">JSONSerialization</span>.jsonObject (with: data, options: []) {</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">let</span> json = obj <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] {</span><br><span class="line">                        <span class="keyword">if</span> <span class="keyword">let</span> data = json [<span class="string">"data"</span>] <span class="keyword">as</span>? [<span class="type">String</span>: <span class="type">Any</span>] {</span><br><span class="line">                            <span class="keyword">if</span> <span class="keyword">let</span> series = data [<span class="string">"series"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>: <span class="type">Any</span>]] {</span><br><span class="line"> </span><br><span class="line">                                <span class="comment">//there would be more than one data series if we passed</span></span><br><span class="line">                                <span class="comment">//multiple "channel IDs" (e.g. for more than 1 station)</span></span><br><span class="line">                                <span class="keyword">if</span> <span class="keyword">let</span> first = series.first {</span><br><span class="line">                                    <span class="keyword">if</span> <span class="keyword">let</span> points = first [<span class="string">"data"</span>] <span class="keyword">as</span>? [[<span class="type">String</span>]] {</span><br><span class="line"> </span><br><span class="line">                                        <span class="comment">//the data series is an array of up to 26 hourly</span></span><br><span class="line">                                        <span class="comment">//measurements; we only take the last one for now</span></span><br><span class="line">                                        <span class="keyword">if</span> <span class="keyword">let</span> point = points.last {</span><br><span class="line">                                            <span class="keyword">let</span> date = <span class="type">Date</span>(</span><br><span class="line">                                                timeIntervalSince1970: <span class="type">Double</span>(point [<span class="number">0</span>])!</span><br><span class="line">                                            )</span><br><span class="line">                                            <span class="keyword">let</span> value = <span class="type">Double</span>(point [<span class="number">1</span>])!</span><br><span class="line"> </span><br><span class="line">                                            <span class="keyword">self</span>.dataStore.currentLevel = value</span><br><span class="line">                                            <span class="keyword">self</span>.dataStore.lastMeasurementDate = date</span><br><span class="line"> </span><br><span class="line">                                            <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: saving data:"</span> +</span><br><span class="line">                                                <span class="string">"%.0f at %@"</span>, value, <span class="string">"\(date)"</span>)</span><br><span class="line"> </span><br><span class="line">                                            success = <span class="literal">true</span></span><br><span class="line">                                        }</span><br><span class="line">                                    }</span><br><span class="line">                                }</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> !success {</span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"KrakowPiosDataLoader: no data found"</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">            completion (success)</span><br><span class="line">        }</span><br><span class="line"> </span><br><span class="line">        task.resume ()</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>不要忘记在最后用 <code>resume ()</code> 启动任务。</p><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ul><li>我们向 API 请求 PM10 的数据，硬编码请求当天和特点地点。</li><li>我们只取最后的测量结果 (多数情况下是最近一两个小时的数据)</li><li>如果我们拿到数据，存储一个数字，表示 PM10 的浓度，以及测量的时间点</li><li>通知调用方我们拿到或者没有拿到数据</li></ul><p>上面的代码用了老式的 Json 解析方法，因为我认为这样比较容易理解。</p><p>我用老式的 <code>NSLog</code> 而不是 Swift 的 <code>print ()</code> ，是因为后者只会显示在 Xcode 的控制台，并不会记录到系统日志，所以在控制台 app 的诊断日志里看到，在某些情况下你需要在 app 没有连接 mac 时跟踪它的行为。</p><p>还有，注意我们是在前台请求数据，用最基本的 URL session 。这不是通常我们最理想的应用方案 —— 理想的，所有的请求都应该是在后台 URL sessions 中完成，不过这里只是一个最小可用原型，先保持这样吧。</p><p>不过我们通过把超时时间设置为每次请求不超过 10 秒钟来限制了 URL session。 这里 <code>timeoutIntervalForResource</code> 的用法，而不是 <code>timeoutIntervalForRequest</code> 或者 <code>timeoutInterval</code> 很重要，因为自上一次接收到数据包后，后面两个只会在空闲时间工作，而我们希望控制总的请求时间。之所以要控制总时间，是因为看起来这里边有一个针对后台任务的硬性限制，并且没有在文档中提到：如果一个 app 超出了 15 秒的后台运行时间，它会被立即杀死，崩溃报告如下：</p><blockquote><p>Termination Reason: CAROUSEL, Background App Refresh watchdog transgression. Exhausted wall time allowance of 15.00 seconds. Termination Description: SPRINGBOARD, CSLHandleBackgroundRefreshAction watchdog transgression: eu.mackuba.SmogWatch.watchkitapp.watchkitextension exhausted real (wall clock) time allowance of 15.00 seconds (…)</p></blockquote><p>为了便于你了解最后一次检测的时间点，我们把 <code>lastMeasurementDate</code> 时间戳存进了 <code>DataStore</code> ，这是一个我们可以用来实现之前提到的 “过时数据 特性的潜在结构。</p><p>那么这个 <code>DataStore</code> 究竟是什么？其实只是 <code>UserDefaults</code> ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">CurrentLevelKey</span> = <span class="string">"CurrentLevel"</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">let</span> <span class="type">LastMeasurementDate</span> = <span class="string">"LastMeasurementDate"</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataStore</span> </span>{</span><br><span class="line">    <span class="keyword">let</span> defaults = <span class="type">UserDefaults</span>.standard</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> currentLevel: <span class="type">Double?</span> {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> defaults.object (forKey: <span class="type">CurrentLevelKey</span>) <span class="keyword">as</span>? <span class="type">Double</span> }</span><br><span class="line">        <span class="keyword">set</span> { defaults.<span class="keyword">set</span>(newValue, forKey: <span class="type">CurrentLevelKey</span>) }</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> lastMeasurementDate: <span class="type">Date?</span> {</span><br><span class="line">        <span class="keyword">get</span> { <span class="keyword">return</span> defaults.object (forKey: <span class="type">LastMeasurementDate</span>) <span class="keyword">as</span>? <span class="type">Date</span> }</span><br><span class="line">        <span class="keyword">set</span> { defaults.<span class="keyword">set</span>(newValue, forKey: <span class="type">LastMeasurementDate</span>)}</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>最后，我们需要添加一个例外域名到 WatchKit Extension target 的 App Transport Security 设置中，因为这个域名不支持 Https 。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">key</span>&gt;</span>NSAppTransportSecurity<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionDomains<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">key</span>&gt;</span>monitoring.krakow.pios.gov.pl<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">key</span>&gt;</span>NSExceptionAllowsInsecureHTTPLoads<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">true</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h1 id="显示真实数据"><a href="#显示真实数据" class="headerlink" title="显示真实数据"></a>显示真实数据</h1><p>为了实际加载数据，我们需要在某个地方调用这个类的方法。我们来看一看 <code>ExtensionDelegate</code> 这个类，它实现了 <code>WKExtensionDelegate</code> —— 基本上就是一个 WatchKit 版本的 <code>UIApplicationDelegate</code> 。就像所有的 app 代理， <code>WKExtensionDelegate</code> 有许多生命周期方法，这些方法会被系统在各种时刻调用： <code>applicationWillEnterForeground</code> ， <code>applicationDidBecomeActive</code> ， <code>applicationWillResignActive</code> 和 <code>applicationDidEnterBackground</code> 等等。</p><p>这里头我们目前唯一会用到的是 <code>applicationDidFinishLaunching</code> 。这个方法会在 app 进程启动时被调用 —— 无论是通过 app launcher 或者通过 Xcode ，又或者从后台启动。只要是 app 需要被唤起，并且之前已经被系统清理掉的时候，这个周期都会运行 (通常在晚上，被系统杀死的情况经常发生) 。</p><p>无论何时， app 启动或者在后台重启，我们都希望借助这个机会立即拉取最新的数据，如果我们得到响应，重新加载所有活动的 complication （活动的 complication 指那些在当前选择的表盘上显示的 complication）。</p><p>所以我们将这样做：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: applicationDidFinishLaunching ()"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> success {</span><br><span class="line">            <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>为了拉取数据，我们调用了 KrakowPiosDataLoader 类，然后在有任何新数据的情况下重载加载 complications ，否则的话就不必了。在 watchOS 上，不要浪费时间做无用功，这是一条通用的准则。</p><p>为了重新加载 complications ，我们得拿到活动 complication 的列表，这是借由全局共享的  <code>CLKComplicationServer</code> 实例来获得的，并且也通过它的 <code>reloadTimeline (for:)</code> 方法来重新加载那些活动的 complication 。如果打算在已经存在的 timeline 实体后追加新的 timeline 实体，我们也可以用另一个相似方法  <code>extendTimeline (for:)</code> ，两者的区别是前者我们希望立刻用新数据替换掉之前的数据。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reloadActiveComplications</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">let</span> server = <span class="type">CLKComplicationServer</span>.sharedInstance ()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> complication <span class="keyword">in</span> server.activeComplications ?? [] {</span><br><span class="line">        server.reloadTimeline (<span class="keyword">for</span>: complication)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码会触发一轮对你的 <code>CLKComplicationDataSource</code> 的调用 —— 有的时候是一会之后，不过通常几乎都是立刻发生。现在我们有了真实数据，我们可以回到之前写的 <code>getCurrentTimelineEntry</code> 方法，然后把占位的代码替换成实际的逻辑：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getCurrentTimelineEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">for</span> complication: CLKComplication,</span></span></span><br><span class="line"><span class="function"><span class="params">    withHandler handler: @escaping <span class="params">(CLKComplicationTimelineEntry?)</span></span></span> -&gt; <span class="type">Void</span>)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">let</span> store = <span class="type">DataStore</span>()</span><br><span class="line">    <span class="keyword">let</span> entry: <span class="type">CLKComplicationTimelineEntry</span></span><br><span class="line">    <span class="keyword">let</span> date: <span class="type">Date</span></span><br><span class="line">    <span class="keyword">let</span> valueLabel: <span class="type">String</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> lastMeasurement = store.lastMeasurementDate, <span class="keyword">let</span> level = store.currentLevel {</span><br><span class="line">        valueLabel = <span class="type">String</span>(<span class="type">Int</span>(level.rounded ()))</span><br><span class="line">        date = lastMeasurement</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        valueLabel = <span class="string">"--"</span></span><br><span class="line">        date = <span class="type">Date</span>()</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">switch</span> complication.family {</span><br><span class="line">    <span class="keyword">case</span> .modularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateModularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM10"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: valueLabel)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: date, complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">case</span> .circularSmall:</span><br><span class="line">        <span class="keyword">let</span> template = <span class="type">CLKComplicationTemplateCircularSmallStackText</span>()</span><br><span class="line">        template.line1TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: <span class="string">"PM"</span>)</span><br><span class="line">        template.line2TextProvider = <span class="type">CLKSimpleTextProvider</span>(text: valueLabel)</span><br><span class="line">        entry = <span class="type">CLKComplicationTimelineEntry</span>(date: date, complicationTemplate: template)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">preconditionFailure</span>(<span class="string">"Complication family not supported"</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    handler (entry)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>现在，当我们运行 app 时，点击 home 按钮返回表盘时，我们会看到一个刚刚借助 API 加载的真实数据：</p><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExtensionDelegate: applicationDidFinishLaunching ()</span><br><span class="line">KrakowPiosDataLoader: sending request to http://monitoring.krakow.pios.gov.pl/dane-pomiarowe/pobierz with</span><br><span class="line">query={"viewTypeEntityId": "pm10", "measType": "Auto", "viewType": "Parameter", "dateRange": "Day",</span><br><span class="line">"date": "24.02.2019", "channels": [148]} ...</span><br><span class="line">KrakowPiosDataLoader: received response: 1553 bytes</span><br><span class="line">KrakowPiosDataLoader: saving data: 46.4462 at 2019-02-24 10:00:00 +0000</span><br></pre></td></tr></tbody></table></figure><p><img src="/images/watch-complication-46.png" width="34%" height="34%" style="margin: 10 auto;"></p><hr><h1 id="安排更新"><a href="#安排更新" class="headerlink" title="安排更新"></a>安排更新</h1><p>最后的拼图是确保我们可以按照有规律的间隔加载新的数据并重新加载 complication 。有一些场景你可以更新 complications ：</p><ul><li>当你的 app 处于前台时，你总是可以做这件事 —— 但你无法依赖它定期发生。</li><li>当你接受到一些静默的推送通知时，尤其是专门为这种用途设计的 (借助 PushKit framework ，采用  PKPushTypeComplication 类型) —— 当你的数据以不规则间隔更新时，这种机制会有用 —— 当外部发生一些事件时。</li><li>当 iPhone app 以某种方式接收到新的数据并把它传输给 watch 时</li><li>通过计划定期的后台刷新 —— 当你希望拉取数据而不是被动等推送时，这种方式更好。</li></ul><p>注意，不管你采用哪种策略，对于我们刷新数据的频率以及完成刷新的用时，有许多限制。 (比如，每天不超过 50 个推送通知) —— 如果你用尽了所有的时间或者每天可用的推送数量，你将无法再在后台运行，有可能要等到第二天。对于这点约束，看起来没有什么特别好的方案可以绕过，你也不应该尝试去寻找这类方案。</p><p>既然我们知道城市监测站每小时发送一次新的测量数据，我们会使用计划好的后台刷新来更新我们的 complication ，并且会在 <code>ExtensionDelegate</code> 中完成。</p><p>为了确保我们的 app ，我们需要实现一样我称为 “后台刷新循环” 的东西：当 app 启动或者重启时，我们安排一次后台刷新，然后当 app 被这个后台刷新唤起时，我们做的第一件事就是安排下一次后台刷新，以确保若干时间后总有新的刷新被计划。</p><p>我们会在所有其他事情之前开始做刷新计划，因为我们无法知道在我们的 app 被挂起或者杀死之前还有多少可用的时间。否则，如果在我们设置下一次刷新之前 app 就被挂起，那么 app 就相当于没设闹钟就睡过去了，那么它将会睡过头。 😉</p><p>现在，让我们再看一下 <code>applicationDidFinishLaunching</code> 方法，我们需要在 web 请求发送之前增加一个新的方法调用 <code>scheduleNextReload ()</code> :</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">applicationDidFinishLaunching</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: applicationDidFinishLaunching ()"</span>)</span><br><span class="line"> </span><br><span class="line">    scheduleNextReload ()</span><br><span class="line"> </span><br><span class="line">    <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">if</span> success {</span><br><span class="line">            <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="计算下一次刷新时间"><a href="#计算下一次刷新时间" class="headerlink" title="计算下一次刷新时间"></a>计算下一次刷新时间</h1><p>在计划下一次刷新前，我们首先需要定出下一次刷新的时机。</p><p>为了优化后台刷新的耗时，尽可能利用好珍贵的后台时间，思考清楚我们的数据究竟需要在何时和以何种频率改变。一个很好的例子是 —— 证券交易只发生在工作时间，不在工作时间内，股票价格不会变化，所以在夜间重载不会改变的数据是没有意义的。</p><p>我对获取数据的 API 做了一些测试，新的数据几乎总是 1 个整小时的 0 到 10 分钟内添加。所以我决定每小时请求一次刷新，总是在每小时的 15 分做这件事 (10:15 ， 然后 11:15， 然后 12:15 ，以此类推)。为了实现这种方式，我们需要一个辅助方法来让我们基于当前时间找到最接近 xx:15 的时间 —— 幸运的是，利用 NSCalendar API 很容易做到：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextReloadTime</span><span class="params">(after date: Date)</span></span> -&gt; <span class="type">Date</span> {</span><br><span class="line">    <span class="keyword">let</span> calendar = <span class="type">Calendar</span>(identifier: .gregorian)</span><br><span class="line">    <span class="keyword">let</span> targetMinutes = <span class="type">DateComponents</span>(minute: <span class="number">15</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">var</span> nextReloadTime = calendar.nextDate (</span><br><span class="line">        after: date,</span><br><span class="line">        matching: targetMinutes,</span><br><span class="line">        matchingPolicy: .nextTime</span><br><span class="line">    )!</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果和当前时间间隔小于 5 分钟，那么跳过，尝试下一个小时 </span></span><br><span class="line">    <span class="keyword">if</span> nextReloadTime.timeIntervalSince (date) &lt; <span class="number">5</span> * <span class="number">60</span> {</span><br><span class="line">        nextReloadTime.addTimeInterval (<span class="number">3600</span>)</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> nextReloadTime</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="计划后台刷新"><a href="#计划后台刷新" class="headerlink" title="计划后台刷新"></a>计划后台刷新</h1><p>最后，为了在计算好的未来时点请求更新，我们需要在 <code>WKExtension</code> (等价于 <code>UIApplication</code>) 上调用  <code>scheduleBackgroundRefresh</code> ：</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scheduleNextReload</span><span class="params">()</span></span> {</span><br><span class="line">    <span class="keyword">let</span> targetDate = nextReloadTime (after: <span class="type">Date</span>())</span><br><span class="line"> </span><br><span class="line">    <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: scheduling next update at %@"</span>, <span class="string">"\(targetDate)"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="type">WKExtension</span>.shared ().scheduleBackgroundRefresh (</span><br><span class="line">        withPreferredDate: targetDate,</span><br><span class="line">        userInfo: <span class="literal">nil</span>,</span><br><span class="line">        scheduledCompletion: { <span class="number">_</span> <span class="keyword">in</span> }</span><br><span class="line">    )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>你传入的日期是你希望你的 app 被唤起的时间。当然，系统会把它看做一种提示 —— 你的 app 实际被唤起的时间还可能取决于各种因素（我猜测这其中包含电量，充电状态，网络访问，你请求刷新的频率，你每次刷新的耗时，等等）。所以，不要假定你的 app 总是能在固定的间隔运行。</p><p>不过，基于我的测试，在实践中一个拥有一个活动 complication ，每隔一个小时更新的 app ，通常在 10 秒以后的请求时间，在白天的表现比在夜间充电的表现要好很多，或者 app 运行频繁，或者 app 处于 dock 但是没有 complication 时，后台任务被调用的机会更少。不在 dock 也不没有 complication 的 app ，几乎不被调用。</p><p><code>scheduledCompletion</code> 块在文档中被描述为 “A block that is called by the system after the background app refresh task has completed” ，但是实际上它是在下一个刷新任务计划完成时就被立即执行。不过由于它是一个可选的参数，你可以提供一个空的块。至于 <code>userInfo</code> ，它可以传递一些元数据给后台任务的 handler ，但这里我们用不上。</p><h1 id="处理后台任务"><a href="#处理后台任务" class="headerlink" title="处理后台任务"></a>处理后台任务</h1><p>watchOS 上的后台刷新是通过在各种时刻从后台唤起你的 app ，然后调用代理方法 <code>handle (_ backgroundTasks:)</code> ，传给它一个或者多个取决于上下文的 “后台任务”。这个方法对于你的 app 后台事务至关重要，不管你构建的 app 是什么类型，几乎一定要在这里做些事情。</p><p>任务的类型有不少，但你应当做跟当时接收到的任务相关的工作。比如有的任务是处理 URLSession 返回的数据，有的任务是处理 iPhone 返回的数据，有的任务是处理 Siri 快捷方式，但是这里我们要处理的是一种通过之前的 <code>scheduleBackgroundRefresh</code> 发起的任务 —— 这是一种最普通的 <code>WKApplicationRefreshBackgroundTask</code> 。这种任务意味着你的 app 是由于你自己的请求而被唤起的，以便你可以运行一些后台的 URL 请求，更新你的 complication 等等。</p><p>当 app 在后台被唤起时，在 <code>handle (_ backgroundTasks:)</code> 方法中，我们做的事情跟启动时的差不多 —— 我们计划下一次刷新，并尝试更新数据。注意，我们只用了 <code>WKApplicationRefreshBackgroundTask</code> ，忽略其他的任务类型。不过，在完成任务后，记得总是调用 <code>setTaskCompletedWithSnapshot ()</code> 方法，这很关键，即便对于那些被你忽略掉并且不处理的任务。不过，调用这个方法表明我们的事干完了，在这之后我们的 app 可能会被挂起。</p><figure class="highlight swift"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">handle</span><span class="params">(<span class="number">_</span> backgroundTasks: Set&lt;WKRefreshBackgroundTask&gt;)</span></span> {</span><br><span class="line">    <span class="keyword">for</span> task <span class="keyword">in</span> backgroundTasks {</span><br><span class="line">        <span class="keyword">switch</span> task {</span><br><span class="line">        <span class="keyword">case</span> <span class="keyword">let</span> backgroundTask <span class="keyword">as</span> <span class="type">WKApplicationRefreshBackgroundTask</span>:</span><br><span class="line">            <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: handling WKApplicationRefreshBackgroundTask"</span>)</span><br><span class="line"> </span><br><span class="line">            scheduleNextReload ()</span><br><span class="line"> </span><br><span class="line">            <span class="type">KrakowPiosDataLoader</span>().fetchData { success <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">if</span> success {</span><br><span class="line">                    <span class="keyword">self</span>.reloadActiveComplications ()</span><br><span class="line">                }</span><br><span class="line"> </span><br><span class="line">                <span class="type">NSLog</span>(<span class="string">"ExtensionDelegate: completed WKApplicationRefreshBackgroundTask"</span>)</span><br><span class="line">                backgroundTask.setTaskCompletedWithSnapshot (<span class="literal">false</span>)</span><br><span class="line">            }</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            task.setTaskCompletedWithSnapshot (<span class="literal">false</span>)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>让 watchOS 模拟器运行 app 后台刷新任务需要一些技巧，即使你已经安排它们在一会之后运行。如果你测试时发现不工作，可以尝试随机切换 app ，主屏和表盘，直到后台刷新任务可以工作。</p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>就这些，我们完成了！🎉 我们得到一个每小时运行的 app ，从 web API 加载新数据，显示到你选择的表盘上，你只要抬腕就能看到它。</p><p>依我看来，为了构建一个带 complication 的最小可行的 watch app ，你需要做这些事：</p><ol><li>确定你的 app 想要在 complication 上展示的最重要的东西。</li><li>确定你的 complication 内容什么时候改变，你的 timeline 存放什么以及存在哪里。</li><li>浏览 complication 家族以及对应可用的模板，确定哪些最适合你</li><li>实现从 web 或者系统 API 加载数据的代码</li><li>实现 complication 数据源要求的方法，以构建 <code>CLKComplicationTimelineEntry</code> 和 <code>CLKComplicationTemplate</code> 对象，以合适的方式展示你的内容。</li><li>确保你的 app 定期更新，用计划的后台刷新或者借助推送通知 (分析你的数据变化的模式，以便优化后台时间)</li><li>测试，测试，再测试，用任何你能想到的场景和组合 🙂</li></ol><p>如果你只是构建一个静态的 complication ，永远不更新，就像 Apple 的 “launcher” 型的 complications ， 比如 Breathe ， Maps ， Reminders 等等。那么，你只需要做这些事：</p><ol><li>为所有支持的 complications 挑选一个图标。</li><li>实现数据源方法，用 “single icon” 模板返回单一实体的 timeline 。</li></ol><p>这种情况下你不需要计划后台刷新以更新 complication ，因为它永远不变。不过，由于 complication 需要链接到真实 app 时，也有大量工作需要做。 😉</p><p>工程中的代码可以从这个仓库找到: <a href="https://github.com/mackuba/SmogWatch" target="_blank" rel="noopener">https://github.com/mackuba/SmogWatch</a> (master 分支最新代码，或者对应这篇文档的 post2 分支的版本)。 它是 WTFPL-licensed ，所以尽管拿去用，你可以分享给我你都做出什么好玩的东西！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;要做一个 watch app，逻辑上，你会先想到从主 UI 开始。毕竟，notfication 和 complication 是可选的。人们说到 app ，通常指的就是主 UI 。&lt;/p&gt;
&lt;p&gt;但是，如果要做一个在表盘用于浏览空气质量指数的 wa
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="watchOS" scheme="https://theinfinitegame.tech/tags/watchOS/"/>
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
  </entry>
  
  <entry>
    <title>watchOS 学习笔记 | Big Picture</title>
    <link href="https://theinfinitegame.tech/development/note-watchos-big-picture/"/>
    <id>https://theinfinitegame.tech/development/note-watchos-big-picture/</id>
    <published>2020-02-20T03:42:05.000Z</published>
    <updated>2020-02-20T07:01:30.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="watchOS-应用"><a href="#watchOS-应用" class="headerlink" title="watchOS 应用"></a>watchOS 应用</h1><p>相比 macOS，iOS 和 tvOS ，watchOS (目前为止) 并非是完全独立的平台，一定程度上依赖配对的 iPhone 。</p><blockquote><p>watchOS 6.0 之后，watch app 可以独立发布和安装，也就说，应用生态上可以独立了。但是，某些功能要想发挥最大的效用，还要借助 iPhone 设备的计算能力。毕竟，后者目前还是要强大很多。可以这么理解，当需要用到 watch 本身不具备的硬件能力时，如视频拍摄，你仍可以把 watch 视为控制器。这个跟人们看待早期智能手表的视角一致。</p></blockquote><h1 id="Watch-app-和扩展"><a href="#Watch-app-和扩展" class="headerlink" title="Watch app 和扩展"></a>Watch app 和扩展</h1><p>watchOS app 跟 iOS app 最显著的差异是前者被严格的分成了两部分。第一部分称为 Watch app —— 有点混淆对吧？正常理解，两部分加起来才是一个完整的 app 。但字面上，这个主要由 UI 构成的部分就叫 Watch app ，所以我们干脆以 UI 来代表，第二个部分是 WatchKit 扩展。两部分有各自独立的数据容器，如果需要共享容器中的文件，需要用到 <strong>App Groups</strong> 。</p><p>watch OS 6 引入 SwiftUI 后，情况变得有些复杂。因为 SwiftUI 中，UI 即代码。原来的 watch app 部分只有一个 hosting view 。</p><h1 id="这些年-watchOS-的变化"><a href="#这些年-watchOS-的变化" class="headerlink" title="这些年 watchOS 的变化"></a>这些年 watchOS 的变化</h1><p>watchOS 1 中，app UI 运行在 watch 上，但扩展运行在 iPhone 上。扩展可以很容易地与设备上的其他 iOS app 通信，但扩展和 watch UI 之间的通信是设备间的，因此整个 app 运行很慢。</p><p>watchOS 2 中，扩展被移到了 watch 上。watch app 和 iOS app 通信需要借助 <strong>WatchConnectivty framework</strong> 。因为扩展处于 watch 上，所以能用到 SDK 自然变少了。当然，后来各种缺失的 SDK 也被陆续添加到 watchOS 中。</p><p>watchOS 4 中，扩展和 UI 被合为一个进程运行。当然，这一点对开发者来说相对无感，唯一的效果是 app 运行的更快了。</p><p>watch OS 5 以前，WatchKit app 需要依赖 iPhone 的连接来完成大部分通信。它只能连接 iPhone 连接过的 “已知 Wi-Fi 网络” 。watch OS 5 引入了连接全新 WiFi 网络的能力。</p><p>在 watch OS 5 及之前的版本，watch app 总是要求有一个伴生的 iOS app 。watch app 是内置在 iOS app bundle 中，它的安装也是通过先安装 iOS app ，再间接下载到 watch 上来完成的。最近的 watch OS 6 ，watch app 真正意义上宣布独立。你既可以采用之前的 iOS app + watch app 的方式， 也可以只开发独立的 watch app 。watch app 不再是内置在 iOS app 中，两者被分隔在各自平台的 App Store 发布。因此，对于因特网的连接方式，最新的建议是 借助 <strong>URLSession</strong> ，<strong>CloudKit</strong> 等直接下载数据到 watch ，只有在真的需要跟 iPhone 交换数据时才用到 <strong>WatchConnectivity</strong> 。</p><hr><h1 id="多于一个用户接口"><a href="#多于一个用户接口" class="headerlink" title="多于一个用户接口"></a>多于一个用户接口</h1><p>iOS app 通常有一个主要的用户入口。人们想到 iOS app 的时候，通常想到的是主界面上的图标。当然，也有各种扩展可以访问 app 的不同部分，但是通常被认为是主 app 的附属。你使用 app 的主要姿势是打开主 app 。</p><p>来到 watchOS ，情况大不相同。主 UI ，根据你的用例，很有可能不是最常被使用的部分。其主要原因在于 iPhone 和 Apple Watch 完全不同的交互模式。你不可能像在 iPhone 上那样在 watch 的屏幕上花很长的时间浏览内容吧？很显然，那很不舒服。</p><p>对于 watchOS ，Apple 一直重复的关键词是 <strong>glances</strong> 或者说 <strong>glanceable</strong> 。期望的 app 交互方式是：抬起手腕，看表，做一两个点击（或者甚至都不点击），或者转一下数字表冠，然后放下手腕，回到现实。这一系列动作的平均时间是以秒计的。实际上，建议是在 2 秒内让用户找到目标信息 (glanceable) 或者执行动作 (actionable) 。</p><p>如果你用过 watchOS app ，你应该知道通过主 app 找到目标信息需要一点技巧。首先，你要在主屏上那一堆六边形网格中找到 app ，然后点击，等待加载，然后在 app 的不同屏之间寻找你要的东西。基于此，也取决于你的 app 类型，极有可能你的主 UI 只会偶尔被用到。 WatchKit app 实际上提供了一些其他的入口来交互，它们可能更重要。</p><h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><p>通知实际上是 watch 的一个绝佳的应用场景。花不到一秒的时间看一眼手表，比从口袋里掏出手机来省事不少吧？许多人会告诉你，他们戴 watch 的主要用途就是看通知。</p><p>但是，通知用的好不好，对不对，主要还是取决于你的 app 类型，通知的目的。比如，你的目的是不定期的通知用户某些事情发生了，通知可以是你的 app 很重要的一部分。典型的，提醒事项 app 。</p><p>watchOS 上通知的 UI 有三种变体：</p><ul><li>只有预制的静态信息</li><li>非交互式的动态信息</li><li>可交互的动态信息，watchOS 5 引入 </li></ul><p>watch OS 6 允许推送绕过 iPhone ，只到达 Apple Watch 的远程通知。</p><h3 id="Glances-Dock"><a href="#Glances-Dock" class="headerlink" title="Glances / Dock"></a>Glances / Dock</h3><p>watchOS 1 开始，引入了一种被叫做 <strong>glance</strong> 的界面，卡片式，可点击，水平滚动。借助 storyboard 上单独的场景构建。</p><p>watchOS 3 开始，<strong>glance</strong> 被废弃，由 <strong>dock</strong> 取代，后者是通过按压表侧的长按钮访问。它的工作方式和 glance 相似，但是卡片的外观是基于主 app 的实际 UI (类似 iOS 上的体验)，通过系统对 app 生命周期某些节点的快照来实现。当你完成滚动，选择了某个 app 后，系统会唤醒这个 app ，不久之后这个 app 实际的 live 视图会更新 dock 的静态图片。</p><p>watch OS 4 之后，dock 变成竖向滚动，跟 iOS 的体验更相似。</p><h3 id="Complications"><a href="#Complications" class="headerlink" title="Complications"></a>Complications</h3><p>“<strong>Complications</strong>“ 是 Apple 给表盘上的各种 widget 取的一个比较有逼格的名字。</p><img src="/images/watch-complications.png" width="68%" height="68%" style="margin: 10 auto;"><p>Complications 有很多不同的家族，为不同的表盘设计 —— 圆形的，矩形的，小的，大的。这些 complictions 的共同点是展示信息的空间极其有限，一直可见（激活状态），因此需要保持最新状态。</p><p>你可以想象，complication 的特点是不可能通过让 app 持续运行在后台，并且完全访问表盘的方式来实现的。因为这样做电池撑不住。</p><p>Apple 的解决方案是你需要周期性的提前提供一个包含给定时间范围的 <strong>timeline</strong> 数据给 complication 用于显示。系统存储这份数据，到时间点了自动切换到正确的状态。你不能在 complication 里随意显示内容 —— 你只能从给定的 complication 家族中选择预先定义好的模板，然后填充一些精心准备的，允许系统在必要时简化以便适配可用空间的数据。</p><p>这里面的一个挑战是：如何找出有用的东西，填充到这么小的空间里 —— 同时这也是一个能简化工作的约束，因为你只有有限的选项。</p><p>Apple 一开始就说了，complications 只对部分 app 有意义 —— 因而并非每个 app 都有一些关键信息，可以展示为一个数字或者一行文本。不过，从 watchOS 3 开始，官方建议所有的 app 都实现一个 complication ，即便这个 complication 只是一个静态的启动器。（个人认为这个要求对用户的意义在于，用户可以在表盘上添加特定 app 的 complication ，仅仅作为启动器也是有价值的）。技术层面，系统可以针对当前表格的启动器，做一些优化，以便 app 启动更快。</p><h3 id="Siri"><a href="#Siri" class="headerlink" title="Siri"></a>Siri</h3><p>最后一个入口就是 Siri 了， watchOS 5 以后，Siri 可以用于更多的用例，例如发消息，todo list 等等。</p><hr><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><p><a href="https://mackuba.eu/2018/12/18/watchkit-adventure-1-the-big-picture/" target="_blank" rel="noopener">MacKuba 关于 WatchKit 的文章 1</a></p><p><a href="https://mackuba.eu/2019/03/06/watchkit-adventure-2-mvc/" target="_blank" rel="noopener">MacKuba 关于 WatchKit 的文章 2</a></p><p><a href="https://github.com/mackuba/SmogWatch" target="_blank" rel="noopener">MacKuba 的一个 apple watch 项目</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;watchOS-应用&quot;&gt;&lt;a href=&quot;#watchOS-应用&quot; class=&quot;headerlink&quot; title=&quot;watchOS 应用&quot;&gt;&lt;/a&gt;watchOS 应用&lt;/h1&gt;&lt;p&gt;相比 macOS，iOS 和 tvOS ，watchOS (目前为止) 并非
      
    
    </summary>
    
    
      <category term="development" scheme="https://theinfinitegame.tech/categories/development/"/>
    
    
      <category term="watchOS" scheme="https://theinfinitegame.tech/tags/watchOS/"/>
    
      <category term="development" scheme="https://theinfinitegame.tech/tags/development/"/>
    
  </entry>
  
  <entry>
    <title>AR | ARKit 概览</title>
    <link href="https://theinfinitegame.tech/computer-tech/ar-arkit-overview/"/>
    <id>https://theinfinitegame.tech/computer-tech/ar-arkit-overview/</id>
    <published>2020-02-17T08:44:13.000Z</published>
    <updated>2020-02-17T09:28:20.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h1><ul><li><strong>运动跟踪 (motion tracking)</strong> 使得手机理解和追踪它相对于世界的位置。</li><li><strong>环境理解 (environmental understanding)</strong> 使得手机可以侦测各种表面的尺寸和位置：水平的，竖直的，成一定角度的，比如地面，咖啡桌或者墙面。</li><li><strong>光线评估 (light estimation)</strong> 使得手机可以估计环境当前的光照条件。</li></ul><hr><h1 id="ARKit"><a href="#ARKit" class="headerlink" title="ARKit"></a>ARKit</h1><h2 id="ARKit-3"><a href="#ARKit-3" class="headerlink" title="ARKit 3"></a>ARKit 3</h2><p>ARKit 3 带给人们不可思议的体验。通过 People Occlusion，ARKit 3 知道人们和 AR 对象在哪里，并适当地遮挡 scene。ARKit 3 使用 Motion Capture 跟踪人们的运动，将其输入到 AR scene 中。它还可以同时跟踪最多三张人脸，支持 collaborative sessions 等等。</p><h4 id="People-Occlusion"><a href="#People-Occlusion" class="headerlink" title="People Occlusion"></a>People Occlusion</h4><p>现在 AR 内容能呈现在人们的身后和前面，使 AR 体验更加沉浸化。同时，在大多数环境能实现绿幕风格的效果。</p><h4 id="Motion-Capture"><a href="#Motion-Capture" class="headerlink" title="Motion Capture"></a>Motion Capture</h4><p>用一台相机实时捕捉人们的运动。通过将人们身体的位置和运动，理解为一系列关节和骨骼，您可以使用运动和姿势作为 AR 体验的输入 —— 将人们放置在 AR 的中心。</p><h4 id="Simultaneous-Front-and-Back-Camera"><a href="#Simultaneous-Front-and-Back-Camera" class="headerlink" title="Simultaneous Front and Back Camera"></a>Simultaneous Front and Back Camera</h4><p>现在，你可以在前置和后置摄像头上同时使用人脸和世界跟踪。例如，用户可以只使用他们的脸部，与后置摄像头的 AR 内容交互。</p><h4 id="Multiple-Face-Tracking"><a href="#Multiple-Face-Tracking" class="headerlink" title="Multiple Face Tracking"></a>Multiple Face Tracking</h4><p>现在 ARKit 人脸跟踪可以一次跟踪最多三张人脸，使用 iPhone X, iPhone XS, iPhone XS Max, iPhone XR 和 iPad Pro 的 TrueDepth 摄像头。该摄像头为 Memoji 和 Snapchat 等前置摄像头的体验提供能力。</p><h4 id="Collaborative-Sessions"><a href="#Collaborative-Sessions" class="headerlink" title="Collaborative Sessions"></a>Collaborative Sessions</h4><p>通过多人之间的实时协作会话，您可以构建一个协作的 world map，让您更快地开发 AR 体验，让用户像进入多人游戏一样，更快地进入共享的 AR 体验。</p><h4 id="其他改进"><a href="#其他改进" class="headerlink" title="其他改进"></a>其他改进</h4><p>一次检测多达 100 幅图像，并自动地估计图像的物理大小。3D 对象检测更加稳定，因为对象在复杂环境中可以更好地被识别。现在，机器学习被用来更快地检测环境中的平面。</p><h2 id="Reality-Composer"><a href="#Reality-Composer" class="headerlink" title="Reality Composer"></a>Reality Composer</h2><p>Reality Composer 是一款针对 iOS 和 Mac 的功能强大的新应用，可以轻松创建交互式 AR 体验，而无需 3D 经验。可以使用 live linking ，在您的 Mac、iPhone 和 iPad 之间无缝地移动。 RealityKit 是一个全新的高级框架，包含 photo-realistic 渲染、相机特效、动画、物理等功能，专为 AR 而构建。</p><p>现在，任何人都可以快速地原型化和制作 AR 体验的内容，这些内容可以使用 Xcode 集成到应用程序中或者导出到 AR Quick Look 。Reality Composer 让您在 iOS 和 Mac 上构建动画和交互，以丰富您的 3D 内容。</p><h4 id="Built-in-AR-Library"><a href="#Built-in-AR-Library" class="headerlink" title="Built-in AR Library"></a>Built-in AR Library</h4><p>导入您自己的 USDZ 文件，或者利用内置 AR 库中数百个现成的虚拟对象。该库为各种 assets 利用 procedural content generation ，您可以自定义虚拟对象的大小、样式等。</p><h4 id="Animations-and-Audio"><a href="#Animations-and-Audio" class="headerlink" title="Animations and Audio"></a>Animations and Audio</h4><p>增加移动、缩放等动画，比如虚拟对象的 “摆动” 或 “旋转”。当用户点击对象、靠近对象或触发其他触发器，您可以选择要进行的操作。您还可以利用 spatial audio 为您的 AR 场景添加真实感。</p><h4 id="Seamless-Tools"><a href="#Seamless-Tools" class="headerlink" title="Seamless Tools"></a>Seamless Tools</h4><p>Reality Composer 被包含在 Xcode ，也是一款 iOS APP 。因此您可以在 iPhone 或 iPad 上 build 、 test 、 tune 和模拟 AR 体验。利用 live linking ，您可以在 Mac 和 iOS 之间快速切换，创建吸引人的复杂的 AR 体验。</p><h4 id="Record-and-Play"><a href="#Record-and-Play" class="headerlink" title="Record and Play"></a>Record and Play</h4><p>有了 iOS 版的 Reality Composer，您可以记录 AR 体验运行位置的传感器和摄像机数据，然后在构建 APP 时在 iOS 上播放这些数据。</p><h2 id="RealityKit"><a href="#RealityKit" class="headerlink" title="RealityKit"></a>RealityKit</h2><p>这个全新的高级框架是从头开始创建的，专门用于 AR ，包括 photo-realistic 渲染、相机特效、动画、物理等等。它还有一个 Swift API 。使用集成的 ARKit 、基于物理的渲染、变换和骨骼动画、 spatial audio 和刚体物理， RealityKit 使 AR 开发比以往任何时候都更快、更容易。</p><h4 id="World-class-Rendering-RealityKit"><a href="#World-class-Rendering-RealityKit" class="headerlink" title="World-class Rendering RealityKit"></a>World-class Rendering RealityKit</h4><p>使用基于物理的真实材质、环境反射、 grounding shadows 、 camera noise 、 motion blur 等，将虚拟内容与现实世界无缝融合，使虚拟内容与现实世界几乎无法区分。</p><h4 id="Scalable-Performance"><a href="#Scalable-Performance" class="headerlink" title="Scalable Performance"></a>Scalable Performance</h4><p>RealityKit 利用最新的 Metal 特性充分利用 GPU ，充分利用 CPU 缓存和多核，提供难以置信的流畅的视觉效果和物理模拟。因为它自动地伸展每个 iOS 设备的 AR 体验的性能，所以您只需要创建一个 AR 体验。</p><h4 id="Swift-API"><a href="#Swift-API" class="headerlink" title="Swift API"></a>Swift API</h4><p>容易使用但功能强大的 RealityKit 使用 Swift 丰富的语言特性并提供完整的功能。因此您可以更快地构建增强现实体验，而无需抄模板代码。</p><h4 id="Shared-AR-Experiences"><a href="#Shared-AR-Experiences" class="headerlink" title="Shared AR Experiences"></a>Shared AR Experiences</h4><p>RealityKit 使网络开发工作变得简单，例如保持一致的状态、优化网络流量、处理数据包丢失或 performing ownership transfers 。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关键技术&quot;&gt;&lt;a href=&quot;#关键技术&quot; class=&quot;headerlink&quot; title=&quot;关键技术&quot;&gt;&lt;/a&gt;关键技术&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;运动跟踪 (motion tracking)&lt;/strong&gt; 使得手机理解和追踪它相对于世界的
      
    
    </summary>
    
    
      <category term="computer-tech" scheme="https://theinfinitegame.tech/categories/computer-tech/"/>
    
    
      <category term="AR" scheme="https://theinfinitegame.tech/tags/AR/"/>
    
      <category term="ARKit" scheme="https://theinfinitegame.tech/tags/ARKit/"/>
    
  </entry>
  
  <entry>
    <title>计算方法 02 | 科学的起源</title>
    <link href="https://theinfinitegame.tech/social-science/quantitative-method-origin/"/>
    <id>https://theinfinitegame.tech/social-science/quantitative-method-origin/</id>
    <published>2020-02-08T06:15:52.000Z</published>
    <updated>2020-02-26T10:15:16.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="古典时期-Classical-Period"><a href="#古典时期-Classical-Period" class="headerlink" title="古典时期 (Classical Period)"></a>古典时期 (Classical Period)</h1><p>最早寻求事物的自然或俗世解释而非神的解释的思想家，是古希腊学者泰勒斯 (Thales)、毕达哥拉斯 (Pythagoras) 和德谟克利特 (Democritus) 等人。但最先思考如何获得知识的 是两千三百多年前的柏拉图 (Plato) 和亚里士多德 (Aristotle) 。</p><p>对柏拉图来说，外部世界及其中的事物，只是它们理想形式的不完美投射或影子。这些理想形式往往被描绘成在墙上投下影子。</p><p><img src="/images/sci-ori_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>柏拉图是一个 <strong>哲学实在论者 (philosophical realist)</strong> 。他认为 <strong>现实 (reality)</strong> 即理想世界，是独立于人的思想之外存在的。对他来说，这些理想并非只是我们心中的抽象概念，它们真实存在，但独立于物质世界之外。</p><p>他认为既然我们看到的物质世界是真实的 <em>不完美投射 (imperfect reflection)</em> ，我们就不能从感官经历中认识到 <strong>现实的本质 (the true nature of reality)</strong> 。他坚信理想形式的知识只能通过推理论证获得。所以柏拉图被称为 <strong>理性主义者 (rationalist)</strong> 。</p><p>他的学生亚里士多德也是个实在论者。他认为现实独立存在于人类的思想之外。但对亚里士多德来说，现实就是物质世界，没有单独的抽象形象存在。在如何了解事物本质上，他也与柏拉图意见相左。亚里士多德是 <strong>经验主义者 (empiricist)</strong> 。他认为感官经验准确地代表了现实。所以我们可以用感官去理解现实。他认为，归根结底知识来源于观察。但这并不意味着他仅对观察感兴趣，他依然将推理论证视作了解和解释自然的最佳方式。事实上，他建立了 <strong>形式逻辑 (formal logic)</strong> ，更确切地说是 <strong>三段论 (syllogism)</strong> 。</p><p><img src="/images/sci-ori_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>这有一个三段论的例子。</p><blockquote><p>“所有人都会死去，而所有希腊人都是人类，因此所有希腊人都会死。”</p></blockquote><p>如果两个前提为真，那么结论必然为真。把此结论当作新三段论的前提，我们就能积累知识。但这只在前提确实为真的情况下成立。看看这个：</p><blockquote><p>“所有哺乳动物都长毛，而猫都是哺乳动物，所以猫全都长毛。”</p></blockquote><p>第一个前提是错的，这就意味着结论不一定对，不是积累知识的好基础。</p><p>那么如何确保前提是正确的呢？你可以用另一个三段论来证明它。但当然你需要不停地证明这些前提，有一套你认为毫无争议的初始前提。亚里士多德认为，这些 <strong>基础前提 (fundamental premises)</strong> ，可以通过观察世界的基本形式或规律来决定。不巧他并未意识到他的某些观察选择性太强，导致一些基础前提在我们现在看来错得彻彻底底。比如，以他的观察为依据，昆虫有四条腿，男人比女人的牙齿多。</p><p>亚里士多德可能看到蜉蝣用四条腿走路得出了这个结论，但实际上蜉蝣与其他昆虫一样都有六条腿。也有可能他检查了自己和那些男性朋友的牙齿，但只查看了女佣的牙齿，她们更有可能因为营养不良而牙齿变少。他并没有意识到这点，他的观察是不准确的。即便如此，他和柏拉图的观念仍在近两千年内占据了主流。直到 16 世纪末期，人们才意识到他们的观点是有缺陷的。</p><p><img src="/images/sci-ori_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>他们时代之后的科学方法是如何发展的呢？古希腊人有很多科技进步。比如，托勒密 (Ptolemy) 将行星运动描述为：地球位于宇宙的中心，静止不动；其他行星，包括太阳都沿着各自的小轨道绕地球运动。必须要加上这些大环套小环，才能解释行星有时逆行的奇怪现象。</p><p>托勒密的模型能进行准确的预测，但人们并不认为它描述了真实的行星运动，它只能解释现象。</p><p><img src="/images/sci-ori_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>希腊城邦消亡后，在罗马帝国的兴衰更替间，以及中世纪的最初几百年，几乎没有任何科学进展。柏拉图和之后亚里士多德的哲学观点一直是主流，直到 16 世纪末新的科学革命拉开了启蒙时代的序幕。</p><p>让我们来看看哪些进步最终引导了革命。</p><p>首先，阿拉伯和波斯学者比如伊本・哈桑 (Ibn al-Hasan) ，比鲁尼 (Al Biruni) 和伊本西纳 (Ibn Sina) 开始使用系统观察和实验。强调无偏见的观察，而不只是逻辑推理。之后，在前人的基础上，英国的格罗斯泰斯特 (Grosseteste) 和罗杰・培根 (Roger Bacon) 提倡使用归纳 (induction) 与演绎 (deduction) 。</p><p><strong>归纳 (Induction)</strong> ，即通过特定观察得到一般解释。 <strong>演绎 (Deduction)</strong> ，即用一般解释预测特定结果。</p><p>第三个重大发展是印刷机的发明，这为科学革命创造了极好的条件。更多学者的成果得到了广泛的传播，其中就包括哥白尼 (Copernicus) 的《天体运行论》(De Revolutionibus Orbium Coelestium) ，这是引领科学革命的第四个重大发展。在哥白尼的新行星运动模型中，行星包括地球都围绕太阳运动。这与当时的宗教教义不符，教会接受亚里士多德和托勒密的模型，即地球位于宇宙中心。很多历史学家认为，哥白尼不敢发表他的成果，因为他害怕教会会因为违背教义惩罚他。但他最终还是发表了他的新模型，但加上了给教皇的特别献词，声称如果托勒密能炮制一个轨道怪异且只能解释现象的模型，那么他也应该享有同等的自由。他暗示他的模型仅仅是个实用的模型，而不是确切的表述。</p><p>他是否真心相信这一点也不得而知，不久他就与世长辞了。在这之后 60 年都没有引发骚动。很多人认为，科学革命和启蒙时代由哥白尼而始，但其他人认为荣誉应该归于第一个拒绝向天主教低头，坚持认为日心说模型才是现实的真实描述的人。</p><p>这个人就是伽利略・伽利雷 (Galileo Galilei) 。</p><hr><h1 id="启发-Enlightenment"><a href="#启发-Enlightenment" class="headerlink" title="启发 (Enlightenment)"></a>启发 (Enlightenment)</h1><p>伽利略 (Galileo) 被认为是现代科学之父，因为他开始将科学从哲学、伦理学和神学中分离，这些原来都在天主教的严格管控之下。</p><p>有人已经默默拥护基于 <strong>观察和实验 (observation and experimentation)</strong> 的科学方法，而不是使用 <strong>神学推理 (theological reasoning)</strong>，但伽利略是第一个这样光明正大做的人<br>。他也反对亚里士多德的几个理论，这些理论被天主教视为教义。</p><p>例如，他驳斥了亚里士多德说重物落地比轻物更快的观点。伽利略用了思想实验来证明这个观点，表明除了观察，他也重视 <strong>逻辑推理 (logical reasoning)</strong> 。当然，他最出名的是质疑亚里士多德和托勒密有关地球是宇宙中心的观点。他支持哥白尼的日心，即太阳是宇宙中心。伽利略对金星进行了系统的观察，发现行星只有绕太阳转而不是绕地球转才说得通。</p><p>哥白尼认为，日心说模型恰恰解释了这个现象，说明该模型准确预测了我们对行星的观察，但他却说这模型并非反映物理现实。相反，伽利略却毫无顾忌地声称地球就是绕着太阳转的。</p><p>天主教不喜欢伽利略离经叛道的想法。他们对伽利略进行宗教审判，把他软禁起来直到去世。</p><p><img src="/images/sci-ori_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>发明笛卡尔坐标系的 勒内・笛卡尔 (René Descartes) 和伽利略是同一时代的。虽然笛卡尔也反对亚里士多德许多的观点，但他同意知识应当基于 <strong>第一原理 (First principle)</strong> 。因为他认为我们的感官和思想很容易被欺骗，他决定放弃所有哪怕只有一点点疑问的想法。一旦移除了所有的怀疑，就只剩下一点可以确定 —— 即他在思考，那么他一定存在。我思故我在。</p><p><img src="/images/sci-ori_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>他最终得出结论：我们只能用 <strong>推理 (reasoning)</strong> 来了解世界本质。</p><p>弗朗西斯・培根 (René Descartes) 和笛卡尔一样，认为科学知识应当基于第一原理。但和笛卡尔相反，培根坚持认为这只能通过 <strong>归纳法 (inductive methods)</strong> 。归纳法就是把对特定实例的观察，用于总结普遍规律或解释。假设我每次碰到的天鹅都是白色的，我就能归纳出普遍规律：所有天鹅都是白色的。培根相信，不仅仅是第一原理，所有的知识都只能用归纳法获取，也就是这种基于感官经验总结出解释的方法。这就是为什么他被视作 <strong>经验主义 (empiricism)</strong> 之父。经验主义就是关于经验或观察。</p><p>大卫・休谟 (René Descartes) 把经验主义发挥到了极致 —— 只接受感官数据为知识来源，且摈弃与直接观察结果不符的理论概念。他认为现实的本质只由物体的特征组成，而不是物体本身。经验主义的极端形式叫做 <strong>怀疑主义  (skepticism)</strong> 。我来给你举个例子，比如有个实物 —— 一只猫。什么使得这只猫能成为猫 是它的各种属性 它的尾巴、胡须、颜色、皮毛、体型。如果把组成猫的属性都移走，那剩下的是啥都没了，猫的本质埋藏在其特征中。</p><p>休谟也指出了归纳法的问题：即使持续反复观察一个现象，但也没法保证下一次观察到的和前一次相同。</p><p>至少在欧洲人的长期观念中，所有的天鹅目击记录都证明天鹅是白色的。直到在澳州发现黑天鹅后，才知道原来还有黑的。换句话说，即使再多的验证观察，也不能确实证明关于世界的科学命题是真的。所以如果你要求所有的知识都只能基于观察，那么你永远不能确定你知道些什么。</p><p>19 世纪初，部分是针对休谟的怀疑主义， <strong>德国唯心主义 (German Idealism)</strong> 的哲学运动流行起来。唯心主义者相信我们的精神构筑了现实，我们对世界的体验是精神的重构，因此科学探索应当专注于通过自身推理能获得什么。唯心主义者主要关注的问题是非物质的东西，像自我、上帝、本质、存在和因果，他们也因使用模糊和过度复杂的语言而受到强烈批评。</p><p>在十九世纪第二次工业革命前夕，科学家开始对唯心主义者的形而上学失去耐心。在科学、医药和技术飞速发展的时代，他们对存在本质的思考变得越来越没用。在 20 世纪初，一种新的科学哲学登上舞台，提议彻底返回经验主义，这项运动叫做 <strong>逻辑实证主义 (logical positivism)</strong> 。</p><hr><h1 id="现代科学-Modern-Science"><a href="#现代科学-Modern-Science" class="headerlink" title="现代科学 (Modern Science)"></a>现代科学 (Modern Science)</h1><p>第一次世界大战过后，由于不满于德国那群专注于知识的第一原理和世界的本质的唯心主义者的 <strong>形而上学 (metaphysics)</strong> ，一群数学家、科学家和哲学家组成了维也纳学派 (Vienna Circle)。</p><p>维也纳学派的成员，摩里茲・石里克 (Moritz Schlick)、奥托・诺伊拉特 (Otto Neurath) 和鲁道夫・卡纳普 (Rudolf Carnap) 认为唯心主义者关于自我存在的问题毫无意义，因为这些问题无法回答。他们提出了新的科学哲学思想 ——  <strong>逻辑实证主义 (Logical Positivism)</strong> 。它重新将科学定义成是研究对世界有意义的命题。那么，要使一个命题有意义，它必须可验证，也就是有验证标准。这意味着要能确定命题的真实性。</p><p>有意义的命题有两种： <strong>分析命题 (analytic statements)</strong> 和 <strong>综合命题 (synthetic statements)</strong> 。</p><p>分析命题会 <strong>同义反复 (tautological)</strong> ，一定是真的。比如说，单身汉未婚，所有正方形都有四条边。这些是 <strong>先验命题 (priori statements)</strong> ，如定义和纯逻辑命题。它们不取决于世界的状态，因此也不需要通过观察来验证。它们可以被运用在数学和逻辑中，分析命题的新组合可以用形式逻辑验证。</p><p>综合命题依存于世界的状态。比如说，所有单身汉都快乐和所有猫天生都有尾巴。这些命题是 <strong>后验的 (posteriori)</strong> —— 它们只能通过观察验证。逻辑实证主义者认为，这些命题应始终可公开研究。同时，命题不许提及无法观察的实体，如电子或重力，因为它们无法被直接观察到。如果命题提及了无法观察的实体 或不是同义反复的，或不合逻辑的，或经验上不可验证的，那么它就是无意义的。这样一来，形而上学、神学和伦理学之类的主题，就完美地从科学中被剔除了。</p><p>当然，源自观察的标准和验证无法处理归纳法问题。明确证明或验证一个命题的确切证据永远都不够。总有可能在未来发现矛盾的地方。所以就把验证标准的强度弱化了，只要求确认而不是验证就可以了。</p><p>另一个非常严格的规则也必须改变了 —— 不许提及无法观察的实体造成了大麻烦：像电子、重力和抑郁这种无法被直接观察，但它们在科学解释中是不可或缺的。</p><p>这些以及归纳法问题，使逻辑实证主义出现了一个更温和版本 —— <strong>逻辑经验主义 (logical empiricism)</strong> 。</p><p>卡尔・波普尔 (Karl Popper) 也被戏称为维也纳学派的官方反对者，是他们的主要批判者之一。他认为要区分命题是否有意义，应建立在 <strong>可证伪性 (falsification)</strong> 的标准上，而不是能否 <strong>证实 (verification)</strong> 。</p><p>他认为，我们永远不能用观察来确切验证或证明一个命题，但我们可以用与之矛盾的证据有力驳斥。他认为一个命题必须有可证伪性才有意义。他提出科学家应该积极进行冒险的实验，它们能把找到与假说矛盾的证据的可能性最大化。如果我们找到了这样的反面证据，就能从中找到改进假说的线索。 <strong>只有反面证据缺失时 该假说才能暂时成立。</strong></p><p>现在，威拉德・冯・奥曼・奎因 (Willard Van Orman Quine) 证明，这个标准也有问题。在杜恒 - 奎因论题 (Duhem-Quine thesis) 中，他认为没有假说能够被单独验证，总有 <strong>背景假设 (background assumptions)</strong> 和 <strong>辅助假设 (supporting hypotheses)</strong> 来支持。如果找到了反面证据，根据波普尔的理论，我们的科学解释是错的，应该被驳回。但根据奎因的理论，我们总可以驳回某个背景假设或辅助假说，而不是科学解释本身。这样就挽救了原始假说。</p><p>托马斯・库恩 (Thomas Kuhn) 指出，科学并非脱胎于验证或证伪原则的严格应用。如果数据与假设不符，假设不会被立刻驳回或修改，科学是在一定的框架或 <strong>范式 (paradigm)</strong> 内进行。建立的假说要适用这个范式，意外结果使假说需要修正。但只要其适合范式即可。但当越来也多的反面证据累积起来，危机就出现了 这就导致了 <strong>范式转换 (paradigm shift)</strong> 。新的范式被采用，然后循而往复。</p><p><img src="/images/sci-ori_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>即使变成较弱形式的逻辑经验主义，逻辑实证主义也不能从波普尔、奎因等人的批判中幸存。所以，我们发展出一种更实用的科学哲学。如今的科学家采用 <strong>假说 - 演绎法 (hypothetico-deductive method)</strong>，其结合了归纳和演绎的方法；要求可证伪性；仅在假说有临时支持时接受重复确认。</p><p><img src="/images/sci-ori_8.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>哲学层面上，很多科学家可能会喜欢巴斯・范・弗拉森的 <strong>建构经验主义 (constructive empiricism)</strong> ，其主张科学是为了产生基于大量经验的理论。知识需要观察，但不可观察的实体也是允许的。接受一个科学理论并不意味永远认同 —— 这是对世界的真实表述。建构经验主义者认为，只要在观察范围内，即可接受科学主张为真实。该命题是否真实代表了不可观察的实体，我们无需判断，这只是目前对观察结果的最佳解释，仅此而已。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;古典时期-Classical-Period&quot;&gt;&lt;a href=&quot;#古典时期-Classical-Period&quot; class=&quot;headerlink&quot; title=&quot;古典时期 (Classical Period)&quot;&gt;&lt;/a&gt;古典时期 (Classical Perio
      
    
    </summary>
    
    
      <category term="social-science" scheme="https://theinfinitegame.tech/categories/social-science/"/>
    
    
      <category term="计量方法" scheme="https://theinfinitegame.tech/tags/%E8%AE%A1%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    
      <category term="社会科学" scheme="https://theinfinitegame.tech/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>计量方法 01 | 科学是什么？</title>
    <link href="https://theinfinitegame.tech/social-science/quantitative-methods-what-science-is/"/>
    <id>https://theinfinitegame.tech/social-science/quantitative-methods-what-science-is/</id>
    <published>2020-02-07T06:40:56.000Z</published>
    <updated>2020-02-26T09:40:38.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="非科学的方法-Non-scientific-Methods"><a href="#非科学的方法-Non-scientific-Methods" class="headerlink" title="非科学的方法 (Non-scientific Methods)"></a>非科学的方法 (Non-scientific Methods)</h1><p>为了知道为什么我们需要科学方法，让我们来看看在日常生活中人们的认知基于什么。</p><p><img src="/images/non-sci_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>人们可能会基于 <strong>直觉 (intuition)</strong> 或 <strong>信念 (belief)</strong> 而认为某事是正确的。</p><p>让我们来看下我对我的猫 Misha 所拥有的坚定信念：我相信 Misha 在所有人中最爱我 —— 我就是知道他爱我胜过其他所有人，我能在内心深处感受到。那么这种信念算不算是知识的坚实基础？并不是，简单地相信某件事并不会让它成真。我们坚信不疑的事情可能最后被证明是假的。还有，如果有人持相反的观点会怎样？如果我的未婚夫认为 Misha 爱他多一些呢？</p><p><img src="/images/non-sci_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p><strong>仅仅通过较量我们的观点，是无法得出谁对谁错的。</strong></p><p>我们可以数每个观点的支持人数，然后得到一个大部分或是 <strong>一致同意的观点 (consensus)</strong> ，但是这也不能作为知识的坚实基础。仅因为大部分人认同某事是并不意味着它就是真的。几世纪以来，几乎人人都认为地球是平的，但结果证明他们错了 —— 地球是圆的。</p><p>另一个知识的来源就是 <strong>权威 (authority)</strong> 的观点。这也不是一个很好的来源。一些诸如政治领袖、专家、科学家等权威的观点，也只是一种观点。权威或许能接触到更多或更好的知识，但他们出于个人利益也会推动自己的观点被大众接受，他们的职业和名誉都依赖于此。假设我的未婚夫找到了一个懂猫语的人，那人声称 Misha 更爱我的未婚夫。当然我会对这一专业观点表示怀疑，尤其当他是受我未婚夫雇佣的时候。我可以找到我自己的猫咪专家来和未婚夫的猫语者打擂台。但这时我们又有两个相反的观点了 —— 我们需要的是 <strong>证据 (evidence)</strong> 。</p><p>那么我们该如何用证据来解决 Misha 更爱谁的争论呢？</p><p>假设我总是 <strong>观察 (observe)</strong> 到每次下班回家后 Misha 总会过来坐在我的腿上而不是我未婚夫的腿上。我就运用了对客观世界，也就是对下班后 Misha 坐谁的腿上的 <strong>观察 (ovservation)</strong> 来证明我说的 Misha 更爱我这个 <strong>命题 (statement)</strong> 。</p><p>以 <strong>随机观察 (casual observation)</strong> 取证得到的认识，比前面其他方法了解到的认识更有根据一些，但这仍然不够好。 <em>因为人们并不十分擅长观察</em> 。我们倾向于 <strong>选择性观察</strong> ，并且记住与我们观念相符的事情。比如我可能恰好忘记了， Misha 在早饭的时候总是坐在我未婚夫的腿上。</p><p>除了选择性知觉外还存在许多 <strong>偏见 (bias)</strong> ，会让随机观察成为一个棘手的认识来源。我们运用 <strong>逻辑 (logic)</strong> 的能力也是如此。 <strong>逻辑推理 (logical reasoning)</strong> 得出的认识看上去是有坚实基础的，但 <strong>非形式逻辑推理 (informal logical reasoning)</strong> 并不总是具有一致性。人们在日常生活中进行推理时，总会不停地出现 <strong>谬误 (fallacy)</strong> 或 <strong>逻辑矛盾 (logical inconsistency)</strong> 。</p><p><img src="/images/non-sci_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>如果想获得更准确的认识，确定我们对世界的解释是正确的，那就还需要点别的东西。我们不能依赖于主观的、无法证实的来源 —— 诸如信念、观点、舆论。我们也不能相信随机观察和非形式逻辑，因为它们可能被我们的信念严重扭曲。</p><p>我们需要 <strong>系统观察</strong> ，摒弃任何偏见，辅以一致的逻辑。换言之 我们需要 <strong>科学方法</strong> 。</p><hr><h1 id="科学方法-Scientific-Method"><a href="#科学方法-Scientific-Method" class="headerlink" title="科学方法 (Scientific Method)"></a>科学方法 (Scientific Method)</h1><p>当我们试图解释世上事物运行原理时，为了确保知识有效，我们需要科学方法，而不是依靠观点、信念、随意观察和非形式逻辑。它们都太主观且容易出错。</p><p>科学方法基于 <strong>系统观察 (systematic observation)</strong> 和 <strong>逻辑一致性 (consistent logic)</strong> 。使用科学方法，增加了我们得出正确解释的机率。同时，我们也可以通过科学方法鉴定 <strong>科学主张 (scientific claim)</strong> 、 <strong>假说 (hypothesis)</strong> ，以及鉴定在我们实证研究中用来支撑假说的那些 <strong>经验证据 (empirical evidence)</strong> 的说服力。</p><p>科学方法有六大原则科学方法有六大原则。如果我们的研究符合这些原则，就能归为科学研究。</p><p><img src="/images/sci-method_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>这个假说亦可以与其他科学论断一较高下，为我们的世界提供尽可能最好的解释。</p><p>第一条原则是：假说应该可以 <strong>在实证中检验 (empirically testable)</strong> ，即支持或反驳假说的经验证据、物证或观测结果都是可以收集的。</p><p>比如我假设家里的猫爱我多于我未婚夫。要实证检验这个假说，我们需要收集观察结果或数据。但如何观察这只猫对我们的喜爱程度呢？我们不能询问猫的看法。假设我们都认为猫是无法像人类那样表达爱意的，那就没什么好观察的了。所以这条假说不符合实证可检验的原则。</p><p>第二原则是：<strong>可重复性 (replicability)</strong> 。一项研究及其发现结果都应该具有可重复性。这意味着重复原研究是可以得到一致结果的。</p><p>如果预期结果只出现了一次，或出现次数极少，那这个结果可能只是巧合。如果一个假说能被重复确认，它会更为可靠。所以一项研究需要经受住重复和复制的考验。比如我说服未婚夫认同 “猫在谁腿上呆得久就更喜欢谁” 这个评判标准。现在我观察到这周猫趴在我腿上的时间，是它呆在未婚夫腿上时间的两倍。那意味着我的假说是正确的吗？猫咪就爱我多一点吗？如果接下来几周这个观察结果保持不变，那么我的假说就是靠谱的。但如果观察了一周这只猫就死了怎么办？如此一来我们就无法验证这个假说了，这个研究再也无法重复。</p><p>要验证结果是否可重复，我们必须按原研究的条件和过程进行重复。假如我们处理过程不同，于是得到了别的结果，这表明原研究不可重复吗？答案当然是否定的。重复失败可能是由于我们改变了程序。</p><p>第三原则是 <strong>客观性 (objectivity)</strong> ，指他人能自行重复该实验而无需求助原研究者。“客观” 的字面意思是谁来进行研究不重要。基于假说跟其程序的描述，每个人都应该得到相同的结论。因此研究者提出的假说、概念、程序应尽量客观。这要求清楚明确地定义所有研究元素，不给主观解释留任何余地。</p><p>假设我认为猫咪拿脸蹭我是示爱的表现，但我没有明确告诉我未婚夫这一条，那么我衡量爱意的程序就是主观的。即使我们同时对猫进行系统性观察，结果仍然会因观察者而异。较之我未婚夫，我会认为猫示爱次数更多。这个例子中的结论是主观的，因此不具有可比性，而我们经常对此毫无自觉。如果我们没有明确讨论并就示爱标志达成共识，那么我们的猫咪爱意衡量程序则不够客观。</p><p>第四原则是 <strong>透明性 (transparency)</strong> 。保持透明度与客观性原则密切相关。在科学界，不论是你的支持者还是批评者，任何人都应该可以重复得出你的结论。这要求研究者共享他们建立的假设 —— 如何定义概念、使用了什么研究程序，还有一切和进行精确复制相关的所有信息。</p><p>第五原则指出一个假说应该具有 <strong>可证伪性</strong> 。可证伪性是一个非常重要的原则。如果你能想象出一种情形会使观察与假说出现矛盾，那么它就是可证伪的。如果我们想不出有什么样的反例存在，那这个假说就不可能被推翻。</p><p>比如你问一个有坚定宗教信仰的人，有什么证据可以证明他们的信仰是虚假的？不管你提出什么样的反例，他们可能都要争辩。这些事实并不违背自己的忠诚信仰。这种仅源于纯信念的观点，比如宗教，是不属于科学范畴的。如果对任何形式的证据，该假说都不接受其为反例，那这个假说根本没有讨论意义，也不用再寻求证实，因为结论已经在那里了。</p><p>我们要讲的第六点也是最后的原则是 <strong>逻辑一致性 (logical consistency)</strong> 。一个假说应该保持逻辑上的一致或连贯。这是指假说不会有任何自相矛盾的地方。比如 ，一个支撑假说的子假设是否与假说冲突。</p><p>我们观察得出的结论也应该保持逻辑一致性。这就是说，在整个过程中，研究者对正面或反面证据的标准应该一致。</p><p>让我继续用猫的例子进行说明。我的假说是猫更爱我，所以预测他会在我腿上呆更久。但要是它趴在我未婚夫腿上更久呢？我会说猫能察觉到趴在我腿上让我不舒服，因为他爱我多一些所以照顾我情绪便趴得少了。显然，这就是逻辑不一致。为了让观察结果符合我的假说，我对观察结果进行了 “再解读”。顺便一提，这也会让我的假说无法证伪。不管猫是否常趴我腿上，我都会得出它爱我的结论。</p><p>总结一下，科学方法要求我们构造的假说为实证可检验的，这就是说观察结果可以支撑或反驳假说；可重复性，也就是假说是可以被重复测试的；客观性，指他人可以独立检验这个假说；透明性，指假说与结果都公之于人，以便他人检验；可证伪性，指找到反例的可能性是存在的。最后，逻辑一致性是指假说本身保持内在的一致性，支持或反驳假说的观察结论也应逻辑一致。</p><p>最后一点，科学方法只在态度端正的情况下才有效。为了提出更好的假说，研究者们应该对自己和他人的研究持批判态度，所以他们应该做到公开透明、乐于接受批判。如果别人有更好的解释，就放弃他们心爱的假说。如此，科学界才能像进化系统一样 —— 只有最合适、最可靠的假说存留下来。</p><hr><h1 id="科学主张-Scientific-Claims"><a href="#科学主张-Scientific-Claims" class="headerlink" title="科学主张 (Scientific Claims)"></a>科学主张 (Scientific Claims)</h1><p>我已经讲过了有关我们周围世界的命题、假说以及解释，我没有准确解释就用了这些通用术语。是时候阐明清楚了。</p><p>关于周遭世界的科学主张，可分为不同类别。一些科学主张会比别的主张描述或解释更多现象。同样，某些科学主张对于我们周围的世界，命题、假说以及解释提供了更可信的描述或解释。我们发现某些主张会更准确一些，比起别的来有更多证据支持。</p><p>在科学中，最基本的主张是 <strong>观察 (observation)</strong> 。观察可以是对世界准确或不准确的 <strong>表达（(representation)</strong> 。</p><p>假设我观察我的猫：姜黄色毛，重 6.5 公斤。大多数科学家会接受这个观察结果，作为我们周围世界某一方面较为准确的投射 —— 假设体重秤有效且可靠的。但就解释力度而言，他们会发现这个观察非常无趣 —— 观察本身没有很大信息量，它不能描述属性间的一般联系，无法解释任何事。</p><p>但这不表示观察不重要。观察是经验科学的基础，但是观察本身不是很有用，观察本身是最无趣的科学主张，因为它没什么解释能力。观察在确定或反驳假说时会变得有用。</p><p><strong>假说 (hypothesis)</strong> 是一种 <strong>命题 (hypothesis)</strong> ，它描述了 <strong>属性 (hypothesis)</strong> 间的 <strong>模式 (pattern)</strong> 或一般关系。假说也可以对它描述的模式进行解释。我们建立这样一个假说：姜黄色猫一般都会超重，概率比其他颜色的猫要高得多。我可以用解释来延伸这个假说，就是毛色和肥胖间的相关性。比如，通过证明控制姜黄毛色和发出饱腹信号的基因是连锁的。</p><p>假说的 <strong>可信度范围 (plausibility)</strong> 可以从非常不确定到非常确定。一个假说若是没有支持，那么它就是不确定的。比如这是个新且未经检验的假说。假说也能被很多实证研究强烈支持，从而变得更确定。</p><p><img src="/images/sci-claim_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>假设的一种特殊类型就是 <strong>定律 (law)</strong> ，定律是对 <strong>关系 (relation)</strong> 或模式非常精确的描述 —— 精确到总是能用 <strong>数学公式 (mathematical equations)</strong> 表达。它们通常被证明得很完整，所以它们如此精确。比如，我把猫食盆从 56 米高的地方扔下去，且我知道万有引力常数，然后用牛顿的万有引力定律就能很准确地预测这个碗掉到地上要花多长时间。</p><p>定律能做出很精确的预测 但它们通常不会解释其描述的关系。在这里，是距离、时间和重力之间的关系。当然，社会科学方面的定律很少能表达成公式。我们对个人和人群的了解还太少，还不能得到如此精度的固定行为模式，并用来推测出科学定律。</p><p><img src="/images/sci-claim_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>好，接下来我们来讲讲 <strong>“理论 (theory)”</strong> 的概念。在日常生活中，理论意味着 <strong>未被证明的 (unsubstantiated)</strong> 命题，有根据的猜想。但是在科学中，理论指的是许多相关现象的总体解释。在自然和行为科学中，理论由被经验证据强烈支持的各种假说构成。在社会科学中，更多的是定性研究和历史比较的方法。当理论经受住了逻辑上、历史上或定性分析的驳斥时，可以认为该理论高度可信。</p><p><img src="/images/sci-claim_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>在科学范畴里，理论的解释最为完善，是我们拥有的最接近准确的东西，因为它们由经科学方法审视并留存的假说构成。当然，这不意味着科学理论是确定或真实的。世上有许多证明完备的理论最终也被取代了，比如牛顿力学就为相对论让路了。 <strong>科学的世界里没有确定性，只有暂时的最佳解释 (provisional best explanation)。</strong></p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;非科学的方法-Non-scientific-Methods&quot;&gt;&lt;a href=&quot;#非科学的方法-Non-scientific-Methods&quot; class=&quot;headerlink&quot; title=&quot;非科学的方法 (Non-scientific Methods)&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="social-science" scheme="https://theinfinitegame.tech/categories/social-science/"/>
    
    
      <category term="计量方法" scheme="https://theinfinitegame.tech/tags/%E8%AE%A1%E9%87%8F%E6%96%B9%E6%B3%95/"/>
    
      <category term="社会科学" scheme="https://theinfinitegame.tech/tags/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之二十三 | 第一类错误和第二类错误</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-type-i-and-type-ii-errors/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-type-i-and-type-ii-errors/</id>
    <published>2020-02-03T05:58:06.000Z</published>
    <updated>2020-02-03T13:46:55.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一类错误和第二类错误"><a href="#第一类错误和第二类错误" class="headerlink" title="第一类错误和第二类错误"></a>第一类错误和第二类错误</h1><p>回忆一下此前提到过的庭审的例子。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。</p><p>在审判时，有四种可能的结果。一，被告确实有罪且被判有罪，这是个正确的决定。二，被告确实无辜且被判无罪，这也是正确的决定。三，被告实际上是无辜的，但被判有罪，这是错误的决定。四，被告实际上有罪的，但是被判无罪，这也是错误的决定。</p><p>这也是我们在实施显著性检验时会发生的情况。辩方观点类似零假设为真，而被告有罪则等效于零假设为假。判被告有罪类似拒绝零假设，而无罪释放则等同于不拒绝零假设。这会导致四种可能的情形。其中的两种，你做了正确的决定，包括零假设的确为真并且你没有拒绝它以及零假设的确为假并且你拒绝了它。但也有两种你做了错误的决定，包括零假设为真而你拒绝了它以及零假设的确为假而你没有拒绝它。第一个错误我们称为 <strong>第一类错误 (type I error)</strong> ，或者说 <strong>伪阳性 (false positive)</strong> 。第个错误我们称为 <strong>第二类错误 (type II error)</strong> ，或者说 <strong>伪阴性 (false negative)</strong> 。</p><img src="/images/t1t2_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>让我给你举个例子。想象你的零假设是：美国的持证水肺潜水者总体， 50% 有超过 35 小时的潜水经验。换言之， $ \pi = 0.5 $ 。备选假设是它是另外一个百分比，换言之， $ \pi \neq 0.5 $ 。你问了一组简单随机抽样的 500 个美国潜水者，你发现有 0.56 的比例有超过 35 小时的潜水经验。现在，假定你的零假设实际上是真的，当你决定基于你的样本数据拒绝零假设时，一个第一类错误就出现了。 </p><img src="/images/t1t2_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><a id="more"></a><p>如果零假设为真，抽样分布是像下面这样的：</p><img src="/images/t1t2_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如果你的显著性水平 $ \alpha $ 等于 0.05 ，通过查询 z 表得到临界值是 -1.96 和 1.96 。你的检验统计量落在拒绝域内。换言之，你要拒绝零假设。这件事情发生的概率是 0.025 加上 0.025 ，等于 0.05 。意味着第一类错误发生的概率等于显著性水平。</p><img src="/images/t1t2_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>由此，你可能想到要降低显著性水平。</p><img src="/images/t1t2_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>但是，这不一定是个好主意。如果你在零假设实际为真时降低了错误地拒绝它的概率，你实际上增加了零假设实际为假而你错误地没有拒绝它的概率。 </p><img src="/images/t1t2_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>犯第二类错误的概率我们称为 $ \beta $ 。</p><img src="/images/t1t2_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>计算 $ \beta $ 相当复杂，它依赖各种因素，例如 $ \alpha $ 的值，样本容量以及参数的真实值。基于这个原因，我们并不会去计算 $ \beta $ 的值，但重要的是你需要意识到，当我们试图降低某一类错误的概率时，另一类错误的概率会上升。</p><img src="/images/t1t2_8.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>当零假设为假时，并且你实施了检验，你希望检验的 <strong>功效 (power)</strong> 是高的。检验的功效是拒绝零假设的概率，给定它为假，换言之，一个检验的功效等于 1 减去第二类错误的概率，也就是 $ 1 - \beta $ 。</p><img src="/images/t1t2_9.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>为什么功效这么重要呢？是这样的，当你要实施一项研究之前，它可以帮助你确定你需要多少的参与者。在你实施完研究之后，它能帮助你确定结论不是统计显著的。</p><p>最后一个提示，在实践中，你永远无从得知某个决定正确与否。我们唯一能做的是控制做出不正确决定的概率。</p><hr><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>想象你是一个对鲸鲨感兴趣的潜水者，你想要知道这些巨大的动物平均的身长有多少。我们还假设你已经花费了很多年在世界各地研究了这些生物。这些年你已经测量了 258 头鲸鲨。因为你已经测量了世界各地的鲸鲨，我们假定这 258 头鲸鲨可以被看作一个简单随机样本。平均的长度等于 8.3 米，样本标准差是 3.4 米，并且鲸鲨长度的分布也近似正态分布。</p><img src="/images/t1t2ex_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在这一节中，我们将检验三种备选假设和一种零假设：鲸鲨总体的长度均值等于 8 米。第一个假设是总体均值不是 8 米。第二个假设是均值大于 8 米，第三个假设是总体均值小于 8 米。所有这几种情况中，我们都把显著性水平设为 0.10 。 </p><img src="/images/t1t2ex_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>首先，我们得检查我们的假定。如我之前说过的，鲸鲨的选择可以看作是简单随机抽样，并且我们也看到鲸鲨身长的分布近似正态。因此，我们没有理由预期总体分布会和正态分布差异巨大。再者，这也不是个问题，因为我们的样本量相当大。 </p><p>现在，让我们计算检验统计量，它的值对于几个假设都是一样的，毕竟，样本均值和零假设一样。</p><img src="/images/t1t2ex_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>代入公式， 8.3 减去 8 ，除以 3.4 除以 258 的平方根，等于大约 1.42 。</p><p>现在，我们开始第一个备选假设，它断言总体均值不是 8 米。我们画出相关的抽样分布，并显示零假设的值。我们需要基于 0.01 的显著性水平做双尾检验，查询 t 表格得到临界值 -1.66 和 1.66 ，检验统计量等于 1.42 不在拒绝域内因为我们不拒绝零假设。这意味着基于 0.10 的显著性水平，我们不能得出总体均值不是 8 的结论。</p><img src="/images/t1t2ex_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>第二个备选假设是总体均值大于 8 。抽样分布一样，但这一次我们做右尾检验。查询 t 表格得临界值是 1.29 ，这一次检验统计量是落在拒绝域内。因此在这种情况下，我们拒绝零假设，并且下结论总体的均值的确大于 8 。</p><img src="/images/t1t2ex_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>最后的备选假设是总体均值小于 8 。在这种情况下，我们做左尾检验，它是右尾的镜像，所以相关的临界值是 -1.29 。现在我们的检验统计量是 1.42 ，对于临界值时一个极端值，但它在分布的另一边。这意味着，它也不在拒绝域内，因此我们也不拒绝零假设。</p><img src="/images/t1t2ex_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>最后的例子显示，画出抽样分布很重要。否则，你可能会无法注意到检验统计量相对于临界值处于分布的另一边。不论检验的结果如何，有两件事是可以确定的。第一，鲸鲨真的很大。第二，教程即将结束，我要放假啦～感谢阅读！</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一类错误和第二类错误&quot;&gt;&lt;a href=&quot;#第一类错误和第二类错误&quot; class=&quot;headerlink&quot; title=&quot;第一类错误和第二类错误&quot;&gt;&lt;/a&gt;第一类错误和第二类错误&lt;/h1&gt;&lt;p&gt;回忆一下此前提到过的庭审的例子。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。&lt;/p&gt;
&lt;p&gt;在审判时，有四种可能的结果。一，被告确实有罪且被判有罪，这是个正确的决定。二，被告确实无辜且被判无罪，这也是正确的决定。三，被告实际上是无辜的，但被判有罪，这是错误的决定。四，被告实际上有罪的，但是被判无罪，这也是错误的决定。&lt;/p&gt;
&lt;p&gt;这也是我们在实施显著性检验时会发生的情况。辩方观点类似零假设为真，而被告有罪则等效于零假设为假。判被告有罪类似拒绝零假设，而无罪释放则等同于不拒绝零假设。这会导致四种可能的情形。其中的两种，你做了正确的决定，包括零假设的确为真并且你没有拒绝它以及零假设的确为假并且你拒绝了它。但也有两种你做了错误的决定，包括零假设为真而你拒绝了它以及零假设的确为假而你没有拒绝它。第一个错误我们称为 &lt;strong&gt;第一类错误 (type I error)&lt;/strong&gt; ，或者说 &lt;strong&gt;伪阳性 (false positive)&lt;/strong&gt; 。第个错误我们称为 &lt;strong&gt;第二类错误 (type II error)&lt;/strong&gt; ，或者说 &lt;strong&gt;伪阴性 (false negative)&lt;/strong&gt; 。&lt;/p&gt;
&lt;img src=&quot;/images/t1t2_1.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;让我给你举个例子。想象你的零假设是：美国的持证水肺潜水者总体， 50% 有超过 35 小时的潜水经验。换言之， $ \pi = 0.5 $ 。备选假设是它是另外一个百分比，换言之， $ \pi \neq 0.5 $ 。你问了一组简单随机抽样的 500 个美国潜水者，你发现有 0.56 的比例有超过 35 小时的潜水经验。现在，假定你的零假设实际上是真的，当你决定基于你的样本数据拒绝零假设时，一个第一类错误就出现了。 &lt;/p&gt;
&lt;img src=&quot;/images/t1t2_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之二十二 | 分步计划和置信区间</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-step-by-step-plan-and-ci/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-step-by-step-plan-and-ci/</id>
    <published>2020-02-03T01:47:28.000Z</published>
    <updated>2020-02-03T12:21:50.853Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分步计划"><a href="#分步计划" class="headerlink" title="分步计划"></a>分步计划</h1><p>比较以下两种期望。一，你期望超过半数的持证美国潜水者有超过 35 小时的潜水经验。二，所有持证美国潜水者的平均潜水时长超过 35 小时。第一眼，两个期望看起来很相似。但是，在第一个例子中，你面对的是比例，你感兴趣的是潜水经验超过 35 小时的潜水者的比例。而第二个例子中，你关心的是均值。你想知道潜水时长的均值。因此，当实施显著性检验时，你需要特别注意你的方法。</p><p>这一节中，我将以分布计划的方式来引导你。想象你问了一个容量是 500 个持证潜水者的简单随机样本，他们的潜水时长是多少个小时。假设你发现 0.57 的比例有超过 35 小时的潜水经验，时长均值是 35.5 小时，均值是 8 小时。在我们的样本中，<br>潜水经验的变量分布近似正态。下面是分布计划全图：</p><img src="/images/sbs_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>第一步，评估你面对的是比例还是均值，这个我们已经讨论过。第一个例子是比例，第二个例子是均值。</p><p>第二步，形式化你的假设。在比例的例子中，零假设是：$ \pi = \pi_0 $ ，在均值的例子中，零假设是 $ \mu = \mu_0 $ 。我们可以有三种类型的备选假设：如果你做双尾检验，是 $ \pi\neq\pi_0 $ 或者 $ \mu\neq\mu_0 $ ；如果你做单尾的右尾检验，是 $ \pi\geq\pi_0 $ 或者 $ \mu\geq\mu_0 $ ；如果你做单尾的左尾检验，是 $ \pi\leq\pi_0 $ ，$ \mu\leq\mu_0 $ 。我们零假设是： $ \pi=0.5,\mu=35 $ ，备选假设是 $ \pi\geq0.5,\mu\geq35 $ 。因此我们需要实施右尾检验。</p><p>第三步，检查你的假定是否满足。在两个例子中，随机化都是必要的。你的样本必须通过随机抽样的方法收集，或者说，随机化的实验。在比例的例子中，根据零假设的比例，样本容量乘以比例以及 1 减去样本容量再乘以比例，必须等于或者大于 15 。均值的例子则要求总体分布近似正态。但实践中，这一点只有样本容量很小，且做的是单尾检验时才重要。对于我们的例子，所有的假定都满足。</p><p>第四步，确定显著性水平 $ \alpha $ 。常用的显著性水平是 0.05 。我们的检验将基于 $ \alpha=0.05 $ 。</p><p>第五步，计算检验统计量。在比例的例子中，公式是 $ z = \frac {p-\pi_0}{se_0} , se_0 = \sqrt {\frac {\pi_0 (1-\pi_0)}{n}} $ ，在均值的例子中，公式是 $ t = \frac {\bar x-\mu_0}{se_0} , se_0 = \frac {s}{n} $ 。注意，在比例的案例中，我们使用 z 分布，而在均值的案例中，我们使用 t 分布。</p><p>第六步，抽取相关的抽样分布，展示零假设和检验统计量，补上拒绝域和对应的临界值。在比例的案例中，</p><p>第七步，评估你的检验统计量是否落在拒绝域内。</p><p>第八步，决定是否拒绝零假设。</p><p>第九步，解释你的发现。</p><p>在下结论之前，值得提醒的是，不拒绝零值假设并不暗含你就可以接受零值假设。在第二个例子中，我们不拒绝零值假设，即潜水时长等于 35 小时的假设，但并不能得出潜水时长就等于 35 小时的结论。</p><hr><h1 id="显著性检验和置信区间"><a href="#显著性检验和置信区间" class="headerlink" title="显著性检验和置信区间"></a>显著性检验和置信区间</h1><p>假设你问样本容量为 500 的水肺潜水者他们潜水了多少个小时，均值是 36 小时，标准差是 8 小时，变量的样本分布近似于正态。基于样本信息，你希望推断总体的参数 $ \mu $ ，这是我们所知的推断统计学 —— 基于样本信息得出样本所在总体的结论。  </p><p>推断统计学有两种方法。其一，通过均值的置信区间来推断区间估计。其二，用显著性检验来推断点估计。在这一节中，我将向你展示这两种方法其实关联密切。</p><img src="/images/sbs_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>假定你预期潜水时长的均值不是 35 小时，你将做一个显著性检验。我们对均值感兴趣，检验统计量如下：</p><img src="/images/sbs_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>零假设是： $ \mu = 35 $ ，备选假设是： $ \mu \neq 35 $ 。我们的假定满足，分析基于简单随机样本并且样本足够大，并且样本近似正态分布。检验统计量等于 36 减去 35 ，除以 8 除以 500 的平方根，等于 2.80 。抽样分布看起来是这样的。</p><img src="/images/sbs_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们可以通过查询 t 表找到对应双尾检验显著性水平 0.05 的临界点是 $ \pm1.984 $ 。因此我们的检验统计量落在拒绝域内。我们将拒绝零假设，得出潜水时长不等于 35 小时的结论。</p><p>现在，如果我们构造 95% 的置信区间，会发生什么呢？公式如下：样本均值，加减 95% 置信水平对应的 t 分数，乘以标准误差，这个标准误差等于标准差除以样本容量的平方根。相关的 t 分数是 1.984 ，代入公式，得到置信区间是 35.29 到 36.71 。由此我们有信心说，通过无限重复的抽样， 95% 的情况下区间会包含实际的总体均值。这个区间给了我们关于总体均值的一个有说服力的范围。和显著性测试一样，这个置信区间也告诉我们，总体的样本均值不是 35 。通常，双尾显著性检验的结果与置信区间的结果是一致的。</p><img src="/images/sbs_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>更准确的说，如果双尾显著性检验的 P 值等于或者小于 0.05 ，那么 95% 置信区间也不包含零假设的值。类似的，如果双尾检验的 P 值大于 0.05 ，那么 95% 置信区间将包含零假设的值。</p><img src="/images/sbs_5_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这听起来很合理，对吧？它以下图表示。你会看到，观察值 36 落在拒绝域内，而对应的置信区间也不包含零假设的总体均值。</p><img src="/images/sbs_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>现在假设观察到的均值是 35.5 ，而不是 36 ，这样的话，我们的检验统计量将变成 1.40 ，它不落在拒绝域内。我们因此不拒绝零假设，相似的，置信区间的两个端点编程 34.79 和 36.21 ，则包含了零假设的均值 35 。</p><img src="/images/sbs_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们可以有信息说，通过无限重复抽样， 95% 的情况区间会包含实际的总体均值。这意味着零假设有说服力，我们不该拒绝零假设。也说明了，构建置信区间的方法和双尾假设检验的方法虽然看起来不同，但是数学上是相关的，彼此一致。</p><img src="/images/sbs_8.jpg" width="68%" height="68%" style="margin: 10 auto;"><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;分步计划&quot;&gt;&lt;a href=&quot;#分步计划&quot; class=&quot;headerlink&quot; title=&quot;分步计划&quot;&gt;&lt;/a&gt;分步计划&lt;/h1&gt;&lt;p&gt;比较以下两种期望。一，你期望超过半数的持证美国潜水者有超过 35 小时的潜水经验。二，所有持证美国潜水者的平均潜水时长超过 
      
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之二十一 | 假设检验和显著性检验</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-hypotheses-and-significance-test/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-hypotheses-and-significance-test/</id>
    <published>2020-02-02T05:57:35.000Z</published>
    <updated>2020-02-02T13:15:49.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h1><p>教程来到最后一个模块，很快我要放假了。明天我将背起行囊，出发去潜水。好吧，让我们再谨慎一点，我并不完全确定明天我能成行。我的航班可能延误，我可能睡过头误了航班，或者可能生病导致无法去潜水。总之，我期望明天出发，但我并不能完全地确定。或者说，不能 100% 确定。</p><p>当研究人员对于他们感兴趣的参数有所期待时，我们在讨论的是 <strong>统计假设 (statistical hypotheses)</strong> 。这一节将介绍统计假设。他们构成了 <strong>显著性检验 (significance testing)</strong> 方法中最主要的部分。一个统计假设，其实就是一个关于总体的期望。通常，假设会被形式化为一条对总体参数持有特定值或者落在特定范围的声明。这种声明是基于研究或者理论。基于样本的信息，我们评价一个假设靠谱与否。这个过程我们称为显著性检验，它是一种用样本数据来检验提前形式化的假设的方法。就像置信区间一样，显著性检验是一种推断统计学的方法。毕竟，我们也是用样本数据来推断关于总体参数的结论。</p><img src="/images/hypo_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们先来看 <strong>零假设检验 (null-hypothesis testing)</strong> ，在这种检验中，显著性检验基于两个假设， <strong>零假设 (null hypothesis)</strong> 和 <strong>备选假设 (alternative hypothesis)</strong> 。零假设以 $ H_0 $ 注记，备选假设以  $ H_a $ 注记。零假设断言你感兴趣的参数是某个特定值。它通常代表变量之间没有关联的情况，或者组与组之间没有差异的情况。它是一个当你的样本数据表明它不太可能发生时需要被拒绝的假设。而备选假设断言你感兴趣的参数落在另一个范围。通常，零假设和备选假设互斥。如果你做显著性测试，假设零假设为真，除非你的数据有很强的反面证据。</p><img src="/images/hypo_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>想象一个法庭的庭审。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。这正是显著性检验里发生的事情。辩护无辜相当于零假设，而有罪预期则等同于备选假设。</p><img src="/images/hypo_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在研究实践中，你对于参数的期望是以备选假设的方式出现，而零假设就是对立面，但它必须是一个单值，不能是一个范围。你只有在数据提供强力佐证时才能认定零假设成立。</p><img src="/images/hypo_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><a id="more"></a><p>举个例子，假设你有理由相信全体美国人中有 3% 有过水肺潜水的经历。那么这里的零假设和备选假设分别是什么呢？你的期望被视为备选假设。我们把它写下来， $ H_a:\pi\leq0.03 $ ，零假设是对立面，但必须表示为单一值，因此 $ H_0:\pi=0.03 $ 。</p><img src="/images/hypo_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>假设你对水肺潜水的最大深度很感兴趣。你有理由期望美国潜水者的最大潜水深度均值 <em>不是</em> 25 米。你的备选假设是 $ \mu\neq25 $ ，零假设是 $ \mu=25 $ 。很简单，不是吗？</p><img src="/images/hypo_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>记住这条：在显著性检验中，你总是假定你的零假设成立，如果你为备选假设找到足够的支撑，就拒绝零假设。如果你没有找到足够的证据，你就不能拒绝它。但没能拒绝零假设并不意味着零假设就是真的。你可以拿法庭的例子再回味一下。在庭审中，被告被假定无罪。如果有足够的证据证明他或者她有罪，则定罪。没有足够的证据，被告则不会被定罪。但这并不意味着你可以得出他或者她是无辜的结论。</p><!-- more --><h1 id="关于比例的检验"><a href="#关于比例的检验" class="headerlink" title="关于比例的检验"></a>关于比例的检验</h1><p>假定你对有多少美国人有过水肺潜水经历这个问题感兴趣，你也有理由相信少于 3% 的美国人有这种经历。这意味着你的备选假设是 $ \pi\leq0.03 $ ，你的零假设是 $ \pi=0.03 $ 。</p><p>这一节中，我们将学习如何在对比例感兴趣时实施显著性检验。我们是这样来实施检验的：先假定我们感兴趣的总体参数有某个值，在我们收集到来自总体的样本后估计这个值的可能性。因为我们看到是一个样本，所以聚焦在抽样分布。我们可以决定，比如给定总体比例是 0.03 时样本比例的抽样分布。看下图，我们这样来实施检验：评估标准差（因为面对的是抽样分布，所以是标准误差），样本观察到的比例远离总体比例，这个标准误差的数值我们称为 <strong>检验统计量 (test statistic)</strong> 。</p><img src="/images/tap_0.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>想象我们抽取了 1000 个美国人，受试者中有水肺潜水经历的人比例等于 0.02 。接下来，我们这么做：</p><img src="/images/tap_0_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>你看到一个样本比例的抽样分布，我们假定零值假设为真，总体比例确实等于 0.03 。那么一个样本比例为 0.02 的总体，有多大的可能性其比例真的是 0.03 呢？为了回答这个问题，我们计算检验统计量，或者说样本统计和假定的总体参数之间的偏移幅度。标准误差远离均值的数量用 z 分数表示，我们可以计算样本统计量距离总体均值有多少个 z 分数。 公式如下：</p><img src="/images/tap_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>先计算零假设的标准误差，它等于 0.03 乘以 0.97 再除以 1000 ，取平方根，大约是 0.005 。因为我们的检验统计量是 0.02 减去 0.03 ，除以 0.005 ，等于 -1.85 。这意味着当零假设为真时，我们的样本比例落在总体比例 1.85 个标准误差之下。 这是否足以拒绝零假设呢？</p><img src="/images/tap_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>基于这个信息，我们可以查询 z 表格，对应的概率值是 0.0322 ，这个概率值我们称为 <strong>P 值 (P-value)</strong> 。 P 值告诉我们，基于总体比例是 0.03 的前提，要找到一个比例是 0.02 的样本，可能性是很低的。但是否低到可以拒绝零假设了呢？这取决于我们选择 <strong>显著性水平 (significance level)</strong> 。在我们实施检验之前，我们需要决定 P 值要达到多小以拒绝零假设。最常用的显著性水平是 0.05 ，这时我们说样本提供了足够的证据拒绝零假设。我们的 P 值是 0.3222 ，小于 0.05 。所以如果我们把显著性水平设置在 0.05 ，我们需要拒绝零假设。这也被我们称为 <strong>拒绝域 (reject region)</strong> 。</p><img src="/images/tap_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>形成拒绝域边界的临界 z 值是 -1.64 ，你可以通过查询 z 表格得到它，它对应 0.05 概率的左尾。我们的检验统计量是 -1.85 ，落在拒绝域内。因此我们需要拒绝零假设，并且得出结论：美国有水肺潜水经历的人的比例低于 0.03 。我们说，这个结论是 <strong>统计显著的 (statistically significant)</strong> 。</p><img src="/images/tap_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在这个例子中，我们的检验基于备选假设是 $ \pi\leq0.03 $ 。因此，我们只聚焦在抽样分布的一边 —— 左边。这叫做 <strong>单尾检验 (one-tailed test)</strong> 。那如果我们的备选检验是 $ \pi\neq0.03 $ 呢？如果是那样的话，我们将不再只聚焦在分布的左边，而分布的两边。这种检验叫做 <strong>双尾检验 (two-tailed test)</strong> 。 </p><img src="/images/tap_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如果我们还是采用 0.05 作为显著性水平，这意味着左边对应的累积概率是 0.025 ，右边也是。同样可以查询 z 表得到，对应的拒绝域的临界点分别是 -1.96 和 1.96 。现在，我们的检验统计量 -1.85 不再落在拒绝域内，意味着我们不能再拒绝零假设 $ \pi = 0.03 $ 。这说明，选择单尾或者双尾检验，对于结论有重大的差别。实践中，双尾检验要常用的多。我的建议是，只有你有非常好的理论依据时才使用单尾检验。</p><p>现在，让我们来改变显著性水平，看看会发生什么。比如，我们可以显著性水平设置为 0.01 ，这意味着我们在 P 值小于 0.01 时拒绝零假设。如果做单尾检验， 0.01 的显著性水平对于 -2.33 。</p><img src="/images/tap_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在我们的例子中，检验统计量没有落在拒绝域，因此不拒绝零假设。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如你所见，选择单尾或者双尾检验，会强烈地改变结果。需要记住的是，大部分单尾或者双尾检验都是基于 0.05 的显著性水平。</p><img src="/images/tap_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><h1 id="关于均值的检验"><a href="#关于均值的检验" class="headerlink" title="关于均值的检验"></a>关于均值的检验</h1><p>你好奇潜水者会在水下待多长时间吗？这个时间取决于他们的氧气罐，经验，潜水深度以及许多其他因素。假设你有理由期望美国潜水者在携带平均水平的氧气罐下潜到平均深度，可以待在水下超过 60 分钟，并且假设你也接触到了 100 个有经验的美国水肺潜水者，测量了他们在携带平均水平的氧气罐待在平均深度下的时长。这个样本的均值是 62 分钟，标准差是 5 分钟。</p><p>你预期潜水者可以在水下待超过 60 分钟，这导致了下面这样一个零假设： $ \mu = 60 $ ，备选假设是 $ \mu\geq60 $ 。我们实施一个关于总体均值的显著性检验，抽样分布如下：</p><img src="/images/tam_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这是一个均值等于 60 的样本均值的抽样分布， 60 是零假设的值。那么基于这样一个总体，一个样本的均值等于 60 的可能性有多大呢？ 同样，为了回答这个问题，我们计算检验统计量，它是样本均值偏离总体均值的标准误差。你可能记得如何计算标准误差 —— 我们需要用总体的标准差，因为我们不知道这个值，需要用样本标准差估计。因为这隐含着额外的误差，我们引入 t 分布来取代 z 分布。</p><img src="/images/tam_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们的检验统计量是通过下面的公式计算：</p><img src="/images/tam_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>由样本均值减去零假设的均值，然后除以样本均值的标准误差。标准误差等于样本标准差除以样本容量的平方根。</p><p>我们先计算出标准误差， 5 除以 100 的平方根，得 0.5 。 62 减去 60 ，再除以 0.5 ，得到 4 。这是否足以拒绝零假设呢？仍然取决于显著性水平。让我们引入最常用的显著性水平 0.05 。做单尾检验，查询 t 表，临界值是 1.67 。</p><img src="/images/tam_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>注意到我们的自由度是 99 ，但表里向下最接近的是 60 ，我们需要查看 $ t_{90%} $ ，因为右尾累积概率 0.05 。你需要记住， $ t_{90%} $ 代表置信水平为 90% ，也就表示分布的两尾加起来有 10% ，左右尾各 0.05 。</p><p>结果如下，我们的检验统计量 4 落在拒绝域内，意味着我们需要拒绝总体均值是 60 分钟的零假设。</p><img src="/images/tam_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>我们可以总结，平均情况下，有经验的美国潜水者携带平均的氧气量潜到平均的深度，能够在水下待超过 60 分钟。如果我们的期望并不是超过 60 分钟，而是不等于 60 分钟呢？</p><img src="/images/tam_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这种情况下，我们做双尾检验。假设显著性水平设置为 0.01 ，左尾和右尾的累积概率分别为 0.005 。查表，对应的临界值分别为 -2.66 和 2.66 ，而我们的检验统计量是 4 。因此，我们还是要拒绝零假设，并对我们的发现做统计显著的结论。</p><img src="/images/tam_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>因为我们现在做了双尾检验，所以我们的临时结论现在变成了有经验的美国潜水者在携带平均氧气量，潜到平均深度后，能待在水下的平均时间不等于 60 分钟。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;假设&quot;&gt;&lt;a href=&quot;#假设&quot; class=&quot;headerlink&quot; title=&quot;假设&quot;&gt;&lt;/a&gt;假设&lt;/h1&gt;&lt;p&gt;教程来到最后一个模块，很快我要放假了。明天我将背起行囊，出发去潜水。好吧，让我们再谨慎一点，我并不完全确定明天我能成行。我的航班可能延误，我可能睡过头误了航班，或者可能生病导致无法去潜水。总之，我期望明天出发，但我并不能完全地确定。或者说，不能 100% 确定。&lt;/p&gt;
&lt;p&gt;当研究人员对于他们感兴趣的参数有所期待时，我们在讨论的是 &lt;strong&gt;统计假设 (statistical hypotheses)&lt;/strong&gt; 。这一节将介绍统计假设。他们构成了 &lt;strong&gt;显著性检验 (significance testing)&lt;/strong&gt; 方法中最主要的部分。一个统计假设，其实就是一个关于总体的期望。通常，假设会被形式化为一条对总体参数持有特定值或者落在特定范围的声明。这种声明是基于研究或者理论。基于样本的信息，我们评价一个假设靠谱与否。这个过程我们称为显著性检验，它是一种用样本数据来检验提前形式化的假设的方法。就像置信区间一样，显著性检验是一种推断统计学的方法。毕竟，我们也是用样本数据来推断关于总体参数的结论。&lt;/p&gt;
&lt;img src=&quot;/images/hypo_1.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;我们先来看 &lt;strong&gt;零假设检验 (null-hypothesis testing)&lt;/strong&gt; ，在这种检验中，显著性检验基于两个假设， &lt;strong&gt;零假设 (null hypothesis)&lt;/strong&gt; 和 &lt;strong&gt;备选假设 (alternative hypothesis)&lt;/strong&gt; 。零假设以 $ H_0 $ 注记，备选假设以  $ H_a $ 注记。零假设断言你感兴趣的参数是某个特定值。它通常代表变量之间没有关联的情况，或者组与组之间没有差异的情况。它是一个当你的样本数据表明它不太可能发生时需要被拒绝的假设。而备选假设断言你感兴趣的参数落在另一个范围。通常，零假设和备选假设互斥。如果你做显著性测试，假设零假设为真，除非你的数据有很强的反面证据。&lt;/p&gt;
&lt;img src=&quot;/images/hypo_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;想象一个法庭的庭审。被告方的辩护律师的观点是被告是无辜的，公诉方则试图说服陪审团和法官被告是有罪的。举证有罪的责任在于原告。被告只有在原告提供有力证据驳斥被告假定无罪的情况下才能被认定为有罪。这正是显著性检验里发生的事情。辩护无辜相当于零假设，而有罪预期则等同于备选假设。&lt;/p&gt;
&lt;img src=&quot;/images/hypo_3.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;在研究实践中，你对于参数的期望是以备选假设的方式出现，而零假设就是对立面，但它必须是一个单值，不能是一个范围。你只有在数据提供强力佐证时才能认定零假设成立。&lt;/p&gt;
&lt;img src=&quot;/images/hypo_4.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之二十 | 样本容量</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-sample-size/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-sample-size/</id>
    <published>2020-02-02T03:05:16.000Z</published>
    <updated>2020-02-02T03:43:13.026Z</updated>
    
    <content type="html"><![CDATA[<p>还是前面的新生儿父母睡觉减少时长的例子，由于我们无法去询问你家乡所有的年轻父母。我们采取简单随机抽样。一个很关键的问题是 —— 样本应该取多大。应该是 50 个就够了？或者 至少 300 个或者 1000 个？</p><p>这一节中，我们将分布讨论对均值和比例感兴趣的不同情况。</p><p>先从均值开始。样本容量主要取决于三个因素。首先是你想要的精度。记得吗，置信区间是通过点估计加减一个误差界限来得到的。你允许多大的误差界限，如果你希望它越小，那么你的样本容量就得越大。其次，你的样本容量还依赖你想要的置信水平。越大的置信水平，需要越大的样本容量。最后，数据的变异性也影响样本容量的选择。你的变量的标准差越大，你需要的样本容量也越大。公式如下：</p><p>$$ n = \frac {\sigma^2z^2}{m^2} $$</p><p>n 代表样本容量，m 代表误差界限，$ \sigma $ 代表总体的标准差， z 代表 z 分数。显而易见，你不知道总体的标准差，而且你还没抽取样本也不知道样本的标准差。所以，你需要利用 <strong>合理的猜测 (educated guess)</strong> 来估计一个值。</p><p>让我来演示这个过程是怎么样的。想象我们想要 95% 的置信水平，对应这个置信水平的 z 分数是 1.96 ，并且我不希望误差界限宽过 0.3 小时，就取 0.3 小时吧。现在我们可以填完这个公式的一部分了。现在我们需要对 $ \sigma $ 进行合理猜测了。如果已经存在这方面的研究而且你知道变量的标准差，可以简单地采纳这个标准差。但是，如果这样一个研究之前并未做过，就必须靠我们自己的猜测。我先假定某些父母根本没法睡，某些父母睡觉少于 5 个小时，并且父母们也不可能睡的比之前还多。因此，我们假定变量服从正态分布， 95% 的父母睡觉时间介于 0 到 5 个小时之间。均值是 2.5 小时，标准差是 1.25 小时。毕竟， 95% 是落在均值左右两个标准差范围内，两个标准差等于 2.5 ，那么一个标准差就是 1.25 。我们用这组数字完成公式，得到 66.69 ，取整，得出结论我们需要 67 个受试者。</p><p>对于比例感兴趣而不是均值的情况，也可以采取类似的方式。假设我们想知道新生儿在换尿布时便便的比例，我想要 99% 的置信水平，误差界限 0.10 。公式非常相似：</p><p>$$ n = \frac {p (1-p) z^2}{m^2} $$</p><p>m 是 0.10 ，z 可由查表得 2.58 ，它对应 99% 置信水平。我们不知道的是 p 。还是采用合理的猜测，或者采用一种被称为 <strong>安全方法 (safe approach)</strong> 的方式。你会发现 $ p (1-p) $ 的最大值是 0.25 ，它发生在 p = 0.5 的时候，于是我们用 p = 0.5 完成公式，0.5 乘以 0.5 乘以 2.58 的平方除以 0.10 的平方，得到 166.41 ，即 167 位受试者。</p><p>在理想世界中，你可以去寻求大样本，比如说 1000 位受试者或者更多。但是，在现实世界中，我们的时间有限，资源有限，无法抽取大样本。因此，计算所需的样本容量可以帮助我们把成本降到最低。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;还是前面的新生儿父母睡觉减少时长的例子，由于我们无法去询问你家乡所有的年轻父母。我们采取简单随机抽样。一个很关键的问题是 —— 样本应该取多大。应该是 50 个就够了？或者 至少 300 个或者 1000 个？&lt;/p&gt;
&lt;p&gt;这一节中，我们将分布讨论对均值和比例感兴趣的不同
      
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之十九 | 比例的置信区间和置信水平</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-confidence-interval-for-proportion/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-confidence-interval-for-proportion/</id>
    <published>2020-02-02T02:28:44.000Z</published>
    <updated>2020-02-28T05:48:27.346Z</updated>
    
    <content type="html"><![CDATA[<h1 id="比例的置信区间"><a href="#比例的置信区间" class="headerlink" title="比例的置信区间"></a>比例的置信区间</h1><p>在过去的几周中我认识到新生儿喜欢排便，频繁地排便。恰好我的女儿 Lois 尤其喜欢在特定的情况下排便 —— 在我给她换尿布的时候。我说真的，一旦她决定上厕所 (answer nature’s call) ，一上就是六次。是的，六次，发生在换尿布的过程中。</p><p><img src="/images/statistics_cip_1.jpg" width="33%" height="33%" style="margin: 10 auto;"></p><p>这正常吗？我不确定，但我知道我需要搞清楚。假定我随机问 100 个新生儿的父母，他们的宝宝是否喜欢在换尿布时排便。在这一节教程中，我会告诉你，如何基于这样一个研究，构建一个估计总体比例的置信区间。</p><p>假定我的 100 的受试者里有 17% 报告他们的宝宝喜欢在换尿布时排便， 83% 的受试者报告他们的宝宝不会这样做。我们由此得到一个 0.17 的比例，这个比例的新生儿父母的宝宝喜欢在换尿布时排便。当我们为比例构建置信区间时，我们引入样本比例的抽样分布。我们知道，只要样本足够大，这个抽样分布就是正态分布，并且均值等于总体比例 $\pi$ ，标准差 $\sigma<em>p$ 等于 $ \sqrt {\frac {\pi (1-\pi)}{n}} $ 。我们还知道，找到一个比例处于均值两个标准差范围内的样本的概率，同时也是总体的比例，是 0.95 。 更精确的说，如果我们对应概率的 z 分数，我们会得到 1.96 。这意味着我们有 95% 的机会确定我们的样本比例会落在总体比例 1.96 个标准差范围内，这被我们称为 <em>_误差界限 (margin of error)</em></em> 。我们用于计算 95% 置信区间的公式如下：</p><script type="math/tex; mode=display">p\pm1.96\sigma_p , \sigma_p = \sqrt {\frac {\pi (1-\pi)}{n}}</script><p>其中 1.96 是对应 95% 置信区间的 z 分数。所以上面的公式我们也可以写成：</p><script type="math/tex; mode=display">p\pm {Z_{95\%}}\sigma_p , \sigma_p = \sqrt {\frac {\pi (1-\pi)}{n}}</script><p>我们这里讨论的是 95% 的置信区间，意味着如果我们能从总体抽取无限多的样本，那么 95% 的情况下，我们的置信区间会包含总体比例 $\pi$ 。不过，你可能注意到，我们并不知道总体比例 $\pi$ 的值，所以就无从计算样本比例的抽样分布的标准差。因此，我们用一个估计值来代替总体参数 $\pi$ ，这个估计值来自样本统计量， $P$ ，由此得到下面的公式：</p><script type="math/tex; mode=display">p\pm {Z_{95\%}}(se) , se = \sqrt {\frac {p (1-p)}{n}}</script><p>就像我们为均值构建置信区间时一样，我们称这个估计的标准差为 <strong>标准误差 (standard error)</strong> ，又称为标准误。 作为与均值的置信区间的对比，在构建比例的置信区间时，我们并不使用 t 分布。不过，你的数据需要满足一个必要的假定。你必须要有至少 15 个成功和 15 个失败。换言之， $np \geq 15$ 并且 $n (1-p) \geq 15$ 。如果不满足，那 你就不能基于上面的公式计算置信区间。现在回到例子，我们有 0.17 的比例报告宝宝在换尿布时排便。公式如下：</p><script type="math/tex; mode=display">p\pm {Z_{95\%}}(se) , se = \sqrt {\frac {p (1-p)}{n}}</script><p>让我们先计算标准误差。0.17 乘以 0.83 ，除以 100 ，然后取平方根，结果是 0.038 。误差界限等于 1.96 乘以 0.038 ，约定于 0.07 。 0.17 减去 0.07 等于 0.10 ，0.17 加上 0.07 等于 0.24 。因此我们的置信区间是 0.10 到 0.24 。这意味着我们有 95% 的信心说，总体比例落在 0.10 到 0.24 之间。或者说，如果我们能抽取无限多容量为 100 的样本，那么对于每个样本我们计算这个误差界限下的置信区间，有 95% 的情况这个区间会包含总体的比例。这个 95% 置信区间说明，大部分宝宝并不喜欢在换尿布时排便。但另一方面，如果他们确实在这个时候排便了，也并奇怪。我们有 95% 的信心说有 10% 到 24% 的宝宝确实会在换尿布时排便。</p><hr><h1 id="置信水平"><a href="#置信水平" class="headerlink" title="置信水平"></a>置信水平</h1><p>95% 的置信区间，告诉我们对于我们的点估计有 95% 的可信度，这个点估计可以是均值或者比例。或者说，如果能够抽取无限多的样本，近似于我们当前的样本，对所有的样本基于相同的误差界限计算 95% 的置信区间。那么 95% 的情况下，总体的参数值回落在这个置信区间内。同时也意味着， 5% 的情况，这个方法会产生一个不包含实际总体参数的区间。</p><p>如果你希望减少错误推断的可能性，你可以诉诸更大的置信区间，比如说 99% 。这一节中，我将向你演示如何改变置信水平，以及这么做会带来什么结果。</p><p>99% 置信区间和 95% 置信区间的唯一区别是不同的 z 分数，通过查询 z 表，代入公式，最终我们算得 99% 置信区间是 0.07 到 0.27 。对于 90% 的置信区间，结果是 0.11 到 0.23 。</p><p>我以图形演示，你会看到，更高的置信水平导致更宽的置信区间。换言之，我们想获得可信度越高的推断，那么就要接受更宽的误差界限。因此，我们需要在可信度和精度之间折中。在多数情况下，我们采用 95% 置信区间。</p><p><img src="/images/statistics_cil.jpg" width="33%" height="33%" style="margin: 10 auto;"></p><p>这个原理同样适用于均值的置信区间，区别在于在比例中，我们查询相关的 z 分数而在均值的案例中，我们查询相关的 t 分数，并且均值的计算中还要用到自由度，即 n 减去 1 。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;比例的置信区间&quot;&gt;&lt;a href=&quot;#比例的置信区间&quot; class=&quot;headerlink&quot; title=&quot;比例的置信区间&quot;&gt;&lt;/a&gt;比例的置信区间&lt;/h1&gt;&lt;p&gt;在过去的几周中我认识到新生儿喜欢排便，频繁地排便。恰好我的女儿 Lois 尤其喜欢在特定的情况下排便
      
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之十八 | 均值的推断和置信区间</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-inference-and-confidence-interval/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-inference-and-confidence-interval/</id>
    <published>2020-02-01T03:03:48.000Z</published>
    <updated>2020-02-27T09:08:54.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统计推断"><a href="#统计推断" class="headerlink" title="统计推断"></a>统计推断</h1><p>这一节我们以睡眠为例。假设你通常每晚睡 8 个小时，你突然做了年轻爸爸或者年轻妈妈，你的睡眠时间减少到每晚 5 个小时，这意味着每晚减少 3 个小时，相当于每周 20 个小时，每年 1000 个小时，差不多 40 天。换言之，如果你家宝宝继续保持他 / 她的睡眠时间，一年之后你会比之前少睡 大约 40 天。</p><p>回到统计学，想象你想要知道你家乡的年轻父母在孩子刚出生那一年减少了多少睡眠。在这一节中我们将讨论统计推断。我们会基于样本信息，得出关于总体的结论。我们将会区分两种统计推断的方法，一种叫 <strong>统计估计 (statistical estimation)</strong> ，另一种叫 <strong>假设检验 (hypothesis testing)</strong> 。在这篇教程中，我们将先了解统计估计。 </p><p>有两种方式估计总体参数的值，其一叫 <strong>点估计 (point estimate)</strong> ，它是一个对于总体参数的最佳猜想。其二是 <strong>区间估计 (interval estimate)</strong> ，它是一个我们预期参数会落在的范围。 </p><p>想象我们抽取了 60 个受试者样本，有了第一个小孩后每晚减少的睡眠小时数均值为 2.6 小时。这个均值是一个对于总体均值很好的点估计。换言之，$ \bar x $ ，是一个对于 $ \mu $ 的很好的点估计。不过，单一的点估计无法告诉我们估计是否接近我们感兴趣的总体参数。因此，研究人员通常还希望知道点估计可能的准确度。他们借由计算区间估计来显示这种准确度。</p><p>区间估计是一个最有可能包含总体实际参数值的数字区间。基于我们的样本均值 2.6 小时，我们可以预测，比如说，你家乡新生儿父母每晚睡眠减少的平均小时数介于 2.3 小时到 2.9 小时之间。</p><p>这个区间包含总体参数值的概率，被我们称为 <strong>置信水平 (confidence level)</strong> ，置信水平总是一个接近 1 的值，多数情况下是 0.95 。接下来我们将讨论有 95% 置信水平的区间。</p><a id="more"></a><hr><h1 id="已知总体标准差，求均值的置信区间"><a href="#已知总体标准差，求均值的置信区间" class="headerlink" title="已知总体标准差，求均值的置信区间"></a>已知总体标准差，求均值的置信区间</h1><p>假设我们知道 60 个年轻父母的样本在第一个小孩出生后睡眠减少小时数的标准差是 0.9 小时，也知道总体的标准差是 1.1 小时。（实践中，不太可能知道这个参数，但这里我们先假定你知道）</p><p>这一节中，我们将学习如何基于样本信息和总体的标准差来构造 <strong>置信区间 (confidence interval)</strong> 。首先，我们来解释一下这样一个置信区间应该如何解读。</p><p>为了构造一个置信区间，我们需要用到样本均值的抽样分布。毕竟，我们是在处理一个来自总体的样本。 我们知道，只要样本足够大，抽样分布就是正态分布的，并且均值等于总体的均值，标准差等于总体的标准差除以样本数 n 的平方根。我们还知道，找到距离样本均值少于等于两个标准差的概率是 0.95 。更精确的，如果查询对应概率的 z 分数，我们会得到 -1.96 和 1.96 。</p><p>这意味着我们有 95% 的机会令样本均值落在总体均值 1.96 个标准差范围内。 1.96 个标准差的距离我们称为 <strong>误差界限 (margin error)</strong> 。误差界限告诉我们用样本均值 $ \bar x $ 估计总体均值的准确程度。 95% 置信区间的公式如下：</p><p><img src="/images/ci_1.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>它是由点估计或者样本均值加减误差界限，即 1.96 个标准差。注意我们是在处理样本均值的抽样分布。因此分布的标准差等于 $ \frac {\sigma}{\sqrt {n}} $ 。接下来请集中注意力，因为过程会有点复杂。 </p><p>假设你抽取一个样本，样本均值由某个点表示，从均值往两侧有一根线表示误差界限。它们一起构成了 95% 的置信区间。如果样本均值落在红色区域，则置信区间包含总体均值 $ \mu $ 。如果样本均值不落在红色区域，则置信区间不包含总体均值 $ \mu $ 。我们讨论的是 95% 的置信区间，这意味着随机选择一个样本，它包含总体均值的概率是 0.95 ，不包含总体均值的 0.05 。换言之，如果我们抽取无限多个样本， 95% 的情况，我们的置信区间会包含总体的均值。</p><p>现在让我们回到例子。例子中样本均值是 2.6 小时。总体标准差 1.1 。样本容量是 60 ，现在我们有了计算置信区间需要的全部数字。公式如下：</p><script type="math/tex; mode=display">\bar x\pm1.96\sigma_{\bar x}</script><p>我们知道 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ ，即 $ \frac {1.1}{\sqrt {60}} $ ，得到 0.142 。接下来计算误差界限， 1.96 乘以 0.142 ，约等于 0.28 。样本均值等于 2.6 ，因此 95% 置信区间是 2.6 减去 0.28 到 2.6 加上 0.28 的区间，即 2.32 到 2.88 。我们可以说，我们有 95% 的信心确定这个区间包含了实际的总体均值。更精确地说，如果我们从总体中抽取无限多个大小为 60 的样本，并且对于每个样本，我们计算误差界限， 95% 的情况下，总体的均值会落在样本的置信区间内。</p><p><img src="/images/ci_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>如果新生儿父母的这种境况会持续一年，我们有 95% 的信息说，这些人会减少 2.32 乘以 365 小时到 2.88 乘以 365 小时的睡眠时间，或者说， 846.8 小时到 1,051.2 小时，又或者说， 35.3 到 43.8 个整天。</p><hr><h1 id="未知总体标准差，求均值的置信区间"><a href="#未知总体标准差，求均值的置信区间" class="headerlink" title="未知总体标准差，求均值的置信区间"></a>未知总体标准差，求均值的置信区间</h1><p>95% 置信区间用于评估总体的均值，它告诉我们我们有 95% 的信息这个区间包含实际的总体均值。利用这个公式 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ ，你可以计算区间的两个端点。这个公式有一个问题，为了计算置信区间，你需要知道总体的标准差。然而，我们通常并不知道这个参数。毕竟，我们本来就在用样本推测总体的参数。</p><p>这一节中，我们将学习如何在不知道总体参数的情况下做出推断。解决方案是我们估计总体的标准差，因而我们要引入另一个分布，它叫 <strong>T 分布</strong> 。让我来告诉它如何工作。</p><p>想象我们问了 60 个年轻家庭他们在有了第一个孩子之后睡眠时间少了多少个小时，均值是 2.6 小时，标准差是 0.9 小时。为了构建一个 95% 的置信区间，我们需要用到 $\bar x\pm1.96 \sigma<em>{\bar x}$ ，<br>或者可以写成 $\bar x\pm {Z</em>{95 \%}} \sigma_{\bar x}$ 。这一次，我们不知道总体的标准差。</p><p><img src="/images/ci_3.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>因此我们用样本的标准差来估计总体的标准差，公式变成: $\bar x\pm {Z_{95 \%}} s_e$ ，其中 $ s_e = \frac {s}{\sqrt {n}} $</p><p><img src="/images/ci_4.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>我们把 $ se $ 这个估计的抽样分布的标准差称为 <strong>标准误差 (standard error)</strong> 。但是因为我们现在是估计标准差，所以我们在计算中引入了额外的误差。基于此，我们引入另一个分布， z 分布。由于额外的误差，我们现在使用 T 分布，公式如下。</p><p>$\bar x\pm {t_{95 \%}} se$</p><p><img src="/images/ci_5.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>现在让我来详细解释 t 分布和 t 分数。 t 分布跟标准正态分布非常之相似，它是钟形的，对称的，并且均值是 0 。但是，它有一点点区别。 因为我们现在是估计抽样分布的标准差，我们引入了额外的误差。当我们的样本比较小时，这个误差很可观。 t 分布将这小样本的这个误差考虑在内了，因此它比标准正态分布稍微宽一点，标准差更大一些。如下：</p><p><img src="/images/ci_5_2.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>黑色的分布是标准正态分布，蓝色的分布是 t 分布。 t 分布的准确形状取决于样本容量。样本越大，t 分布越接近标准正态分布。更准确的说， t 分布的形状取决于单一个参数，我们称为 <strong>自由度 (degrees of freedom)</strong> ，以 $ df $ 注记。 t 分布中的自由度等于样本容量 n - 1 。这意味着我们实际上有许多不同的 t 分布，每一个都有单独的 $ df $。比如，自由度为 2 的 t 分布：</p><p><img src="/images/ci_6.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>自由度为 5 的 t 分布：</p><p><img src="/images/ci_7.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>自由度为 30 的 t 分布：</p><p><img src="/images/ci_8.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>可以看到，当我们有 30 或者更大自由度时， t 分布几乎就等同于标准正态分布。更准确的说，标准正态分布其实就是自由度等于无限的 t 分布。 </p><p><img src="/images/ci_9.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>同标准正态分布和 z 分数一样，我们也可以为特定的 t 分数寻找累积概率。重要的区别在于，这些概率依赖于自由度。当你计算一个 95% 置信区间时，你可以为所有可能的自由度找到对应 95% 置信水平的 t 分数，这个表格称为 <strong>t 表格</strong> ，它和 z 表格类似。</p><p><img src="/images/ci_10.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>让我用睡眠时间的例子来演示。样本中睡眠减少小时数的均值是 2.6 小时，标准差是 0.9 小时，样本容量是 60 。计算 95% 置信区间的公式：</p><p><img src="/images/ci_11.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>让我们从标准误差开始，它等于样本标准差除以 n 的平方根，即 0.9 除以 60 的平方根，得到 0.116 。我们的标准误差，或者说，估计的样本均值的抽样分布的标准差等于 0.116 。为了计算误差界限，我们需要用标准误差乘以 95% 置信区间的 t 分数。如你所知， t 分数取决于自由度。自由度 df 等于 n - 1 。我们有 60 个样本，因此 60-1 的 50 。在 t 表格中，我们在列中查找 95% 置信水平，在行中查找 59 自由度。因为表格中没有报告 59 自由度，我们向下取 50 自由度。对应的 t 分数是 2.009 。</p><p><img src="/images/ci_12.jpg" width="68%" height="68%" style="margin: 10 auto;"></p><p>因此我们用 0.116 乘以 2.009 ，大约 0.23 。从样本均值 2.6 中加减这个值后，得到我们的置信区间是 2.37 到 2.83 。我们有 95% 的信心认为这个区间包含实际的总体均值。</p><p>为了计算总体均值的置信区间，有两个假定需要满足。首先，你的数据是随机获取的。换言之，样本必须是随机样本，否则你的发现就不是合法的。其次，总体必须近似正态分布。这一点可能是个问题，因为总体中的许多变量可能并不是正态分布的。不过，好消息是，采用 t 分布来构造置信区间，可以有效对抗第二个假设破坏。也就是说，即使违反了假设，这种统计方法仍然是健壮的。最后，在基于 t 分布构造置信区间是，你还需要对异常值保持机警。如果数据里有异常值，那么这个方法可能会失效。因此要记得在开始之前检查数据。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;统计推断&quot;&gt;&lt;a href=&quot;#统计推断&quot; class=&quot;headerlink&quot; title=&quot;统计推断&quot;&gt;&lt;/a&gt;统计推断&lt;/h1&gt;&lt;p&gt;这一节我们以睡眠为例。假设你通常每晚睡 8 个小时，你突然做了年轻爸爸或者年轻妈妈，你的睡眠时间减少到每晚 5 个小时，这意味着每晚减少 3 个小时，相当于每周 20 个小时，每年 1000 个小时，差不多 40 天。换言之，如果你家宝宝继续保持他 / 她的睡眠时间，一年之后你会比之前少睡 大约 40 天。&lt;/p&gt;
&lt;p&gt;回到统计学，想象你想要知道你家乡的年轻父母在孩子刚出生那一年减少了多少睡眠。在这一节中我们将讨论统计推断。我们会基于样本信息，得出关于总体的结论。我们将会区分两种统计推断的方法，一种叫 &lt;strong&gt;统计估计 (statistical estimation)&lt;/strong&gt; ，另一种叫 &lt;strong&gt;假设检验 (hypothesis testing)&lt;/strong&gt; 。在这篇教程中，我们将先了解统计估计。 &lt;/p&gt;
&lt;p&gt;有两种方式估计总体参数的值，其一叫 &lt;strong&gt;点估计 (point estimate)&lt;/strong&gt; ，它是一个对于总体参数的最佳猜想。其二是 &lt;strong&gt;区间估计 (interval estimate)&lt;/strong&gt; ，它是一个我们预期参数会落在的范围。 &lt;/p&gt;
&lt;p&gt;想象我们抽取了 60 个受试者样本，有了第一个小孩后每晚减少的睡眠小时数均值为 2.6 小时。这个均值是一个对于总体均值很好的点估计。换言之，$ \bar x $ ，是一个对于 $ \mu $ 的很好的点估计。不过，单一的点估计无法告诉我们估计是否接近我们感兴趣的总体参数。因此，研究人员通常还希望知道点估计可能的准确度。他们借由计算区间估计来显示这种准确度。&lt;/p&gt;
&lt;p&gt;区间估计是一个最有可能包含总体实际参数值的数字区间。基于我们的样本均值 2.6 小时，我们可以预测，比如说，你家乡新生儿父母每晚睡眠减少的平均小时数介于 2.3 小时到 2.9 小时之间。&lt;/p&gt;
&lt;p&gt;这个区间包含总体参数值的概率，被我们称为 &lt;strong&gt;置信水平 (confidence level)&lt;/strong&gt; ，置信水平总是一个接近 1 的值，多数情况下是 0.95 。接下来我们将讨论有 95% 置信水平的区间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之十七 | 样本比例的抽样分布</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-sampling-distribution-of-sample-proportion/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-sampling-distribution-of-sample-proportion/</id>
    <published>2020-01-31T09:08:32.000Z</published>
    <updated>2020-02-02T03:04:57.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽样分布比例"><a href="#抽样分布比例" class="headerlink" title="抽样分布比例"></a>抽样分布比例</h1><p>想象你住在巴黎，你知道所有的学生中有 0.10 的比例把自己看做嬉皮士。你想要知道这个比例的抽样分布是什么样的。注意，在这里计算总体均值是没有什么意义的。因为你感兴趣的变量是一个二元标量。学生们可以选择认定自己是或者不是嬉皮士。均值和这样一个二元变量无关。</p><p>在本节教程中，我将解释一个总体比例的抽样分布是长什么样。你知道巴黎有 10% 的学生认为自己是嬉皮士，这意味着总体比例，用 $ \pi $ 注记，等于 0.10 。现在想象我们从这个总体中抽取 200 个学生。样本的比例，用 $ p $ 注记，将会是一个接近 0.10 的数字，比如 0.09 或者 0.12 。</p><p>如果抽取了 5 组样本，样本比例可能如下：</p><img src="/images/sdp_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这样样本比例的直方图可能如下：</p><img src="/images/sdp_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>有五个值，全部都出现一次，它们的概率都是 0.2 。现在，你抽取 25 组样本，分布可能如下：</p><img src="/images/sdp_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>抽取 50 个样本，分布如下：</p><img src="/images/sdp_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>无限多组样本，分布如下：</p><img src="/images/sdp_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这是样本比例的抽样分布，分布的均值是 0.10 ，等于总体的比例。为了表明我们是处理抽样分布的均值，均值被注记为 $ \mu_p $ ，下标 p 是为了说明我们正在处理的分布的分数不是个体的分数，而是样本比例。如你所见，逻辑上和样本均值的抽样分布一模一样。</p><a id="more"></a><img src="/images/sdp_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>在样本均值的抽样分布案例中，如果总体本身是正态分布或者样本容量足够，那抽样分布是近似钟形的。通用最小需要 30 个样本数。在样本比例的抽样分布中，只有当你拥有至少 15 个正向的 case 以及至少 15 个负向 case 的前提下，你才能确信分布是钟形的，即至少 15 个嬉皮士和 15 个非嬉皮士。公式表达如下：</p><p>$$ n\pi \geq 15 $$<br>$$ n (1 - \pi) \geq 15 $$</p><p>这对于我们的例子意味着什么呢？首先，样本容量和总体比例的乘积必须大于等于 15 。在我们的案例中，即 200 乘以 0.10 ，等于 20 个嬉皮士。其次，总体比例和 $ 1 - \pi $ 的乘积必须大于等于 15 。在我们的案例中，即 200 乘以 (1-0.10)，等于 200 乘以 0.90 ， 等于 180 个非嬉皮士。 因此我们可以下结论，抽样分布将会是钟形的，因为 20 和 180 都大于 15 。有一个相当直接的公式可以计算样本比例的抽样分布的标准差。我们以 $ \sigma_p $ 注记标准差，你知道 $ \sigma $ 代表标准差，而添加的 p 则表明我们正在讨论的是样本比例的抽样分布。 为了计算这个标准差，公式如下：</p><p>$$ \sigma_p = \sqrt {\frac {\pi (1-\pi)}{n}} $$ </p><p>在我们的案例中，标准差算出来是 0.02 。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>对于二元类别变量，计算总体均值和标准差没有意义。取而代之的是，我们计算分类变量的比例。对于二元变量，我们只有总体的比例 $ \pi $ 。</li><li>相似的逻辑也适用于样本。我们也只有样本比例 p 。对于样本比例的抽样分布来说，我们的确有均值和标准差。只要知道总体的比例，抽样分布的这些参数也很容易计算出来。</li></ul><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;抽样分布比例&quot;&gt;&lt;a href=&quot;#抽样分布比例&quot; class=&quot;headerlink&quot; title=&quot;抽样分布比例&quot;&gt;&lt;/a&gt;抽样分布比例&lt;/h1&gt;&lt;p&gt;想象你住在巴黎，你知道所有的学生中有 0.10 的比例把自己看做嬉皮士。你想要知道这个比例的抽样分布是什么样的。注意，在这里计算总体均值是没有什么意义的。因为你感兴趣的变量是一个二元标量。学生们可以选择认定自己是或者不是嬉皮士。均值和这样一个二元变量无关。&lt;/p&gt;
&lt;p&gt;在本节教程中，我将解释一个总体比例的抽样分布是长什么样。你知道巴黎有 10% 的学生认为自己是嬉皮士，这意味着总体比例，用 $ \pi $ 注记，等于 0.10 。现在想象我们从这个总体中抽取 200 个学生。样本的比例，用 $ p $ 注记，将会是一个接近 0.10 的数字，比如 0.09 或者 0.12 。&lt;/p&gt;
&lt;p&gt;如果抽取了 5 组样本，样本比例可能如下：&lt;/p&gt;
&lt;img src=&quot;/images/sdp_1.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;这样样本比例的直方图可能如下：&lt;/p&gt;
&lt;img src=&quot;/images/sdp_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;有五个值，全部都出现一次，它们的概率都是 0.2 。现在，你抽取 25 组样本，分布可能如下：&lt;/p&gt;
&lt;img src=&quot;/images/sdp_3.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;抽取 50 个样本，分布如下：&lt;/p&gt;
&lt;img src=&quot;/images/sdp_4.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;无限多组样本，分布如下：&lt;/p&gt;
&lt;img src=&quot;/images/sdp_5.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;这是样本比例的抽样分布，分布的均值是 0.10 ，等于总体的比例。为了表明我们是处理抽样分布的均值，均值被注记为 $ \mu_p $ ，下标 p 是为了说明我们正在处理的分布的分数不是个体的分数，而是样本比例。如你所见，逻辑上和样本均值的抽样分布一模一样。&lt;/p&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>极速统计教程之十六 | 样本均值的抽样分布和中心极限定理</title>
    <link href="https://theinfinitegame.tech/data-science/statistics-sampling-distribution-and-central-limit-theorem/"/>
    <id>https://theinfinitegame.tech/data-science/statistics-sampling-distribution-and-central-limit-theorem/</id>
    <published>2020-01-31T02:48:29.000Z</published>
    <updated>2020-02-02T03:04:42.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽样分布"><a href="#抽样分布" class="headerlink" title="抽样分布"></a>抽样分布</h1><p>研究人员经常会用样本来推断样本所处的总体。为了做这件事，他们需要用到统计世界中非常重要的一种概率分布 —— <strong>抽样分布 (sampling distribution)</strong> 。</p><p>这一节中，我将向你解释抽样分布是什么。需要特别注意的是，抽样分布是帮助研究人员基于仅仅一个样本得出关于总体结论的桥梁。另外说明，在这节教程中，我们假装自己知道总体是什么样的。因为在研究实践中，我们通过永远都无法得知总体的全貌。这一步对于理解推断统计学至关重要。</p><p>好吧，让我们进入正题。想象有一群北欧的嬉皮士组织了一场胡子节庆典。庆典将在挪威首都奥斯陆附近的一个小岛举行。显然，你能想到庆典的受众是有胡子的男性。组织售出了 5,000 张门票，并且提供了往来小岛的免费运送。</p><img src="/images/sdl_1.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>拥有门票的人将在奥斯陆的港口集结。组织将他们随即分装到运送乘客前往该岛的船上，每条船搭载 30 名庆典的粉丝。</p><img src="/images/sdl_2.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>现在，有一艘船迷失在挪威的群岛间。雪上加霜的是，手机网络崩溃了，因此组织无法联系上船长，船上的乘客也无法联系上组织。所有组织决定派出一些雇员去搜寻走失的船只。你正是其中的一名雇员。在历经里半个多小时的搜寻后，你看到一艘失事的船，上面有大约 30 个人。Yes，终于找到他们了。你正准备通过对讲机向组织报告失联船只已找到，这时你再看了一眼船上的乘客。你发现乘客都是一些带着小孩的家庭。这很奇怪，去胡子节的船上，不是应该都是一些随机选取的有胡子的成年男人吗？而不是一些带着小孩的年轻家庭。你认定这艘船不太可能是你要找的船，决定继续搜寻。果然，不久之后证明你的决定是明智的。你前面遇到的那艘船是一艘运送人们去另外一个岛上的家庭公园的船。</p><p>为什么要讲这个故事呢？这么说吧，如果你理解上面那个故事里 “你” 决策的原因，你就会理解抽样分布背后的基本思想。它是这样的，如果你从总体中抽取一个简单随机样本，那么它是不太可能强烈地区域于样本所处的总体的。在我们的案例中，人们正前往胡子节，他们构成了总体。一艘载有 30 个从总体中随机选取的人的船就是一个简单随机样本。</p><img src="/images/sdl_3.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>实际上，所有从奥斯陆港口前往庆典小岛的船都可以看做是一个简单随机样本。当然，每艘船都和其他船不一样，但大部分船都会包含大比例的有胡子的男人。不太可能有一艘船上都是各种年轻家庭。当然，有某些家庭参加胡子节是可能的，但是随机遇到一艘船，全部都是年轻家庭，则是非常不太可能发生的。</p><img src="/images/sdl_4.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>假设你决定测量每艘船的平均胡子长度。每艘船有 30 个人。想象 5,000 个庆典参与者的平均胡子长度时 10.3 毫米，即均值是 10.3 毫米。你还知道胡子的长度在总体中服从一个钟形的分布。在一艘船上，你可能遇到胡子平均长度是 9.4 毫米，另一艘则可能是 10.8 。但是，不太可能遇到一艘船，上面的人平均胡子长度是 3.4 毫米，或者 19.2 毫米。因为这些船上的人的胡子的平均值可以看作是样本的均值，我们用 $ \bar x $ 来注记。</p><img src="/images/sdl_5.jpg" width="68%" height="68%" style="margin: 10 auto;"><a id="more"></a><p>现在想象你正看着三艘船，概率分布可能长这样：</p><img src="/images/sdl_6.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>一艘船的均值是 9.9 ，一艘是 10.7 ，还有一艘是 10.2 。我们一共有三艘，所以每个均值的概率是 0.33 。现在想象有 17 艘船，40 艘船，100 艘船，你会发现胡子均值长度的分布会越来越接近钟形分布，并且，你会发现分布的均值接近 10.3 ，跟总体的均值一模一样。</p><img src="/images/sdl_7.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如果你仔细琢磨一下，就发现这并不奇怪。你会期望，在绝大多数情况下，样本的均值和总体的均值接近。某一艘船的均值可能高一点，另一艘船的均值可能低一点。但是，当你看到许多船时，你会期望所有这些不同船的均值的均值，就等于总体的均值。</p><img src="/images/sdl_8.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>现在，想象你的总体包含了所有的挪威男人。你知道这个总体的胡子长度均值是 1.22 毫米，并且变量服从一个钟形分布。如果你抽取一个 30 人的简单随机样本，你会发现均值接近总体均值，比如 1.34 毫米。你再抽取另一个随机样本，均值可能是 1.19 毫米，也很接近总体均值。如果你重复五次，你会得到五个不同的值，但是都很接近总体的均值。</p><img src="/images/sdl_9.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>当我们可以抽取无限多个样本时，分布将会是一个完美的钟形，均值是精确的 1.22 毫米，跟总体均值一样。我们把这种分布称为 <strong>样本均值的抽样分布 (sampling distribution of the sample mean)</strong> ，它是这样一种分布：你从总体中无限抽取样本，计算所有样本的均值。</p><img src="/images/sdl_10.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>目前为止，你应当意识到，在实际的研究中，我们不可能从某个总体中抽取无限多的样本。但是，你需要知道，如果我们能这么做，这个分布的均值将等于总体的均值，这正是我们把这个分布称为样本均值的抽样分布的原因。不要把这个和样本或者数据分布混淆在一起，这只是实际抽取的一个样本的分布，只针对实际收集的数据而言。</p><hr><h1 id="中心极限定理"><a href="#中心极限定理" class="headerlink" title="中心极限定理"></a>中心极限定理</h1><p>如果你从钟形分布的总体中取无限个样本，来自这个无限个样本的均值分布将会是钟形的。并且这种样本均值的分布将会和总体均值完全一样。我们将此分布称为样本均值的抽样分布。</p><p>在这一节中，我将讨论 <strong>中心极限定理 (central limit theorem)</strong> —— 推理统计学中，最重要的公式之一。 </p><img src="/images/sdl_11.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>中心极限定理表明，假设样本量足够大，样本均值 $ \bar X $ (x 的均值) 的抽样分布近似正态分布，即使这个变量在总体中并不是正态分布。这不是很神奇吗？不用理会变量在总体中是如何分布的，样本均值的抽样分布总是如此，总是近似正态分布，只要样本量足够大。作为足够大的指导，通常使用 30 或更大的样本。</p><img src="/images/sdl_12.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>你们可以看这些总体分布可能的形状。这是当你取样本容量 n=30 时，样本均值的抽样分布图。记住，这意味着你从总体中抽取了无数个由 30 个调查对象组成的随机样本，在分布中显示所有生成的样本均值。</p><p>你应该意识到，在实践中，根本不可能抽取无数个样本。但是，好消息是根本不需要抽取多个样本来确定样本分布的形状。 因为如果它是正态分布，你可以通过两个参数来描述它的形状，即均值和标准差。因此，估计这两个参数就足够了。正如我之前告诉你的那样，抽样分布的均值等于总体分布的均值。我们可以这样表示，$ \mu_{\bar x} = \mu $，$ \mu $ 代表总体的均值，$ \mu_{\bar x} $ 代表样本均值的均值。 </p><p>想象你对挪威男人的平均胡须长度感兴趣。总体包括所有挪威男子，$ \mu $ 是总体的平均胡须长度。我们假设它是 1.22 毫米。对于样本均值的均值，如果我们从总体中抽取无数个样本，并记下每个样本中的平均胡须长度，我们就会得到这个分布的平均值，等于总体均值 1.22 。$ \bar X $ 是用来强调抽样分布中的分数是样本均值，而不是个体的分数。换句话说，总体分布的平均值是所有挪威男性的胡子长度得分的平均值。抽样分布的均值是从该人群中抽取的无限多个样本的样本平均值。</p><img src="/images/sdl_13.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>如果我们知道总体分布如何，我们可以轻松的计算出样本的标准差。抽样分布的标准差的符号化是 $ \sigma_{\bar x} = \frac {\sigma}{\sqrt {n}} $ 。添加 $ \bar x $ 下标是为了表明我们正在谈论抽样分布的标准差，其中分数是样本均值，或者换句话说，$ \bar x $ 的 $ \mu $。$ \sigma $ 代表总体的标准差， n 代表样本的大小。此公式表明抽样分布的标准差受两个特征影响。首先，它受总体标准差的影响，假设 n 等于 30 ，你的总体标准差是 1 ，你的抽样分布的标准差等于 1 除于根号 30 ，等于 0.18 。如果你的总体标准差增加至 2 ，样本的标准差变成 2 除于根号 30 ，即 0.37 ，如果你的总体标准差变成 3，样本的标准差变成 0.55 ，等等。</p><p>所以，如果总体分布的的标准差增加，抽样分布的标准差也会增加。换句话说，总体方差越大，样本均值的方差越大。这在直觉上是合理的，对吧？如果你从人群中胡须长度差异很大的人群中抽取 30 个受试者的各种样本，你可以预期这些样本的相互之间的差异比你从几乎没有差异的总体中抽取各种样本的差异更大。你的抽样分布的标准差，也会受到样本容量的影响。再看看这个公式。假设总体标准差等于 2 。现在，如果 n=30 ，$ \sigma_{\bar x} $ 等于 2 除于根号 30 ，等于 0.37 。 如果 n=100 ，你的抽样分布的标准差将变为 2 除于根号 100 ，等于 0.2 。如果 n = 500 ，你的 $ \sigma_{\bar x} $ 变为 0.09 。</p><img src="/images/sdl_14.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>这表明，一个更大的样本量导致抽样分布的标准差更小。这在直觉上也是合理的。如果总体中的挪威男性的平均胡子长度为 1.22 毫米，你只有两个受访者作为样本，找到一个更高的平均值并不奇怪。如果你抽取了五个样本，你的样本均值是看起来像这样。</p><img src="/images/sdl_15.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>现在，想象一下你抽取了一个 1000 个受试者的样本，这个样本的均值不太可能是 5 或者 10 毫米。毕竟，长胡子的人会被完全没有胡子的人抵消。如果你抽取五组样本，样本均值可能看起来像这样。</p><img src="/images/sdl_16.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>它们都将非常接近总体平均值 1.22 毫米。所以你的样本容量越大，样本均值越接近总体均值，样本分布的标准差越小。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>中心极限定理告诉你：无论变量在总体中分布如何，只要样本容量至少为 30 ，样本平均值的抽样分布都近似正态分布。</li><li>抽样分布的均值 $ \mu_{\bar x} $ 等于总体均值 $ \mu $ ，抽样分布的标准差 $ \sigma_{\bar x} $ 等于总体分布的标准差 $ \sigma $ 除于 $ \sqrt {n} $。</li></ul><hr><h1 id="三种分布"><a href="#三种分布" class="headerlink" title="三种分布"></a>三种分布</h1><p>许多社会的、政治的以及宗教的团体有它们自己的神圣文字。嬉皮士，也有它们自己的 “圣经”，这是一本名叫 “On the Road” 的书。这一节中，我们对于纽约市的嬉皮士花了多少时间读这本书感兴趣。</p><p>假设我们知道总体，所有嬉皮士读这本书的平均时长是 943 分钟。我们还知道，总体的标准差等于 212 分钟。你从总体中做简单随机抽样抽取了 200 个受试者。这个样本中的平均阅读时长是 867 分钟，标准差 188 分钟。</p><p>这一节，我将介绍对于研究项目十分重要的三种分布 —— <strong>总体分布 (population distribution)</strong> ，<strong>样本分布 (sample distribution)</strong> ， <strong>抽样分布 (sampling distribution)</strong> 。我将向你展示，如果计算针对特定分数的选择性个体的概率。 </p><p>第一个分布，总体分布，它看起来像这样，近似钟形，均值 943 分钟，标准差 212 分钟，主体是纽约的嬉皮士们。</p><p>第二个分布，数据分布或者是样本分布，它是样本数据的分布，看起来像这样。它跟总体分布一样，近似钟形，均值 867 分钟，和总体均值 943 分钟相差不大。标准差 188 分钟。</p><img src="/images/sdl_17.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>注意，样本统计里采用罗马字母注记，而总体里采用希腊字母注记。</p><p>第三种分布，样本均值的抽样分布，它就像下面这样：</p><img src="/images/sdl_18.jpg" width="68%" height="68%" style="margin: 10 auto;"><p>根据中心极限理论，它是正态分布的。在这个分布中，主体不是分布中的个体，而是来自纽约嬉皮士的 200 个受试者样本的一个不确定的数字。样本均值的抽样分布的均值，是这些不确定样本均值的均值。具体的数值，等于总体分布均值的数值，即 943 分钟。为了说明我们正在讨论的是抽样分布，我们添加 $ \bar x $ 下标来表明是样本均值的均值而不是个体分数的均值。抽样分布的标准差，等于总体标准差，除以 n 的平方根，即 212 ，除以 200 的平方根，得到 15 。</p><p>你需要记住的是，第三个分布是一个理论上的分布。我们并不实际地收集无限多的样本。那是不可能做到的，也不必做到。因为只要我们知道总体的均值和标准差，我们就能知道抽样分布长什么样。正态分布的一个大好处是，我们可以通过把原始分数变换成 z 分数，以及引入 z 表格，找出概率。</p><p>现在，想象你从总体中选择一个随机样本，这个嬉皮士阅读时长大于等于 1000 分钟的概率是多大呢？</p><p>首先，我们需要知道一个嬉皮士阅读那本书的时长等于 1000 分钟距离均值有多少个标准差。我们在总体中计算这个人的 z 分数，z 分数是 1,000 减去 943 ，除以 212 ，等于 0.27 。我们感兴趣的是这个值右边的区域。查询 z 表格，我们发现选中一个阅读时长大于等于 1,000 分钟的嬉皮士的概率是 39% 。现在，想象我们抽取 200 个嬉皮士。这个样本均值大于等于 1,000 分钟的概率是多少？千万注意，这是一个完全不同的问题。我们不是在讨论从总体中选取一个特定的人，而是在讨论基于总体中的特定样本的统计学。因此，我们不用总体分布，而是样本均值的抽样分布。通常，过程是相同的，只不过我们用的是不一样的均值和标准差。这里， z 分数计算过程如下。我们从感兴趣的均值，即 1000 ，减去抽样分布的均值，即 943 ，然后除以抽样分布的标准差，即 212 除以 200 的平方根，即 15 。因此， (1000 - 943) / 15 ，最后得到 z 分数是 3.8 。查询 z 表格，我们发现抽取一个样本的平均阅读时长均值大于等于 1,000 分钟的概率是 0.01% 。</p><img src="/images/sdl_19.jpg" width="68%" height="68%" style="margin: 10 auto;"><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><ul><li>决定选用哪种分布时，需要十分小心。如果你是对选择的独立个体感兴趣，应当使用总体分布；但如果你是对选择的样本感兴趣，应当使用抽样分布。在实际的研究实践中，混淆总体和抽样分布几乎不可能发生。因为你永远无从知道总体的全貌。你唯一可以确定的是你的样本长什么样。</li></ul><p>接下来，我们会学习如何在缺少总体分布信息的情况下，利用好抽样分布。</p><hr><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;抽样分布&quot;&gt;&lt;a href=&quot;#抽样分布&quot; class=&quot;headerlink&quot; title=&quot;抽样分布&quot;&gt;&lt;/a&gt;抽样分布&lt;/h1&gt;&lt;p&gt;研究人员经常会用样本来推断样本所处的总体。为了做这件事，他们需要用到统计世界中非常重要的一种概率分布 —— &lt;strong&gt;抽样分布 (sampling distribution)&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;这一节中，我将向你解释抽样分布是什么。需要特别注意的是，抽样分布是帮助研究人员基于仅仅一个样本得出关于总体结论的桥梁。另外说明，在这节教程中，我们假装自己知道总体是什么样的。因为在研究实践中，我们通过永远都无法得知总体的全貌。这一步对于理解推断统计学至关重要。&lt;/p&gt;
&lt;p&gt;好吧，让我们进入正题。想象有一群北欧的嬉皮士组织了一场胡子节庆典。庆典将在挪威首都奥斯陆附近的一个小岛举行。显然，你能想到庆典的受众是有胡子的男性。组织售出了 5,000 张门票，并且提供了往来小岛的免费运送。&lt;/p&gt;
&lt;img src=&quot;/images/sdl_1.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;拥有门票的人将在奥斯陆的港口集结。组织将他们随即分装到运送乘客前往该岛的船上，每条船搭载 30 名庆典的粉丝。&lt;/p&gt;
&lt;img src=&quot;/images/sdl_2.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;现在，有一艘船迷失在挪威的群岛间。雪上加霜的是，手机网络崩溃了，因此组织无法联系上船长，船上的乘客也无法联系上组织。所有组织决定派出一些雇员去搜寻走失的船只。你正是其中的一名雇员。在历经里半个多小时的搜寻后，你看到一艘失事的船，上面有大约 30 个人。Yes，终于找到他们了。你正准备通过对讲机向组织报告失联船只已找到，这时你再看了一眼船上的乘客。你发现乘客都是一些带着小孩的家庭。这很奇怪，去胡子节的船上，不是应该都是一些随机选取的有胡子的成年男人吗？而不是一些带着小孩的年轻家庭。你认定这艘船不太可能是你要找的船，决定继续搜寻。果然，不久之后证明你的决定是明智的。你前面遇到的那艘船是一艘运送人们去另外一个岛上的家庭公园的船。&lt;/p&gt;
&lt;p&gt;为什么要讲这个故事呢？这么说吧，如果你理解上面那个故事里 “你” 决策的原因，你就会理解抽样分布背后的基本思想。它是这样的，如果你从总体中抽取一个简单随机样本，那么它是不太可能强烈地区域于样本所处的总体的。在我们的案例中，人们正前往胡子节，他们构成了总体。一艘载有 30 个从总体中随机选取的人的船就是一个简单随机样本。&lt;/p&gt;
&lt;img src=&quot;/images/sdl_3.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;实际上，所有从奥斯陆港口前往庆典小岛的船都可以看做是一个简单随机样本。当然，每艘船都和其他船不一样，但大部分船都会包含大比例的有胡子的男人。不太可能有一艘船上都是各种年轻家庭。当然，有某些家庭参加胡子节是可能的，但是随机遇到一艘船，全部都是年轻家庭，则是非常不太可能发生的。&lt;/p&gt;
&lt;img src=&quot;/images/sdl_4.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;

&lt;p&gt;假设你决定测量每艘船的平均胡子长度。每艘船有 30 个人。想象 5,000 个庆典参与者的平均胡子长度时 10.3 毫米，即均值是 10.3 毫米。你还知道胡子的长度在总体中服从一个钟形的分布。在一艘船上，你可能遇到胡子平均长度是 9.4 毫米，另一艘则可能是 10.8 。但是，不太可能遇到一艘船，上面的人平均胡子长度是 3.4 毫米，或者 19.2 毫米。因为这些船上的人的胡子的平均值可以看作是样本的均值，我们用 $ \bar x $ 来注记。&lt;/p&gt;
&lt;img src=&quot;/images/sdl_5.jpg&quot; width=&quot;68%&quot; height=&quot;68%&quot; style=&quot;margin: 10 auto;&quot;&gt;
    
    </summary>
    
    
      <category term="data-science" scheme="https://theinfinitegame.tech/categories/data-science/"/>
    
    
      <category term="统计" scheme="https://theinfinitegame.tech/tags/%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="数据科学" scheme="https://theinfinitegame.tech/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
</feed>
